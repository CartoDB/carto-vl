/*!
 * CARTO VL js https://carto.com/
 * Version: 1.4.6
 * 
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["carto"] = factory();
	else
		root["carto"] = factory();
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * base64-arraybuffer
 * https://github.com/niklasvh/base64-arraybuffer
 *
 * Copyright (c) 2012 Niklas von Hertzen
 * Licensed under the MIT license.
 */
(function(){
  "use strict";

  var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

  // Use a lookup table to find the index.
  var lookup = new Uint8Array(256);
  for (var i = 0; i < chars.length; i++) {
    lookup[chars.charCodeAt(i)] = i;
  }

  exports.encode = function(arraybuffer) {
    var bytes = new Uint8Array(arraybuffer),
    i, len = bytes.length, base64 = "";

    for (i = 0; i < len; i+=3) {
      base64 += chars[bytes[i] >> 2];
      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];
      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];
      base64 += chars[bytes[i + 2] & 63];
    }

    if ((len % 3) === 2) {
      base64 = base64.substring(0, base64.length - 1) + "=";
    } else if (len % 3 === 1) {
      base64 = base64.substring(0, base64.length - 2) + "==";
    }

    return base64;
  };

  exports.decode =  function(base64) {
    var bufferLength = base64.length * 0.75,
    len = base64.length, i, p = 0,
    encoded1, encoded2, encoded3, encoded4;

    if (base64[base64.length - 1] === "=") {
      bufferLength--;
      if (base64[base64.length - 2] === "=") {
        bufferLength--;
      }
    }

    var arraybuffer = new ArrayBuffer(bufferLength),
    bytes = new Uint8Array(arraybuffer);

    for (i = 0; i < len; i+=4) {
      encoded1 = lookup[base64.charCodeAt(i)];
      encoded2 = lookup[base64.charCodeAt(i+1)];
      encoded3 = lookup[base64.charCodeAt(i+2)];
      encoded4 = lookup[base64.charCodeAt(i+3)];

      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);
      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);
      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);
    }

    return arraybuffer;
  };
})();


/***/ }),

/***/ "./node_modules/cartocolor/cartocolor.js":
/*!***********************************************!*\
  !*** ./node_modules/cartocolor/cartocolor.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;!function() {

var cartocolor = {
    "Burg": {
        "2": [
            "#ffc6c4",
            "#672044"
        ],
        "3": [
            "#ffc6c4",
            "#cc607d",
            "#672044"
        ],
        "4": [
            "#ffc6c4",
            "#e38191",
            "#ad466c",
            "#672044"
        ],
        "5": [
            "#ffc6c4",
            "#ee919b",
            "#cc607d",
            "#9e3963",
            "#672044"
        ],
        "6": [
            "#ffc6c4",
            "#f29ca3",
            "#da7489",
            "#b95073",
            "#93345d",
            "#672044"
        ],
        "7": [
            "#ffc6c4",
            "#f4a3a8",
            "#e38191",
            "#cc607d",
            "#ad466c",
            "#8b3058",
            "#672044"
        ],
        "tags": [
            "quantitative"
        ]
    },
    "BurgYl": {
        "2": [
            "#fbe6c5",
            "#70284a"
        ],
        "3": [
            "#fbe6c5",
            "#dc7176",
            "#70284a"
        ],
        "4": [
            "#fbe6c5",
            "#ee8a82",
            "#c8586c",
            "#70284a"
        ],
        "5": [
            "#fbe6c5",
            "#f2a28a",
            "#dc7176",
            "#b24b65",
            "#70284a"
        ],
        "6": [
            "#fbe6c5",
            "#f4b191",
            "#e7807d",
            "#d06270",
            "#a44360",
            "#70284a"
        ],
        "7": [
            "#fbe6c5",
            "#f5ba98",
            "#ee8a82",
            "#dc7176",
            "#c8586c",
            "#9c3f5d",
            "#70284a"
        ],
        "tags": [
            "quantitative"
        ]
    },
    "RedOr": {
        "2": [
            "#f6d2a9",
            "#b13f64"
        ],
        "3": [
            "#f6d2a9",
            "#ea8171",
            "#b13f64"
        ],
        "4": [
            "#f6d2a9",
            "#f19c7c",
            "#dd686c",
            "#b13f64"
        ],
        "5": [
            "#f6d2a9",
            "#f3aa84",
            "#ea8171",
            "#d55d6a",
            "#b13f64"
        ],
        "6": [
            "#f6d2a9",
            "#f4b28a",
            "#ef9177",
            "#e3726d",
            "#cf5669",
            "#b13f64"
        ],
        "7": [
            "#f6d2a9",
            "#f5b78e",
            "#f19c7c",
            "#ea8171",
            "#dd686c",
            "#ca5268",
            "#b13f64"
        ],
        "tags": [
            "quantitative"
        ]
    },
    "OrYel": {
        "2": [
            "#ecda9a",
            "#ee4d5a"
        ],
        "3": [
            "#ecda9a",
            "#f7945d",
            "#ee4d5a"
        ],
        "4": [
            "#ecda9a",
            "#f3ad6a",
            "#f97b57",
            "#ee4d5a"
        ],
        "5": [
            "#ecda9a",
            "#f1b973",
            "#f7945d",
            "#f86f56",
            "#ee4d5a"
        ],
        "6": [
            "#ecda9a",
            "#f0c079",
            "#f5a363",
            "#f98558",
            "#f76856",
            "#ee4d5a"
        ],
        "7": [
            "#ecda9a",
            "#efc47e",
            "#f3ad6a",
            "#f7945d",
            "#f97b57",
            "#f66356",
            "#ee4d5a"
        ],
        "tags": [
            "quantitative"
        ]
    },
    "Peach": {
        "2": [
            "#fde0c5",
            "#eb4a40"
        ],
        "3": [
            "#fde0c5",
            "#f59e72",
            "#eb4a40"
        ],
        "4": [
            "#fde0c5",
            "#f8b58b",
            "#f2855d",
            "#eb4a40"
        ],
        "5": [
            "#fde0c5",
            "#f9c098",
            "#f59e72",
            "#f17854",
            "#eb4a40"
        ],
        "6": [
            "#fde0c5",
            "#fac7a1",
            "#f7ac80",
            "#f38f65",
            "#f0704f",
            "#eb4a40"
        ],
        "7": [
            "#fde0c5",
            "#facba6",
            "#f8b58b",
            "#f59e72",
            "#f2855d",
            "#ef6a4c",
            "#eb4a40"
        ],
        "tags": [
            "quantitative"
        ]
    },
    "PinkYl": {
        "2": [
            "#fef6b5",
            "#e15383"
        ],
        "3": [
            "#fef6b5",
            "#ffa679",
            "#e15383"
        ],
        "4": [
            "#fef6b5",
            "#ffc285",
            "#fa8a76",
            "#e15383"
        ],
        "5": [
            "#fef6b5",
            "#ffd08e",
            "#ffa679",
            "#f67b77",
            "#e15383"
        ],
        "6": [
            "#fef6b5",
            "#ffd795",
            "#ffb77f",
            "#fd9576",
            "#f37378",
            "#e15383"
        ],
        "7": [
            "#fef6b5",
            "#ffdd9a",
            "#ffc285",
            "#ffa679",
            "#fa8a76",
            "#f16d7a",
            "#e15383"
        ],
        "tags": [
            "quantitative"
        ]
    },
    "Mint": {
        "2": [
            "#e4f1e1",
            "#0d585f"
        ],
        "3": [
            "#e4f1e1",
            "#63a6a0",
            "#0d585f"
        ],
        "4": [
            "#e4f1e1",
            "#89c0b6",
            "#448c8a",
            "#0d585f"
        ],
        "5": [
            "#E4F1E1",
            "#9CCDC1",
            "#63A6A0",
            "#337F7F",
            "#0D585F"
        ],
        "6": [
            "#e4f1e1",
            "#abd4c7",
            "#7ab5ad",
            "#509693",
            "#2c7778",
            "#0d585f"
        ],
        "7": [
            "#e4f1e1",
            "#b4d9cc",
            "#89c0b6",
            "#63a6a0",
            "#448c8a",
            "#287274",
            "#0d585f"
        ],
        "tags": [
            "quantitative"
        ]
    },
    "BluGrn": {
        "2": [
            "#c4e6c3",
            "#1d4f60"
        ],
        "3": [
            "#c4e6c3",
            "#4da284",
            "#1d4f60"
        ],
        "4": [
            "#c4e6c3",
            "#6dbc90",
            "#36877a",
            "#1d4f60"
        ],
        "5": [
            "#c4e6c3",
            "#80c799",
            "#4da284",
            "#2d7974",
            "#1d4f60"
        ],
        "6": [
            "#c4e6c3",
            "#8dce9f",
            "#5fb28b",
            "#3e927e",
            "#297071",
            "#1d4f60"
        ],
        "7": [
            "#c4e6c3",
            "#96d2a4",
            "#6dbc90",
            "#4da284",
            "#36877a",
            "#266b6e",
            "#1d4f60"
        ],
        "tags": [
            "quantitative"
        ]
    },
    "DarkMint": {
        "2": [
            "#d2fbd4",
            "#123f5a"
        ],
        "3": [
            "#d2fbd4",
            "#559c9e",
            "#123f5a"
        ],
        "4": [
            "#d2fbd4",
            "#7bbcb0",
            "#3a7c89",
            "#123f5a"
        ],
        "5": [
            "#d2fbd4",
            "#8eccb9",
            "#559c9e",
            "#2b6c7f",
            "#123f5a"
        ],
        "6": [
            "#d2fbd4",
            "#9cd5be",
            "#6cafa9",
            "#458892",
            "#266377",
            "#123f5a"
        ],
        "7": [
            "#d2fbd4",
            "#a5dbc2",
            "#7bbcb0",
            "#559c9e",
            "#3a7c89",
            "#235d72",
            "#123f5a"
        ],
        "tags": [
            "quantitative"
        ]
    },
    "Emrld": {
        "2": [
            "#d3f2a3",
            "#074050"
        ],
        "3": [
            "#d3f2a3",
            "#4c9b82",
            "#074050"
        ],
        "4": [
            "#d3f2a3",
            "#6cc08b",
            "#217a79",
            "#074050"
        ],
        "5": [
            "#d3f2a3",
            "#82d091",
            "#4c9b82",
            "#19696f",
            "#074050"
        ],
        "6": [
            "#d3f2a3",
            "#8fda94",
            "#60b187",
            "#35877d",
            "#145f69",
            "#074050"
        ],
        "7": [
            "#d3f2a3",
            "#97e196",
            "#6cc08b",
            "#4c9b82",
            "#217a79",
            "#105965",
            "#074050"
        ],
        "tags": [
            "quantitative"
        ]
    },
    "ag_GrnYl": {
        "2": [
            "#245668",
            "#EDEF5D"
        ],
        "3": [
            "#245668",
            "#39AB7E",
            "#EDEF5D"
        ],
        "4": [
            "#245668",
            "#0D8F81",
            "#6EC574",
            "#EDEF5D"
        ],
        "5": [
            "#245668",
            "#04817E",
            "#39AB7E",
            "#8BD16D",
            "#EDEF5D"
        ],
        "6": [
            "#245668",
            "#09787C",
            "#1D9A81",
            "#58BB79",
            "#9DD869",
            "#EDEF5D"
        ],
        "7": [
            "#245668",
            "#0F7279",
            "#0D8F81",
            "#39AB7E",
            "#6EC574",
            "#A9DC67",
            "#EDEF5D"
        ],
        "tags": [
            "aggregation"
        ]
    },
    "BluYl": {
        "2": [
            "#f7feae",
            "#045275"
        ],
        "3": [
            "#f7feae",
            "#46aea0",
            "#045275"
        ],
        "4": [
            "#f7feae",
            "#7ccba2",
            "#089099",
            "#045275"
        ],
        "5": [
            "#f7feae",
            "#9bd8a4",
            "#46aea0",
            "#058092",
            "#045275"
        ],
        "6": [
            "#f7feae",
            "#ace1a4",
            "#68bfa1",
            "#2a9c9c",
            "#02778e",
            "#045275"
        ],
        "7": [
            "#f7feae",
            "#b7e6a5",
            "#7ccba2",
            "#46aea0",
            "#089099",
            "#00718b",
            "#045275"
        ],
        "tags": [
            "quantitative"
        ]
    },
    "Teal": {
        "2": [
            "#d1eeea",
            "#2a5674"
        ],
        "3": [
            "#d1eeea",
            "#68abb8",
            "#2a5674"
        ],
        "4": [
            "#d1eeea",
            "#85c4c9",
            "#4f90a6",
            "#2a5674"
        ],
        "5": [
            "#d1eeea",
            "#96d0d1",
            "#68abb8",
            "#45829b",
            "#2a5674"
        ],
        "6": [
            "#d1eeea",
            "#a1d7d6",
            "#79bbc3",
            "#599bae",
            "#3f7994",
            "#2a5674"
        ],
        "7": [
            "#d1eeea",
            "#a8dbd9",
            "#85c4c9",
            "#68abb8",
            "#4f90a6",
            "#3b738f",
            "#2a5674"
        ],
        "tags": [
            "quantitative"
        ]
    },
    "TealGrn": {
        "2": [
            "#b0f2bc",
            "#257d98"
        ],
        "3": [
            "#b0f2bc",
            "#4cc8a3",
            "#257d98"
        ],
        "4": [
            "#b0f2bc",
            "#67dba5",
            "#38b2a3",
            "#257d98"
        ],
        "5": [
            "#b0f2bc",
            "#77e2a8",
            "#4cc8a3",
            "#31a6a2",
            "#257d98"
        ],
        "6": [
            "#b0f2bc",
            "#82e6aa",
            "#5bd4a4",
            "#3fbba3",
            "#2e9ea1",
            "#257d98"
        ],
        "7": [
            "#b0f2bc",
            "#89e8ac",
            "#67dba5",
            "#4cc8a3",
            "#38b2a3",
            "#2c98a0",
            "#257d98"
        ],
        "tags": [
            "quantitative"
        ]
    },
    "Purp": {
        "2": [
            "#f3e0f7",
            "#63589f"
        ],
        "3": [
            "#f3e0f7",
            "#b998dd",
            "#63589f"
        ],
        "4": [
            "#f3e0f7",
            "#d1afe8",
            "#9f82ce",
            "#63589f"
        ],
        "5": [
            "#f3e0f7",
            "#dbbaed",
            "#b998dd",
            "#9178c4",
            "#63589f"
        ],
        "6": [
            "#f3e0f7",
            "#e0c2ef",
            "#c8a5e4",
            "#aa8bd4",
            "#8871be",
            "#63589f"
        ],
        "7": [
            "#f3e0f7",
            "#e4c7f1",
            "#d1afe8",
            "#b998dd",
            "#9f82ce",
            "#826dba",
            "#63589f"
        ],
        "tags": [
            "quantitative"
        ]
    },
    "PurpOr": {
        "3": [
            "#f9ddda",
            "#ce78b3",
            "#573b88"
        ],
        "4": [
            "#f9ddda",
            "#e597b9",
            "#ad5fad",
            "#573b88"
        ],
        "5": [
            "#f9ddda",
            "#eda8bd",
            "#ce78b3",
            "#9955a8",
            "#573b88"
        ],
        "6": [
            "#f9ddda",
            "#f0b2c1",
            "#dd8ab6",
            "#bb69b0",
            "#8c4fa4",
            "#573b88"
        ],
        "7": [
            "#f9ddda",
            "#f2b9c4",
            "#e597b9",
            "#ce78b3",
            "#ad5fad",
            "#834ba0",
            "#573b88"
        ],
        "tags": [
            "quantitative"
        ]
    },
    "Sunset": {
        "2": [
            "#f3e79b",
            "#5c53a5"
        ],
        "3": [
            "#f3e79b",
            "#eb7f86",
            "#5c53a5"
        ],
        "4": [
            "#f3e79b",
            "#f8a07e",
            "#ce6693",
            "#5c53a5"
        ],
        "5": [
            "#f3e79b",
            "#fab27f",
            "#eb7f86",
            "#b95e9a",
            "#5c53a5"
        ],
        "6": [
            "#f3e79b",
            "#fabc82",
            "#f59280",
            "#dc6f8e",
            "#ab5b9e",
            "#5c53a5"
        ],
        "7": [
            "#f3e79b",
            "#fac484",
            "#f8a07e",
            "#eb7f86",
            "#ce6693",
            "#a059a0",
            "#5c53a5"
        ],
        "tags": [
            "quantitative"
        ]
    },
    "Magenta": {
        "2": [
            "#f3cbd3",
            "#6c2167"
        ],
        "3": [
            "#f3cbd3",
            "#ca699d",
            "#6c2167"
        ],
        "4": [
            "#f3cbd3",
            "#dd88ac",
            "#b14d8e",
            "#6c2167"
        ],
        "5": [
            "#f3cbd3",
            "#e498b4",
            "#ca699d",
            "#a24186",
            "#6c2167"
        ],
        "6": [
            "#f3cbd3",
            "#e7a2b9",
            "#d67ba5",
            "#bc5894",
            "#983a81",
            "#6c2167"
        ],
        "7": [
            "#f3cbd3",
            "#eaa9bd",
            "#dd88ac",
            "#ca699d",
            "#b14d8e",
            "#91357d",
            "#6c2167"
        ],
        "tags": [
            "quantitative"
        ]
    },
    "SunsetDark": {
        "2": [
            "#fcde9c",
            "#7c1d6f"
        ],
        "3": [
            "#fcde9c",
            "#e34f6f",
            "#7c1d6f"
        ],
        "4": [
            "#fcde9c",
            "#f0746e",
            "#dc3977",
            "#7c1d6f"
        ],
        "5": [
            "#fcde9c",
            "#f58670",
            "#e34f6f",
            "#d72d7c",
            "#7c1d6f"
        ],
        "6": [
            "#fcde9c",
            "#f89872",
            "#ec666d",
            "#df4273",
            "#c5287b",
            "#7c1d6f"
        ],
        "7": [
            "#fcde9c",
            "#faa476",
            "#f0746e",
            "#e34f6f",
            "#dc3977",
            "#b9257a",
            "#7c1d6f"
        ],
        "tags": [
            "quantitative"
        ]
    },
    "ag_Sunset": {
        "2": [
            "#4b2991",
            "#edd9a3"
        ],
        "3": [
            "#4b2991",
            "#ea4f88",
            "#edd9a3"
        ],
        "4": [
            "#4b2991",
            "#c0369d",
            "#fa7876",
            "#edd9a3"
        ],
        "5": [
            "#4b2991",
            "#a52fa2",
            "#ea4f88",
            "#fa9074",
            "#edd9a3"
        ],
        "6": [
            "#4b2991",
            "#932da3",
            "#d43f96",
            "#f7667c",
            "#f89f77",
            "#edd9a3"
        ],
        "7": [
            "#4b2991",
            "#872ca2",
            "#c0369d",
            "#ea4f88",
            "#fa7876",
            "#f6a97a",
            "#edd9a3"
        ],
        "tags": [
            "aggregation"
        ]
    },
    "BrwnYl": {
        "2": [
            "#ede5cf",
            "#541f3f"
        ],
        "3": [
            "#ede5cf",
            "#c1766f",
            "#541f3f"
        ],
        "4": [
            "#ede5cf",
            "#d39c83",
            "#a65461",
            "#541f3f"
        ],
        "5": [
            "#ede5cf",
            "#daaf91",
            "#c1766f",
            "#95455a",
            "#541f3f"
        ],
        "6": [
            "#ede5cf",
            "#ddba9b",
            "#cd8c7a",
            "#b26166",
            "#8a3c56",
            "#541f3f"
        ],
        "7": [
            "#ede5cf",
            "#e0c2a2",
            "#d39c83",
            "#c1766f",
            "#a65461",
            "#813753",
            "#541f3f"
        ],
        "tags": [
            "quantitative"
        ]
    },
    "ArmyRose": {
        "2": [
            "#929b4f",
            "#db8195"
        ],
        "3": [
            "#a3ad62",
            "#fdfbe4",
            "#df91a3"
        ],
        "4": [
            "#929b4f",
            "#d9dbaf",
            "#f3d1ca",
            "#db8195"
        ],
        "5": [
            "#879043",
            "#c1c68c",
            "#fdfbe4",
            "#ebb4b8",
            "#d8758b"
        ],
        "6": [
            "#7f883b",
            "#b0b874",
            "#e3e4be",
            "#f6ddd1",
            "#e4a0ac",
            "#d66d85"
        ],
        "7": [
            "#798234",
            "#a3ad62",
            "#d0d3a2",
            "#fdfbe4",
            "#f0c6c3",
            "#df91a3",
            "#d46780"
        ],
        "tags": [
            "diverging"
        ]
    },
    "Fall": {
        "2": [
            "#3d5941",
            "#ca562c"
        ],
        "3": [
            "#3d5941",
            "#f6edbd",
            "#ca562c"
        ],
        "4": [
            "#3d5941",
            "#b5b991",
            "#edbb8a",
            "#ca562c"
        ],
        "5": [
            "#3d5941",
            "#96a07c",
            "#f6edbd",
            "#e6a272",
            "#ca562c"
        ],
        "6": [
            "#3d5941",
            "#839170",
            "#cecea2",
            "#f1cf9e",
            "#e19464",
            "#ca562c"
        ],
        "7": [
            "#3d5941",
            "#778868",
            "#b5b991",
            "#f6edbd",
            "#edbb8a",
            "#de8a5a",
            "#ca562c"
        ],
        "tags": [
            "diverging"
        ]
    },
    "Geyser": {
        "2": [
            "#008080",
            "#ca562c"
        ],
        "3": [
            "#008080",
            "#f6edbd",
            "#ca562c"
        ],
        "4": [
            "#008080",
            "#b4c8a8",
            "#edbb8a",
            "#ca562c"
        ],
        "5": [
            "#008080",
            "#92b69e",
            "#f6edbd",
            "#e6a272",
            "#ca562c"
        ],
        "6": [
            "#008080",
            "#7eab98",
            "#ced7b1",
            "#f1cf9e",
            "#e19464",
            "#ca562c"
        ],
        "7": [
            "#008080",
            "#70a494",
            "#b4c8a8",
            "#f6edbd",
            "#edbb8a",
            "#de8a5a",
            "#ca562c"
        ],
        "tags": [
            "diverging"
        ]
    },
    "Temps": {
        "2": [
            "#009392",
            "#cf597e"
        ],
        "3": [
            "#009392",
            "#e9e29c",
            "#cf597e"
        ],
        "4": [
            "#009392",
            "#9ccb86",
            "#eeb479",
            "#cf597e"
        ],
        "5": [
            "#009392",
            "#71be83",
            "#e9e29c",
            "#ed9c72",
            "#cf597e"
        ],
        "6": [
            "#009392",
            "#52b684",
            "#bcd48c",
            "#edc783",
            "#eb8d71",
            "#cf597e"
        ],
        "7": [
            "#009392",
            "#39b185",
            "#9ccb86",
            "#e9e29c",
            "#eeb479",
            "#e88471",
            "#cf597e"
        ],
        "tags": [
            "diverging"
        ]
    },
    "TealRose": {
        "2": [
            "#009392",
            "#d0587e"
        ],
        "3": [
            "#009392",
            "#f1eac8",
            "#d0587e"
        ],
        "4": [
            "#009392",
            "#91b8aa",
            "#f1eac8",
            "#dfa0a0",
            "#d0587e"
        ],
        "5": [
            "#009392",
            "#91b8aa",
            "#f1eac8",
            "#dfa0a0",
            "#d0587e"
        ],
        "6": [
            "#009392",
            "#72aaa1",
            "#b1c7b3",
            "#e5b9ad",
            "#d98994",
            "#d0587e"
        ],
        "7": [
            "#009392",
            "#72aaa1",
            "#b1c7b3",
            "#f1eac8",
            "#e5b9ad",
            "#d98994",
            "#d0587e"
        ],
        "tags": [
            "diverging"
        ]
    },
    "Tropic": {
        "2": [
            "#009B9E",
            "#C75DAB"
        ],
        "3": [
            "#009B9E",
            "#F1F1F1",
            "#C75DAB"
        ],
        "4": [
            "#009B9E",
            "#A7D3D4",
            "#E4C1D9",
            "#C75DAB"
        ],
        "5": [
            "#009B9E",
            "#7CC5C6",
            "#F1F1F1",
            "#DDA9CD",
            "#C75DAB"
        ],
        "6": [
            "#009B9E",
            "#5DBCBE",
            "#C6DFDF",
            "#E9D4E2",
            "#D99BC6",
            "#C75DAB"
        ],
        "7": [
            "#009B9E",
            "#42B7B9",
            "#A7D3D4",
            "#F1F1F1",
            "#E4C1D9",
            "#D691C1",
            "#C75DAB"
        ],
        "tags": [
            "diverging"
        ]
    },
    "Earth": {
        "2": [
            "#A16928",
            "#2887a1"
        ],
        "3": [
            "#A16928",
            "#edeac2",
            "#2887a1"
        ],
        "4": [
            "#A16928",
            "#d6bd8d",
            "#b5c8b8",
            "#2887a1"
        ],
        "5": [
            "#A16928",
            "#caa873",
            "#edeac2",
            "#98b7b2",
            "#2887a1"
        ],
        "6": [
            "#A16928",
            "#c29b64",
            "#e0cfa2",
            "#cbd5bc",
            "#85adaf",
            "#2887a1"
        ],
        "7": [
            "#A16928",
            "#bd925a",
            "#d6bd8d",
            "#edeac2",
            "#b5c8b8",
            "#79a7ac",
            "#2887a1"
        ],
        "tags": [
            "diverging"
        ]
    },
    "Antique": {
        "2": [
            "#855C75",
            "#D9AF6B",
            "#7C7C7C"
        ],
        "3": [
            "#855C75",
            "#D9AF6B",
            "#AF6458",
            "#7C7C7C"
        ],
        "4": [
            "#855C75",
            "#D9AF6B",
            "#AF6458",
            "#736F4C",
            "#7C7C7C"
        ],
        "5": [
            "#855C75",
            "#D9AF6B",
            "#AF6458",
            "#736F4C",
            "#526A83",
            "#7C7C7C"
        ],
        "6": [
            "#855C75",
            "#D9AF6B",
            "#AF6458",
            "#736F4C",
            "#526A83",
            "#625377",
            "#7C7C7C"
        ],
        "7": [
            "#855C75",
            "#D9AF6B",
            "#AF6458",
            "#736F4C",
            "#526A83",
            "#625377",
            "#68855C",
            "#7C7C7C"
        ],
        "8": [
            "#855C75",
            "#D9AF6B",
            "#AF6458",
            "#736F4C",
            "#526A83",
            "#625377",
            "#68855C",
            "#9C9C5E",
            "#7C7C7C"
        ],
        "9": [
            "#855C75",
            "#D9AF6B",
            "#AF6458",
            "#736F4C",
            "#526A83",
            "#625377",
            "#68855C",
            "#9C9C5E",
            "#A06177",
            "#7C7C7C"
        ],
        "10": [
            "#855C75",
            "#D9AF6B",
            "#AF6458",
            "#736F4C",
            "#526A83",
            "#625377",
            "#68855C",
            "#9C9C5E",
            "#A06177",
            "#8C785D",
            "#7C7C7C"
        ],
        "11": [
            "#855C75",
            "#D9AF6B",
            "#AF6458",
            "#736F4C",
            "#526A83",
            "#625377",
            "#68855C",
            "#9C9C5E",
            "#A06177",
            "#8C785D",
            "#467378",
            "#7C7C7C"
        ],
        "tags": [
            "qualitative"
        ]
    },
    "Bold": {
        "2": [
            "#7F3C8D",
            "#11A579",
            "#A5AA99"
        ],
        "3": [
            "#7F3C8D",
            "#11A579",
            "#3969AC",
            "#A5AA99"
        ],
        "4": [
            "#7F3C8D",
            "#11A579",
            "#3969AC",
            "#F2B701",
            "#A5AA99"
        ],
        "5": [
            "#7F3C8D",
            "#11A579",
            "#3969AC",
            "#F2B701",
            "#E73F74",
            "#A5AA99"
        ],
        "6": [
            "#7F3C8D",
            "#11A579",
            "#3969AC",
            "#F2B701",
            "#E73F74",
            "#80BA5A",
            "#A5AA99"
        ],
        "7": [
            "#7F3C8D",
            "#11A579",
            "#3969AC",
            "#F2B701",
            "#E73F74",
            "#80BA5A",
            "#E68310",
            "#A5AA99"
        ],
        "8": [
            "#7F3C8D",
            "#11A579",
            "#3969AC",
            "#F2B701",
            "#E73F74",
            "#80BA5A",
            "#E68310",
            "#008695",
            "#A5AA99"
        ],
        "9": [
            "#7F3C8D",
            "#11A579",
            "#3969AC",
            "#F2B701",
            "#E73F74",
            "#80BA5A",
            "#E68310",
            "#008695",
            "#CF1C90",
            "#A5AA99"
        ],
        "10": [
            "#7F3C8D",
            "#11A579",
            "#3969AC",
            "#F2B701",
            "#E73F74",
            "#80BA5A",
            "#E68310",
            "#008695",
            "#CF1C90",
            "#f97b72",
            "#A5AA99"
        ],
        "11": [
            "#7F3C8D",
            "#11A579",
            "#3969AC",
            "#F2B701",
            "#E73F74",
            "#80BA5A",
            "#E68310",
            "#008695",
            "#CF1C90",
            "#f97b72",
            "#4b4b8f",
            "#A5AA99"
        ],
        "tags": [
            "qualitative"
        ]
    },
    "Pastel": {
        "2": [
            "#66C5CC",
            "#F6CF71",
            "#B3B3B3"
        ],
        "3": [
            "#66C5CC",
            "#F6CF71",
            "#F89C74",
            "#B3B3B3"
        ],
        "4": [
            "#66C5CC",
            "#F6CF71",
            "#F89C74",
            "#DCB0F2",
            "#B3B3B3"
        ],
        "5": [
            "#66C5CC",
            "#F6CF71",
            "#F89C74",
            "#DCB0F2",
            "#87C55F",
            "#B3B3B3"
        ],
        "6": [
            "#66C5CC",
            "#F6CF71",
            "#F89C74",
            "#DCB0F2",
            "#87C55F",
            "#9EB9F3",
            "#B3B3B3"
        ],
        "7": [
            "#66C5CC",
            "#F6CF71",
            "#F89C74",
            "#DCB0F2",
            "#87C55F",
            "#9EB9F3",
            "#FE88B1",
            "#B3B3B3"
        ],
        "8": [
            "#66C5CC",
            "#F6CF71",
            "#F89C74",
            "#DCB0F2",
            "#87C55F",
            "#9EB9F3",
            "#FE88B1",
            "#C9DB74",
            "#B3B3B3"
        ],
        "9": [
            "#66C5CC",
            "#F6CF71",
            "#F89C74",
            "#DCB0F2",
            "#87C55F",
            "#9EB9F3",
            "#FE88B1",
            "#C9DB74",
            "#8BE0A4",
            "#B3B3B3"
        ],
        "10": [
            "#66C5CC",
            "#F6CF71",
            "#F89C74",
            "#DCB0F2",
            "#87C55F",
            "#9EB9F3",
            "#FE88B1",
            "#C9DB74",
            "#8BE0A4",
            "#B497E7",
            "#B3B3B3"
        ],
        "11": [
            "#66C5CC",
            "#F6CF71",
            "#F89C74",
            "#DCB0F2",
            "#87C55F",
            "#9EB9F3",
            "#FE88B1",
            "#C9DB74",
            "#8BE0A4",
            "#B497E7",
            "#D3B484",
            "#B3B3B3"
        ],
        "tags": [
            "qualitative"
        ]
    },
    "Prism": {
        "2": [
            "#5F4690",
            "#1D6996",
            "#666666"
        ],
        "3": [
            "#5F4690",
            "#1D6996",
            "#38A6A5",
            "#666666"
        ],
        "4": [
            "#5F4690",
            "#1D6996",
            "#38A6A5",
            "#0F8554",
            "#666666"
        ],
        "5": [
            "#5F4690",
            "#1D6996",
            "#38A6A5",
            "#0F8554",
            "#73AF48",
            "#666666"
        ],
        "6": [
            "#5F4690",
            "#1D6996",
            "#38A6A5",
            "#0F8554",
            "#73AF48",
            "#EDAD08",
            "#666666"
        ],
        "7": [
            "#5F4690",
            "#1D6996",
            "#38A6A5",
            "#0F8554",
            "#73AF48",
            "#EDAD08",
            "#E17C05",
            "#666666"
        ],
        "8": [
            "#5F4690",
            "#1D6996",
            "#38A6A5",
            "#0F8554",
            "#73AF48",
            "#EDAD08",
            "#E17C05",
            "#CC503E",
            "#666666"
        ],
        "9": [
            "#5F4690",
            "#1D6996",
            "#38A6A5",
            "#0F8554",
            "#73AF48",
            "#EDAD08",
            "#E17C05",
            "#CC503E",
            "#94346E",
            "#666666"
        ],
        "10": [
            "#5F4690",
            "#1D6996",
            "#38A6A5",
            "#0F8554",
            "#73AF48",
            "#EDAD08",
            "#E17C05",
            "#CC503E",
            "#94346E",
            "#6F4070",
            "#666666"
        ],
        "11": [
            "#5F4690",
            "#1D6996",
            "#38A6A5",
            "#0F8554",
            "#73AF48",
            "#EDAD08",
            "#E17C05",
            "#CC503E",
            "#94346E",
            "#6F4070",
            "#994E95",
            "#666666"
        ],
        "tags": [
            "qualitative"
        ]
    },
    "Safe": {
        "2": [
            "#88CCEE",
            "#CC6677",
            "#888888"
        ],
        "3": [
            "#88CCEE",
            "#CC6677",
            "#DDCC77",
            "#888888"
        ],
        "4": [
            "#88CCEE",
            "#CC6677",
            "#DDCC77",
            "#117733",
            "#888888"
        ],
        "5": [
            "#88CCEE",
            "#CC6677",
            "#DDCC77",
            "#117733",
            "#332288",
            "#888888"
        ],
        "6": [
            "#88CCEE",
            "#CC6677",
            "#DDCC77",
            "#117733",
            "#332288",
            "#AA4499",
            "#888888"
        ],
        "7": [
            "#88CCEE",
            "#CC6677",
            "#DDCC77",
            "#117733",
            "#332288",
            "#AA4499",
            "#44AA99",
            "#888888"
        ],
        "8": [
            "#88CCEE",
            "#CC6677",
            "#DDCC77",
            "#117733",
            "#332288",
            "#AA4499",
            "#44AA99",
            "#999933",
            "#888888"
        ],
        "9": [
            "#88CCEE",
            "#CC6677",
            "#DDCC77",
            "#117733",
            "#332288",
            "#AA4499",
            "#44AA99",
            "#999933",
            "#882255",
            "#888888"
        ],
        "10": [
            "#88CCEE",
            "#CC6677",
            "#DDCC77",
            "#117733",
            "#332288",
            "#AA4499",
            "#44AA99",
            "#999933",
            "#882255",
            "#661100",
            "#888888"
        ],
        "11": [
            "#88CCEE",
            "#CC6677",
            "#DDCC77",
            "#117733",
            "#332288",
            "#AA4499",
            "#44AA99",
            "#999933",
            "#882255",
            "#661100",
            "#6699CC",
            "#888888"
        ],
        "tags": [
            "qualitative",
            "colorblind"
        ]
    },
    "Vivid": {
        "2": [
            "#E58606",
            "#5D69B1",
            "#A5AA99"
        ],
        "3": [
            "#E58606",
            "#5D69B1",
            "#52BCA3",
            "#A5AA99"
        ],
        "4": [
            "#E58606",
            "#5D69B1",
            "#52BCA3",
            "#99C945",
            "#A5AA99"
        ],
        "5": [
            "#E58606",
            "#5D69B1",
            "#52BCA3",
            "#99C945",
            "#CC61B0",
            "#A5AA99"
        ],
        "6": [
            "#E58606",
            "#5D69B1",
            "#52BCA3",
            "#99C945",
            "#CC61B0",
            "#24796C",
            "#A5AA99"
        ],
        "7": [
            "#E58606",
            "#5D69B1",
            "#52BCA3",
            "#99C945",
            "#CC61B0",
            "#24796C",
            "#DAA51B",
            "#A5AA99"
        ],
        "8": [
            "#E58606",
            "#5D69B1",
            "#52BCA3",
            "#99C945",
            "#CC61B0",
            "#24796C",
            "#DAA51B",
            "#2F8AC4",
            "#A5AA99"
        ],
        "9": [
            "#E58606",
            "#5D69B1",
            "#52BCA3",
            "#99C945",
            "#CC61B0",
            "#24796C",
            "#DAA51B",
            "#2F8AC4",
            "#764E9F",
            "#A5AA99"
        ],
        "10": [
            "#E58606",
            "#5D69B1",
            "#52BCA3",
            "#99C945",
            "#CC61B0",
            "#24796C",
            "#DAA51B",
            "#2F8AC4",
            "#764E9F",
            "#ED645A",
            "#A5AA99"
        ],
        "11": [
            "#E58606",
            "#5D69B1",
            "#52BCA3",
            "#99C945",
            "#CC61B0",
            "#24796C",
            "#DAA51B",
            "#2F8AC4",
            "#764E9F",
            "#ED645A",
            "#CC3A8E",
            "#A5AA99"
        ],
        "tags": [
            "qualitative"
        ]
    }
};

var colorbrewer_tags = {
  "Blues": { "tags": ["quantitative"] },
  "BrBG": { "tags": ["diverging"] },
  "Greys": { "tags": ["quantitative"] },
  "PiYG": { "tags": ["diverging"] },
  "PRGn": { "tags": ["diverging"] },
  "Purples": { "tags": ["quantitative"] },
  "RdYlGn": { "tags": ["diverging"] },
  "Spectral": { "tags": ["diverging"] },
  "YlOrBr": { "tags": ["quantitative"] },
  "YlGn": { "tags": ["quantitative"] },
  "YlGnBu": { "tags": ["quantitative"] },
  "YlOrRd": { "tags": ["quantitative"] }
}

var colorbrewer = __webpack_require__(/*! colorbrewer */ "./node_modules/colorbrewer/index.js");

// augment colorbrewer with tags
for (var r in colorbrewer) {
  var ramps = colorbrewer[r];
  var augmentedRamps = {};
  for (var i in ramps) {
    augmentedRamps[i] = ramps[i];
  }

  if (r in colorbrewer_tags) {
    augmentedRamps.tags = colorbrewer_tags[r].tags;
  }

  cartocolor['cb_' + r] = augmentedRamps;
}

if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (cartocolor),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}

}();


/***/ }),

/***/ "./node_modules/cartocolor/index.js":
/*!******************************************!*\
  !*** ./node_modules/cartocolor/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./cartocolor */ "./node_modules/cartocolor/cartocolor.js");


/***/ }),

/***/ "./node_modules/colorbrewer/colorbrewer.js":
/*!*************************************************!*\
  !*** ./node_modules/colorbrewer/colorbrewer.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).
// JavaScript specs as packaged in the D3 library (d3js.org). Please see license at http://colorbrewer.org/export/LICENSE.txt
!function() {

var colorbrewer = {YlGn: {
3: ["#f7fcb9","#addd8e","#31a354"],
4: ["#ffffcc","#c2e699","#78c679","#238443"],
5: ["#ffffcc","#c2e699","#78c679","#31a354","#006837"],
6: ["#ffffcc","#d9f0a3","#addd8e","#78c679","#31a354","#006837"],
7: ["#ffffcc","#d9f0a3","#addd8e","#78c679","#41ab5d","#238443","#005a32"],
8: ["#ffffe5","#f7fcb9","#d9f0a3","#addd8e","#78c679","#41ab5d","#238443","#005a32"],
9: ["#ffffe5","#f7fcb9","#d9f0a3","#addd8e","#78c679","#41ab5d","#238443","#006837","#004529"]
},YlGnBu: {
3: ["#edf8b1","#7fcdbb","#2c7fb8"],
4: ["#ffffcc","#a1dab4","#41b6c4","#225ea8"],
5: ["#ffffcc","#a1dab4","#41b6c4","#2c7fb8","#253494"],
6: ["#ffffcc","#c7e9b4","#7fcdbb","#41b6c4","#2c7fb8","#253494"],
7: ["#ffffcc","#c7e9b4","#7fcdbb","#41b6c4","#1d91c0","#225ea8","#0c2c84"],
8: ["#ffffd9","#edf8b1","#c7e9b4","#7fcdbb","#41b6c4","#1d91c0","#225ea8","#0c2c84"],
9: ["#ffffd9","#edf8b1","#c7e9b4","#7fcdbb","#41b6c4","#1d91c0","#225ea8","#253494","#081d58"]
},GnBu: {
3: ["#e0f3db","#a8ddb5","#43a2ca"],
4: ["#f0f9e8","#bae4bc","#7bccc4","#2b8cbe"],
5: ["#f0f9e8","#bae4bc","#7bccc4","#43a2ca","#0868ac"],
6: ["#f0f9e8","#ccebc5","#a8ddb5","#7bccc4","#43a2ca","#0868ac"],
7: ["#f0f9e8","#ccebc5","#a8ddb5","#7bccc4","#4eb3d3","#2b8cbe","#08589e"],
8: ["#f7fcf0","#e0f3db","#ccebc5","#a8ddb5","#7bccc4","#4eb3d3","#2b8cbe","#08589e"],
9: ["#f7fcf0","#e0f3db","#ccebc5","#a8ddb5","#7bccc4","#4eb3d3","#2b8cbe","#0868ac","#084081"]
},BuGn: {
3: ["#e5f5f9","#99d8c9","#2ca25f"],
4: ["#edf8fb","#b2e2e2","#66c2a4","#238b45"],
5: ["#edf8fb","#b2e2e2","#66c2a4","#2ca25f","#006d2c"],
6: ["#edf8fb","#ccece6","#99d8c9","#66c2a4","#2ca25f","#006d2c"],
7: ["#edf8fb","#ccece6","#99d8c9","#66c2a4","#41ae76","#238b45","#005824"],
8: ["#f7fcfd","#e5f5f9","#ccece6","#99d8c9","#66c2a4","#41ae76","#238b45","#005824"],
9: ["#f7fcfd","#e5f5f9","#ccece6","#99d8c9","#66c2a4","#41ae76","#238b45","#006d2c","#00441b"]
},PuBuGn: {
3: ["#ece2f0","#a6bddb","#1c9099"],
4: ["#f6eff7","#bdc9e1","#67a9cf","#02818a"],
5: ["#f6eff7","#bdc9e1","#67a9cf","#1c9099","#016c59"],
6: ["#f6eff7","#d0d1e6","#a6bddb","#67a9cf","#1c9099","#016c59"],
7: ["#f6eff7","#d0d1e6","#a6bddb","#67a9cf","#3690c0","#02818a","#016450"],
8: ["#fff7fb","#ece2f0","#d0d1e6","#a6bddb","#67a9cf","#3690c0","#02818a","#016450"],
9: ["#fff7fb","#ece2f0","#d0d1e6","#a6bddb","#67a9cf","#3690c0","#02818a","#016c59","#014636"]
},PuBu: {
3: ["#ece7f2","#a6bddb","#2b8cbe"],
4: ["#f1eef6","#bdc9e1","#74a9cf","#0570b0"],
5: ["#f1eef6","#bdc9e1","#74a9cf","#2b8cbe","#045a8d"],
6: ["#f1eef6","#d0d1e6","#a6bddb","#74a9cf","#2b8cbe","#045a8d"],
7: ["#f1eef6","#d0d1e6","#a6bddb","#74a9cf","#3690c0","#0570b0","#034e7b"],
8: ["#fff7fb","#ece7f2","#d0d1e6","#a6bddb","#74a9cf","#3690c0","#0570b0","#034e7b"],
9: ["#fff7fb","#ece7f2","#d0d1e6","#a6bddb","#74a9cf","#3690c0","#0570b0","#045a8d","#023858"]
},BuPu: {
3: ["#e0ecf4","#9ebcda","#8856a7"],
4: ["#edf8fb","#b3cde3","#8c96c6","#88419d"],
5: ["#edf8fb","#b3cde3","#8c96c6","#8856a7","#810f7c"],
6: ["#edf8fb","#bfd3e6","#9ebcda","#8c96c6","#8856a7","#810f7c"],
7: ["#edf8fb","#bfd3e6","#9ebcda","#8c96c6","#8c6bb1","#88419d","#6e016b"],
8: ["#f7fcfd","#e0ecf4","#bfd3e6","#9ebcda","#8c96c6","#8c6bb1","#88419d","#6e016b"],
9: ["#f7fcfd","#e0ecf4","#bfd3e6","#9ebcda","#8c96c6","#8c6bb1","#88419d","#810f7c","#4d004b"]
},RdPu: {
3: ["#fde0dd","#fa9fb5","#c51b8a"],
4: ["#feebe2","#fbb4b9","#f768a1","#ae017e"],
5: ["#feebe2","#fbb4b9","#f768a1","#c51b8a","#7a0177"],
6: ["#feebe2","#fcc5c0","#fa9fb5","#f768a1","#c51b8a","#7a0177"],
7: ["#feebe2","#fcc5c0","#fa9fb5","#f768a1","#dd3497","#ae017e","#7a0177"],
8: ["#fff7f3","#fde0dd","#fcc5c0","#fa9fb5","#f768a1","#dd3497","#ae017e","#7a0177"],
9: ["#fff7f3","#fde0dd","#fcc5c0","#fa9fb5","#f768a1","#dd3497","#ae017e","#7a0177","#49006a"]
},PuRd: {
3: ["#e7e1ef","#c994c7","#dd1c77"],
4: ["#f1eef6","#d7b5d8","#df65b0","#ce1256"],
5: ["#f1eef6","#d7b5d8","#df65b0","#dd1c77","#980043"],
6: ["#f1eef6","#d4b9da","#c994c7","#df65b0","#dd1c77","#980043"],
7: ["#f1eef6","#d4b9da","#c994c7","#df65b0","#e7298a","#ce1256","#91003f"],
8: ["#f7f4f9","#e7e1ef","#d4b9da","#c994c7","#df65b0","#e7298a","#ce1256","#91003f"],
9: ["#f7f4f9","#e7e1ef","#d4b9da","#c994c7","#df65b0","#e7298a","#ce1256","#980043","#67001f"]
},OrRd: {
3: ["#fee8c8","#fdbb84","#e34a33"],
4: ["#fef0d9","#fdcc8a","#fc8d59","#d7301f"],
5: ["#fef0d9","#fdcc8a","#fc8d59","#e34a33","#b30000"],
6: ["#fef0d9","#fdd49e","#fdbb84","#fc8d59","#e34a33","#b30000"],
7: ["#fef0d9","#fdd49e","#fdbb84","#fc8d59","#ef6548","#d7301f","#990000"],
8: ["#fff7ec","#fee8c8","#fdd49e","#fdbb84","#fc8d59","#ef6548","#d7301f","#990000"],
9: ["#fff7ec","#fee8c8","#fdd49e","#fdbb84","#fc8d59","#ef6548","#d7301f","#b30000","#7f0000"]
},YlOrRd: {
3: ["#ffeda0","#feb24c","#f03b20"],
4: ["#ffffb2","#fecc5c","#fd8d3c","#e31a1c"],
5: ["#ffffb2","#fecc5c","#fd8d3c","#f03b20","#bd0026"],
6: ["#ffffb2","#fed976","#feb24c","#fd8d3c","#f03b20","#bd0026"],
7: ["#ffffb2","#fed976","#feb24c","#fd8d3c","#fc4e2a","#e31a1c","#b10026"],
8: ["#ffffcc","#ffeda0","#fed976","#feb24c","#fd8d3c","#fc4e2a","#e31a1c","#b10026"],
9: ["#ffffcc","#ffeda0","#fed976","#feb24c","#fd8d3c","#fc4e2a","#e31a1c","#bd0026","#800026"]
},YlOrBr: {
3: ["#fff7bc","#fec44f","#d95f0e"],
4: ["#ffffd4","#fed98e","#fe9929","#cc4c02"],
5: ["#ffffd4","#fed98e","#fe9929","#d95f0e","#993404"],
6: ["#ffffd4","#fee391","#fec44f","#fe9929","#d95f0e","#993404"],
7: ["#ffffd4","#fee391","#fec44f","#fe9929","#ec7014","#cc4c02","#8c2d04"],
8: ["#ffffe5","#fff7bc","#fee391","#fec44f","#fe9929","#ec7014","#cc4c02","#8c2d04"],
9: ["#ffffe5","#fff7bc","#fee391","#fec44f","#fe9929","#ec7014","#cc4c02","#993404","#662506"]
},Purples: {
3: ["#efedf5","#bcbddc","#756bb1"],
4: ["#f2f0f7","#cbc9e2","#9e9ac8","#6a51a3"],
5: ["#f2f0f7","#cbc9e2","#9e9ac8","#756bb1","#54278f"],
6: ["#f2f0f7","#dadaeb","#bcbddc","#9e9ac8","#756bb1","#54278f"],
7: ["#f2f0f7","#dadaeb","#bcbddc","#9e9ac8","#807dba","#6a51a3","#4a1486"],
8: ["#fcfbfd","#efedf5","#dadaeb","#bcbddc","#9e9ac8","#807dba","#6a51a3","#4a1486"],
9: ["#fcfbfd","#efedf5","#dadaeb","#bcbddc","#9e9ac8","#807dba","#6a51a3","#54278f","#3f007d"]
},Blues: {
3: ["#deebf7","#9ecae1","#3182bd"],
4: ["#eff3ff","#bdd7e7","#6baed6","#2171b5"],
5: ["#eff3ff","#bdd7e7","#6baed6","#3182bd","#08519c"],
6: ["#eff3ff","#c6dbef","#9ecae1","#6baed6","#3182bd","#08519c"],
7: ["#eff3ff","#c6dbef","#9ecae1","#6baed6","#4292c6","#2171b5","#084594"],
8: ["#f7fbff","#deebf7","#c6dbef","#9ecae1","#6baed6","#4292c6","#2171b5","#084594"],
9: ["#f7fbff","#deebf7","#c6dbef","#9ecae1","#6baed6","#4292c6","#2171b5","#08519c","#08306b"]
},Greens: {
3: ["#e5f5e0","#a1d99b","#31a354"],
4: ["#edf8e9","#bae4b3","#74c476","#238b45"],
5: ["#edf8e9","#bae4b3","#74c476","#31a354","#006d2c"],
6: ["#edf8e9","#c7e9c0","#a1d99b","#74c476","#31a354","#006d2c"],
7: ["#edf8e9","#c7e9c0","#a1d99b","#74c476","#41ab5d","#238b45","#005a32"],
8: ["#f7fcf5","#e5f5e0","#c7e9c0","#a1d99b","#74c476","#41ab5d","#238b45","#005a32"],
9: ["#f7fcf5","#e5f5e0","#c7e9c0","#a1d99b","#74c476","#41ab5d","#238b45","#006d2c","#00441b"]
},Oranges: {
3: ["#fee6ce","#fdae6b","#e6550d"],
4: ["#feedde","#fdbe85","#fd8d3c","#d94701"],
5: ["#feedde","#fdbe85","#fd8d3c","#e6550d","#a63603"],
6: ["#feedde","#fdd0a2","#fdae6b","#fd8d3c","#e6550d","#a63603"],
7: ["#feedde","#fdd0a2","#fdae6b","#fd8d3c","#f16913","#d94801","#8c2d04"],
8: ["#fff5eb","#fee6ce","#fdd0a2","#fdae6b","#fd8d3c","#f16913","#d94801","#8c2d04"],
9: ["#fff5eb","#fee6ce","#fdd0a2","#fdae6b","#fd8d3c","#f16913","#d94801","#a63603","#7f2704"]
},Reds: {
3: ["#fee0d2","#fc9272","#de2d26"],
4: ["#fee5d9","#fcae91","#fb6a4a","#cb181d"],
5: ["#fee5d9","#fcae91","#fb6a4a","#de2d26","#a50f15"],
6: ["#fee5d9","#fcbba1","#fc9272","#fb6a4a","#de2d26","#a50f15"],
7: ["#fee5d9","#fcbba1","#fc9272","#fb6a4a","#ef3b2c","#cb181d","#99000d"],
8: ["#fff5f0","#fee0d2","#fcbba1","#fc9272","#fb6a4a","#ef3b2c","#cb181d","#99000d"],
9: ["#fff5f0","#fee0d2","#fcbba1","#fc9272","#fb6a4a","#ef3b2c","#cb181d","#a50f15","#67000d"]
},Greys: {
3: ["#f0f0f0","#bdbdbd","#636363"],
4: ["#f7f7f7","#cccccc","#969696","#525252"],
5: ["#f7f7f7","#cccccc","#969696","#636363","#252525"],
6: ["#f7f7f7","#d9d9d9","#bdbdbd","#969696","#636363","#252525"],
7: ["#f7f7f7","#d9d9d9","#bdbdbd","#969696","#737373","#525252","#252525"],
8: ["#ffffff","#f0f0f0","#d9d9d9","#bdbdbd","#969696","#737373","#525252","#252525"],
9: ["#ffffff","#f0f0f0","#d9d9d9","#bdbdbd","#969696","#737373","#525252","#252525","#000000"]
},PuOr: {
3: ["#f1a340","#f7f7f7","#998ec3"],
4: ["#e66101","#fdb863","#b2abd2","#5e3c99"],
5: ["#e66101","#fdb863","#f7f7f7","#b2abd2","#5e3c99"],
6: ["#b35806","#f1a340","#fee0b6","#d8daeb","#998ec3","#542788"],
7: ["#b35806","#f1a340","#fee0b6","#f7f7f7","#d8daeb","#998ec3","#542788"],
8: ["#b35806","#e08214","#fdb863","#fee0b6","#d8daeb","#b2abd2","#8073ac","#542788"],
9: ["#b35806","#e08214","#fdb863","#fee0b6","#f7f7f7","#d8daeb","#b2abd2","#8073ac","#542788"],
10: ["#7f3b08","#b35806","#e08214","#fdb863","#fee0b6","#d8daeb","#b2abd2","#8073ac","#542788","#2d004b"],
11: ["#7f3b08","#b35806","#e08214","#fdb863","#fee0b6","#f7f7f7","#d8daeb","#b2abd2","#8073ac","#542788","#2d004b"]
},BrBG: {
3: ["#d8b365","#f5f5f5","#5ab4ac"],
4: ["#a6611a","#dfc27d","#80cdc1","#018571"],
5: ["#a6611a","#dfc27d","#f5f5f5","#80cdc1","#018571"],
6: ["#8c510a","#d8b365","#f6e8c3","#c7eae5","#5ab4ac","#01665e"],
7: ["#8c510a","#d8b365","#f6e8c3","#f5f5f5","#c7eae5","#5ab4ac","#01665e"],
8: ["#8c510a","#bf812d","#dfc27d","#f6e8c3","#c7eae5","#80cdc1","#35978f","#01665e"],
9: ["#8c510a","#bf812d","#dfc27d","#f6e8c3","#f5f5f5","#c7eae5","#80cdc1","#35978f","#01665e"],
10: ["#543005","#8c510a","#bf812d","#dfc27d","#f6e8c3","#c7eae5","#80cdc1","#35978f","#01665e","#003c30"],
11: ["#543005","#8c510a","#bf812d","#dfc27d","#f6e8c3","#f5f5f5","#c7eae5","#80cdc1","#35978f","#01665e","#003c30"]
},PRGn: {
3: ["#af8dc3","#f7f7f7","#7fbf7b"],
4: ["#7b3294","#c2a5cf","#a6dba0","#008837"],
5: ["#7b3294","#c2a5cf","#f7f7f7","#a6dba0","#008837"],
6: ["#762a83","#af8dc3","#e7d4e8","#d9f0d3","#7fbf7b","#1b7837"],
7: ["#762a83","#af8dc3","#e7d4e8","#f7f7f7","#d9f0d3","#7fbf7b","#1b7837"],
8: ["#762a83","#9970ab","#c2a5cf","#e7d4e8","#d9f0d3","#a6dba0","#5aae61","#1b7837"],
9: ["#762a83","#9970ab","#c2a5cf","#e7d4e8","#f7f7f7","#d9f0d3","#a6dba0","#5aae61","#1b7837"],
10: ["#40004b","#762a83","#9970ab","#c2a5cf","#e7d4e8","#d9f0d3","#a6dba0","#5aae61","#1b7837","#00441b"],
11: ["#40004b","#762a83","#9970ab","#c2a5cf","#e7d4e8","#f7f7f7","#d9f0d3","#a6dba0","#5aae61","#1b7837","#00441b"]
},PiYG: {
3: ["#e9a3c9","#f7f7f7","#a1d76a"],
4: ["#d01c8b","#f1b6da","#b8e186","#4dac26"],
5: ["#d01c8b","#f1b6da","#f7f7f7","#b8e186","#4dac26"],
6: ["#c51b7d","#e9a3c9","#fde0ef","#e6f5d0","#a1d76a","#4d9221"],
7: ["#c51b7d","#e9a3c9","#fde0ef","#f7f7f7","#e6f5d0","#a1d76a","#4d9221"],
8: ["#c51b7d","#de77ae","#f1b6da","#fde0ef","#e6f5d0","#b8e186","#7fbc41","#4d9221"],
9: ["#c51b7d","#de77ae","#f1b6da","#fde0ef","#f7f7f7","#e6f5d0","#b8e186","#7fbc41","#4d9221"],
10: ["#8e0152","#c51b7d","#de77ae","#f1b6da","#fde0ef","#e6f5d0","#b8e186","#7fbc41","#4d9221","#276419"],
11: ["#8e0152","#c51b7d","#de77ae","#f1b6da","#fde0ef","#f7f7f7","#e6f5d0","#b8e186","#7fbc41","#4d9221","#276419"]
},RdBu: {
3: ["#ef8a62","#f7f7f7","#67a9cf"],
4: ["#ca0020","#f4a582","#92c5de","#0571b0"],
5: ["#ca0020","#f4a582","#f7f7f7","#92c5de","#0571b0"],
6: ["#b2182b","#ef8a62","#fddbc7","#d1e5f0","#67a9cf","#2166ac"],
7: ["#b2182b","#ef8a62","#fddbc7","#f7f7f7","#d1e5f0","#67a9cf","#2166ac"],
8: ["#b2182b","#d6604d","#f4a582","#fddbc7","#d1e5f0","#92c5de","#4393c3","#2166ac"],
9: ["#b2182b","#d6604d","#f4a582","#fddbc7","#f7f7f7","#d1e5f0","#92c5de","#4393c3","#2166ac"],
10: ["#67001f","#b2182b","#d6604d","#f4a582","#fddbc7","#d1e5f0","#92c5de","#4393c3","#2166ac","#053061"],
11: ["#67001f","#b2182b","#d6604d","#f4a582","#fddbc7","#f7f7f7","#d1e5f0","#92c5de","#4393c3","#2166ac","#053061"]
},RdGy: {
3: ["#ef8a62","#ffffff","#999999"],
4: ["#ca0020","#f4a582","#bababa","#404040"],
5: ["#ca0020","#f4a582","#ffffff","#bababa","#404040"],
6: ["#b2182b","#ef8a62","#fddbc7","#e0e0e0","#999999","#4d4d4d"],
7: ["#b2182b","#ef8a62","#fddbc7","#ffffff","#e0e0e0","#999999","#4d4d4d"],
8: ["#b2182b","#d6604d","#f4a582","#fddbc7","#e0e0e0","#bababa","#878787","#4d4d4d"],
9: ["#b2182b","#d6604d","#f4a582","#fddbc7","#ffffff","#e0e0e0","#bababa","#878787","#4d4d4d"],
10: ["#67001f","#b2182b","#d6604d","#f4a582","#fddbc7","#e0e0e0","#bababa","#878787","#4d4d4d","#1a1a1a"],
11: ["#67001f","#b2182b","#d6604d","#f4a582","#fddbc7","#ffffff","#e0e0e0","#bababa","#878787","#4d4d4d","#1a1a1a"]
},RdYlBu: {
3: ["#fc8d59","#ffffbf","#91bfdb"],
4: ["#d7191c","#fdae61","#abd9e9","#2c7bb6"],
5: ["#d7191c","#fdae61","#ffffbf","#abd9e9","#2c7bb6"],
6: ["#d73027","#fc8d59","#fee090","#e0f3f8","#91bfdb","#4575b4"],
7: ["#d73027","#fc8d59","#fee090","#ffffbf","#e0f3f8","#91bfdb","#4575b4"],
8: ["#d73027","#f46d43","#fdae61","#fee090","#e0f3f8","#abd9e9","#74add1","#4575b4"],
9: ["#d73027","#f46d43","#fdae61","#fee090","#ffffbf","#e0f3f8","#abd9e9","#74add1","#4575b4"],
10: ["#a50026","#d73027","#f46d43","#fdae61","#fee090","#e0f3f8","#abd9e9","#74add1","#4575b4","#313695"],
11: ["#a50026","#d73027","#f46d43","#fdae61","#fee090","#ffffbf","#e0f3f8","#abd9e9","#74add1","#4575b4","#313695"]
},Spectral: {
3: ["#fc8d59","#ffffbf","#99d594"],
4: ["#d7191c","#fdae61","#abdda4","#2b83ba"],
5: ["#d7191c","#fdae61","#ffffbf","#abdda4","#2b83ba"],
6: ["#d53e4f","#fc8d59","#fee08b","#e6f598","#99d594","#3288bd"],
7: ["#d53e4f","#fc8d59","#fee08b","#ffffbf","#e6f598","#99d594","#3288bd"],
8: ["#d53e4f","#f46d43","#fdae61","#fee08b","#e6f598","#abdda4","#66c2a5","#3288bd"],
9: ["#d53e4f","#f46d43","#fdae61","#fee08b","#ffffbf","#e6f598","#abdda4","#66c2a5","#3288bd"],
10: ["#9e0142","#d53e4f","#f46d43","#fdae61","#fee08b","#e6f598","#abdda4","#66c2a5","#3288bd","#5e4fa2"],
11: ["#9e0142","#d53e4f","#f46d43","#fdae61","#fee08b","#ffffbf","#e6f598","#abdda4","#66c2a5","#3288bd","#5e4fa2"]
},RdYlGn: {
3: ["#fc8d59","#ffffbf","#91cf60"],
4: ["#d7191c","#fdae61","#a6d96a","#1a9641"],
5: ["#d7191c","#fdae61","#ffffbf","#a6d96a","#1a9641"],
6: ["#d73027","#fc8d59","#fee08b","#d9ef8b","#91cf60","#1a9850"],
7: ["#d73027","#fc8d59","#fee08b","#ffffbf","#d9ef8b","#91cf60","#1a9850"],
8: ["#d73027","#f46d43","#fdae61","#fee08b","#d9ef8b","#a6d96a","#66bd63","#1a9850"],
9: ["#d73027","#f46d43","#fdae61","#fee08b","#ffffbf","#d9ef8b","#a6d96a","#66bd63","#1a9850"],
10: ["#a50026","#d73027","#f46d43","#fdae61","#fee08b","#d9ef8b","#a6d96a","#66bd63","#1a9850","#006837"],
11: ["#a50026","#d73027","#f46d43","#fdae61","#fee08b","#ffffbf","#d9ef8b","#a6d96a","#66bd63","#1a9850","#006837"]
},Accent: {
3: ["#7fc97f","#beaed4","#fdc086"],
4: ["#7fc97f","#beaed4","#fdc086","#ffff99"],
5: ["#7fc97f","#beaed4","#fdc086","#ffff99","#386cb0"],
6: ["#7fc97f","#beaed4","#fdc086","#ffff99","#386cb0","#f0027f"],
7: ["#7fc97f","#beaed4","#fdc086","#ffff99","#386cb0","#f0027f","#bf5b17"],
8: ["#7fc97f","#beaed4","#fdc086","#ffff99","#386cb0","#f0027f","#bf5b17","#666666"]
},Dark2: {
3: ["#1b9e77","#d95f02","#7570b3"],
4: ["#1b9e77","#d95f02","#7570b3","#e7298a"],
5: ["#1b9e77","#d95f02","#7570b3","#e7298a","#66a61e"],
6: ["#1b9e77","#d95f02","#7570b3","#e7298a","#66a61e","#e6ab02"],
7: ["#1b9e77","#d95f02","#7570b3","#e7298a","#66a61e","#e6ab02","#a6761d"],
8: ["#1b9e77","#d95f02","#7570b3","#e7298a","#66a61e","#e6ab02","#a6761d","#666666"]
},Paired: {
3: ["#a6cee3","#1f78b4","#b2df8a"],
4: ["#a6cee3","#1f78b4","#b2df8a","#33a02c"],
5: ["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99"],
6: ["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c"],
7: ["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c","#fdbf6f"],
8: ["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c","#fdbf6f","#ff7f00"],
9: ["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c","#fdbf6f","#ff7f00","#cab2d6"],
10: ["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c","#fdbf6f","#ff7f00","#cab2d6","#6a3d9a"],
11: ["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c","#fdbf6f","#ff7f00","#cab2d6","#6a3d9a","#ffff99"],
12: ["#a6cee3","#1f78b4","#b2df8a","#33a02c","#fb9a99","#e31a1c","#fdbf6f","#ff7f00","#cab2d6","#6a3d9a","#ffff99","#b15928"]
},Pastel1: {
3: ["#fbb4ae","#b3cde3","#ccebc5"],
4: ["#fbb4ae","#b3cde3","#ccebc5","#decbe4"],
5: ["#fbb4ae","#b3cde3","#ccebc5","#decbe4","#fed9a6"],
6: ["#fbb4ae","#b3cde3","#ccebc5","#decbe4","#fed9a6","#ffffcc"],
7: ["#fbb4ae","#b3cde3","#ccebc5","#decbe4","#fed9a6","#ffffcc","#e5d8bd"],
8: ["#fbb4ae","#b3cde3","#ccebc5","#decbe4","#fed9a6","#ffffcc","#e5d8bd","#fddaec"],
9: ["#fbb4ae","#b3cde3","#ccebc5","#decbe4","#fed9a6","#ffffcc","#e5d8bd","#fddaec","#f2f2f2"]
},Pastel2: {
3: ["#b3e2cd","#fdcdac","#cbd5e8"],
4: ["#b3e2cd","#fdcdac","#cbd5e8","#f4cae4"],
5: ["#b3e2cd","#fdcdac","#cbd5e8","#f4cae4","#e6f5c9"],
6: ["#b3e2cd","#fdcdac","#cbd5e8","#f4cae4","#e6f5c9","#fff2ae"],
7: ["#b3e2cd","#fdcdac","#cbd5e8","#f4cae4","#e6f5c9","#fff2ae","#f1e2cc"],
8: ["#b3e2cd","#fdcdac","#cbd5e8","#f4cae4","#e6f5c9","#fff2ae","#f1e2cc","#cccccc"]
},Set1: {
3: ["#e41a1c","#377eb8","#4daf4a"],
4: ["#e41a1c","#377eb8","#4daf4a","#984ea3"],
5: ["#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00"],
6: ["#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00","#ffff33"],
7: ["#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00","#ffff33","#a65628"],
8: ["#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00","#ffff33","#a65628","#f781bf"],
9: ["#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00","#ffff33","#a65628","#f781bf","#999999"]
},Set2: {
3: ["#66c2a5","#fc8d62","#8da0cb"],
4: ["#66c2a5","#fc8d62","#8da0cb","#e78ac3"],
5: ["#66c2a5","#fc8d62","#8da0cb","#e78ac3","#a6d854"],
6: ["#66c2a5","#fc8d62","#8da0cb","#e78ac3","#a6d854","#ffd92f"],
7: ["#66c2a5","#fc8d62","#8da0cb","#e78ac3","#a6d854","#ffd92f","#e5c494"],
8: ["#66c2a5","#fc8d62","#8da0cb","#e78ac3","#a6d854","#ffd92f","#e5c494","#b3b3b3"]
},Set3: {
3: ["#8dd3c7","#ffffb3","#bebada"],
4: ["#8dd3c7","#ffffb3","#bebada","#fb8072"],
5: ["#8dd3c7","#ffffb3","#bebada","#fb8072","#80b1d3"],
6: ["#8dd3c7","#ffffb3","#bebada","#fb8072","#80b1d3","#fdb462"],
7: ["#8dd3c7","#ffffb3","#bebada","#fb8072","#80b1d3","#fdb462","#b3de69"],
8: ["#8dd3c7","#ffffb3","#bebada","#fb8072","#80b1d3","#fdb462","#b3de69","#fccde5"],
9: ["#8dd3c7","#ffffb3","#bebada","#fb8072","#80b1d3","#fdb462","#b3de69","#fccde5","#d9d9d9"],
10: ["#8dd3c7","#ffffb3","#bebada","#fb8072","#80b1d3","#fdb462","#b3de69","#fccde5","#d9d9d9","#bc80bd"],
11: ["#8dd3c7","#ffffb3","#bebada","#fb8072","#80b1d3","#fdb462","#b3de69","#fccde5","#d9d9d9","#bc80bd","#ccebc5"],
12: ["#8dd3c7","#ffffb3","#bebada","#fb8072","#80b1d3","#fdb462","#b3de69","#fccde5","#d9d9d9","#bc80bd","#ccebc5","#ffed6f"]
}};

if (true) {
    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (colorbrewer),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}

}();


/***/ }),

/***/ "./node_modules/colorbrewer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/colorbrewer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./colorbrewer.js */ "./node_modules/colorbrewer/colorbrewer.js");


/***/ }),

/***/ "./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),

/***/ "./node_modules/gl-matrix/lib/gl-matrix.js":
/*!*************************************************!*\
  !*** ./node_modules/gl-matrix/lib/gl-matrix.js ***!
  \*************************************************/
/*! exports provided: glMatrix, mat2, mat2d, mat3, mat4, quat, quat2, vec2, vec3, vec4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _gl_matrix_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gl-matrix/common.js */ "./node_modules/gl-matrix/lib/gl-matrix/common.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "glMatrix", function() { return _gl_matrix_common_js__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony import */ var _gl_matrix_mat2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gl-matrix/mat2.js */ "./node_modules/gl-matrix/lib/gl-matrix/mat2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2", function() { return _gl_matrix_mat2_js__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _gl_matrix_mat2d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gl-matrix/mat2d.js */ "./node_modules/gl-matrix/lib/gl-matrix/mat2d.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat2d", function() { return _gl_matrix_mat2d_js__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _gl_matrix_mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gl-matrix/mat3.js */ "./node_modules/gl-matrix/lib/gl-matrix/mat3.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat3", function() { return _gl_matrix_mat3_js__WEBPACK_IMPORTED_MODULE_3__; });
/* harmony import */ var _gl_matrix_mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gl-matrix/mat4.js */ "./node_modules/gl-matrix/lib/gl-matrix/mat4.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "mat4", function() { return _gl_matrix_mat4_js__WEBPACK_IMPORTED_MODULE_4__; });
/* harmony import */ var _gl_matrix_quat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./gl-matrix/quat.js */ "./node_modules/gl-matrix/lib/gl-matrix/quat.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat", function() { return _gl_matrix_quat_js__WEBPACK_IMPORTED_MODULE_5__; });
/* harmony import */ var _gl_matrix_quat2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./gl-matrix/quat2.js */ "./node_modules/gl-matrix/lib/gl-matrix/quat2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "quat2", function() { return _gl_matrix_quat2_js__WEBPACK_IMPORTED_MODULE_6__; });
/* harmony import */ var _gl_matrix_vec2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./gl-matrix/vec2.js */ "./node_modules/gl-matrix/lib/gl-matrix/vec2.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec2", function() { return _gl_matrix_vec2_js__WEBPACK_IMPORTED_MODULE_7__; });
/* harmony import */ var _gl_matrix_vec3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./gl-matrix/vec3.js */ "./node_modules/gl-matrix/lib/gl-matrix/vec3.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec3", function() { return _gl_matrix_vec3_js__WEBPACK_IMPORTED_MODULE_8__; });
/* harmony import */ var _gl_matrix_vec4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./gl-matrix/vec4.js */ "./node_modules/gl-matrix/lib/gl-matrix/vec4.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "vec4", function() { return _gl_matrix_vec4_js__WEBPACK_IMPORTED_MODULE_9__; });













/***/ }),

/***/ "./node_modules/gl-matrix/lib/gl-matrix/common.js":
/*!********************************************************!*\
  !*** ./node_modules/gl-matrix/lib/gl-matrix/common.js ***!
  \********************************************************/
/*! exports provided: EPSILON, ARRAY_TYPE, RANDOM, setMatrixArrayType, toRadian, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON", function() { return EPSILON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RANDOM", function() { return RANDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMatrixArrayType", function() { return setMatrixArrayType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadian", function() { return toRadian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/**
 * Common utilities
 * @module glMatrix
 */

// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;

/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */
function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}

var degree = Math.PI / 180;

/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */
function toRadian(a) {
  return a * degree;
}

/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */
function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

/***/ }),

/***/ "./node_modules/gl-matrix/lib/gl-matrix/mat2.js":
/*!******************************************************!*\
  !*** ./node_modules/gl-matrix/lib/gl-matrix/mat2.js ***!
  \******************************************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, transpose, invert, adjoint, determinant, multiply, rotate, scale, fromRotation, fromScaling, str, frob, LDU, add, subtract, exactEquals, equals, multiplyScalar, multiplyScalarAndAdd, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LDU", function() { return LDU; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/lib/gl-matrix/common.js");


/**
 * 2x2 Matrix
 * @module mat2
 */

/**
 * Creates a new identity mat2
 *
 * @returns {mat2} a new 2x2 matrix
 */
function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}

/**
 * Creates a new mat2 initialized with values from an existing matrix
 *
 * @param {mat2} a matrix to clone
 * @returns {mat2} a new 2x2 matrix
 */
function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Copy the values from one mat2 to another
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set a mat2 to the identity matrix
 *
 * @param {mat2} out the receiving matrix
 * @returns {mat2} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Create a new mat2 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out A new 2x2 matrix
 */
function fromValues(m00, m01, m10, m11) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Set the components of a mat2 to the given values
 *
 * @param {mat2} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m10 Component in column 1, row 0 position (index 2)
 * @param {Number} m11 Component in column 1, row 1 position (index 3)
 * @returns {mat2} out
 */
function set(out, m00, m01, m10, m11) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m10;
  out[3] = m11;
  return out;
}

/**
 * Transpose the values of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache
  // some values
  if (out === a) {
    var a1 = a[1];
    out[1] = a[2];
    out[2] = a1;
  } else {
    out[0] = a[0];
    out[1] = a[2];
    out[2] = a[1];
    out[3] = a[3];
  }

  return out;
}

/**
 * Inverts a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];

  // Calculate the determinant
  var det = a0 * a3 - a2 * a1;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = a3 * det;
  out[1] = -a1 * det;
  out[2] = -a2 * det;
  out[3] = a0 * det;

  return out;
}

/**
 * Calculates the adjugate of a mat2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the source matrix
 * @returns {mat2} out
 */
function adjoint(out, a) {
  // Caching this value is nessecary if out == a
  var a0 = a[0];
  out[0] = a[3];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a0;

  return out;
}

/**
 * Calculates the determinant of a mat2
 *
 * @param {mat2} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[2] * a[1];
}

/**
 * Multiplies two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  return out;
}

/**
 * Rotates a mat2 by the given angle
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  return out;
}

/**
 * Scales the mat2 by the dimensions in the given vec2
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2} out
 **/
function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.rotate(dest, dest, rad);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2} out
 */
function fromRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2.identity(dest);
 *     mat2.scale(dest, dest, vec);
 *
 * @param {mat2} out mat2 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2
 *
 * @param {mat2} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns Frobenius norm of a mat2
 *
 * @param {mat2} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));
}

/**
 * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix
 * @param {mat2} L the lower triangular matrix
 * @param {mat2} D the diagonal matrix
 * @param {mat2} U the upper triangular matrix
 * @param {mat2} a the input matrix to factorize
 */

function LDU(L, D, U, a) {
  L[2] = a[2] / a[0];
  U[0] = a[0];
  U[1] = a[1];
  U[3] = a[3] - L[2] * U[1];
  return [L, D, U];
}

/**
 * Adds two mat2's
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @returns {mat2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2} a The first matrix.
 * @param {mat2} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2} out the receiving matrix
 * @param {mat2} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two mat2's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2} out the receiving vector
 * @param {mat2} a the first operand
 * @param {mat2} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}

/**
 * Alias for {@link mat2.multiply}
 * @function
 */
var mul = multiply;

/**
 * Alias for {@link mat2.subtract}
 * @function
 */
var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/lib/gl-matrix/mat2d.js":
/*!*******************************************************!*\
  !*** ./node_modules/gl-matrix/lib/gl-matrix/mat2d.js ***!
  \*******************************************************/
/*! exports provided: create, clone, copy, identity, fromValues, set, invert, determinant, multiply, rotate, scale, translate, fromRotation, fromScaling, fromTranslation, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/lib/gl-matrix/common.js");


/**
 * 2x3 Matrix
 * @module mat2d
 *
 * @description
 * A mat2d contains six elements defined as:
 * <pre>
 * [a, c, tx,
 *  b, d, ty]
 * </pre>
 * This is a short form for the 3x3 matrix:
 * <pre>
 * [a, c, tx,
 *  b, d, ty,
 *  0, 0, 1]
 * </pre>
 * The last row is ignored so the array is shorter and operations are faster.
 */

/**
 * Creates a new identity mat2d
 *
 * @returns {mat2d} a new 2x3 matrix
 */
function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);
  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[4] = 0;
    out[5] = 0;
  }
  out[0] = 1;
  out[3] = 1;
  return out;
}

/**
 * Creates a new mat2d initialized with values from an existing matrix
 *
 * @param {mat2d} a matrix to clone
 * @returns {mat2d} a new 2x3 matrix
 */
function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Copy the values from one mat2d to another
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  return out;
}

/**
 * Set a mat2d to the identity matrix
 *
 * @param {mat2d} out the receiving matrix
 * @returns {mat2d} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Create a new mat2d with the given values
 *
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} A new mat2d
 */
function fromValues(a, b, c, d, tx, ty) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](6);
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Set the components of a mat2d to the given values
 *
 * @param {mat2d} out the receiving matrix
 * @param {Number} a Component A (index 0)
 * @param {Number} b Component B (index 1)
 * @param {Number} c Component C (index 2)
 * @param {Number} d Component D (index 3)
 * @param {Number} tx Component TX (index 4)
 * @param {Number} ty Component TY (index 5)
 * @returns {mat2d} out
 */
function set(out, a, b, c, d, tx, ty) {
  out[0] = a;
  out[1] = b;
  out[2] = c;
  out[3] = d;
  out[4] = tx;
  out[5] = ty;
  return out;
}

/**
 * Inverts a mat2d
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the source matrix
 * @returns {mat2d} out
 */
function invert(out, a) {
  var aa = a[0],
      ab = a[1],
      ac = a[2],
      ad = a[3];
  var atx = a[4],
      aty = a[5];

  var det = aa * ad - ab * ac;
  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = ad * det;
  out[1] = -ab * det;
  out[2] = -ac * det;
  out[3] = aa * det;
  out[4] = (ac * aty - ad * atx) * det;
  out[5] = (ab * atx - aa * aty) * det;
  return out;
}

/**
 * Calculates the determinant of a mat2d
 *
 * @param {mat2d} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  return a[0] * a[3] - a[1] * a[2];
}

/**
 * Multiplies two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function multiply(out, a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  out[0] = a0 * b0 + a2 * b1;
  out[1] = a1 * b0 + a3 * b1;
  out[2] = a0 * b2 + a2 * b3;
  out[3] = a1 * b2 + a3 * b3;
  out[4] = a0 * b4 + a2 * b5 + a4;
  out[5] = a1 * b4 + a3 * b5 + a5;
  return out;
}

/**
 * Rotates a mat2d by the given angle
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function rotate(out, a, rad) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  out[0] = a0 * c + a2 * s;
  out[1] = a1 * c + a3 * s;
  out[2] = a0 * -s + a2 * c;
  out[3] = a1 * -s + a3 * c;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Scales the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat2d} out
 **/
function scale(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0 * v0;
  out[1] = a1 * v0;
  out[2] = a2 * v1;
  out[3] = a3 * v1;
  out[4] = a4;
  out[5] = a5;
  return out;
}

/**
 * Translates the mat2d by the dimensions in the given vec2
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to translate
 * @param {vec2} v the vec2 to translate the matrix by
 * @returns {mat2d} out
 **/
function translate(out, a, v) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var v0 = v[0],
      v1 = v[1];
  out[0] = a0;
  out[1] = a1;
  out[2] = a2;
  out[3] = a3;
  out[4] = a0 * v0 + a2 * v1 + a4;
  out[5] = a1 * v0 + a3 * v1 + a5;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.rotate(dest, dest, rad);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat2d} out
 */
function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = -s;
  out[3] = c;
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.scale(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat2d} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = v[1];
  out[4] = 0;
  out[5] = 0;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat2d.identity(dest);
 *     mat2d.translate(dest, dest, vec);
 *
 * @param {mat2d} out mat2d receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat2d} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = v[0];
  out[5] = v[1];
  return out;
}

/**
 * Returns a string representation of a mat2d
 *
 * @param {mat2d} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';
}

/**
 * Returns Frobenius norm of a mat2d
 *
 * @param {mat2d} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);
}

/**
 * Adds two mat2d's
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @returns {mat2d} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat2d} out the receiving matrix
 * @param {mat2d} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat2d} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  return out;
}

/**
 * Adds two mat2d's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat2d} out the receiving vector
 * @param {mat2d} a the first operand
 * @param {mat2d} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat2d} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat2d} a The first matrix.
 * @param {mat2d} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5));
}

/**
 * Alias for {@link mat2d.multiply}
 * @function
 */
var mul = multiply;

/**
 * Alias for {@link mat2d.subtract}
 * @function
 */
var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/lib/gl-matrix/mat3.js":
/*!******************************************************!*\
  !*** ./node_modules/gl-matrix/lib/gl-matrix/mat3.js ***!
  \******************************************************/
/*! exports provided: create, fromMat4, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, rotate, scale, fromTranslation, fromRotation, fromScaling, fromMat2d, fromQuat, normalFromMat4, projection, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat2d", function() { return fromMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalFromMat4", function() { return normalFromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projection", function() { return projection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/lib/gl-matrix/common.js");


/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */
function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }
  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}

/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */
function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}

/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */
function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */
function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */
function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}

/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}

/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;

  // Calculate the determinant
  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}

/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */
function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}

/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}

/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];

  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];

  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;

  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;

  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}

/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */
function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];

  out[0] = a00;
  out[1] = a01;
  out[2] = a02;

  out[3] = a10;
  out[4] = a11;
  out[5] = a12;

  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}

/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);

  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;

  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;

  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
};

/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/
function scale(out, a, v) {
  var x = v[0],
      y = v[1];

  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];

  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];

  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */
function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);

  out[0] = c;
  out[1] = s;
  out[2] = 0;

  out[3] = -s;
  out[4] = c;
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;

  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;

  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}

/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/
function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;

  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;

  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}

/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/
function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;

  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;

  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;

  return out;
}

/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/
function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

  return out;
}

/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */
function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}

/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}

/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
}

/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}

/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}

/**
 * Alias for {@link mat3.multiply}
 * @function
 */
var mul = multiply;

/**
 * Alias for {@link mat3.subtract}
 * @function
 */
var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/lib/gl-matrix/mat4.js":
/*!******************************************************!*\
  !*** ./node_modules/gl-matrix/lib/gl-matrix/mat4.js ***!
  \******************************************************/
/*! exports provided: create, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, scale, rotate, rotateX, rotateY, rotateZ, fromTranslation, fromScaling, fromRotation, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation, fromQuat2, getTranslation, getScaling, getRotation, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspective, perspectiveFromFieldOfView, ortho, lookAt, targetTo, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromXRotation", function() { return fromXRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromYRotation", function() { return fromYRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromZRotation", function() { return fromZRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat2", function() { return fromQuat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScaling", function() { return getScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRotation", function() { return getRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScale", function() { return fromRotationTranslationScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScaleOrigin", function() { return fromRotationTranslationScaleOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frustum", function() { return frustum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspective", function() { return perspective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspectiveFromFieldOfView", function() { return perspectiveFromFieldOfView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ortho", function() { return ortho; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lookAt", function() { return lookAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "targetTo", function() { return targetTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/lib/gl-matrix/common.js");


/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }
  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */
function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */
function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];

    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }
  det = 1.0 / det;

  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

  return out;
}

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32;

  // Calculate the determinant
  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}

/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];

  // Cache only the current line of the second matrix
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

  b0 = b[4];b1 = b[5];b2 = b[6];b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

  b0 = b[8];b1 = b[9];b2 = b[10];b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

  b0 = b[12];b1 = b[13];b2 = b[14];b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00 = void 0,
      a01 = void 0,
      a02 = void 0,
      a03 = void 0;
  var a10 = void 0,
      a11 = void 0,
      a12 = void 0,
      a13 = void 0;
  var a20 = void 0,
      a21 = void 0,
      a22 = void 0,
      a23 = void 0;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];
    a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];
    a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];

    out[0] = a00;out[1] = a01;out[2] = a02;out[3] = a03;
    out[4] = a10;out[5] = a11;out[6] = a12;out[7] = a13;
    out[8] = a20;out[9] = a21;out[10] = a22;out[11] = a23;

    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}

/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];

  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}

/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.sqrt(x * x + y * y + z * z);
  var s = void 0,
      c = void 0,
      t = void 0;
  var a00 = void 0,
      a01 = void 0,
      a02 = void 0,
      a03 = void 0;
  var a10 = void 0,
      a11 = void 0,
      a12 = void 0,
      a13 = void 0;
  var a20 = void 0,
      a21 = void 0,
      a22 = void 0,
      a23 = void 0;
  var b00 = void 0,
      b01 = void 0,
      b02 = void 0;
  var b10 = void 0,
      b11 = void 0,
      b12 = void 0;
  var b20 = void 0,
      b21 = void 0,
      b22 = void 0;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];
  a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];
  a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];

  // Construct the elements of the rotation matrix
  b00 = x * x * t + c;b01 = y * x * t + z * s;b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;b11 = y * y * t + c;b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;b21 = y * z * t - x * s;b22 = z * z * t + c;

  // Perform rotation-specific matrix multiplication
  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }
  return out;
}

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  // Perform axis-specific matrix multiplication
  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.sqrt(x * x + y * y + z * z);
  var s = void 0,
      c = void 0,
      t = void 0;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;

  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);

  // Perform axis-specific matrix multiplication
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {quat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */
function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];

  var magnitude = bx * bx + by * by + bz * bz + bw * bw;
  //Only scale if it makes sense
  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }
  fromRotationTranslation(out, a, translation);
  return out;
}

/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];

  return out;
}

/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */
function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];

  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);

  return out;
}

/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */
function getRotation(out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S;
    out[2] = (mat[1] - mat[4]) / S;
  } else if (mat[0] > mat[5] && mat[0] > mat[10]) {
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S;
    out[2] = (mat[8] + mat[2]) / S;
  } else if (mat[5] > mat[10]) {
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S;
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S;
  } else {
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */
function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];

  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;

  return out;
}

/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */
function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  var sx = s[0];
  var sy = s[1];
  var sz = s[2];

  var ox = o[0];
  var oy = o[1];
  var oz = o[2];

  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;

  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;

  return out;
}

/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */
function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;

  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;

  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;

  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;

  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;

  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;

  return out;
}

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}

/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf = void 0;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;
  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }
  return out;
}

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);

  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
  var x0 = void 0,
      x1 = void 0,
      x2 = void 0,
      y0 = void 0,
      y1 = void 0,
      y2 = void 0,
      z0 = void 0,
      z1 = void 0,
      z2 = void 0,
      len = void 0;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;

  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;

  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;

  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;

  return out;
}

/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];

  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];

  var len = z0 * z0 + z1 * z1 + z2 * z2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;

  len = x0 * x0 + x1 * x1 + x2 * x2;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
};

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}

/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */
function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
}

/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}

/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}

/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */
function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}

/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */
function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}

/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}

/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];

  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}

/**
 * Alias for {@link mat4.multiply}
 * @function
 */
var mul = multiply;

/**
 * Alias for {@link mat4.subtract}
 * @function
 */
var sub = subtract;

/***/ }),

/***/ "./node_modules/gl-matrix/lib/gl-matrix/quat.js":
/*!******************************************************!*\
  !*** ./node_modules/gl-matrix/lib/gl-matrix/quat.js ***!
  \******************************************************/
/*! exports provided: create, identity, setAxisAngle, getAxisAngle, multiply, rotateX, rotateY, rotateZ, calculateW, slerp, random, invert, conjugate, fromMat3, fromEuler, str, clone, fromValues, copy, set, add, mul, scale, dot, lerp, length, len, squaredLength, sqrLen, normalize, exactEquals, equals, rotationTo, sqlerp, setAxes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxisAngle", function() { return setAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAxisAngle", function() { return getAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateW", function() { return calculateW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slerp", function() { return slerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat3", function() { return fromMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEuler", function() { return fromEuler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotationTo", function() { return rotationTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqlerp", function() { return sqlerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxes", function() { return setAxes; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/lib/gl-matrix/common.js");
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat3.js */ "./node_modules/gl-matrix/lib/gl-matrix/mat3.js");
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec3.js */ "./node_modules/gl-matrix/lib/gl-matrix/vec3.js");
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vec4.js */ "./node_modules/gl-matrix/lib/gl-matrix/vec4.js");





/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */
function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  out[3] = 1;
  return out;
}

/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}

/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/
function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}

/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */
function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);
  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }
  return rad;
}

/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */
function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];

  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateX(out, a, rad) {
  rad *= 0.5;

  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);

  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateY(out, a, rad) {
  rad *= 0.5;

  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);

  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}

/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */
function rotateZ(out, a, rad) {
  rad *= 0.5;

  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);

  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}

/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */
function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];

  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}

/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */
function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];

  var omega = void 0,
      cosom = void 0,
      sinom = void 0,
      scale0 = void 0,
      scale1 = void 0;

  // calc cosine
  cosom = ax * bx + ay * by + az * bz + aw * bw;
  // adjust signs (if necessary)
  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  }
  // calculate coefficients
  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  }
  // calculate final values
  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;

  return out;
}

/**
 * Generates a random quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */
function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();

  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);

  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}

/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */
function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0;

  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}

/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */
function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot = void 0;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w
    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)
    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;

    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}

/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */
function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;

  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);

  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;

  return out;
}

/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */
var clone = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["clone"];

/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */
var fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["fromValues"];

/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */
var copy = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["copy"];

/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */
var set = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["set"];

/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */
var add = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["add"];

/**
 * Alias for {@link quat.multiply}
 * @function
 */
var mul = multiply;

/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */
var scale = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["scale"];

/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
var dot = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["dot"];

/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */
var lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["lerp"];

/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */
var length = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["length"];

/**
 * Alias for {@link quat.length}
 * @function
 */
var len = length;

/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
var squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["squaredLength"];

/**
 * Alias for {@link quat.squaredLength}
 * @function
 */
var sqrLen = squaredLength;

/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */
var normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["normalize"];

/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
var exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["exactEquals"];

/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
var equals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["equals"];

/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */
var rotationTo = function () {
  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["create"]();
  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](1, 0, 0);
  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](0, 1, 0);

  return function (out, a, b) {
    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["dot"](a, b);
    if (dot < -0.999999) {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, xUnitVec3, a);
      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__["len"](tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, yUnitVec3, a);
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();

/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */
var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();

  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));

    return out;
  };
}();

/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */
var setAxes = function () {
  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_1__["create"]();

  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];

    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];

    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];

    return normalize(out, fromMat3(out, matr));
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/lib/gl-matrix/quat2.js":
/*!*******************************************************!*\
  !*** ./node_modules/gl-matrix/lib/gl-matrix/quat2.js ***!
  \*******************************************************/
/*! exports provided: create, clone, fromValues, fromRotationTranslationValues, fromRotationTranslation, fromTranslation, fromRotation, fromMat4, copy, identity, set, getReal, getDual, setReal, setDual, getTranslation, translate, rotateX, rotateY, rotateZ, rotateByQuatAppend, rotateByQuatPrepend, rotateAroundAxis, add, multiply, mul, scale, dot, lerp, invert, conjugate, length, len, squaredLength, sqrLen, normalize, str, exactEquals, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationValues", function() { return fromRotationTranslationValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getReal", function() { return getReal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDual", function() { return getDual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setReal", function() { return setReal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDual", function() { return setDual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateByQuatAppend", function() { return rotateByQuatAppend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateByQuatPrepend", function() { return rotateByQuatPrepend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateAroundAxis", function() { return rotateAroundAxis; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/lib/gl-matrix/common.js");
/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quat.js */ "./node_modules/gl-matrix/lib/gl-matrix/quat.js");
/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat4.js */ "./node_modules/gl-matrix/lib/gl-matrix/mat4.js");




/**
 * Dual Quaternion<br>
 * Format: [real, dual]<br>
 * Quaternion format: XYZW<br>
 * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>
 * @module quat2
 */

/**
 * Creates a new identity dual quat
 *
 * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]
 */
function create() {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    dq[0] = 0;
    dq[1] = 0;
    dq[2] = 0;
    dq[4] = 0;
    dq[5] = 0;
    dq[6] = 0;
    dq[7] = 0;
  }
  dq[3] = 1;
  return dq;
}

/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat2} a dual quaternion to clone
 * @returns {quat2} new dual quaternion
 * @function
 */
function clone(a) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = a[0];
  dq[1] = a[1];
  dq[2] = a[2];
  dq[3] = a[3];
  dq[4] = a[4];
  dq[5] = a[5];
  dq[6] = a[6];
  dq[7] = a[7];
  return dq;
}

/**
 * Creates a new dual quat initialized with the given values
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} new dual quaternion
 * @function
 */
function fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  dq[4] = x2;
  dq[5] = y2;
  dq[6] = z2;
  dq[7] = w2;
  return dq;
}

/**
 * Creates a new dual quat from the given values (quat and translation)
 *
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component (translation)
 * @param {Number} y2 Y component (translation)
 * @param {Number} z2 Z component (translation)
 * @returns {quat2} new dual quaternion
 * @function
 */
function fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {
  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](8);
  dq[0] = x1;
  dq[1] = y1;
  dq[2] = z1;
  dq[3] = w1;
  var ax = x2 * 0.5,
      ay = y2 * 0.5,
      az = z2 * 0.5;
  dq[4] = ax * w1 + ay * z1 - az * y1;
  dq[5] = ay * w1 + az * x1 - ax * z1;
  dq[6] = az * w1 + ax * y1 - ay * x1;
  dq[7] = -ax * x1 - ay * y1 - az * z1;
  return dq;
}

/**
 * Creates a dual quat from a quaternion and a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q quaternion
 * @param {vec3} t tranlation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */
function fromRotationTranslation(out, q, t) {
  var ax = t[0] * 0.5,
      ay = t[1] * 0.5,
      az = t[2] * 0.5,
      bx = q[0],
      by = q[1],
      bz = q[2],
      bw = q[3];
  out[0] = bx;
  out[1] = by;
  out[2] = bz;
  out[3] = bw;
  out[4] = ax * bw + ay * bz - az * by;
  out[5] = ay * bw + az * bx - ax * bz;
  out[6] = az * bw + ax * by - ay * bx;
  out[7] = -ax * bx - ay * by - az * bz;
  return out;
}

/**
 * Creates a dual quat from a translation
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {vec3} t translation vector
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */
function fromTranslation(out, t) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = t[0] * 0.5;
  out[5] = t[1] * 0.5;
  out[6] = t[2] * 0.5;
  out[7] = 0;
  return out;
}

/**
 * Creates a dual quat from a quaternion
 *
 * @param {quat2} dual quaternion receiving operation result
 * @param {quat} q the quaternion
 * @returns {quat2} dual quaternion receiving operation result
 * @function
 */
function fromRotation(out, q) {
  out[0] = q[0];
  out[1] = q[1];
  out[2] = q[2];
  out[3] = q[3];
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}

/**
 * Creates a new dual quat from a matrix (4x4)
 *
 * @param {quat2} out the dual quaternion
 * @param {mat4} a the matrix
 * @returns {quat2} dual quat receiving operation result
 * @function
 */
function fromMat4(out, a) {
  //TODO Optimize this
  var outer = _quat_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__["getRotation"](outer, a);
  var t = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  _mat4_js__WEBPACK_IMPORTED_MODULE_2__["getTranslation"](t, a);
  fromRotationTranslation(out, outer, t);
  return out;
}

/**
 * Copy the values from one dual quat to another
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the source dual quaternion
 * @returns {quat2} out
 * @function
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  return out;
}

/**
 * Set a dual quat to the identity dual quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @returns {quat2} out
 */
function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  out[4] = 0;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  return out;
}

/**
 * Set the components of a dual quat to the given values
 *
 * @param {quat2} out the receiving quaternion
 * @param {Number} x1 X component
 * @param {Number} y1 Y component
 * @param {Number} z1 Z component
 * @param {Number} w1 W component
 * @param {Number} x2 X component
 * @param {Number} y2 Y component
 * @param {Number} z2 Z component
 * @param {Number} w2 W component
 * @returns {quat2} out
 * @function
 */
function set(out, x1, y1, z1, w1, x2, y2, z2, w2) {
  out[0] = x1;
  out[1] = y1;
  out[2] = z1;
  out[3] = w1;

  out[4] = x2;
  out[5] = y2;
  out[6] = z2;
  out[7] = w2;
  return out;
}

/**
 * Gets the real part of a dual quat
 * @param  {quat} out real part
 * @param  {quat2} a Dual Quaternion
 * @return {quat} real part
 */
var getReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];

/**
 * Gets the dual part of a dual quat
 * @param  {quat} out dual part
 * @param  {quat2} a Dual Quaternion
 * @return {quat} dual part
 */
function getDual(out, a) {
  out[0] = a[4];
  out[1] = a[5];
  out[2] = a[6];
  out[3] = a[7];
  return out;
}

/**
 * Set the real component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat} q a quaternion representing the real part
 * @returns {quat2} out
 * @function
 */
var setReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__["copy"];

/**
 * Set the dual component of a dual quat to the given quaternion
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat} q a quaternion representing the dual part
 * @returns {quat2} out
 * @function
 */
function setDual(out, q) {
  out[4] = q[0];
  out[5] = q[1];
  out[6] = q[2];
  out[7] = q[3];
  return out;
}

/**
 * Gets the translation of a normalized dual quat
 * @param  {vec3} out translation
 * @param  {quat2} a Dual Quaternion to be decomposed
 * @return {vec3} translation
 */
function getTranslation(out, a) {
  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3];
  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  return out;
}

/**
 * Translates a dual quat by the given vector
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to translate
 * @param {vec3} v vector to translate by
 * @returns {quat2} out
 */
function translate(out, a, v) {
  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3],
      bx1 = v[0] * 0.5,
      by1 = v[1] * 0.5,
      bz1 = v[2] * 0.5,
      ax2 = a[4],
      ay2 = a[5],
      az2 = a[6],
      aw2 = a[7];
  out[0] = ax1;
  out[1] = ay1;
  out[2] = az1;
  out[3] = aw1;
  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;
  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;
  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;
  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;
  return out;
}

/**
 * Rotates a dual quat around the X axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */
function rotateX(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateX"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}

/**
 * Rotates a dual quat around the Y axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */
function rotateY(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateY"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}

/**
 * Rotates a dual quat around the Z axis
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {number} rad how far should the rotation be
 * @returns {quat2} out
 */
function rotateZ(out, a, rad) {
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7],
      ax1 = ax * bw + aw * bx + ay * bz - az * by,
      ay1 = ay * bw + aw * by + az * bx - ax * bz,
      az1 = az * bw + aw * bz + ax * by - ay * bx,
      aw1 = aw * bw - ax * bx - ay * by - az * bz;
  _quat_js__WEBPACK_IMPORTED_MODULE_1__["rotateZ"](out, a, rad);
  bx = out[0];
  by = out[1];
  bz = out[2];
  bw = out[3];
  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;
  return out;
}

/**
 * Rotates a dual quat by a given quaternion (a * q)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {quat} q quaternion to rotate by
 * @returns {quat2} out
 */
function rotateByQuatAppend(out, a, q) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];

  out[0] = ax * qw + aw * qx + ay * qz - az * qy;
  out[1] = ay * qw + aw * qy + az * qx - ax * qz;
  out[2] = az * qw + aw * qz + ax * qy - ay * qx;
  out[3] = aw * qw - ax * qx - ay * qy - az * qz;
  ax = a[4];
  ay = a[5];
  az = a[6];
  aw = a[7];
  out[4] = ax * qw + aw * qx + ay * qz - az * qy;
  out[5] = ay * qw + aw * qy + az * qx - ax * qz;
  out[6] = az * qw + aw * qz + ax * qy - ay * qx;
  out[7] = aw * qw - ax * qx - ay * qy - az * qz;
  return out;
}

/**
 * Rotates a dual quat by a given quaternion (q * a)
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat} q quaternion to rotate by
 * @param {quat2} a the dual quaternion to rotate
 * @returns {quat2} out
 */
function rotateByQuatPrepend(out, q, a) {
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3],
      bx = a[0],
      by = a[1],
      bz = a[2],
      bw = a[3];

  out[0] = qx * bw + qw * bx + qy * bz - qz * by;
  out[1] = qy * bw + qw * by + qz * bx - qx * bz;
  out[2] = qz * bw + qw * bz + qx * by - qy * bx;
  out[3] = qw * bw - qx * bx - qy * by - qz * bz;
  bx = a[4];
  by = a[5];
  bz = a[6];
  bw = a[7];
  out[4] = qx * bw + qw * bx + qy * bz - qz * by;
  out[5] = qy * bw + qw * by + qz * bx - qx * bz;
  out[6] = qz * bw + qw * bz + qx * by - qy * bx;
  out[7] = qw * bw - qx * bx - qy * by - qz * bz;
  return out;
}

/**
 * Rotates a dual quat around a given axis. Does the normalisation automatically
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the dual quaternion to rotate
 * @param {vec3} axis the axis to rotate around
 * @param {Number} rad how far the rotation should be
 * @returns {quat2} out
 */
function rotateAroundAxis(out, a, axis, rad) {
  //Special case for rad = 0
  if (Math.abs(rad) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return copy(out, a);
  }
  var axisLength = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);

  rad = rad * 0.5;
  var s = Math.sin(rad);
  var bx = s * axis[0] / axisLength;
  var by = s * axis[1] / axisLength;
  var bz = s * axis[2] / axisLength;
  var bw = Math.cos(rad);

  var ax1 = a[0],
      ay1 = a[1],
      az1 = a[2],
      aw1 = a[3];
  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;
  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;
  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;
  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;

  var ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  out[4] = ax * bw + aw * bx + ay * bz - az * by;
  out[5] = ay * bw + aw * by + az * bx - ax * bz;
  out[6] = az * bw + aw * bz + ax * by - ay * bx;
  out[7] = aw * bw - ax * bx - ay * by - az * bz;

  return out;
}

/**
 * Adds two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 * @function
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  return out;
}

/**
 * Multiplies two dual quat's
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {quat2} out
 */
function multiply(out, a, b) {
  var ax0 = a[0],
      ay0 = a[1],
      az0 = a[2],
      aw0 = a[3],
      bx1 = b[4],
      by1 = b[5],
      bz1 = b[6],
      bw1 = b[7],
      ax1 = a[4],
      ay1 = a[5],
      az1 = a[6],
      aw1 = a[7],
      bx0 = b[0],
      by0 = b[1],
      bz0 = b[2],
      bw0 = b[3];
  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;
  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;
  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;
  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;
  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;
  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;
  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;
  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;
  return out;
}

/**
 * Alias for {@link quat2.multiply}
 * @function
 */
var mul = multiply;

/**
 * Scales a dual quat by a scalar number
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the dual quat to scale
 * @param {Number} b amount to scale the dual quat by
 * @returns {quat2} out
 * @function
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  return out;
}

/**
 * Calculates the dot product of two dual quat's (The dot product of the real parts)
 *
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */
var dot = _quat_js__WEBPACK_IMPORTED_MODULE_1__["dot"];

/**
 * Performs a linear interpolation between two dual quats's
 * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)
 *
 * @param {quat2} out the receiving dual quat
 * @param {quat2} a the first operand
 * @param {quat2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat2} out
 */
function lerp(out, a, b, t) {
  var mt = 1 - t;
  if (dot(a, b) < 0) t = -t;

  out[0] = a[0] * mt + b[0] * t;
  out[1] = a[1] * mt + b[1] * t;
  out[2] = a[2] * mt + b[2] * t;
  out[3] = a[3] * mt + b[3] * t;
  out[4] = a[4] * mt + b[4] * t;
  out[5] = a[5] * mt + b[5] * t;
  out[6] = a[6] * mt + b[6] * t;
  out[7] = a[7] * mt + b[7] * t;

  return out;
}

/**
 * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quat to calculate inverse of
 * @returns {quat2} out
 */
function invert(out, a) {
  var sqlen = squaredLength(a);
  out[0] = -a[0] / sqlen;
  out[1] = -a[1] / sqlen;
  out[2] = -a[2] / sqlen;
  out[3] = a[3] / sqlen;
  out[4] = -a[4] / sqlen;
  out[5] = -a[5] / sqlen;
  out[6] = -a[6] / sqlen;
  out[7] = a[7] / sqlen;
  return out;
}

/**
 * Calculates the conjugate of a dual quat
 * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.
 *
 * @param {quat2} out the receiving quaternion
 * @param {quat2} a quat to calculate conjugate of
 * @returns {quat2} out
 */
function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  out[4] = -a[4];
  out[5] = -a[5];
  out[6] = -a[6];
  out[7] = a[7];
  return out;
}

/**
 * Calculates the length of a dual quat
 *
 * @param {quat2} a dual quat to calculate length of
 * @returns {Number} length of a
 * @function
 */
var length = _quat_js__WEBPACK_IMPORTED_MODULE_1__["length"];

/**
 * Alias for {@link quat2.length}
 * @function
 */
var len = length;

/**
 * Calculates the squared length of a dual quat
 *
 * @param {quat2} a dual quat to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */
var squaredLength = _quat_js__WEBPACK_IMPORTED_MODULE_1__["squaredLength"];

/**
 * Alias for {@link quat2.squaredLength}
 * @function
 */
var sqrLen = squaredLength;

/**
 * Normalize a dual quat
 *
 * @param {quat2} out the receiving dual quaternion
 * @param {quat2} a dual quaternion to normalize
 * @returns {quat2} out
 * @function
 */
function normalize(out, a) {
  var magnitude = squaredLength(a);
  if (magnitude > 0) {
    magnitude = Math.sqrt(magnitude);

    var a0 = a[0] / magnitude;
    var a1 = a[1] / magnitude;
    var a2 = a[2] / magnitude;
    var a3 = a[3] / magnitude;

    var b0 = a[4];
    var b1 = a[5];
    var b2 = a[6];
    var b3 = a[7];

    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;

    out[0] = a0;
    out[1] = a1;
    out[2] = a2;
    out[3] = a3;

    out[4] = (b0 - a0 * a_dot_b) / magnitude;
    out[5] = (b1 - a1 * a_dot_b) / magnitude;
    out[6] = (b2 - a2 * a_dot_b) / magnitude;
    out[7] = (b3 - a3 * a_dot_b) / magnitude;
  }
  return out;
}

/**
 * Returns a string representation of a dual quatenion
 *
 * @param {quat2} a dual quaternion to represent as a string
 * @returns {String} string representation of the dual quat
 */
function str(a) {
  return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';
}

/**
 * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat2} a the first dual quaternion.
 * @param {quat2} b the second dual quaternion.
 * @returns {Boolean} true if the dual quaternions are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];
}

/**
 * Returns whether or not the dual quaternions have approximately the same elements in the same position.
 *
 * @param {quat2} a the first dual quat.
 * @param {quat2} b the second dual quat.
 * @returns {Boolean} true if the dual quats are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7));
}

/***/ }),

/***/ "./node_modules/gl-matrix/lib/gl-matrix/vec2.js":
/*!******************************************************!*\
  !*** ./node_modules/gl-matrix/lib/gl-matrix/vec2.js ***!
  \******************************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, str, exactEquals, equals, len, sub, mul, div, dist, sqrDist, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2", function() { return transformMat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2d", function() { return transformMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/lib/gl-matrix/common.js");


/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */
function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}

/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */
function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */
function fromValues(x, y) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}

/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */
function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}

/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}

/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}

/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}

/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}

/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}

/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}

/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}

/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}

/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}

/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}

/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}

/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0],
      y = a[1];
  return Math.sqrt(x * x + y * y);
}

/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}

/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}

/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}

/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */
function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}

/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}

/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */
function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */
function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}

/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}

/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}

/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}

/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */
function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}

/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {vec2} a The vec2 point to rotate
 * @param {vec2} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec2} out
 */
function rotate(out, a, b, c) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(c),
      cosC = Math.cos(c);

  //perform rotation and translate to correct position
  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];

  return out;
}

/**
 * Get the angle between two 2D vectors
 * @param {vec2} a The first operand
 * @param {vec2} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1];

  var len1 = x1 * x1 + y1 * y1;
  if (len1 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
  }

  var len2 = x2 * x2 + y2 * y2;
  if (len2 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len2 = 1 / Math.sqrt(len2);
  }

  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}

/**
 * Alias for {@link vec2.length}
 * @function
 */
var len = length;

/**
 * Alias for {@link vec2.subtract}
 * @function
 */
var sub = subtract;

/**
 * Alias for {@link vec2.multiply}
 * @function
 */
var mul = multiply;

/**
 * Alias for {@link vec2.divide}
 * @function
 */
var div = divide;

/**
 * Alias for {@link vec2.distance}
 * @function
 */
var dist = distance;

/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */
var sqrDist = squaredDistance;

/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */
var sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var forEach = function () {
  var vec = create();

  return function (a, stride, offset, count, fn, arg) {
    var i = void 0,
        l = void 0;
    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];a[i + 1] = vec[1];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/lib/gl-matrix/vec3.js":
/*!******************************************************!*\
  !*** ./node_modules/gl-matrix/lib/gl-matrix/vec3.js ***!
  \******************************************************/
/*! exports provided: create, clone, length, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, squaredLength, negate, inverse, normalize, dot, cross, lerp, hermite, bezier, random, transformMat4, transformMat3, transformQuat, rotateX, rotateY, rotateZ, angle, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hermite", function() { return hermite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bezier", function() { return bezier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/lib/gl-matrix/common.js");


/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;
  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];

  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}

/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */
function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;

  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;

  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
  scale = scale || 1.0;

  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;

  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}

/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2];
  // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);
  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x;
  // var uuv = vec3.cross([], qvec, uv);
  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx;
  // vec3.scale(uv, uv, 2 * w);
  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2;
  // vec3.scale(uuv, uuv, 2);
  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2;
  // return vec3.add(out, a, vec3.add(out, uv, uuv));
  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateX(out, a, b, c) {
  var p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0];
  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateY(out, a, b, c) {
  var p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateZ(out, a, b, c) {
  var p = [],
      r = [];
  //Translate point to the origin
  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2];

  //perform rotation
  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
  r[2] = p[2];

  //translate to correct position
  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];

  return out;
}

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);

  normalize(tempA, tempA);
  normalize(tempB, tempB);

  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}

/**
 * Alias for {@link vec3.subtract}
 * @function
 */
var sub = subtract;

/**
 * Alias for {@link vec3.multiply}
 * @function
 */
var mul = multiply;

/**
 * Alias for {@link vec3.divide}
 * @function
 */
var div = divide;

/**
 * Alias for {@link vec3.distance}
 * @function
 */
var dist = distance;

/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */
var sqrDist = squaredDistance;

/**
 * Alias for {@link vec3.length}
 * @function
 */
var len = length;

/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */
var sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var forEach = function () {
  var vec = create();

  return function (a, stride, offset, count, fn, arg) {
    var i = void 0,
        l = void 0;
    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/gl-matrix/lib/gl-matrix/vec4.js":
/*!******************************************************!*\
  !*** ./node_modules/gl-matrix/lib/gl-matrix/vec4.js ***!
  \******************************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, lerp, random, transformMat4, transformQuat, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "./node_modules/gl-matrix/lib/gl-matrix/common.js");


/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */
function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }
  return out;
}

/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */
function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */
function fromValues(x, y, z, w) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */
function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}

/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */
function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}

/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}

/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}

/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}

/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}

/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}

/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}

/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}

/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */
function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}

/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */
function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}

/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */
function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}

/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */
function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}

/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}

/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}

/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}

/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}

/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */
function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}

/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}

/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */
function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
    out[0] = x * len;
    out[1] = y * len;
    out[2] = z * len;
    out[3] = w * len;
  }
  return out;
}

/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}

/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */
function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}

/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */
function random(out, scale) {
  scale = scale || 1.0;

  // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;
  var v1, v2, v3, v4;
  var s1, s2;
  do {
    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);
  do {
    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}

/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */
function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}

/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */
function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];

  // calculate quat * vec
  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z;

  // calculate result * inverse quat
  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}

/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */
function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}

/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}

/**
 * Alias for {@link vec4.subtract}
 * @function
 */
var sub = subtract;

/**
 * Alias for {@link vec4.multiply}
 * @function
 */
var mul = multiply;

/**
 * Alias for {@link vec4.divide}
 * @function
 */
var div = divide;

/**
 * Alias for {@link vec4.distance}
 * @function
 */
var dist = distance;

/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */
var sqrDist = squaredDistance;

/**
 * Alias for {@link vec4.length}
 * @function
 */
var len = length;

/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */
var sqrLen = squaredLength;

/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
var forEach = function () {
  var vec = create();

  return function (a, stride, offset, count, fn, arg) {
    var i = void 0,
        l = void 0;
    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "./node_modules/jsep/build/jsep.js":
/*!*****************************************!*\
  !*** ./node_modules/jsep/build/jsep.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//     JavaScript Expression Parser (JSEP) 0.3.4
//     JSEP may be freely distributed under the MIT License
//     http://jsep.from.so/

/*global module: true, exports: true, console: true */
(function (root) {
	'use strict';
	// Node Types
	// ----------

	// This is the full set of types that any JSEP node can be.
	// Store them here to save space when minified
	var COMPOUND = 'Compound',
		IDENTIFIER = 'Identifier',
		MEMBER_EXP = 'MemberExpression',
		LITERAL = 'Literal',
		THIS_EXP = 'ThisExpression',
		CALL_EXP = 'CallExpression',
		UNARY_EXP = 'UnaryExpression',
		BINARY_EXP = 'BinaryExpression',
		LOGICAL_EXP = 'LogicalExpression',
		CONDITIONAL_EXP = 'ConditionalExpression',
		ARRAY_EXP = 'ArrayExpression',

		PERIOD_CODE = 46, // '.'
		COMMA_CODE  = 44, // ','
		SQUOTE_CODE = 39, // single quote
		DQUOTE_CODE = 34, // double quotes
		OPAREN_CODE = 40, // (
		CPAREN_CODE = 41, // )
		OBRACK_CODE = 91, // [
		CBRACK_CODE = 93, // ]
		QUMARK_CODE = 63, // ?
		SEMCOL_CODE = 59, // ;
		COLON_CODE  = 58, // :

		throwError = function(message, index) {
			var error = new Error(message + ' at character ' + index);
			error.index = index;
			error.description = message;
			throw error;
		},

	// Operations
	// ----------

	// Set `t` to `true` to save space (when minified, not gzipped)
		t = true,
	// Use a quickly-accessible map to store all of the unary operators
	// Values are set to `true` (it really doesn't matter)
		unary_ops = {'-': t, '!': t, '~': t, '+': t},
	// Also use a map for the binary operations but set their values to their
	// binary precedence for quick reference:
	// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)
		binary_ops = {
			'||': 1, '&&': 2, '|': 3,  '^': 4,  '&': 5,
			'==': 6, '!=': 6, '===': 6, '!==': 6,
			'<': 7,  '>': 7,  '<=': 7,  '>=': 7,
			'<<':8,  '>>': 8, '>>>': 8,
			'+': 9, '-': 9,
			'*': 10, '/': 10, '%': 10
		},
	// Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)
		additional_identifier_chars = {'$': t, '_': t},
	// Get return the longest key length of any object
		getMaxKeyLen = function(obj) {
			var max_len = 0, len;
			for(var key in obj) {
				if((len = key.length) > max_len && obj.hasOwnProperty(key)) {
					max_len = len;
				}
			}
			return max_len;
		},
		max_unop_len = getMaxKeyLen(unary_ops),
		max_binop_len = getMaxKeyLen(binary_ops),
	// Literals
	// ----------
	// Store the values to return for the various literals we may encounter
		literals = {
			'true': true,
			'false': false,
			'null': null
		},
	// Except for `this`, which is special. This could be changed to something like `'self'` as well
		this_str = 'this',
	// Returns the precedence of a binary operator or `0` if it isn't a binary operator
		binaryPrecedence = function(op_val) {
			return binary_ops[op_val] || 0;
		},
	// Utility function (gets called from multiple places)
	// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions
		createBinaryExpression = function (operator, left, right) {
			var type = (operator === '||' || operator === '&&') ? LOGICAL_EXP : BINARY_EXP;
			return {
				type: type,
				operator: operator,
				left: left,
				right: right
			};
		},
		// `ch` is a character code in the next three functions
		isDecimalDigit = function(ch) {
			return (ch >= 48 && ch <= 57); // 0...9
		},
		isIdentifierStart = function(ch) {
			return  (ch >= 65 && ch <= 90) || // A...Z
					(ch >= 97 && ch <= 122) || // a...z
					(ch >= 128 && !binary_ops[String.fromCharCode(ch)]) || // any non-ASCII that is not an operator
					(additional_identifier_chars.hasOwnProperty(String.fromCharCode(ch))); // additional characters
		},
		isIdentifierPart = function(ch) {
			return 	(ch >= 65 && ch <= 90) || // A...Z
					(ch >= 97 && ch <= 122) || // a...z
					(ch >= 48 && ch <= 57) || // 0...9
					(ch >= 128 && !binary_ops[String.fromCharCode(ch)])|| // any non-ASCII that is not an operator
					(additional_identifier_chars.hasOwnProperty(String.fromCharCode(ch))); // additional characters
		},

		// Parsing
		// -------
		// `expr` is a string with the passed in expression
		jsep = function(expr) {
			// `index` stores the character number we are currently at while `length` is a constant
			// All of the gobbles below will modify `index` as we move along
			var index = 0,
				charAtFunc = expr.charAt,
				charCodeAtFunc = expr.charCodeAt,
				exprI = function(i) { return charAtFunc.call(expr, i); },
				exprICode = function(i) { return charCodeAtFunc.call(expr, i); },
				length = expr.length,

				// Push `index` up to the next non-space character
				gobbleSpaces = function() {
					var ch = exprICode(index);
					// space or tab
					while(ch === 32 || ch === 9 || ch === 10 || ch === 13) {
						ch = exprICode(++index);
					}
				},

				// The main parsing function. Much of this code is dedicated to ternary expressions
				gobbleExpression = function() {
					var test = gobbleBinaryExpression(),
						consequent, alternate;
					gobbleSpaces();
					if(exprICode(index) === QUMARK_CODE) {
						// Ternary expression: test ? consequent : alternate
						index++;
						consequent = gobbleExpression();
						if(!consequent) {
							throwError('Expected expression', index);
						}
						gobbleSpaces();
						if(exprICode(index) === COLON_CODE) {
							index++;
							alternate = gobbleExpression();
							if(!alternate) {
								throwError('Expected expression', index);
							}
							return {
								type: CONDITIONAL_EXP,
								test: test,
								consequent: consequent,
								alternate: alternate
							};
						} else {
							throwError('Expected :', index);
						}
					} else {
						return test;
					}
				},

				// Search for the operation portion of the string (e.g. `+`, `===`)
				// Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)
				// and move down from 3 to 2 to 1 character until a matching binary operation is found
				// then, return that binary operation
				gobbleBinaryOp = function() {
					gobbleSpaces();
					var biop, to_check = expr.substr(index, max_binop_len), tc_len = to_check.length;
					while(tc_len > 0) {
						// Don't accept a binary op when it is an identifier.
						// Binary ops that start with a identifier-valid character must be followed
						// by a non identifier-part valid character
						if(binary_ops.hasOwnProperty(to_check) && (
							!isIdentifierStart(exprICode(index)) ||
							(index+to_check.length< expr.length && !isIdentifierPart(exprICode(index+to_check.length)))
						)) {
							index += tc_len;
							return to_check;
						}
						to_check = to_check.substr(0, --tc_len);
					}
					return false;
				},

				// This function is responsible for gobbling an individual expression,
				// e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`
				gobbleBinaryExpression = function() {
					var ch_i, node, biop, prec, stack, biop_info, left, right, i, cur_biop;

					// First, try to get the leftmost thing
					// Then, check to see if there's a binary operator operating on that leftmost thing
					left = gobbleToken();
					biop = gobbleBinaryOp();

					// If there wasn't a binary operator, just return the leftmost node
					if(!biop) {
						return left;
					}

					// Otherwise, we need to start a stack to properly place the binary operations in their
					// precedence structure
					biop_info = { value: biop, prec: binaryPrecedence(biop)};

					right = gobbleToken();
					if(!right) {
						throwError("Expected expression after " + biop, index);
					}
					stack = [left, biop_info, right];

					// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)
					while((biop = gobbleBinaryOp())) {
						prec = binaryPrecedence(biop);

						if(prec === 0) {
							break;
						}
						biop_info = { value: biop, prec: prec };

						cur_biop = biop;
						// Reduce: make a binary expression from the three topmost entries.
						while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {
							right = stack.pop();
							biop = stack.pop().value;
							left = stack.pop();
							node = createBinaryExpression(biop, left, right);
							stack.push(node);
						}

						node = gobbleToken();
						if(!node) {
							throwError("Expected expression after " + cur_biop, index);
						}
						stack.push(biop_info, node);
					}

					i = stack.length - 1;
					node = stack[i];
					while(i > 1) {
						node = createBinaryExpression(stack[i - 1].value, stack[i - 2], node);
						i -= 2;
					}
					return node;
				},

				// An individual part of a binary expression:
				// e.g. `foo.bar(baz)`, `1`, `"abc"`, `(a % 2)` (because it's in parenthesis)
				gobbleToken = function() {
					var ch, to_check, tc_len;

					gobbleSpaces();
					ch = exprICode(index);

					if(isDecimalDigit(ch) || ch === PERIOD_CODE) {
						// Char code 46 is a dot `.` which can start off a numeric literal
						return gobbleNumericLiteral();
					} else if(ch === SQUOTE_CODE || ch === DQUOTE_CODE) {
						// Single or double quotes
						return gobbleStringLiteral();
					} else if (ch === OBRACK_CODE) {
						return gobbleArray();
					} else {
						to_check = expr.substr(index, max_unop_len);
						tc_len = to_check.length;
						while(tc_len > 0) {
						// Don't accept an unary op when it is an identifier.
						// Unary ops that start with a identifier-valid character must be followed
						// by a non identifier-part valid character
							if(unary_ops.hasOwnProperty(to_check) && (
								!isIdentifierStart(exprICode(index)) ||
								(index+to_check.length < expr.length && !isIdentifierPart(exprICode(index+to_check.length)))
							)) {
								index += tc_len;
								return {
									type: UNARY_EXP,
									operator: to_check,
									argument: gobbleToken(),
									prefix: true
								};
							}
							to_check = to_check.substr(0, --tc_len);
						}

						if (isIdentifierStart(ch) || ch === OPAREN_CODE) { // open parenthesis
							// `foo`, `bar.baz`
							return gobbleVariable();
						}
					}

					return false;
				},
				// Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to
				// keep track of everything in the numeric literal and then calling `parseFloat` on that string
				gobbleNumericLiteral = function() {
					var number = '', ch, chCode;
					while(isDecimalDigit(exprICode(index))) {
						number += exprI(index++);
					}

					if(exprICode(index) === PERIOD_CODE) { // can start with a decimal marker
						number += exprI(index++);

						while(isDecimalDigit(exprICode(index))) {
							number += exprI(index++);
						}
					}

					ch = exprI(index);
					if(ch === 'e' || ch === 'E') { // exponent marker
						number += exprI(index++);
						ch = exprI(index);
						if(ch === '+' || ch === '-') { // exponent sign
							number += exprI(index++);
						}
						while(isDecimalDigit(exprICode(index))) { //exponent itself
							number += exprI(index++);
						}
						if(!isDecimalDigit(exprICode(index-1)) ) {
							throwError('Expected exponent (' + number + exprI(index) + ')', index);
						}
					}


					chCode = exprICode(index);
					// Check to make sure this isn't a variable name that start with a number (123abc)
					if(isIdentifierStart(chCode)) {
						throwError('Variable names cannot start with a number (' +
									number + exprI(index) + ')', index);
					} else if(chCode === PERIOD_CODE) {
						throwError('Unexpected period', index);
					}

					return {
						type: LITERAL,
						value: parseFloat(number),
						raw: number
					};
				},

				// Parses a string literal, staring with single or double quotes with basic support for escape codes
				// e.g. `"hello world"`, `'this is\nJSEP'`
				gobbleStringLiteral = function() {
					var str = '', quote = exprI(index++), closed = false, ch;

					while(index < length) {
						ch = exprI(index++);
						if(ch === quote) {
							closed = true;
							break;
						} else if(ch === '\\') {
							// Check for all of the common escape codes
							ch = exprI(index++);
							switch(ch) {
								case 'n': str += '\n'; break;
								case 'r': str += '\r'; break;
								case 't': str += '\t'; break;
								case 'b': str += '\b'; break;
								case 'f': str += '\f'; break;
								case 'v': str += '\x0B'; break;
								default : str += ch;
							}
						} else {
							str += ch;
						}
					}

					if(!closed) {
						throwError('Unclosed quote after "'+str+'"', index);
					}

					return {
						type: LITERAL,
						value: str,
						raw: quote + str + quote
					};
				},

				// Gobbles only identifiers
				// e.g.: `foo`, `_value`, `$x1`
				// Also, this function checks if that identifier is a literal:
				// (e.g. `true`, `false`, `null`) or `this`
				gobbleIdentifier = function() {
					var ch = exprICode(index), start = index, identifier;

					if(isIdentifierStart(ch)) {
						index++;
					} else {
						throwError('Unexpected ' + exprI(index), index);
					}

					while(index < length) {
						ch = exprICode(index);
						if(isIdentifierPart(ch)) {
							index++;
						} else {
							break;
						}
					}
					identifier = expr.slice(start, index);

					if(literals.hasOwnProperty(identifier)) {
						return {
							type: LITERAL,
							value: literals[identifier],
							raw: identifier
						};
					} else if(identifier === this_str) {
						return { type: THIS_EXP };
					} else {
						return {
							type: IDENTIFIER,
							name: identifier
						};
					}
				},

				// Gobbles a list of arguments within the context of a function call
				// or array literal. This function also assumes that the opening character
				// `(` or `[` has already been gobbled, and gobbles expressions and commas
				// until the terminator character `)` or `]` is encountered.
				// e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`
				gobbleArguments = function(termination) {
					var ch_i, args = [], node, closed = false;
					var separator_count = 0;
					while(index < length) {
						gobbleSpaces();
						ch_i = exprICode(index);
						if(ch_i === termination) { // done parsing
							closed = true;
							index++;
							if(termination === CPAREN_CODE && separator_count && separator_count >= args.length){
								throwError('Unexpected token ' + String.fromCharCode(termination), index);
							}
							break;
						} else if (ch_i === COMMA_CODE) { // between expressions
							index++;
							separator_count++;
							if(separator_count !== args.length) { // missing argument
								if(termination === CPAREN_CODE) {
									throwError('Unexpected token ,', index);
								}
								else if(termination === CBRACK_CODE) {
									for(var arg = args.length; arg< separator_count; arg++) {
										args.push(null);
									}
								}
							}
						} else {
							node = gobbleExpression();
							if(!node || node.type === COMPOUND) {
								throwError('Expected comma', index);
							}
							args.push(node);
						}
					}
					if (!closed) {
						throwError('Expected ' + String.fromCharCode(termination), index);
					}
					return args;
				},

				// Gobble a non-literal variable name. This variable name may include properties
				// e.g. `foo`, `bar.baz`, `foo['bar'].baz`
				// It also gobbles function calls:
				// e.g. `Math.acos(obj.angle)`
				gobbleVariable = function() {
					var ch_i, node;
					ch_i = exprICode(index);

					if(ch_i === OPAREN_CODE) {
						node = gobbleGroup();
					} else {
						node = gobbleIdentifier();
					}
					gobbleSpaces();
					ch_i = exprICode(index);
					while(ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {
						index++;
						if(ch_i === PERIOD_CODE) {
							gobbleSpaces();
							node = {
								type: MEMBER_EXP,
								computed: false,
								object: node,
								property: gobbleIdentifier()
							};
						} else if(ch_i === OBRACK_CODE) {
							node = {
								type: MEMBER_EXP,
								computed: true,
								object: node,
								property: gobbleExpression()
							};
							gobbleSpaces();
							ch_i = exprICode(index);
							if(ch_i !== CBRACK_CODE) {
								throwError('Unclosed [', index);
							}
							index++;
						} else if(ch_i === OPAREN_CODE) {
							// A function call is being made; gobble all the arguments
							node = {
								type: CALL_EXP,
								'arguments': gobbleArguments(CPAREN_CODE),
								callee: node
							};
						}
						gobbleSpaces();
						ch_i = exprICode(index);
					}
					return node;
				},

				// Responsible for parsing a group of things within parentheses `()`
				// This function assumes that it needs to gobble the opening parenthesis
				// and then tries to gobble everything within that parenthesis, assuming
				// that the next thing it should see is the close parenthesis. If not,
				// then the expression probably doesn't have a `)`
				gobbleGroup = function() {
					index++;
					var node = gobbleExpression();
					gobbleSpaces();
					if(exprICode(index) === CPAREN_CODE) {
						index++;
						return node;
					} else {
						throwError('Unclosed (', index);
					}
				},

				// Responsible for parsing Array literals `[1, 2, 3]`
				// This function assumes that it needs to gobble the opening bracket
				// and then tries to gobble the expressions as arguments.
				gobbleArray = function() {
					index++;
					return {
						type: ARRAY_EXP,
						elements: gobbleArguments(CBRACK_CODE)
					};
				},

				nodes = [], ch_i, node;

			while(index < length) {
				ch_i = exprICode(index);

				// Expressions can be separated by semicolons, commas, or just inferred without any
				// separators
				if(ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {
					index++; // ignore separators
				} else {
					// Try to gobble each expression individually
					if((node = gobbleExpression())) {
						nodes.push(node);
					// If we weren't able to find a binary expression and are out of room, then
					// the expression passed in probably has too much
					} else if(index < length) {
						throwError('Unexpected "' + exprI(index) + '"', index);
					}
				}
			}

			// If there's only one expression just try returning the expression
			if(nodes.length === 1) {
				return nodes[0];
			} else {
				return {
					type: COMPOUND,
					body: nodes
				};
			}
		};

	// To be filled in by the template
	jsep.version = '0.3.4';
	jsep.toString = function() { return 'JavaScript Expression Parser (JSEP) v' + jsep.version; };

	/**
	 * @method jsep.addUnaryOp
	 * @param {string} op_name The name of the unary op to add
	 * @return jsep
	 */
	jsep.addUnaryOp = function(op_name) {
		max_unop_len = Math.max(op_name.length, max_unop_len);
		unary_ops[op_name] = t; return this;
	};

	/**
	 * @method jsep.addBinaryOp
	 * @param {string} op_name The name of the binary op to add
	 * @param {number} precedence The precedence of the binary op (can be a float)
	 * @return jsep
	 */
	jsep.addBinaryOp = function(op_name, precedence) {
		max_binop_len = Math.max(op_name.length, max_binop_len);
		binary_ops[op_name] = precedence;
		return this;
	};

	/**
	 * @method jsep.addIdentifierChar
	 * @param {string} char The additional character to treat as a valid part of an identifier
	 * @return jsep
	 */
	jsep.addIdentifierChar = function(char) {
		additional_identifier_chars[char] = t;
		return this;
	};

	/**
	 * @method jsep.addLiteral
	 * @param {string} literal_name The name of the literal to add
	 * @param {*} literal_value The value of the literal
	 * @return jsep
	 */
	jsep.addLiteral = function(literal_name, literal_value) {
		literals[literal_name] = literal_value;
		return this;
	};

	/**
	 * @method jsep.removeUnaryOp
	 * @param {string} op_name The name of the unary op to remove
	 * @return jsep
	 */
	jsep.removeUnaryOp = function(op_name) {
		delete unary_ops[op_name];
		if(op_name.length === max_unop_len) {
			max_unop_len = getMaxKeyLen(unary_ops);
		}
		return this;
	};

	/**
	 * @method jsep.removeAllUnaryOps
	 * @return jsep
	 */
	jsep.removeAllUnaryOps = function() {
		unary_ops = {};
		max_unop_len = 0;

		return this;
	};

	/**
	 * @method jsep.removeIdentifierChar
	 * @param {string} char The additional character to stop treating as a valid part of an identifier
	 * @return jsep
	 */
	jsep.removeIdentifierChar = function(char) {
		delete additional_identifier_chars[char];
		return this;
	};


	/**
	 * @method jsep.removeBinaryOp
	 * @param {string} op_name The name of the binary op to remove
	 * @return jsep
	 */
	jsep.removeBinaryOp = function(op_name) {
		delete binary_ops[op_name];
		if(op_name.length === max_binop_len) {
			max_binop_len = getMaxKeyLen(binary_ops);
		}
		return this;
	};

	/**
	 * @method jsep.removeAllBinaryOps
	 * @return jsep
	 */
	jsep.removeAllBinaryOps = function() {
		binary_ops = {};
		max_binop_len = 0;

		return this;
	};

	/**
	 * @method jsep.removeLiteral
	 * @param {string} literal_name The name of the literal to remove
	 * @return jsep
	 */
	jsep.removeLiteral = function(literal_name) {
		delete literals[literal_name];
		return this;
	};

	/**
	 * @method jsep.removeAllLiterals
	 * @return jsep
	 */
	jsep.removeAllLiterals = function() {
		literals = {};

		return this;
	};

	// In desktop environments, have a way to restore the old value for `jsep`
	if (false) { var old_jsep; } else {
		// In Node.JS environments
		if (typeof module !== 'undefined' && module.exports) {
			exports = module.exports = jsep;
		} else {
			exports.parse = jsep;
		}
	}
}(this));


/***/ }),

/***/ "./node_modules/lineclip/index.js":
/*!****************************************!*\
  !*** ./node_modules/lineclip/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = lineclip;

lineclip.polyline = lineclip;
lineclip.polygon = polygonclip;


// Cohen-Sutherland line clippign algorithm, adapted to efficiently
// handle polylines rather than just segments

function lineclip(points, bbox, result) {

    var len = points.length,
        codeA = bitCode(points[0], bbox),
        part = [],
        i, a, b, codeB, lastCode;

    if (!result) result = [];

    for (i = 1; i < len; i++) {
        a = points[i - 1];
        b = points[i];
        codeB = lastCode = bitCode(b, bbox);

        while (true) {

            if (!(codeA | codeB)) { // accept
                part.push(a);

                if (codeB !== lastCode) { // segment went outside
                    part.push(b);

                    if (i < len - 1) { // start a new line
                        result.push(part);
                        part = [];
                    }
                } else if (i === len - 1) {
                    part.push(b);
                }
                break;

            } else if (codeA & codeB) { // trivial reject
                break;

            } else if (codeA) { // a outside, intersect with clip edge
                a = intersect(a, b, codeA, bbox);
                codeA = bitCode(a, bbox);

            } else { // b outside
                b = intersect(a, b, codeB, bbox);
                codeB = bitCode(b, bbox);
            }
        }

        codeA = lastCode;
    }

    if (part.length) result.push(part);

    return result;
}

// Sutherland-Hodgeman polygon clipping algorithm

function polygonclip(points, bbox) {

    var result, edge, prev, prevInside, i, p, inside;

    // clip against each side of the clip rectangle
    for (edge = 1; edge <= 8; edge *= 2) {
        result = [];
        prev = points[points.length - 1];
        prevInside = !(bitCode(prev, bbox) & edge);

        for (i = 0; i < points.length; i++) {
            p = points[i];
            inside = !(bitCode(p, bbox) & edge);

            // if segment goes through the clip window, add an intersection
            if (inside !== prevInside) result.push(intersect(prev, p, edge, bbox));

            if (inside) result.push(p); // add a point if it's inside

            prev = p;
            prevInside = inside;
        }

        points = result;

        if (!points.length) break;
    }

    return result;
}

// intersect a segment against one of the 4 lines that make up the bbox

function intersect(a, b, edge, bbox) {
    return edge & 8 ? [a[0] + (b[0] - a[0]) * (bbox[3] - a[1]) / (b[1] - a[1]), bbox[3]] : // top
           edge & 4 ? [a[0] + (b[0] - a[0]) * (bbox[1] - a[1]) / (b[1] - a[1]), bbox[1]] : // bottom
           edge & 2 ? [bbox[2], a[1] + (b[1] - a[1]) * (bbox[2] - a[0]) / (b[0] - a[0])] : // right
           edge & 1 ? [bbox[0], a[1] + (b[1] - a[1]) * (bbox[0] - a[0]) / (b[0] - a[0])] : // left
           null;
}

// bit code reflects the point position relative to the bbox:

//         left  mid  right
//    top  1001  1000  1010
//    mid  0001  0000  0010
// bottom  0101  0100  0110

function bitCode(p, bbox) {
    var code = 0;

    if (p[0] < bbox[0]) code |= 1; // left
    else if (p[0] > bbox[2]) code |= 2; // right

    if (p[1] < bbox[1]) code |= 4; // bottom
    else if (p[1] > bbox[3]) code |= 8; // top

    return code;
}


/***/ }),

/***/ "./node_modules/lru-cache/index.js":
/*!*****************************************!*\
  !*** ./node_modules/lru-cache/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = LRUCache

// This will be a proper iterable 'Map' in engines that support it,
// or a fakey-fake PseudoMap in older versions.
var Map = __webpack_require__(/*! pseudomap */ "./node_modules/pseudomap/map.js")
var util = __webpack_require__(/*! util */ "./node_modules/util/util.js")

// A linked list to keep track of recently-used-ness
var Yallist = __webpack_require__(/*! yallist */ "./node_modules/lru-cache/node_modules/yallist/yallist.js")

// use symbols if possible, otherwise just _props
var hasSymbol = typeof Symbol === 'function'
var makeSymbol
if (hasSymbol) {
  makeSymbol = function (key) {
    return Symbol(key)
  }
} else {
  makeSymbol = function (key) {
    return '_' + key
  }
}

var MAX = makeSymbol('max')
var LENGTH = makeSymbol('length')
var LENGTH_CALCULATOR = makeSymbol('lengthCalculator')
var ALLOW_STALE = makeSymbol('allowStale')
var MAX_AGE = makeSymbol('maxAge')
var DISPOSE = makeSymbol('dispose')
var NO_DISPOSE_ON_SET = makeSymbol('noDisposeOnSet')
var LRU_LIST = makeSymbol('lruList')
var CACHE = makeSymbol('cache')

function naiveLength () { return 1 }

// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
function LRUCache (options) {
  if (!(this instanceof LRUCache)) {
    return new LRUCache(options)
  }

  if (typeof options === 'number') {
    options = { max: options }
  }

  if (!options) {
    options = {}
  }

  var max = this[MAX] = options.max
  // Kind of weird to have a default max of Infinity, but oh well.
  if (!max ||
      !(typeof max === 'number') ||
      max <= 0) {
    this[MAX] = Infinity
  }

  var lc = options.length || naiveLength
  if (typeof lc !== 'function') {
    lc = naiveLength
  }
  this[LENGTH_CALCULATOR] = lc

  this[ALLOW_STALE] = options.stale || false
  this[MAX_AGE] = options.maxAge || 0
  this[DISPOSE] = options.dispose
  this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false
  this.reset()
}

// resize the cache when the max changes.
Object.defineProperty(LRUCache.prototype, 'max', {
  set: function (mL) {
    if (!mL || !(typeof mL === 'number') || mL <= 0) {
      mL = Infinity
    }
    this[MAX] = mL
    trim(this)
  },
  get: function () {
    return this[MAX]
  },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'allowStale', {
  set: function (allowStale) {
    this[ALLOW_STALE] = !!allowStale
  },
  get: function () {
    return this[ALLOW_STALE]
  },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'maxAge', {
  set: function (mA) {
    if (!mA || !(typeof mA === 'number') || mA < 0) {
      mA = 0
    }
    this[MAX_AGE] = mA
    trim(this)
  },
  get: function () {
    return this[MAX_AGE]
  },
  enumerable: true
})

// resize the cache when the lengthCalculator changes.
Object.defineProperty(LRUCache.prototype, 'lengthCalculator', {
  set: function (lC) {
    if (typeof lC !== 'function') {
      lC = naiveLength
    }
    if (lC !== this[LENGTH_CALCULATOR]) {
      this[LENGTH_CALCULATOR] = lC
      this[LENGTH] = 0
      this[LRU_LIST].forEach(function (hit) {
        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)
        this[LENGTH] += hit.length
      }, this)
    }
    trim(this)
  },
  get: function () { return this[LENGTH_CALCULATOR] },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'length', {
  get: function () { return this[LENGTH] },
  enumerable: true
})

Object.defineProperty(LRUCache.prototype, 'itemCount', {
  get: function () { return this[LRU_LIST].length },
  enumerable: true
})

LRUCache.prototype.rforEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this[LRU_LIST].tail; walker !== null;) {
    var prev = walker.prev
    forEachStep(this, fn, walker, thisp)
    walker = prev
  }
}

function forEachStep (self, fn, node, thisp) {
  var hit = node.value
  if (isStale(self, hit)) {
    del(self, node)
    if (!self[ALLOW_STALE]) {
      hit = undefined
    }
  }
  if (hit) {
    fn.call(thisp, hit.value, hit.key, self)
  }
}

LRUCache.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this[LRU_LIST].head; walker !== null;) {
    var next = walker.next
    forEachStep(this, fn, walker, thisp)
    walker = next
  }
}

LRUCache.prototype.keys = function () {
  return this[LRU_LIST].toArray().map(function (k) {
    return k.key
  }, this)
}

LRUCache.prototype.values = function () {
  return this[LRU_LIST].toArray().map(function (k) {
    return k.value
  }, this)
}

LRUCache.prototype.reset = function () {
  if (this[DISPOSE] &&
      this[LRU_LIST] &&
      this[LRU_LIST].length) {
    this[LRU_LIST].forEach(function (hit) {
      this[DISPOSE](hit.key, hit.value)
    }, this)
  }

  this[CACHE] = new Map() // hash of items by key
  this[LRU_LIST] = new Yallist() // list of items in order of use recency
  this[LENGTH] = 0 // length of items in the list
}

LRUCache.prototype.dump = function () {
  return this[LRU_LIST].map(function (hit) {
    if (!isStale(this, hit)) {
      return {
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      }
    }
  }, this).toArray().filter(function (h) {
    return h
  })
}

LRUCache.prototype.dumpLru = function () {
  return this[LRU_LIST]
}

LRUCache.prototype.inspect = function (n, opts) {
  var str = 'LRUCache {'
  var extras = false

  var as = this[ALLOW_STALE]
  if (as) {
    str += '\n  allowStale: true'
    extras = true
  }

  var max = this[MAX]
  if (max && max !== Infinity) {
    if (extras) {
      str += ','
    }
    str += '\n  max: ' + util.inspect(max, opts)
    extras = true
  }

  var maxAge = this[MAX_AGE]
  if (maxAge) {
    if (extras) {
      str += ','
    }
    str += '\n  maxAge: ' + util.inspect(maxAge, opts)
    extras = true
  }

  var lc = this[LENGTH_CALCULATOR]
  if (lc && lc !== naiveLength) {
    if (extras) {
      str += ','
    }
    str += '\n  length: ' + util.inspect(this[LENGTH], opts)
    extras = true
  }

  var didFirst = false
  this[LRU_LIST].forEach(function (item) {
    if (didFirst) {
      str += ',\n  '
    } else {
      if (extras) {
        str += ',\n'
      }
      didFirst = true
      str += '\n  '
    }
    var key = util.inspect(item.key).split('\n').join('\n  ')
    var val = { value: item.value }
    if (item.maxAge !== maxAge) {
      val.maxAge = item.maxAge
    }
    if (lc !== naiveLength) {
      val.length = item.length
    }
    if (isStale(this, item)) {
      val.stale = true
    }

    val = util.inspect(val, opts).split('\n').join('\n  ')
    str += key + ' => ' + val
  })

  if (didFirst || extras) {
    str += '\n'
  }
  str += '}'

  return str
}

LRUCache.prototype.set = function (key, value, maxAge) {
  maxAge = maxAge || this[MAX_AGE]

  var now = maxAge ? Date.now() : 0
  var len = this[LENGTH_CALCULATOR](value, key)

  if (this[CACHE].has(key)) {
    if (len > this[MAX]) {
      del(this, this[CACHE].get(key))
      return false
    }

    var node = this[CACHE].get(key)
    var item = node.value

    // dispose of the old one before overwriting
    // split out into 2 ifs for better coverage tracking
    if (this[DISPOSE]) {
      if (!this[NO_DISPOSE_ON_SET]) {
        this[DISPOSE](key, item.value)
      }
    }

    item.now = now
    item.maxAge = maxAge
    item.value = value
    this[LENGTH] += len - item.length
    item.length = len
    this.get(key)
    trim(this)
    return true
  }

  var hit = new Entry(key, value, len, now, maxAge)

  // oversized objects fall out of cache automatically.
  if (hit.length > this[MAX]) {
    if (this[DISPOSE]) {
      this[DISPOSE](key, value)
    }
    return false
  }

  this[LENGTH] += hit.length
  this[LRU_LIST].unshift(hit)
  this[CACHE].set(key, this[LRU_LIST].head)
  trim(this)
  return true
}

LRUCache.prototype.has = function (key) {
  if (!this[CACHE].has(key)) return false
  var hit = this[CACHE].get(key).value
  if (isStale(this, hit)) {
    return false
  }
  return true
}

LRUCache.prototype.get = function (key) {
  return get(this, key, true)
}

LRUCache.prototype.peek = function (key) {
  return get(this, key, false)
}

LRUCache.prototype.pop = function () {
  var node = this[LRU_LIST].tail
  if (!node) return null
  del(this, node)
  return node.value
}

LRUCache.prototype.del = function (key) {
  del(this, this[CACHE].get(key))
}

LRUCache.prototype.load = function (arr) {
  // reset the cache
  this.reset()

  var now = Date.now()
  // A previous serialized cache has the most recent items first
  for (var l = arr.length - 1; l >= 0; l--) {
    var hit = arr[l]
    var expiresAt = hit.e || 0
    if (expiresAt === 0) {
      // the item was created without expiration in a non aged cache
      this.set(hit.k, hit.v)
    } else {
      var maxAge = expiresAt - now
      // dont add already expired items
      if (maxAge > 0) {
        this.set(hit.k, hit.v, maxAge)
      }
    }
  }
}

LRUCache.prototype.prune = function () {
  var self = this
  this[CACHE].forEach(function (value, key) {
    get(self, key, false)
  })
}

function get (self, key, doUse) {
  var node = self[CACHE].get(key)
  if (node) {
    var hit = node.value
    if (isStale(self, hit)) {
      del(self, node)
      if (!self[ALLOW_STALE]) hit = undefined
    } else {
      if (doUse) {
        self[LRU_LIST].unshiftNode(node)
      }
    }
    if (hit) hit = hit.value
  }
  return hit
}

function isStale (self, hit) {
  if (!hit || (!hit.maxAge && !self[MAX_AGE])) {
    return false
  }
  var stale = false
  var diff = Date.now() - hit.now
  if (hit.maxAge) {
    stale = diff > hit.maxAge
  } else {
    stale = self[MAX_AGE] && (diff > self[MAX_AGE])
  }
  return stale
}

function trim (self) {
  if (self[LENGTH] > self[MAX]) {
    for (var walker = self[LRU_LIST].tail;
         self[LENGTH] > self[MAX] && walker !== null;) {
      // We know that we're about to delete this one, and also
      // what the next least recently used key will be, so just
      // go ahead and set it now.
      var prev = walker.prev
      del(self, walker)
      walker = prev
    }
  }
}

function del (self, node) {
  if (node) {
    var hit = node.value
    if (self[DISPOSE]) {
      self[DISPOSE](hit.key, hit.value)
    }
    self[LENGTH] -= hit.length
    self[CACHE].delete(hit.key)
    self[LRU_LIST].removeNode(node)
  }
}

// classy, since V8 prefers predictable objects.
function Entry (key, value, length, now, maxAge) {
  this.key = key
  this.value = value
  this.length = length
  this.now = now
  this.maxAge = maxAge || 0
}


/***/ }),

/***/ "./node_modules/lru-cache/node_modules/yallist/yallist.js":
/*!****************************************************************!*\
  !*** ./node_modules/lru-cache/node_modules/yallist/yallist.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = Yallist

Yallist.Node = Node
Yallist.create = Yallist

function Yallist (list) {
  var self = this
  if (!(self instanceof Yallist)) {
    self = new Yallist()
  }

  self.tail = null
  self.head = null
  self.length = 0

  if (list && typeof list.forEach === 'function') {
    list.forEach(function (item) {
      self.push(item)
    })
  } else if (arguments.length > 0) {
    for (var i = 0, l = arguments.length; i < l; i++) {
      self.push(arguments[i])
    }
  }

  return self
}

Yallist.prototype.removeNode = function (node) {
  if (node.list !== this) {
    throw new Error('removing node which does not belong to this list')
  }

  var next = node.next
  var prev = node.prev

  if (next) {
    next.prev = prev
  }

  if (prev) {
    prev.next = next
  }

  if (node === this.head) {
    this.head = next
  }
  if (node === this.tail) {
    this.tail = prev
  }

  node.list.length--
  node.next = null
  node.prev = null
  node.list = null
}

Yallist.prototype.unshiftNode = function (node) {
  if (node === this.head) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var head = this.head
  node.list = this
  node.next = head
  if (head) {
    head.prev = node
  }

  this.head = node
  if (!this.tail) {
    this.tail = node
  }
  this.length++
}

Yallist.prototype.pushNode = function (node) {
  if (node === this.tail) {
    return
  }

  if (node.list) {
    node.list.removeNode(node)
  }

  var tail = this.tail
  node.list = this
  node.prev = tail
  if (tail) {
    tail.next = node
  }

  this.tail = node
  if (!this.head) {
    this.head = node
  }
  this.length++
}

Yallist.prototype.push = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    push(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.unshift = function () {
  for (var i = 0, l = arguments.length; i < l; i++) {
    unshift(this, arguments[i])
  }
  return this.length
}

Yallist.prototype.pop = function () {
  if (!this.tail) {
    return undefined
  }

  var res = this.tail.value
  this.tail = this.tail.prev
  if (this.tail) {
    this.tail.next = null
  } else {
    this.head = null
  }
  this.length--
  return res
}

Yallist.prototype.shift = function () {
  if (!this.head) {
    return undefined
  }

  var res = this.head.value
  this.head = this.head.next
  if (this.head) {
    this.head.prev = null
  } else {
    this.tail = null
  }
  this.length--
  return res
}

Yallist.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.head, i = 0; walker !== null; i++) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.next
  }
}

Yallist.prototype.forEachReverse = function (fn, thisp) {
  thisp = thisp || this
  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
    fn.call(thisp, walker.value, i, this)
    walker = walker.prev
  }
}

Yallist.prototype.get = function (n) {
  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.next
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.getReverse = function (n) {
  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
    // abort out of the list early if we hit a cycle
    walker = walker.prev
  }
  if (i === n && walker !== null) {
    return walker.value
  }
}

Yallist.prototype.map = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.head; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.next
  }
  return res
}

Yallist.prototype.mapReverse = function (fn, thisp) {
  thisp = thisp || this
  var res = new Yallist()
  for (var walker = this.tail; walker !== null;) {
    res.push(fn.call(thisp, walker.value, this))
    walker = walker.prev
  }
  return res
}

Yallist.prototype.reduce = function (fn, initial) {
  var acc
  var walker = this.head
  if (arguments.length > 1) {
    acc = initial
  } else if (this.head) {
    walker = this.head.next
    acc = this.head.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = 0; walker !== null; i++) {
    acc = fn(acc, walker.value, i)
    walker = walker.next
  }

  return acc
}

Yallist.prototype.reduceReverse = function (fn, initial) {
  var acc
  var walker = this.tail
  if (arguments.length > 1) {
    acc = initial
  } else if (this.tail) {
    walker = this.tail.prev
    acc = this.tail.value
  } else {
    throw new TypeError('Reduce of empty list with no initial value')
  }

  for (var i = this.length - 1; walker !== null; i--) {
    acc = fn(acc, walker.value, i)
    walker = walker.prev
  }

  return acc
}

Yallist.prototype.toArray = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.head; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.next
  }
  return arr
}

Yallist.prototype.toArrayReverse = function () {
  var arr = new Array(this.length)
  for (var i = 0, walker = this.tail; walker !== null; i++) {
    arr[i] = walker.value
    walker = walker.prev
  }
  return arr
}

Yallist.prototype.slice = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
    walker = walker.next
  }
  for (; walker !== null && i < to; i++, walker = walker.next) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.sliceReverse = function (from, to) {
  to = to || this.length
  if (to < 0) {
    to += this.length
  }
  from = from || 0
  if (from < 0) {
    from += this.length
  }
  var ret = new Yallist()
  if (to < from || to < 0) {
    return ret
  }
  if (from < 0) {
    from = 0
  }
  if (to > this.length) {
    to = this.length
  }
  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
    walker = walker.prev
  }
  for (; walker !== null && i > from; i--, walker = walker.prev) {
    ret.push(walker.value)
  }
  return ret
}

Yallist.prototype.reverse = function () {
  var head = this.head
  var tail = this.tail
  for (var walker = head; walker !== null; walker = walker.prev) {
    var p = walker.prev
    walker.prev = walker.next
    walker.next = p
  }
  this.head = tail
  this.tail = head
  return this
}

function push (self, item) {
  self.tail = new Node(item, self.tail, null, self)
  if (!self.head) {
    self.head = self.tail
  }
  self.length++
}

function unshift (self, item) {
  self.head = new Node(item, null, self.head, self)
  if (!self.tail) {
    self.tail = self.head
  }
  self.length++
}

function Node (value, prev, next, list) {
  if (!(this instanceof Node)) {
    return new Node(value, prev, next, list)
  }

  this.list = list
  this.value = value

  if (prev) {
    prev.next = this
    this.prev = prev
  } else {
    this.prev = null
  }

  if (next) {
    next.prev = this
    this.next = next
  } else {
    this.next = null
  }
}


/***/ }),

/***/ "./node_modules/mitt/dist/mitt.es.js":
/*!*******************************************!*\
  !*** ./node_modules/mitt/dist/mitt.es.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
//      
// An event handler can take an optional event argument
// and should not return a value
                                          
                                                               

// An array of all currently registered event handlers for a type
                                            
                                                            
// A map of event types and their corresponding event handlers.
                        
                                 
                                   
  

/** Mitt: Tiny (~200b) functional event emitter / pubsub.
 *  @name mitt
 *  @returns {Mitt}
 */
function mitt(all                 ) {
	all = all || Object.create(null);

	return {
		/**
		 * Register an event handler for the given type.
		 *
		 * @param  {String} type	Type of event to listen for, or `"*"` for all events
		 * @param  {Function} handler Function to call in response to given event
		 * @memberOf mitt
		 */
		on: function on(type        , handler              ) {
			(all[type] || (all[type] = [])).push(handler);
		},

		/**
		 * Remove an event handler for the given type.
		 *
		 * @param  {String} type	Type of event to unregister `handler` from, or `"*"`
		 * @param  {Function} handler Handler function to remove
		 * @memberOf mitt
		 */
		off: function off(type        , handler              ) {
			if (all[type]) {
				all[type].splice(all[type].indexOf(handler) >>> 0, 1);
			}
		},

		/**
		 * Invoke all handlers for the given type.
		 * If present, `"*"` handlers are invoked after type-matched handlers.
		 *
		 * @param {String} type  The event type to invoke
		 * @param {Any} [evt]  Any value (object is recommended and powerful), passed to each handler
		 * @memberOf mitt
		 */
		emit: function emit(type        , evt     ) {
			(all[type] || []).slice().map(function (handler) { handler(evt); });
			(all['*'] || []).slice().map(function (handler) { handler(type, evt); });
		}
	};
}

/* harmony default export */ __webpack_exports__["default"] = (mitt);
//# sourceMappingURL=mitt.es.js.map


/***/ }),

/***/ "./node_modules/pako/index.js":
/*!************************************!*\
  !*** ./node_modules/pako/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Top level file is just a mixin of submodules & constants


var assign    = __webpack_require__(/*! ./lib/utils/common */ "./node_modules/pako/lib/utils/common.js").assign;

var deflate   = __webpack_require__(/*! ./lib/deflate */ "./node_modules/pako/lib/deflate.js");
var inflate   = __webpack_require__(/*! ./lib/inflate */ "./node_modules/pako/lib/inflate.js");
var constants = __webpack_require__(/*! ./lib/zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");

var pako = {};

assign(pako, deflate, inflate, constants);

module.exports = pako;


/***/ }),

/***/ "./node_modules/pako/lib/deflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/deflate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ "./node_modules/pako/lib/zlib/deflate.js");
var utils        = __webpack_require__(/*! ./utils/common */ "./node_modules/pako/lib/utils/common.js");
var strings      = __webpack_require__(/*! ./utils/strings */ "./node_modules/pako/lib/utils/strings.js");
var msg          = __webpack_require__(/*! ./zlib/messages */ "./node_modules/pako/lib/zlib/messages.js");
var ZStream      = __webpack_require__(/*! ./zlib/zstream */ "./node_modules/pako/lib/zlib/zstream.js");

var toString = Object.prototype.toString;

/* Public constants ==========================================================*/
/* ===========================================================================*/

var Z_NO_FLUSH      = 0;
var Z_FINISH        = 4;

var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_SYNC_FLUSH    = 2;

var Z_DEFAULT_COMPRESSION = -1;

var Z_DEFAULT_STRATEGY    = 0;

var Z_DEFLATED  = 8;

/* ===========================================================================*/


/**
 * class Deflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[deflate]],
 * [[deflateRaw]] and [[gzip]].
 **/

/* internal
 * Deflate.chunks -> Array
 *
 * Chunks of output data, if [[Deflate#onData]] not overridden.
 **/

/**
 * Deflate.result -> Uint8Array|Array
 *
 * Compressed result, generated by default [[Deflate#onData]]
 * and [[Deflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you
 * push a chunk with explicit flush (call [[Deflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Deflate.err -> Number
 *
 * Error code after deflate finished. 0 (Z_OK) on success.
 * You will not need it in real life, because deflate errors
 * are possible only on wrong options or bad `onData` / `onEnd`
 * custom handlers.
 **/

/**
 * Deflate.msg -> String
 *
 * Error message, if [[Deflate.err]] != 0
 **/


/**
 * new Deflate(options)
 * - options (Object): zlib deflate options.
 *
 * Creates new deflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `level`
 * - `windowBits`
 * - `memLevel`
 * - `strategy`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw deflate
 * - `gzip` (Boolean) - create gzip wrapper
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 * - `header` (Object) - custom header for gzip
 *   - `text` (Boolean) - true if compressed data believed to be text
 *   - `time` (Number) - modification time, unix timestamp
 *   - `os` (Number) - operation system code
 *   - `extra` (Array) - array of bytes with extra data (max 65536)
 *   - `name` (String) - file name (binary string)
 *   - `comment` (String) - comment (binary string)
 *   - `hcrc` (Boolean) - true if header crc should be added
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var deflate = new pako.Deflate({ level: 3});
 *
 * deflate.push(chunk1, false);
 * deflate.push(chunk2, true);  // true -> last chunk
 *
 * if (deflate.err) { throw new Error(deflate.err); }
 *
 * console.log(deflate.result);
 * ```
 **/
function Deflate(options) {
  if (!(this instanceof Deflate)) return new Deflate(options);

  this.options = utils.assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ''
  }, options || {});

  var opt = this.options;

  if (opt.raw && (opt.windowBits > 0)) {
    opt.windowBits = -opt.windowBits;
  }

  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {
    opt.windowBits += 16;
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm = new ZStream();
  this.strm.avail_out = 0;

  var status = zlib_deflate.deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );

  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }

  if (opt.header) {
    zlib_deflate.deflateSetHeader(this.strm, opt.header);
  }

  if (opt.dictionary) {
    var dict;
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      // If we need to compress text, change encoding to utf8.
      dict = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      dict = new Uint8Array(opt.dictionary);
    } else {
      dict = opt.dictionary;
    }

    status = zlib_deflate.deflateSetDictionary(this.strm, dict);

    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }

    this._dict_set = true;
  }
}

/**
 * Deflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be
 *   converted to utf8 byte sequence.
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with
 * new compressed chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the compression context.
 *
 * On fail call [[Deflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * array format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Deflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;

  if (this.ended) { return false; }

  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // If we need to compress text, change encoding to utf8.
    strm.input = strings.string2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */

    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {
      if (this.options.to === 'string') {
        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(utils.shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);

  // Finalize on the last chunk.
  if (_mode === Z_FINISH) {
    status = zlib_deflate.deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Deflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Deflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Deflate#onEnd(status) -> Void
 * - status (Number): deflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called once after you tell deflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Deflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === Z_OK) {
    if (this.options.to === 'string') {
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * deflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * Compress `data` with deflate algorithm and `options`.
 *
 * Supported options are:
 *
 * - level
 * - windowBits
 * - memLevel
 * - strategy
 * - dictionary
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be "binary string"
 *    (each char code [0..255])
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);
 *
 * console.log(pako.deflate(data));
 * ```
 **/
function deflate(input, options) {
  var deflator = new Deflate(options);

  deflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }

  return deflator.result;
}


/**
 * deflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function deflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return deflate(input, options);
}


/**
 * gzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to compress.
 * - options (Object): zlib deflate options.
 *
 * The same as [[deflate]], but create gzip wrapper instead of
 * deflate one.
 **/
function gzip(input, options) {
  options = options || {};
  options.gzip = true;
  return deflate(input, options);
}


exports.Deflate = Deflate;
exports.deflate = deflate;
exports.deflateRaw = deflateRaw;
exports.gzip = gzip;


/***/ }),

/***/ "./node_modules/pako/lib/inflate.js":
/*!******************************************!*\
  !*** ./node_modules/pako/lib/inflate.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ "./node_modules/pako/lib/zlib/inflate.js");
var utils        = __webpack_require__(/*! ./utils/common */ "./node_modules/pako/lib/utils/common.js");
var strings      = __webpack_require__(/*! ./utils/strings */ "./node_modules/pako/lib/utils/strings.js");
var c            = __webpack_require__(/*! ./zlib/constants */ "./node_modules/pako/lib/zlib/constants.js");
var msg          = __webpack_require__(/*! ./zlib/messages */ "./node_modules/pako/lib/zlib/messages.js");
var ZStream      = __webpack_require__(/*! ./zlib/zstream */ "./node_modules/pako/lib/zlib/zstream.js");
var GZheader     = __webpack_require__(/*! ./zlib/gzheader */ "./node_modules/pako/lib/zlib/gzheader.js");

var toString = Object.prototype.toString;

/**
 * class Inflate
 *
 * Generic JS-style wrapper for zlib calls. If you don't need
 * streaming behaviour - use more simple functions: [[inflate]]
 * and [[inflateRaw]].
 **/

/* internal
 * inflate.chunks -> Array
 *
 * Chunks of output data, if [[Inflate#onData]] not overridden.
 **/

/**
 * Inflate.result -> Uint8Array|Array|String
 *
 * Uncompressed result, generated by default [[Inflate#onData]]
 * and [[Inflate#onEnd]] handlers. Filled after you push last chunk
 * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you
 * push a chunk with explicit flush (call [[Inflate#push]] with
 * `Z_SYNC_FLUSH` param).
 **/

/**
 * Inflate.err -> Number
 *
 * Error code after inflate finished. 0 (Z_OK) on success.
 * Should be checked if broken data possible.
 **/

/**
 * Inflate.msg -> String
 *
 * Error message, if [[Inflate.err]] != 0
 **/


/**
 * new Inflate(options)
 * - options (Object): zlib inflate options.
 *
 * Creates new inflator instance with specified params. Throws exception
 * on bad params. Supported options:
 *
 * - `windowBits`
 * - `dictionary`
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information on these.
 *
 * Additional options, for internal needs:
 *
 * - `chunkSize` - size of generated data chunks (16K by default)
 * - `raw` (Boolean) - do raw inflate
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 * By default, when no options set, autodetect deflate/gzip data format via
 * wrapper header.
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])
 *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);
 *
 * var inflate = new pako.Inflate({ level: 3});
 *
 * inflate.push(chunk1, false);
 * inflate.push(chunk2, true);  // true -> last chunk
 *
 * if (inflate.err) { throw new Error(inflate.err); }
 *
 * console.log(inflate.result);
 * ```
 **/
function Inflate(options) {
  if (!(this instanceof Inflate)) return new Inflate(options);

  this.options = utils.assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ''
  }, options || {});

  var opt = this.options;

  // Force window size for `raw` data, if not set directly,
  // because we have no header for autodetect.
  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) { opt.windowBits = -15; }
  }

  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate
  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&
      !(options && options.windowBits)) {
    opt.windowBits += 32;
  }

  // Gzip header has no info about windows size, we can do autodetect only
  // for deflate. So, if window size not set, force it to max when gzip possible
  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {
    // bit 3 (16) -> gzipped data
    // bit 4 (32) -> autodetect gzip/deflate
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }

  this.err    = 0;      // error code, if happens (0 = Z_OK)
  this.msg    = '';     // error message
  this.ended  = false;  // used to avoid multiple onEnd() calls
  this.chunks = [];     // chunks of compressed data

  this.strm   = new ZStream();
  this.strm.avail_out = 0;

  var status  = zlib_inflate.inflateInit2(
    this.strm,
    opt.windowBits
  );

  if (status !== c.Z_OK) {
    throw new Error(msg[status]);
  }

  this.header = new GZheader();

  zlib_inflate.inflateGetHeader(this.strm, this.header);

  // Setup dictionary
  if (opt.dictionary) {
    // Convert data if needed
    if (typeof opt.dictionary === 'string') {
      opt.dictionary = strings.string2buf(opt.dictionary);
    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) { //In raw mode we need to set the dictionary early
      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
}

/**
 * Inflate#push(data[, mode]) -> Boolean
 * - data (Uint8Array|Array|ArrayBuffer|String): input data
 * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.
 *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.
 *
 * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with
 * new output chunks. Returns `true` on success. The last data block must have
 * mode Z_FINISH (or `true`). That will flush internal pending buffers and call
 * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you
 * can use mode Z_SYNC_FLUSH, keeping the decompression context.
 *
 * On fail call [[Inflate#onEnd]] with error code and return false.
 *
 * We strongly recommend to use `Uint8Array` on input for best speed (output
 * format is detected automatically). Also, don't skip last param and always
 * use the same type in your code (boolean or number). That will improve JS speed.
 *
 * For regular `Array`-s make sure all elements are [0..255].
 *
 * ##### Example
 *
 * ```javascript
 * push(chunk, false); // push one of data chunks
 * ...
 * push(chunk, true);  // push last chunk
 * ```
 **/
Inflate.prototype.push = function (data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;

  // Flag to properly process Z_BUF_ERROR on testing inflate call
  // when we check that all output data was flushed.
  var allowBufError = false;

  if (this.ended) { return false; }
  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);

  // Convert data if needed
  if (typeof data === 'string') {
    // Only binary strings can be decompressed on practice
    strm.input = strings.binstring2buf(data);
  } else if (toString.call(data) === '[object ArrayBuffer]') {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }

  strm.next_in = 0;
  strm.avail_in = strm.input.length;

  do {
    if (strm.avail_out === 0) {
      strm.output = new utils.Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }

    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */

    if (status === c.Z_NEED_DICT && dictionary) {
      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
    }

    if (status === c.Z_BUF_ERROR && allowBufError === true) {
      status = c.Z_OK;
      allowBufError = false;
    }

    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }

    if (strm.next_out) {
      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {

        if (this.options.to === 'string') {

          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);

          tail = strm.next_out - next_out_utf8;
          utf8str = strings.buf2string(strm.output, next_out_utf8);

          // move tail
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }

          this.onData(utf8str);

        } else {
          this.onData(utils.shrinkBuf(strm.output, strm.next_out));
        }
      }
    }

    // When no more input data, we should check that internal inflate buffers
    // are flushed. The only way to do it when avail_out = 0 - run one more
    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.
    // Here we set flag to process this error properly.
    //
    // NOTE. Deflate does not return error in this case and does not needs such
    // logic.
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }

  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);

  if (status === c.Z_STREAM_END) {
    _mode = c.Z_FINISH;
  }

  // Finalize on the last chunk.
  if (_mode === c.Z_FINISH) {
    status = zlib_inflate.inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === c.Z_OK;
  }

  // callback interim results if Z_SYNC_FLUSH.
  if (_mode === c.Z_SYNC_FLUSH) {
    this.onEnd(c.Z_OK);
    strm.avail_out = 0;
    return true;
  }

  return true;
};


/**
 * Inflate#onData(chunk) -> Void
 * - chunk (Uint8Array|Array|String): output data. Type of array depends
 *   on js engine support. When string output requested, each chunk
 *   will be string.
 *
 * By default, stores data blocks in `chunks[]` property and glue
 * those in `onEnd`. Override this handler, if you need another behaviour.
 **/
Inflate.prototype.onData = function (chunk) {
  this.chunks.push(chunk);
};


/**
 * Inflate#onEnd(status) -> Void
 * - status (Number): inflate status. 0 (Z_OK) on success,
 *   other if not.
 *
 * Called either after you tell inflate that the input stream is
 * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)
 * or if an error happened. By default - join collected chunks,
 * free memory and fill `results` / `err` properties.
 **/
Inflate.prototype.onEnd = function (status) {
  // On success - join
  if (status === c.Z_OK) {
    if (this.options.to === 'string') {
      // Glue & convert here, until we teach pako to send
      // utf8 aligned strings to onData
      this.result = this.chunks.join('');
    } else {
      this.result = utils.flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};


/**
 * inflate(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Decompress `data` with inflate/ungzip and `options`. Autodetect
 * format via wrapper header by default. That's why we don't provide
 * separate `ungzip` method.
 *
 * Supported options are:
 *
 * - windowBits
 *
 * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)
 * for more information.
 *
 * Sugar (options):
 *
 * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify
 *   negative windowBits implicitly.
 * - `to` (String) - if equal to 'string', then result will be converted
 *   from utf8 to utf16 (javascript) string. When string output requested,
 *   chunk length can differ from `chunkSize`, depending on content.
 *
 *
 * ##### Example:
 *
 * ```javascript
 * var pako = require('pako')
 *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])
 *   , output;
 *
 * try {
 *   output = pako.inflate(input);
 * } catch (err)
 *   console.log(err);
 * }
 * ```
 **/
function inflate(input, options) {
  var inflator = new Inflate(options);

  inflator.push(input, true);

  // That will never happens, if you don't cheat with options :)
  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }

  return inflator.result;
}


/**
 * inflateRaw(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * The same as [[inflate]], but creates raw data, without wrapper
 * (header and adler32 crc).
 **/
function inflateRaw(input, options) {
  options = options || {};
  options.raw = true;
  return inflate(input, options);
}


/**
 * ungzip(data[, options]) -> Uint8Array|Array|String
 * - data (Uint8Array|Array|String): input data to decompress.
 * - options (Object): zlib inflate options.
 *
 * Just shortcut to [[inflate]], because it autodetects format
 * by header.content. Done for convenience.
 **/


exports.Inflate = Inflate;
exports.inflate = inflate;
exports.inflateRaw = inflateRaw;
exports.ungzip  = inflate;


/***/ }),

/***/ "./node_modules/pako/lib/utils/common.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/utils/common.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var TYPED_OK =  (typeof Uint8Array !== 'undefined') &&
                (typeof Uint16Array !== 'undefined') &&
                (typeof Int32Array !== 'undefined');

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj /*from1, from2, from3, ...*/) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) { continue; }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
};


// reduce buffer size, avoiding mem copy
exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


var fnTyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    // Fallback to ordinary array
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    var i, l, len, pos, chunk, result;

    // calculate data length
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }

    // join chunks
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};

var fnUntyped = {
  arraySet: function (dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function (chunks) {
    return [].concat.apply([], chunks);
  }
};


// Enable/Disable typed arrays use, for testing
//
exports.setTyped = function (on) {
  if (on) {
    exports.Buf8  = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8  = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);


/***/ }),

/***/ "./node_modules/pako/lib/utils/strings.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/utils/strings.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// String encode/decode helpers



var utils = __webpack_require__(/*! ./common */ "./node_modules/pako/lib/utils/common.js");


// Quick check if we can use fast array to bin string conversion
//
// - apply(Array) can fail on Android 2.2
// - apply(Uint8Array) can fail on iOS 5.1 Safari
//
var STR_APPLY_OK = true;
var STR_APPLY_UIA_OK = true;

try { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }
try { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }


// Table with utf8 lengths (calculated by first byte of sequence)
// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,
// because max possible codepoint is 0x10ffff
var _utf8len = new utils.Buf8(256);
for (var q = 0; q < 256; q++) {
  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);
}
_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start


// convert string to array (typed, when possible)
exports.string2buf = function (str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;

  // count binary size
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
  }

  // allocate buffer
  buf = new utils.Buf8(buf_len);

  // convert
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 0xfc00) === 0xdc00) {
        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);
        m_pos++;
      }
    }
    if (c < 0x80) {
      /* one byte */
      buf[i++] = c;
    } else if (c < 0x800) {
      /* two bytes */
      buf[i++] = 0xC0 | (c >>> 6);
      buf[i++] = 0x80 | (c & 0x3f);
    } else if (c < 0x10000) {
      /* three bytes */
      buf[i++] = 0xE0 | (c >>> 12);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    } else {
      /* four bytes */
      buf[i++] = 0xf0 | (c >>> 18);
      buf[i++] = 0x80 | (c >>> 12 & 0x3f);
      buf[i++] = 0x80 | (c >>> 6 & 0x3f);
      buf[i++] = 0x80 | (c & 0x3f);
    }
  }

  return buf;
};

// Helper (used in 2 places)
function buf2binstring(buf, len) {
  // On Chrome, the arguments in a function call that are allowed is `65534`.
  // If the length of the buffer is smaller than that, we can use this optimization,
  // otherwise we will take a slower path.
  if (len < 65534) {
    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {
      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
    }
  }

  var result = '';
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}


// Convert byte array to binary string
exports.buf2binstring = function (buf) {
  return buf2binstring(buf, buf.length);
};


// Convert binary string (typed, when possible)
exports.binstring2buf = function (str) {
  var buf = new utils.Buf8(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
};


// convert array to string
exports.buf2string = function (buf, max) {
  var i, out, c, c_len;
  var len = max || buf.length;

  // Reserve max possible length (2 words per char)
  // NB: by unknown reasons, Array is significantly faster for
  //     String.fromCharCode.apply than Uint16Array.
  var utf16buf = new Array(len * 2);

  for (out = 0, i = 0; i < len;) {
    c = buf[i++];
    // quick process ascii
    if (c < 0x80) { utf16buf[out++] = c; continue; }

    c_len = _utf8len[c];
    // skip 5 & 6 byte codes
    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }

    // apply mask on first byte
    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;
    // join the rest
    while (c_len > 1 && i < len) {
      c = (c << 6) | (buf[i++] & 0x3f);
      c_len--;
    }

    // terminated by end of string?
    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }

    if (c < 0x10000) {
      utf16buf[out++] = c;
    } else {
      c -= 0x10000;
      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);
      utf16buf[out++] = 0xdc00 | (c & 0x3ff);
    }
  }

  return buf2binstring(utf16buf, out);
};


// Calculate max possible position in utf8 buffer,
// that will not break sequence. If that's not possible
// - (very small limits) return max size as is.
//
// buf[] - utf8 bytes array
// max   - length limit (mandatory);
exports.utf8border = function (buf, max) {
  var pos;

  max = max || buf.length;
  if (max > buf.length) { max = buf.length; }

  // go back from last position, until start of sequence found
  pos = max - 1;
  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }

  // Very small and broken sequence,
  // return max, because we should return something anyway.
  if (pos < 0) { return max; }

  // If we came to start of buffer - that means buffer is too small,
  // return max too.
  if (pos === 0) { return max; }

  return (pos + _utf8len[buf[pos]] > max) ? pos : max;
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/adler32.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/adler32.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


module.exports = adler32;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/constants.js":
/*!*************************************************!*\
  !*** ./node_modules/pako/lib/zlib/constants.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {

  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH:         0,
  Z_PARTIAL_FLUSH:    1,
  Z_SYNC_FLUSH:       2,
  Z_FULL_FLUSH:       3,
  Z_FINISH:           4,
  Z_BLOCK:            5,
  Z_TREES:            6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK:               0,
  Z_STREAM_END:       1,
  Z_NEED_DICT:        2,
  Z_ERRNO:           -1,
  Z_STREAM_ERROR:    -2,
  Z_DATA_ERROR:      -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR:       -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION:         0,
  Z_BEST_SPEED:             1,
  Z_BEST_COMPRESSION:       9,
  Z_DEFAULT_COMPRESSION:   -1,


  Z_FILTERED:               1,
  Z_HUFFMAN_ONLY:           2,
  Z_RLE:                    3,
  Z_FIXED:                  4,
  Z_DEFAULT_STRATEGY:       0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY:                 0,
  Z_TEXT:                   1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN:                2,

  /* The deflate compression method */
  Z_DEFLATED:               8
  //Z_NULL:                 null // Use -1 or null inline, depending on var type
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/crc32.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/crc32.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.

// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


module.exports = crc32;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/deflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/deflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils   = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");
var trees   = __webpack_require__(/*! ./trees */ "./node_modules/pako/lib/zlib/trees.js");
var adler32 = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");
var crc32   = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");
var msg     = __webpack_require__(/*! ./messages */ "./node_modules/pako/lib/zlib/messages.js");

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
var Z_NO_FLUSH      = 0;
var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
//var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
//var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
//var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;


/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;
var Z_DEFAULT_COMPRESSION = -1;


var Z_FILTERED            = 1;
var Z_HUFFMAN_ONLY        = 2;
var Z_RLE                 = 3;
var Z_FIXED               = 4;
var Z_DEFAULT_STRATEGY    = 0;

/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;


/* The deflate compression method */
var Z_DEFLATED  = 8;

/*============================================================================*/


var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */
var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_MEM_LEVEL = 8;


var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */
var LITERALS      = 256;
/* number of literal bytes 0..255 */
var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */
var D_CODES       = 30;
/* number of distance codes */
var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */
var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */
var MAX_BITS  = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);

var PRESET_DICT = 0x20;

var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;

var BS_NEED_MORE      = 1; /* block not completed, need more input or more output */
var BS_BLOCK_DONE     = 2; /* block flush performed */
var BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */
var BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return ((f) << 1) - ((f) > 4 ? 9 : 0);
}

function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }


/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */
function flush_pending(strm) {
  var s = strm.state;

  //_tr_flush_bits(s);
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) { return; }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}


function flush_block_only(s, last) {
  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}


function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}


/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
function putShortMSB(s, b) {
//  put_byte(s, (Byte)(b >> 8));
//  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}


/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) { len = size; }
  if (len === 0) { return 0; }

  strm.avail_in -= len;

  // zmemcpy(buf, strm->next_in, len);
  utils.arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  }

  else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;

  return len;
}


/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;      /* max hash chain length */
  var scan = s.strstart; /* current string */
  var match;                       /* matched string */
  var len;                           /* length of current match */
  var best_len = s.prev_length;              /* best match length so far */
  var nice_match = s.nice_match;             /* stop if match long enough */
  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?
      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;

  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev  = s.prev;

  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1  = _win[scan + best_len - 1];
  var scan_end   = _win[scan + best_len];

  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */
  if (nice_match > s.lookahead) { nice_match = s.lookahead; }

  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;

    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len]     !== scan_end  ||
        _win[match + best_len - 1] !== scan_end1 ||
        _win[match]                !== _win[scan] ||
        _win[++match]              !== _win[scan + 1]) {
      continue;
    }

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2;
    match++;
    // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&
             scan < strend);

    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1  = _win[scan + best_len - 1];
      scan_end   = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}


/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str;

  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart;

    // JS ints have 32 bit, block below not needed
    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}


    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {

      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */
      s.block_start -= _w_size;

      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;
      do {
        m = s.head[--p];
        s.head[p] = (m >= _w_size ? m - _w_size : 0);
      } while (--n);

      n = _w_size;
      p = n;
      do {
        m = s.prev[--p];
        s.prev[p] = (m >= _w_size ? m - _w_size : 0);
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }

    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;

    /* Initialize the hash value now that we have some input: */
    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];

      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;
//#if MIN_MATCH != 3
//        Call update_hash() MIN_MATCH-3 more times
//#endif
      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);

  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
//  if (s.high_water < s.window_size) {
//    var curr = s.strstart + s.lookahead;
//    var init = 0;
//
//    if (s.high_water < curr) {
//      /* Previous high water mark below current data -- zero WIN_INIT
//       * bytes or up to end of window, whichever is less.
//       */
//      init = s.window_size - curr;
//      if (init > WIN_INIT)
//        init = WIN_INIT;
//      zmemzero(s->window + curr, (unsigned)init);
//      s->high_water = curr + init;
//    }
//    else if (s->high_water < (ulg)curr + WIN_INIT) {
//      /* High water mark at or above current data, but below current data
//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
//       * to end of window, whichever is less.
//       */
//      init = (ulg)curr + WIN_INIT - s->high_water;
//      if (init > s->window_size - s->high_water)
//        init = s->window_size - s->high_water;
//      zmemzero(s->window + s->high_water, (unsigned)init);
//      s->high_water += init;
//    }
//  }
//
//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
//    "not enough room for search");
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }

  /* Copy as much as possible from input to output: */
  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {

      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
//        s.block_start >= s.w_size)) {
//        throw  new Error("slide too late");
//      }

      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */
    }
    //Assert(s->block_start >= 0L, "block gone");
//    if (s.block_start < 0) throw new Error("block gone");

    s.strstart += s.lookahead;
    s.lookahead = 0;

    /* Emit a stored block if pending_buf will be full: */
    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/


    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */
    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_NEED_MORE;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
function deflate_fast(s, flush) {
  var hash_head;        /* head of the hash chain */
  var bflush;           /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break; /* flush the current block */
      }
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */
    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }
    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;

      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */
      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {
        s.match_length--; /* string at strstart already in table */
        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);
        s.strstart++;
      } else
      {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */
        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;

//#if MIN_MATCH != 3
//                Call UPDATE_HASH() MIN_MATCH-3 more times
//#endif
        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
function deflate_slow(s, flush) {
  var hash_head;          /* head of hash chain */
  var bflush;              /* set if current block must be flushed */

  var max_insert;

  /* Process the input block. */
  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */
    hash_head = 0/*NIL*/;
    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }

    /* Find the longest match, discarding those <= prev_length.
     */
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&
        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */

      if (s.match_length <= 5 &&
         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {

        /* If prev_match is also MIN_MATCH, match_start is garbage
         * but we will ignore the current match anyway.
         */
        s.match_length = MIN_MATCH - 1;
      }
    }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */
    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */

      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/
      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/
      }

    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));
      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  //Assert (flush != Z_NO_FLUSH, "no flush?");
  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));
    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }

  return BS_BLOCK_DONE;
}


/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */
function deflate_rle(s, flush) {
  var bflush;            /* set if current block must be flushed */
  var prev;              /* byte at distance one to match */
  var scan, strend;      /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) { break; } /* flush the current block */
    }

    /* See how many times the previous byte repeats */
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;
        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 prev === _win[++scan] && prev === _win[++scan] &&
                 scan < strend);
        s.match_length = MAX_MATCH - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");
    }

    /* Emit match if have run of MIN_MATCH or longer, else emit literal */
    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);

      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));
      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);

      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */
function deflate_huff(s, flush) {
  var bflush;             /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;      /* flush the current block */
      }
    }

    /* Output a literal byte */
    s.match_length = 0;
    //Tracevv((stderr,"%c", s->window[s->strstart]));
    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/
  }
  return BS_BLOCK_DONE;
}

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;

configuration_table = [
  /*      good lazy nice chain */
  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */
  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */
  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */
  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */

  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */
  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */
  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */
  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */
  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */
  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */
];


/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
function lm_init(s) {
  s.window_size = 2 * s.w_size;

  /*** CLEAR_HASH(s); ***/
  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */
  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;

  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}


function DeflateState() {
  this.strm = null;            /* pointer back to this zlib stream */
  this.status = 0;            /* as the name implies */
  this.pending_buf = null;      /* output still pending */
  this.pending_buf_size = 0;  /* size of pending_buf */
  this.pending_out = 0;       /* next pending byte to output to the stream */
  this.pending = 0;           /* nb of bytes in the pending buffer */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.gzhead = null;         /* gzip header information to write */
  this.gzindex = 0;           /* where in extra, name, or comment */
  this.method = Z_DEFLATED; /* can only be DEFLATED */
  this.last_flush = -1;   /* value of flush param for previous deflate call */

  this.w_size = 0;  /* LZ77 window size (32K by default) */
  this.w_bits = 0;  /* log2(w_size)  (8..16) */
  this.w_mask = 0;  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;   /* Heads of the hash chains or NIL. */

  this.ins_h = 0;       /* hash index of string to be inserted */
  this.hash_size = 0;   /* number of elements in hash table */
  this.hash_bits = 0;   /* log2(hash_size) */
  this.hash_mask = 0;   /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;      /* length of best match */
  this.prev_match = 0;        /* previous match */
  this.match_available = 0;   /* set if previous match exists */
  this.strstart = 0;          /* start of string to insert */
  this.match_start = 0;       /* start of matching string */
  this.lookahead = 0;         /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;
  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;     /* compression level (1..9) */
  this.strategy = 0;  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0; /* Stop searching when current match exceeds this */

              /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */

  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective
  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);

  this.l_desc   = null;         /* desc. for literal tree */
  this.d_desc   = null;         /* desc. for distance tree */
  this.bl_desc  = null;         /* desc. for bit length tree */

  //ush bl_count[MAX_BITS+1];
  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */
  zero(this.heap);

  this.heap_len = 0;               /* number of elements in the heap */
  this.heap_max = 0;               /* element of largest frequency */
  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];
  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;          /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;      /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;       /* bit length of current block with optimal trees */
  this.static_len = 0;    /* bit length of current block with static trees */
  this.matches = 0;       /* number of string matches in current block */
  this.insert = 0;        /* bytes at end of window left to insert */


  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */
  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */

  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;
  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}


function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;

  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }
  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);
  strm.adler = (s.wrap === 2) ?
    0  // crc32(0, Z_NULL, 0)
  :
    1; // adler32(0, Z_NULL, 0)
  s.last_flush = Z_NO_FLUSH;
  trees._tr_init(s);
  return Z_OK;
}


function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}


function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }
  strm.state.gzhead = head;
  return Z_OK;
}


function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) { // === Z_NULL
    return Z_STREAM_ERROR;
  }
  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) { /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  }

  else if (windowBits > 15) {
    wrap = 2;           /* write gzip wrapper instead */
    windowBits -= 16;
  }


  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||
    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
    strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }


  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */

  var s = new DeflateState();

  strm.state = s;
  s.strm = strm;

  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;

  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);

  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size);

  // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4;

  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;
  s.pending_buf = new utils.Buf8(s.pending_buf_size);

  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
  s.d_buf = 1 * s.lit_bufsize;

  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;

  s.level = level;
  s.strategy = strategy;
  s.method = method;

  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}


function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state ||
    flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output ||
      (!strm.input && strm.avail_in !== 0) ||
      (s.status === FINISH_STATE && flush !== Z_FINISH)) {
    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm; /* just in case */
  old_flush = s.last_flush;
  s.last_flush = flush;

  /* Write the header */
  if (s.status === INIT_STATE) {

    if (s.wrap === 2) { // GZIP header
      strm.adler = 0;  //crc32(0L, Z_NULL, 0);
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) { // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      }
      else {
        put_byte(s, (s.gzhead.text ? 1 : 0) +
                    (s.gzhead.hcrc ? 2 : 0) +
                    (!s.gzhead.extra ? 0 : 4) +
                    (!s.gzhead.name ? 0 : 8) +
                    (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, (s.gzhead.time >> 8) & 0xff);
        put_byte(s, (s.gzhead.time >> 16) & 0xff);
        put_byte(s, (s.gzhead.time >> 24) & 0xff);
        put_byte(s, s.level === 9 ? 2 :
                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?
                     4 : 0));
        put_byte(s, s.gzhead.os & 0xff);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    }
    else // DEFLATE header
    {
      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;
      var level_flags = -1;

      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= (level_flags << 6);
      if (s.strstart !== 0) { header |= PRESET_DICT; }
      header += 31 - (header % 31);

      s.status = BUSY_STATE;
      putShortMSB(s, header);

      /* Save the adler32 of the preset dictionary: */
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 0xffff);
      }
      strm.adler = 1; // adler32(0L, Z_NULL, 0);
    }
  }

//#ifdef GZIP
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */

      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    }
    else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    }
    else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment/* != Z_NULL*/) {
      beg = s.pending;  /* start of bytes to update crc */
      //int val;

      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        // JS specific: little magic to add zero terminator to end of string
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);

      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    }
    else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, (strm.adler >> 8) & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);
        s.status = BUSY_STATE;
      }
    }
    else {
      s.status = BUSY_STATE;
    }
  }
//#endif

  /* Flush as much pending output as possible */
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&
    flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }

  /* User must not provide more input after the first FINISH: */
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }

  /* Start a new block or continue the current one.
   */
  if (strm.avail_in !== 0 || s.lookahead !== 0 ||
    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {
    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :
      (s.strategy === Z_RLE ? deflate_rle(s, flush) :
        configuration_table[s.level].func(s, flush));

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }
      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      }
      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */

        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */
        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/             /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */
        return Z_OK;
      }
    }
  }
  //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}

  if (flush !== Z_FINISH) { return Z_OK; }
  if (s.wrap <= 0) { return Z_STREAM_END; }

  /* Write the trailer */
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, (strm.adler >> 8) & 0xff);
    put_byte(s, (strm.adler >> 16) & 0xff);
    put_byte(s, (strm.adler >> 24) & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, (strm.total_in >> 8) & 0xff);
    put_byte(s, (strm.total_in >> 16) & 0xff);
    put_byte(s, (strm.total_in >> 24) & 0xff);
  }
  else
  {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */
  if (s.wrap > 0) { s.wrap = -s.wrap; }
  /* write the trailer only once! */
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  status = strm.state.status;
  if (status !== INIT_STATE &&
    status !== EXTRA_STATE &&
    status !== NAME_STATE &&
    status !== COMMENT_STATE &&
    status !== HCRC_STATE &&
    status !== BUSY_STATE &&
    status !== FINISH_STATE
  ) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;

  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}


/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {
    return Z_STREAM_ERROR;
  }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {
    return Z_STREAM_ERROR;
  }

  /* when using zlib wrappers, compute Adler-32 for provided dictionary */
  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */
  if (dictLength >= s.w_size) {
    if (wrap === 0) {            /* already empty otherwise */
      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);
    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);
    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;

      s.prev[str & s.w_mask] = s.head[s.ins_h];

      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}


exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';

/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/


/***/ }),

/***/ "./node_modules/pako/lib/zlib/gzheader.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/gzheader.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function GZheader() {
  /* true if compressed data believed to be text */
  this.text       = 0;
  /* modification time */
  this.time       = 0;
  /* extra flags (not used when writing a gzip file) */
  this.xflags     = 0;
  /* operating system */
  this.os         = 0;
  /* pointer to extra field or Z_NULL if none */
  this.extra      = null;
  /* extra field length (valid if extra != Z_NULL) */
  this.extra_len  = 0; // Actually, we don't need it in JS,
                       // but leave for few code modifications

  //
  // Setup limits is not necessary because in js we should not preallocate memory
  // for inflate use constant limit in 65536 bytes
  //

  /* space at extra (only when reading header) */
  // this.extra_max  = 0;
  /* pointer to zero-terminated file name or Z_NULL */
  this.name       = '';
  /* space at name (only when reading header) */
  // this.name_max   = 0;
  /* pointer to zero-terminated comment or Z_NULL */
  this.comment    = '';
  /* space at comment (only when reading header) */
  // this.comm_max   = 0;
  /* true if there was or will be a header crc */
  this.hcrc       = 0;
  /* true when done reading gzip header (not used when writing a gzip file) */
  this.done       = false;
}

module.exports = GZheader;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inffast.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inffast.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
module.exports = function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inflate.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/inflate.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils         = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");
var adler32       = __webpack_require__(/*! ./adler32 */ "./node_modules/pako/lib/zlib/adler32.js");
var crc32         = __webpack_require__(/*! ./crc32 */ "./node_modules/pako/lib/zlib/crc32.js");
var inflate_fast  = __webpack_require__(/*! ./inffast */ "./node_modules/pako/lib/zlib/inffast.js");
var inflate_table = __webpack_require__(/*! ./inftrees */ "./node_modules/pako/lib/zlib/inftrees.js");

var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */
  this.work = new utils.Buf16(288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new utils.Buf8(state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        }
        //=== NEEDBITS(16);
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
          state.check = 0/*crc32(0L, Z_NULL, 0)*/;
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//

          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          state.mode = FLAGS;
          break;
        }
        state.flags = 0;           /* expect zlib header */
        if (state.head) {
          state.head.done = false;
        }
        if (!(state.wrap & 1) ||   /* check if zlib header allowed */
          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }
        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
        len = (hold & 0x0f)/*BITS(4)*/ + 8;
        if (state.wbits === 0) {
          state.wbits = len;
        }
        else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }
        state.dmax = 1 << len;
        //Tracev((stderr, "inflate:   zlib header ok\n"));
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = hold & 0x200 ? DICTID : TYPE;
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        break;
      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.flags = hold;
        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }
        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }
        if (state.head) {
          state.head.text = ((hold >> 8) & 1);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = TIME;
        /* falls through */
      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.time = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          hbuf[2] = (hold >>> 16) & 0xff;
          hbuf[3] = (hold >>> 24) & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0);
          //===
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = OS;
        /* falls through */
      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (state.head) {
          state.head.xflags = (hold & 0xff);
          state.head.os = (hold >> 8);
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = EXLEN;
        /* falls through */
      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length = hold;
          if (state.head) {
            state.head.extra_len = hold;
          }
          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = (hold >>> 8) & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0);
            //===//
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        else if (state.head) {
          state.head.extra = null/*Z_NULL*/;
        }
        state.mode = EXTRA;
        /* falls through */
      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;
          if (copy > have) { copy = have; }
          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;
              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }
              utils.arraySet(
                state.head.extra,
                input,
                next,
                // extra field is limited to 65536 bytes
                // - no need for additional size check
                copy,
                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                len
              );
              //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }
            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            state.length -= copy;
          }
          if (state.length) { break inf_leave; }
        }
        state.length = 0;
        state.mode = NAME;
        /* falls through */
      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.name_max*/)) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.name = null;
        }
        state.length = 0;
        state.mode = COMMENT;
        /* falls through */
      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) { break inf_leave; }
          copy = 0;
          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */
            if (state.head && len &&
                (state.length < 65536 /*state.head.comm_max*/)) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);
          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          if (len) { break inf_leave; }
        }
        else if (state.head) {
          state.head.comment = null;
        }
        state.mode = HCRC;
        /* falls through */
      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
        }
        if (state.head) {
          state.head.hcrc = ((state.flags >> 9) & 1);
          state.head.done = true;
        }
        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;
      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        strm.adler = state.check = zswap32(hold);
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = DICT;
        /* falls through */
      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          return Z_NEED_DICT;
        }
        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
        state.mode = TYPE;
        /* falls through */
      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7;
          //---//
          state.mode = CHECK;
          break;
        }
        //=== NEEDBITS(3); */
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.last = (hold & 0x01)/*BITS(1)*/;
        //--- DROPBITS(1) ---//
        hold >>>= 1;
        bits -= 1;
        //---//

        switch ((hold & 0x03)/*BITS(2)*/) {
          case 0:                             /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;
          case 1:                             /* fixed block */
            fixedtables(state);
            //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = LEN_;             /* decode codes */
            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
              break inf_leave;
            }
            break;
          case 2:                             /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;
          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        }
        //--- DROPBITS(2) ---//
        hold >>>= 2;
        bits -= 2;
        //---//
        break;
      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }
        state.length = hold & 0xffff;
        //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = COPY_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case COPY_:
        state.mode = COPY;
        /* falls through */
      case COPY:
        copy = state.length;
        if (copy) {
          if (copy > have) { copy = have; }
          if (copy > left) { copy = left; }
          if (copy === 0) { break inf_leave; }
          //--- zmemcpy(put, next, copy); ---
          utils.arraySet(output, input, next, copy, put);
          //---//
          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        }
        //Tracev((stderr, "inflate:       stored end\n"));
        state.mode = TYPE;
        break;
      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
        //--- DROPBITS(5) ---//
        hold >>>= 5;
        bits -= 5;
        //---//
        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
        //--- DROPBITS(4) ---//
        hold >>>= 4;
        bits -= 4;
        //---//
//#ifndef PKZIP_BUG_WORKAROUND
        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));
        state.have = 0;
        state.mode = LENLENS;
        /* falls through */
      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
          //--- DROPBITS(3) ---//
          hold >>>= 3;
          bits -= 3;
          //---//
        }
        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        }
        // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table
        state.lencode = state.lendyn;
        state.lenbits = 7;

        opts = { bits: state.lenbits };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, "inflate:       code lengths ok\n"));
        state.have = 0;
        state.mode = CODELENS;
        /* falls through */
      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            state.lens[state.have++] = here_val;
          }
          else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }
              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03);//BITS(2);
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2;
              //---//
            }
            else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 3 + (hold & 0x07);//BITS(3);
              //--- DROPBITS(3) ---//
              hold >>>= 3;
              bits -= 3;
              //---//
            }
            else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;
              while (bits < n) {
                if (have === 0) { break inf_leave; }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              //===//
              //--- DROPBITS(here.bits) ---//
              hold >>>= here_bits;
              bits -= here_bits;
              //---//
              len = 0;
              copy = 11 + (hold & 0x7f);//BITS(7);
              //--- DROPBITS(7) ---//
              hold >>>= 7;
              bits -= 7;
              //---//
            }
            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }

        /* handle error breaks in while */
        if (state.mode === BAD) { break; }

        /* check for end-of-block code (better have one) */
        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }

        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */
        state.lenbits = 9;

        opts = { bits: state.lenbits };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.lenbits = opts.bits;
        // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6;
        //state.distcode.copy(state.codes);
        // Switch to use dynamic table
        state.distcode = state.distdyn;
        opts = { bits: state.distbits };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
        // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;
        state.distbits = opts.bits;
        // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        }
        //Tracev((stderr, 'inflate:       codes ok\n'));
        state.mode = LEN_;
        if (flush === Z_TREES) { break inf_leave; }
        /* falls through */
      case LEN_:
        state.mode = LEN;
        /* falls through */
      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits;
          //---
          inflate_fast(strm, _out);
          //--- LOAD() ---
          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits;
          //---

          if (state.mode === TYPE) {
            state.back = -1;
          }
          break;
        }
        state.back = 0;
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.lencode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        state.length = here_val;
        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }
        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }
        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }
        state.extra = here_op & 15;
        state.mode = LENEXT;
        /* falls through */
      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
        //Tracevv((stderr, "inflate:         length %u\n", state.length));
        state.was = state.length;
        state.mode = DIST;
        /* falls through */
      case DIST:
        for (;;) {
          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;
          for (;;) {
            here = state.distcode[last_val +
                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
            here_bits = here >>> 24;
            here_op = (here >>> 16) & 0xff;
            here_val = here & 0xffff;

            if ((last_bits + here_bits) <= bits) { break; }
            //--- PULLBYTE() ---//
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
            //---//
          }
          //--- DROPBITS(last.bits) ---//
          hold >>>= last_bits;
          bits -= last_bits;
          //---//
          state.back += last_bits;
        }
        //--- DROPBITS(here.bits) ---//
        hold >>>= here_bits;
        bits -= here_bits;
        //---//
        state.back += here_bits;
        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }
        state.offset = here_val;
        state.extra = (here_op) & 15;
        state.mode = DISTEXT;
        /* falls through */
      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;
          while (bits < n) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
          //--- DROPBITS(state.extra) ---//
          hold >>>= state.extra;
          bits -= state.extra;
          //---//
          state.back += state.extra;
        }
//#ifdef INFLATE_STRICT
        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        }
//#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
        state.mode = MATCH;
        /* falls through */
      case MATCH:
        if (left === 0) { break inf_leave; }
        copy = _out - left;
        if (state.offset > copy) {         /* copy from window */
          copy = state.offset - copy;
          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            }
// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
          }
          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          }
          else {
            from = state.wnext - copy;
          }
          if (copy > state.length) { copy = state.length; }
          from_source = state.window;
        }
        else {                              /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }
        if (copy > left) { copy = left; }
        left -= copy;
        state.length -= copy;
        do {
          output[put++] = from_source[from++];
        } while (--copy);
        if (state.length === 0) { state.mode = LEN; }
        break;
      case LIT:
        if (left === 0) { break inf_leave; }
        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;
      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            // Use '|' instead of '+' to make sure that result is signed
            hold |= input[next++] << bits;
            bits += 8;
          }
          //===//
          _out -= left;
          strm.total_out += _out;
          state.total += _out;
          if (_out) {
            strm.adler = state.check =
                /*UPDATE(state.check, put - _out, _out);*/
                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));

          }
          _out = left;
          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }
        state.mode = LENGTH;
        /* falls through */
      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) { break inf_leave; }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          //===//
          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          }
          //=== INITBITS();
          hold = 0;
          bits = 0;
          //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }
        state.mode = DONE;
        /* falls through */
      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;
      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;
      case MEM:
        return Z_MEM_ERROR;
      case SYNC:
        /* falls through */
      default:
        return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/


/***/ }),

/***/ "./node_modules/pako/lib/zlib/inftrees.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/inftrees.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/messages.js":
/*!************************************************!*\
  !*** ./node_modules/pako/lib/zlib/messages.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2:      'need dictionary',     /* Z_NEED_DICT       2  */
  1:      'stream end',          /* Z_STREAM_END      1  */
  0:      '',                    /* Z_OK              0  */
  '-1':   'file error',          /* Z_ERRNO         (-1) */
  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */
  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */
  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */
  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */
  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */
};


/***/ }),

/***/ "./node_modules/pako/lib/zlib/trees.js":
/*!*********************************************!*\
  !*** ./node_modules/pako/lib/zlib/trees.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

var utils = __webpack_require__(/*! ../utils/common */ "./node_modules/pako/lib/utils/common.js");

/* Public constants ==========================================================*/
/* ===========================================================================*/


//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;
var Z_FIXED               = 4;
//var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */
var Z_BINARY              = 0;
var Z_TEXT                = 1;
//var Z_ASCII             = 1; // = Z_TEXT
var Z_UNKNOWN             = 2;

/*============================================================================*/


function zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }

// From zutil.h

var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES    = 2;
/* The three kinds of block type */

var MIN_MATCH    = 3;
var MAX_MATCH    = 258;
/* The minimum and maximum match lengths */

// From deflate.h
/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES  = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS      = 256;
/* number of literal bytes 0..255 */

var L_CODES       = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES       = 30;
/* number of distance codes */

var BL_CODES      = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE     = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS      = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size      = 16;
/* size of bit buffer in bi_buf */


/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK   = 256;
/* end of block literal code */

var REP_3_6     = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10   = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */
var extra_lbits =   /* extra bits for each length code */
  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];

var extra_dbits =   /* extra bits for each distance code */
  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];

var extra_blbits =  /* extra bits for each bit length code */
  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];

var bl_order =
  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512; /* see definition of array dist_code below */

// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1
var static_ltree  = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree  = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code    = new Array(DIST_CODE_LEN);
zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);
zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length   = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist     = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */


function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {

  this.static_tree  = static_tree;  /* static tree or NULL */
  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */
  this.extra_base   = extra_base;   /* base index for extra_bits */
  this.elems        = elems;        /* max number of elements in the tree */
  this.max_length   = max_length;   /* max bit length for the codes */

  // show if `static_tree` has data or dummy - needed for monomorphic objects
  this.has_stree    = static_tree && static_tree.length;
}


var static_l_desc;
var static_d_desc;
var static_bl_desc;


function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;     /* the dynamic tree */
  this.max_code = 0;            /* largest code with non zero frequency */
  this.stat_desc = stat_desc;   /* the corresponding static tree */
}



function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}


/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
function put_short(s, w) {
//    put_byte(s, (uch)((w) & 0xff));
//    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = (w) & 0xff;
  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;
}


/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
function send_bits(s, value, length) {
  if (s.bi_valid > (Buf_size - length)) {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> (Buf_size - s.bi_valid);
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= (value << s.bi_valid) & 0xffff;
    s.bi_valid += length;
  }
}


function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);
}


/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
function bi_reverse(code, len) {
  var res = 0;
  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}


/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;

  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}


/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
function gen_bitlen(s, desc)
//    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree            = desc.dyn_tree;
  var max_code        = desc.max_code;
  var stree           = desc.stat_desc.static_tree;
  var has_stree       = desc.stat_desc.has_stree;
  var extra           = desc.stat_desc.extra_bits;
  var base            = desc.stat_desc.extra_base;
  var max_length      = desc.stat_desc.max_length;
  var h;              /* heap index */
  var n, m;           /* iterate over the tree elements */
  var bits;           /* bit length */
  var xbits;          /* extra bits */
  var f;              /* frequency */
  var overflow = 0;   /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }

  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */
  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1]/*.Len*/ = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) { continue; } /* not a leaf node */

    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2]/*.Freq*/;
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);
    }
  }
  if (overflow === 0) { return; }

  // Trace((stderr,"\nbit length overflow\n"));
  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) { bits--; }
    s.bl_count[bits]--;      /* move one leaf down the tree */
    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */
    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */
    overflow -= 2;
  } while (overflow > 0);

  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) { continue; }
      if (tree[m * 2 + 1]/*.Len*/ !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;
        tree[m * 2 + 1]/*.Len*/ = bits;
      }
      n--;
    }
  }
}


/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
function gen_codes(tree, max_code, bl_count)
//    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */
  var code = 0;              /* running code value */
  var bits;                  /* bit index */
  var n;                     /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

  for (n = 0;  n <= max_code; n++) {
    var len = tree[n * 2 + 1]/*.Len*/;
    if (len === 0) { continue; }
    /* Now reverse the bits */
    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);

    //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}


/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
function tr_static_init() {
  var n;        /* iterates over tree elements */
  var bits;     /* bit counter */
  var length;   /* length value */
  var code;     /* code value */
  var dist;     /* distance index */
  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */

  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */
/*#ifdef NO_INIT_GLOBAL_POINTERS
  static_l_desc.static_tree = static_ltree;
  static_l_desc.extra_bits = extra_lbits;
  static_d_desc.static_tree = static_dtree;
  static_d_desc.extra_bits = extra_dbits;
  static_bl_desc.extra_bits = extra_blbits;
#endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */
  length = 0;
  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;
    for (n = 0; n < (1 << extra_lbits[code]); n++) {
      _length_code[length++] = code;
    }
  }
  //Assert (length == 256, "tr_static_init: length != 256");
  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */
  _length_code[length - 1] = code;

  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
  dist = 0;
  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;
    for (n = 0; n < (1 << extra_dbits[code]); n++) {
      _dist_code[dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: dist != 256");
  dist >>= 7; /* from now on, all distances are divided by 128 */
  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;
    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {
      _dist_code[256 + dist++] = code;
    }
  }
  //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1]/*.Len*/ = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1]/*.Len*/ = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1]/*.Len*/ = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */
  gen_codes(static_ltree, L_CODES + 1, bl_count);

  /* The static distance tree is trivial: */
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]/*.Len*/ = 5;
    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);
  }

  // Now data ready and we can init static trees
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);

  //static_init_done = true;
}


/* ===========================================================================
 * Initialize a new block.
 */
function init_block(s) {
  var n; /* iterates over tree elements */

  /* Initialize the trees. */
  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }
  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }

  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}


/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
function bi_windup(s)
{
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
function copy_block(s, buf, len, header)
//DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);        /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
//  while (len--) {
//    put_byte(s, *buf++);
//  }
  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||
         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));
}

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
function pqdownheap(s, tree, k)
//    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;  /* left son of k */
  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len &&
      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */
    if (smaller(tree, v, s.heap[j], s.depth)) { break; }

    /* Exchange v with the smallest son */
    s.heap[k] = s.heap[j];
    k = j;

    /* And continue down the tree, setting j to the left son of k */
    j <<= 1;
  }
  s.heap[k] = v;
}


// inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
function compress_block(s, ltree, dtree)
//    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;           /* distance of matched string */
  var lc;             /* match length or unmatched char (if dist == 0) */
  var lx = 0;         /* running index in l_buf */
  var code;           /* the code to send */
  var extra;          /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree); /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree); /* send the length code */
        extra = extra_lbits[code];
        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);       /* send the extra length bits */
        }
        dist--; /* dist is now the match distance - 1 */
        code = d_code(dist);
        //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);       /* send the distance code */
        extra = extra_dbits[code];
        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);   /* send the extra distance bits */
        }
      } /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}


/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
function build_tree(s, desc)
//    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree     = desc.dyn_tree;
  var stree    = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems    = desc.stat_desc.elems;
  var n, m;          /* iterate over heap elements */
  var max_code = -1; /* largest code with non zero frequency */
  var node;          /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]/*.Freq*/ !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;

    } else {
      tree[n * 2 + 1]/*.Len*/ = 0;
    }
  }

  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
    tree[node * 2]/*.Freq*/ = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]/*.Len*/;
    }
    /* node is 0 or 1 so it does not have extra bits */
  }
  desc.max_code = max_code;

  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */
  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }

  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */
  node = elems;              /* next internal node of the tree */
  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */
    /*** pqremove ***/
    n = s.heap[1/*SMALLEST*/];
    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1/*SMALLEST*/);
    /***/

    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */

    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */
    s.heap[--s.heap_max] = m;

    /* Create a new node father of n and m */
    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;

    /* and insert the new node in the heap */
    s.heap[1/*SMALLEST*/] = node++;
    pqdownheap(s, tree, 1/*SMALLEST*/);

  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];

  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */
  gen_bitlen(s, desc);

  /* The field len is now set, we can generate the bit codes */
  gen_codes(tree, max_code, s.bl_count);
}


/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
function scan_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      s.bl_tree[curlen * 2]/*.Freq*/ += count;

    } else if (curlen !== 0) {

      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }
      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;

    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;

    } else {
      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
function send_tree(s, tree, max_code)
//    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;                     /* iterates over all tree elements */
  var prevlen = -1;          /* last emitted length */
  var curlen;                /* length of current code */

  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */

  var count = 0;             /* repeat count of the current code */
  var max_count = 7;         /* max repeat count */
  var min_count = 4;         /* min repeat count */

  /* tree[max_code+1].Len = -1; */  /* guard already set */
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;

    if (++count < max_count && curlen === nextlen) {
      continue;

    } else if (count < min_count) {
      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);

    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      //Assert(count >= 3 && count <= 6, " 3_6?");
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);

    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);

    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;

    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;

    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}


/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
function build_bl_tree(s) {
  var max_blindex;  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);

  /* Build the bit length tree: */
  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}


/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
function send_all_trees(s, lcodes, dcodes, blcodes)
//    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;                    /* index in bl_order */

  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));
  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */
  send_bits(s, dcodes - 1,   5);
  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */
  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);
  }
  //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}


/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */
function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;

  /* Check for non-textual ("black-listed") bytes. */
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {
      return Z_BINARY;
    }
  }

  /* Check for textual ("white-listed") bytes. */
  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||
      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {
      return Z_TEXT;
    }
  }

  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */
  return Z_BINARY;
}


var static_init_done = false;

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
function _tr_init(s)
{

  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);

  s.bi_buf = 0;
  s.bi_valid = 0;

  /* Initialize the first block of the first file: */
  init_block(s);
}


/* ===========================================================================
 * Send a stored block
 */
function _tr_stored_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */
  copy_block(s, buf, stored_len, true); /* with header */
}


/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}


/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
function _tr_flush_block(s, buf, stored_len, last)
//DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */
  var max_blindex = 0;        /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */
  if (s.level > 0) {

    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }

    /* Construct the literal and distance trees */
    build_tree(s, s.l_desc);
    // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc);
    // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));
    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */
    max_blindex = build_bl_tree(s);

    /* Determine the best encoding. Compute the block lengths in bytes. */
    opt_lenb = (s.opt_len + 3 + 7) >>> 3;
    static_lenb = (s.static_len + 3 + 7) >>> 3;

    // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }

  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
  }

  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);

  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {

    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);

  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");
  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */
  init_block(s);

  if (last) {
    bi_windup(s);
  }
  // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
function _tr_tally(s, dist, lc)
//    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;

  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;

  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2]/*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */
    dist--;             /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;
  }

// (!) This block is disabled in zlib defaults,
// don't enable it for binary compatibility

//#ifdef TRUNCATE_BLOCK
//  /* Try to guess if it is profitable to stop the current block here */
//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
//    /* Compute an upper bound for the compressed length */
//    out_length = s.last_lit*8;
//    in_length = s.strstart - s.block_start;
//
//    for (dcode = 0; dcode < D_CODES; dcode++) {
//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
//    }
//    out_length >>>= 3;
//    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
//    //       s->last_lit, in_length, out_length,
//    //       100L - out_length*100L/in_length));
//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
//      return true;
//    }
//  }
//#endif

  return (s.last_lit === s.lit_bufsize - 1);
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init  = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block  = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;


/***/ }),

/***/ "./node_modules/pako/lib/zlib/zstream.js":
/*!***********************************************!*\
  !*** ./node_modules/pako/lib/zlib/zstream.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}

module.exports = ZStream;


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/pseudomap/map.js":
/*!***************************************!*\
  !*** ./node_modules/pseudomap/map.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {if (process.env.npm_package_name === 'pseudomap' &&
    process.env.npm_lifecycle_script === 'test')
  process.env.TEST_PSEUDOMAP = 'true'

if (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {
  module.exports = Map
} else {
  module.exports = __webpack_require__(/*! ./pseudomap */ "./node_modules/pseudomap/pseudomap.js")
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/pseudomap/pseudomap.js":
/*!*********************************************!*\
  !*** ./node_modules/pseudomap/pseudomap.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = Object.prototype.hasOwnProperty

module.exports = PseudoMap

function PseudoMap (set) {
  if (!(this instanceof PseudoMap)) // whyyyyyyy
    throw new TypeError("Constructor PseudoMap requires 'new'")

  this.clear()

  if (set) {
    if ((set instanceof PseudoMap) ||
        (typeof Map === 'function' && set instanceof Map))
      set.forEach(function (value, key) {
        this.set(key, value)
      }, this)
    else if (Array.isArray(set))
      set.forEach(function (kv) {
        this.set(kv[0], kv[1])
      }, this)
    else
      throw new TypeError('invalid argument')
  }
}

PseudoMap.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  Object.keys(this._data).forEach(function (k) {
    if (k !== 'size')
      fn.call(thisp, this._data[k].value, this._data[k].key)
  }, this)
}

PseudoMap.prototype.has = function (k) {
  return !!find(this._data, k)
}

PseudoMap.prototype.get = function (k) {
  var res = find(this._data, k)
  return res && res.value
}

PseudoMap.prototype.set = function (k, v) {
  set(this._data, k, v)
}

PseudoMap.prototype.delete = function (k) {
  var res = find(this._data, k)
  if (res) {
    delete this._data[res._index]
    this._data.size--
  }
}

PseudoMap.prototype.clear = function () {
  var data = Object.create(null)
  data.size = 0

  Object.defineProperty(this, '_data', {
    value: data,
    enumerable: false,
    configurable: true,
    writable: false
  })
}

Object.defineProperty(PseudoMap.prototype, 'size', {
  get: function () {
    return this._data.size
  },
  set: function (n) {},
  enumerable: true,
  configurable: true
})

PseudoMap.prototype.values =
PseudoMap.prototype.keys =
PseudoMap.prototype.entries = function () {
  throw new Error('iterators are not implemented in this version')
}

// Either identical, or both NaN
function same (a, b) {
  return a === b || a !== a && b !== b
}

function Entry (k, v, i) {
  this.key = k
  this.value = v
  this._index = i
}

function find (data, k) {
  for (var i = 0, s = '_' + k, key = s;
       hasOwnProperty.call(data, key);
       key = s + i++) {
    if (same(data[key].key, k))
      return data[key]
  }
}

function set (data, k, v) {
  for (var i = 0, s = '_' + k, key = s;
       hasOwnProperty.call(data, key);
       key = s + i++) {
    if (same(data[key].key, k)) {
      data[key].value = v
      return
    }
  }
  data.size++
  data[key] = new Entry(k, v, key)
}


/***/ }),

/***/ "./node_modules/util/support/isBufferBrowser.js":
/*!******************************************************!*\
  !*** ./node_modules/util/support/isBufferBrowser.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}

/***/ }),

/***/ "./node_modules/util/util.js":
/*!***********************************!*\
  !*** ./node_modules/util/util.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = __webpack_require__(/*! ./support/isBuffer */ "./node_modules/util/support/isBufferBrowser.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/worker-loader/dist/workers/InlineWorker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string

var URL = window.URL || window.webkitURL;

module.exports = function (content, url) {
  try {
    try {
      var blob;

      try {
        // BlobBuilder = Deprecated, but widely implemented
        var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;

        blob = new BlobBuilder();

        blob.append(content);

        blob = blob.getBlob();
      } catch (e) {
        // The proposed API
        blob = new Blob([content]);
      }

      return new Worker(URL.createObjectURL(blob));
    } catch (e) {
      return new Worker('data:application/javascript,' + encodeURIComponent(content));
    }
  } catch (e) {
    if (!url) {
      throw Error('Inline worker is not supported');
    }

    return new Worker(url);
  }
};

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: name, version, sideEffects, description, repository, author, contributors, license, files, dependencies, devDependencies, main, scripts, browserslist, previousMapboxGLVersions, default */
/***/ (function(module) {

module.exports = {"name":"@carto/carto-vl","version":"1.4.6","sideEffects":false,"description":"CARTO Vector library","repository":{"type":"git","url":"git://github.com/CartoDB/carto-vl.git"},"author":{"name":"CARTO","url":"https://carto.com/"},"contributors":["David Manzanares <dmanzanares@carto.com>","Iago Lastra <iago@carto.com>","Jess Arroyo Torrens <jarroyo@carto.com>","Javier Goizueta <jgoizueta@carto.com>","Mamata Akella <makella@carto.com>","Ral Ochoa <rochoa@carto.com>","Ariana Escobar <ariana@carto.com>","Elena Torro <elena@carto.com>","Vctor Velarde <victor@carto.com>","Jess Botella <jbotella@carto.com>"],"license":"BSD-3-Clause","files":["src","dist"],"dependencies":{"@babel/runtime":"^7.0.0","@mapbox/vector-tile":"^1.3.0","base64-arraybuffer":"^0.2.0","cartocolor":"^4.0.0","earcut":"^2.1.2","gl-matrix":"^2.8.1","jsep":"CartoDB/jsep#additional-char-ids-packaged-update-1","lineclip":"^1.1.5","lru-cache":"^4.1.1","mitt":"^1.1.3","pako":"^1.0.11","pbf":"^3.1.0"},"devDependencies":{"@babel/core":"^7.0.0","@babel/plugin-transform-runtime":"^7.1.0","@babel/preset-env":"^7.0.0","aws-sdk":"^2.372.0","babel-loader":"^8.0.0","chai":"^4.1.2","chai-as-promised":"^7.1.1","current-git-branch":"^1.1.0","eslint":"^5.7.0","eslint-config-semistandard":"^12.0.1","eslint-config-standard":"^12.0.0","eslint-plugin-import":"^2.13.0","eslint-plugin-node":"^7.0.1","eslint-plugin-promise":"^4.0.1","eslint-plugin-standard":"^4.0.0","exquisite-sst":"^1.6.0","fastly":"^2.2.0","glob":"^7.1.2","http-server":"^0.11.1","jasmine-core":"^3.2.1","jsdoc":"^3.5.5","jsdoc-escape-at":"^1.0.1","karma":"^3.0.0","karma-chrome-launcher":"^2.2.0","karma-falcon-benchmark":"^0.1.1-0","karma-falcon-benchmark-reporter":"^0.1.1-0","karma-jasmine":"^1.1.2","karma-mocha-reporter":"^2.2.5","karma-sourcemap-loader":"^0.3.7","karma-webpack":"^3.0.5","lodash.template":"^4.4.0","mapbox-gl":"1.0.0","mocha":"^5.0.0","puppeteer":"^1.1.0","selenium-webdriver":"3.6.0","serve":"^10.0.2","sloc":"^0.2.0","svg-inline-loader":"^0.8.0","wait-on":"^3.1.0","webpack":"^4.17.1","webpack-bundle-analyzer":"^3.0.3","webpack-cli":"^3.1.1","webpack-glsl-loader":"^1.0.1","worker-loader":"^2.0.0"},"main":"dist/carto-vl.min.js","scripts":{"build":"yarn build:clean && yarn build:dev && yarn build:min","build:clean":"rm -rf dist/","build:dev":"webpack --config webpack/webpack.config.js","build:min":"webpack --config webpack/webpack.min.config.js","build:min:stats":"webpack --config webpack/webpack.min.config.js --profile --json > dist/stats.json && webpack-bundle-analyzer --port 4200 dist/stats.json","build:watch":"webpack -w --config webpack/webpack.config.js","docs":"rm -rf docs/public; jsdoc --configure config/jsdoc/public-conf.json","docs:all":"rm -rf docs/all; jsdoc --configure config/jsdoc/all-conf.json","lint":"eslint .","lint:fix":"eslint . --fix","test":"yarn test:unit && yarn lint && yarn docs","test:unit":"karma start --single-run --browsers ChromeHeadlessNoSandbox test/unit/karma.conf.js","test:unit:min":"MIN=1 yarn test:unit","test:watch":"karma start --no-single-run --auto-watch --browsers ChromeHeadlessNoSandbox test/unit/karma.conf.js","test:watchc":"karma start --no-single-run --auto-watch --browsers Chrome test/unit/karma.conf.js","test:user":"karma start --single-run --browsers ChromeHeadlessNoSandbox test/integration/user/karma.conf.js","test:user:min":"MIN=1 yarn test:user","test:user:watch":"karma start --no-single-run --auto-watch --browsers ChromeHeadlessNoSandbox test/integration/user/karma.conf.js","test:user:watchc":"karma start --no-single-run --browsers Chrome test/integration/user/karma.conf.js","test:browser":"karma start --no-single-run --browsers Chrome test/unit/karma.conf.js","test:browsers:connect":"sc -u $SAUCELABS_USER -k $SAUCELABS_KEY -i cartovl-tunnel --no-autodetect","test:browsers:compatibility":"./scripts/run-cross-browser-tests.sh","test:render":"yarn build:clean && yarn build:dev && mocha test/integration/render/render.test.js --timeout 15000","test:render:min":"yarn build:clean && yarn build:min && MIN=1 mocha test/integration/render/render.test.js --timeout 15000","test:render:clean":"rm -rf test/integration/render/scenarios/**/**/reference.png","test:render:prepare":"yarn build:clean && yarn build:dev && node test/integration/render/render.prepare.js ","test:e2e":"./scripts/run-local-e2e.sh","test:e2e:clean":"rm -rf test/acceptance/e2e/**/reference.png","test:e2e:prepare":"yarn build:clean && yarn build:dev && node test/acceptance/e2e.prepare.js ","test:fps":"node test/benchmark/fps/benchmark.js","test:perf":"karma start --single-run --browsers Chrome test/benchmark/karma.conf.js","serve":"yarn build && yarn docs && http-server --cors -p 8080","preversion":"./scripts/preversion.sh","postversion":"git push origin HEAD --follow-tags","prepublishOnly":"yarn build && ./scripts/release.sh","cdn:branch:publish":"yarn build && ./scripts/publish-branch.sh","ghpublish":"git checkout gh-pages && git pull origin gh-pages && git merge master && yarn build && yarn docs && git commit -a -m \"Auto generated gh-pages\" && git push origin gh-pages && git checkout master","loc":"sloc src/ examples/"},"browserslist":["defaults","not ie <12","not edge <17"],"previousMapboxGLVersions":["v0.53.1","v0.54.0"]};

/***/ }),

/***/ "./src/Layer.js":
/*!**********************!*\
  !*** ./src/Layer.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Layer; });
/* harmony import */ var mitt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mitt */ "./node_modules/mitt/dist/mitt.es.js");
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/util */ "./src/utils/util.js");
/* harmony import */ var _Viz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Viz */ "./src/Viz.js");
/* harmony import */ var _sources_Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sources/Base */ "./src/sources/Base.js");
/* harmony import */ var _renderer_Renderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./renderer/Renderer */ "./src/renderer/Renderer.js");
/* harmony import */ var _renderer_RenderLayer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./renderer/RenderLayer */ "./src/renderer/RenderLayer.js");
/* harmony import */ var _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../src/errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _src_errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../src/errors/carto-runtime-error */ "./src/errors/carto-runtime-error.js");
/* harmony import */ var _renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./renderer/viz/expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/lib/gl-matrix.js");
/* harmony import */ var _LayerConcurrencyHelper__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./LayerConcurrencyHelper */ "./src/LayerConcurrencyHelper.js");














// There is one renderer per map, so the layers added to the same map
// use the same renderer with each renderLayer
const renderers = new WeakMap();

const states = Object.freeze({
    INIT: 'init', // Initial state until the Source is rendered for the first time
    IDLE: 'idle', // The Source has been rendered for the first time already, but there are no scheduled updates
    UPDATING: 'updating' // The Source has been rendered for the first time already and there is a scheduled update
});

/**
*
* A Layer is the primary way to visualize geospatial data.
*
* To create a layer a {@link carto.source|source} and {@link carto.Viz|viz} are required:
*
* - The {@link carto.source|source} is used to know **what** data will be displayed in the Layer.
* - The {@link carto.Viz|viz} is used to know **how** to draw the data in the Layer, Viz instances can only be bound to one single layer.
*
* Note: This Layer implements {@link https://www.mapbox.com/mapbox-gl-js/api/#customlayerinterface|Mapbox GL JS - Custom Layer Interface}
*
* @param {String} id - The ID of the layer. Can be used in the {@link addTo|addTo} function
* @param {carto.source} source - The source of the data
* @param {carto.Viz} viz - The description of the visualization of the data
* @throws CartoError
*
* @example
* const layer = new carto.Layer('layer0', source, viz);
*
* @constructor Layer
* @name carto.Layer
* @api
*/

class Layer {
    constructor (id, source, viz) {
        this._checkId(id);
        this._checkSource(source);
        this._checkViz(viz);

        /* Mapbox GL Custom Layer API attributes:
          - id: string
          - type: "custom"
        */
        this.id = id;
        this.type = 'custom';

        viz._boundLayer = this;

        this._context = new Promise(resolve => {
            this._contextInitialize = resolve;
        });

        this._state = states.INIT;
        this._visible = true;
        this._emitter = Object(mitt__WEBPACK_IMPORTED_MODULE_0__["default"])();
        this._renderLayer = new _renderer_RenderLayer__WEBPACK_IMPORTED_MODULE_5__["default"]();

        this.concurrencyHelper = new _LayerConcurrencyHelper__WEBPACK_IMPORTED_MODULE_10__["default"]();
        this._initialSource = source;
        this._initialViz = viz;
        this._renderWaiters = [];
        this._cameraMatrix = gl_matrix__WEBPACK_IMPORTED_MODULE_9__["mat4"].identity([]);

        this._updateLayer = this.update(source, viz);
        this._map_init = false;
    }

    /**
     * Layer visibility property.
     *
     * @type {boolean}
     * @memberof carto.Layer
     * @instance
     * @api
     */
    get visible () {
        return this._visible;
    }

    set visible (visible) {
        const initial = this._visible;
        this.map.setLayoutProperty(this.id, 'visibility', visible ? 'visible' : 'none');
        this._visible = visible;
        if (visible !== initial) {
            this._fire('updated', 'visibility change');
        }
    }

    /**
     * Change layer visibility to visible
     *
     * @memberof carto.Layer
     * @instance
     * @api
     * @fires updated
     */
    show () {
        this.visible = true;
    }

    /**
     * Change layer visibility to hidden
     *
     * @memberof carto.Layer
     * @instance
     * @api
     * @fires updated
     */
    hide () {
        this.visible = false;
    }

    /**
     * Register an event handler for the given event name.
     *
     * @param {String} eventName - Type of event to listen for. Valid names are: `loaded`, `updated`, and `removed`.
     * @param {function} callback - Function to call in response to given event
     * @memberof carto.Layer
     * @instance
     * @api
     */
    on (eventName, callback) {
        return this._emitter.on(eventName, callback);
    }

    /**
     * Remove an event handler for the given type.
     *
     * @param {String} eventName - Type of event to unregister. Valid names are: `loaded`, `updated`, and `removed`.
     * @param {function} callback - Handler function to unregister
     * @memberof carto.Layer
     * @instance
     * @api
     */
    off (eventName, callback) {
        return this._emitter.off(eventName, callback);
    }

    /**
     * Add this layer to a map. If the map's style is not loaded yet it will wait for it to add the layer as soon as possible.
     *
     * @param {mapboxgl.Map} map - The map on which to add the layer
     * @param {string?} beforeLayerID - The ID of an existing layer to insert the new layer before. If this values is not passed the layer will be added on the top of the existing layers.
     * @memberof carto.Layer
     * @instance
     * @api
     */
    async addTo (map, beforeLayerID) {
        // Manage errors, whether they are an Evented Error or a common Error
        try {
            map.once('error', (data) => {
                console.warn(data.error.message);
                this._waitForMapToLoad(map, beforeLayerID);
            });
            map.addLayer(this, beforeLayerID);
        } catch (error) {
            const STYLE_ERROR_REGEX = /Style is not done loading/;
            const NO_STYLE_AT_ALL = /Cannot read property 'addLayer' of undefined/;
            if (!(STYLE_ERROR_REGEX.test(error) || NO_STYLE_AT_ALL.test(error))) {
                throw new _src_errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_7__["default"](`Error adding layer to map: ${error}`);
            }
            this._waitForMapToLoad(map, beforeLayerID);
        }
    }

    _waitForMapToLoad (map, beforeLayerID) {
        map.on('load', () => {
            map.addLayer(this, beforeLayerID);
        });
    }

    /**
     * Remove this layer from the map. It should be called after the layer is loaded. Otherwise, it will not delete the layer.
     *
     * @memberof carto.Layer
     * @instance
     * @api
     */
    remove () {
        if (this.map) {
            this.map.removeLayer(this.id);
        }
    }

    /**
     * Update the layer with a new Source and a new Viz object, replacing the current ones. The update is done atomically, i.e.:
     * the viz will be changed with the source, not before it.
     *
     * This method will return a promise that will be resolved once the source and the visualization are validated.
     *
     * The promise will be rejected if the validation fails, for example
     * because the visualization expects a property name that is not present in the source.
     *
     * The promise will be rejected also if this method is invoked again before the first promise is resolved.
     * If the promise is rejected the layer's source and viz won't be changed by this call.
     *
     * Concurrent calls to `blendToViz` or `blendTo` won't override calls to update (like calls to `update` do).
     *
     * @param {carto.source} source - The new Source object.
     * @param {carto.Viz?} viz - Optional. The new Viz object. Defaults to the current viz.
     * @memberof carto.Layer
     * @instance
     * @async
     * @api
     */
    async update (source, viz = this._viz) {
        return this._update(source, viz, true);
    }

    async _update (source, viz, majorChange) {
        this._checkSource(source);
        this._checkViz(viz);

        const safeSource = this._cloneSourceIfDifferent(source);

        let change = this._initChange(majorChange);
        const [, metadata] = await Promise.all([
            viz.loadImages(), // start requesting images ASAP
            safeSource.requestMetadata(viz)
        ]);
        await this._context;

        // Set center from tileset metadata
        if (!this._map_init && safeSource._tilesetMetadata && safeSource._tilesetMetadata.center) {
            this._map_init = true;
            const center = safeSource._tilesetMetadata.center;
            this.map.setZoom(center.zoom);
            this.map.setCenter([center.longitude, center.latitude]);
        }

        this._endChange(majorChange, change);

        this._commitSuccesfulUpdate(metadata, viz, safeSource);
    }

    _initChange (majorChange) {
        if (majorChange) {
            return this.concurrencyHelper.initMajorChange();
        }
        return this.concurrencyHelper.initMinorChange();
    }

    _endChange (majorChange, change) {
        if (majorChange) {
            this.concurrencyHelper.endMajorChange(change);
        } else {
            this.concurrencyHelper.endMinorChange(change);
        }
    }

    /**
     * Updating viz and source, after having checked them and having required new metadata
     *
     * @param {Metadata} metadata
     * @param {carto.Viz} newViz
     * @param {carto.source} newSource
     */
    _commitSuccesfulUpdate (metadata, newViz, newSource) {
        this.metadata = metadata;

        this._commitVizChange(newViz);
        this._commitSourceChange(newSource);

        // to force pre-render (which gives us the matrix to request data from the source...)
        this._needRefresh();
    }

    /**
     * Updates the viz with the newViz
     *
     * @param {carto.Viz} newViz
     */
    _commitVizChange (newViz) {
        if (this._viz) {
            this._viz.onChange(null);
        }
        newViz.setDefaultsIfRequired(this.metadata.geomType);
        newViz.setDefaultsIfRequired(this._renderLayer.type);
        newViz.onChange(this._vizChanged.bind(this));
        newViz._bindMetadata(this.metadata);
        newViz.gl = this.gl;
        this._viz = newViz;
    }

    /**
     * Updates the source with the newSource
     *
     * @param {carto.source} newSource
     */
    _commitSourceChange (newSource) {
        newSource.bindLayer(this._onDataframeAdded.bind(this));
        if (newSource !== this._source) {
            this._freeSource();
        }
        this._source = newSource;
    }

    /**
     * Returns a safe source from the new required source.
     *
     * @param {carto.source} source
     * @returns {carto.source} safeSource
     */
    _cloneSourceIfDifferent (source) {
        // The cloning allows the source to be safely used in other layers.
        // That's because using `source.requestMetadata()` can update later on its internal state (depending on what's required by the viz)

        let safeSource;
        if (source !== this._source) {
            safeSource = source._clone();
        } else {
            safeSource = source;
        }
        return safeSource;
    }

    /**
     * Blend the current viz with another viz.
     *
     * This allows smooth transitions between two different Vizs.
     *
     * Blending won't be performed when convenient for the attached Source. This
     * happens with Maps API sources when the new Viz uses a different set of properties or
     * aggregations. In these cases a hard transition will be used instead.
     *
     * This method returns a promise that will be resolved if validations passed.
     *
     * The promise will be rejected if the validation fails, for example
     * because the visualization expects a property name that is not present in the source.
     *
     * The promise will be rejected also if this method is invoked again before the first promise is resolved.
     * If the promise is rejected the layer's viz won't be changed by this call.
     *
     * Concurrent calls to `update` will override the effects of `blendToViz`:
     * if a call to `blendToViz` is performed after a call to `update`, but the `update` hasn't been resolved yet,
     * the call to `update` will override the call to `blendToViz` is it resolves.
     *
     * @example <caption> Smooth transition variating point size </caption>
     * // We create two different vizs varying the width
     * const viz0 = new carto.Viz({ width: 10 });
     * const viz1 = new carto.Viz({ width: 20 });
     * // Create a layer with the first viz
     * const layer = new carto.Layer('layer', source, viz0);
     * // We add the layer to the map, the points in this layer will have widh 10
     * layer.addTo(map, 'layer0');
     * // The points will be animated from 10px to 20px for 500ms.
     * layer.blendToViz(viz1, 500);
     *
     * @param {carto.Viz} viz - The final viz
     * @param {number} [duration=400] - The animation duration in milliseconds
     *
     * @memberof carto.Layer
     * @instance
     * @async
     * @api
     */
    async blendToViz (viz, ms = 400, interpolator = _renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_8__["cubic"]) {
        this._checkViz(viz);
        await this._updateLayer;

        // It doesn't make sense to blendTo if a new request is required
        if (this._viz && !this._source.requiresNewMetadata(viz)) {
            Object.keys(this._viz.variables).map(varName => {
                viz.variables[varName] = this._viz.variables[varName];
            });

            viz.color._blendFrom(this._viz.color, ms, interpolator);
            viz.strokeColor._blendFrom(this._viz.strokeColor, ms, interpolator);
            viz.width._blendFrom(this._viz.width, ms, interpolator);
            viz.strokeWidth._blendFrom(this._viz.strokeWidth, ms, interpolator);
            viz.filter._blendFrom(this._viz.filter, ms, interpolator);
            // FIXME viz.symbol._blendFrom(this._viz.symbol, ms, interpolator);
            // FIXME viz.symbolPlacement._blendFrom(this._viz.symbolPlacement, ms, interpolator);
        }
        return this._update(this._source, viz, false);
    }

    /**
     * Viz attached to this layer.
     *
     * Calls to `blendToViz` and `update` won't update the viz until those calls "commit",
     * having performed and completed all asynchronous necessary sanity checks.
     *
     * @type {carto.Viz}
     * @memberof carto.Layer
     * @readonly
     * @api
     */
    get viz () {
        return this._viz;
    }

    hasDataframes () {
        return this._renderLayer.hasDataframes();
    }

    getNumFeatures () {
        return this._renderLayer.getNumFeatures();
    }

    getFeaturesAtPosition (pos) {
        return this.visible
            ? this._renderLayer.getFeaturesAtPosition(pos).map(this._addLayerIdToFeature.bind(this))
            : [];
    }

    isAnimated () {
        return this._viz && this._viz.isAnimated();
    }

    isPlaying () {
        return this._viz && this._viz.isPlaying();
    }

    /**
     * Custom Layer API: `onAdd` function
     */
    onAdd (map, gl) {
        this.map = map;
        this.gl = gl;
        this.renderer = _getRenderer(map, gl);

        // Initialize render layer
        this._renderLayer.setRenderer(this.renderer);
        this._contextInitialize();
    }

    /**
     * Custom Layer API: `onRemove` function
     */
    onRemove (map, gl) {
        this._fire('removed', this);
    }

    /**
     * Custom Layer API: `prerender` function
     */
    prerender (gl, matrix) {
        const isNewCameraMatrix = this._detectAndSetNewMatrix(matrix);
        if (this._source && this.visible) {
            this._checkSourceRequestsAndFireEvents(isNewCameraMatrix);
        }
    }

    _detectAndSetNewMatrix (newMatrix) {
        const isNewMatrix = !gl_matrix__WEBPACK_IMPORTED_MODULE_9__["mat4"].exactEquals(newMatrix, this._cameraMatrix);
        if (isNewMatrix) {
            this._cameraMatrix = newMatrix;
            this.renderer.matrix = newMatrix; // in case it is not set yet (first layer)
        }
        return isNewMatrix;
    }

    _checkSourceRequestsAndFireEvents (isNewMatrix) {
        const checkForDataframesUpdate = this._source.requestData(this._getZoom(), this._getViewport());

        checkForDataframesUpdate.then(dataframesHaveChanged => {
            if (dataframesHaveChanged) {
                this._needRefresh().then(() => {
                    if (this._state === states.INIT) {
                        this._state = states.IDLE;
                        this._fire('loaded');
                    }
                    this._fire('updated', 'different dataframes required from source');
                });
            } else {
                if (isNewMatrix) {
                    this._fire('updated', 'new camara view');
                }
            }
        });
    }

    _getViewport () {
        return Object(_utils_util__WEBPACK_IMPORTED_MODULE_1__["computeViewportFromCameraMatrix"])(this._cameraMatrix);
    }

    /**
     * Custom Layer API: `render` function
     */
    render (gl, matrix) {
        this._paintLayer();

        this._renderWaiters.forEach(resolve => resolve());

        if (this.isAnimated()) {
            if (this.isPlaying()) {
                this._needRefresh().then(() => {
                    this._fire('updated', 'animation is playing');
                });
            } else {
                this._keepTimestampIfPaused();
            }
        } else {
            if (this._state === states.UPDATING) {
                this._state = states.IDLE;
                this._fire('updated', 'updated viz');
            }
        }
    }

    _keepTimestampIfPaused () {
        let timestamp = this.renderer.timestamp;
        // to avoid 'jumps' after resume playing.
        this._viz._getRootStyleExpressions().forEach(vizExpr => {
            vizExpr._setTimestamp(timestamp);
        });
    }

    _paintLayer () {
        this._renderLayer.setViz(this._viz);
        this.renderer.renderLayer(this._renderLayer, {
            zoomLevel: this.map.getZoom() // for zoom expressions
        });
    }

    _fire (eventType, eventData) {
        // We don't want to fire an event within MGL custom layer callback since an error there
        // would crash MGL renderer
        // We fire the event asynchronously to be safe
        new Promise(resolve => {
            this._emitter.emit(eventType, eventData);
            resolve();
        });
    }

    /**
     * Callback executed when the client adds a new dataframe
     * @param {Dataframe} dataframe
     */
    _onDataframeAdded (dataframe) {
        this._renderLayer.addDataframe(dataframe);
        if (this._viz) {
            this._viz.setDefaultsIfRequired(dataframe.type);
        }
    }

    _needRefresh () {
        if (this._state === states.IDLE) {
            this._state = states.UPDATING;
        }
        return new Promise(resolve => {
            this._renderWaiters.push(resolve);
            this.map.triggerRepaint();
        });
    }

    _addLayerIdToFeature (feature) {
        feature.layerId = this.id;
        return feature;
    }

    async _vizChanged (viz) {
        return this._update(this._source, viz, false);
    }

    _checkId (id) {
        if (id === undefined) {
            throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["default"]('\'id\'', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["CartoValidationErrorTypes"].MISSING_REQUIRED);
        }
        if (!_utils_util__WEBPACK_IMPORTED_MODULE_1__["default"].isString(id)) {
            throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["default"]('\'id\' property must be a string.', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["CartoValidationErrorTypes"].INCORRECT_TYPE);
        }
        if (id === '') {
            throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["default"]('\'id\' property must be not empty.', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["CartoValidationErrorTypes"].INCORRECT_VALUE);
        }
    }

    _checkSource (source) {
        if (source === undefined) {
            throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["default"]('\'source\'', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["CartoValidationErrorTypes"].MISSING_REQUIRED);
        }
        if (!(source instanceof _sources_Base__WEBPACK_IMPORTED_MODULE_3__["default"])) {
            throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["default"]('The given object is not a valid \'source\'. See "carto.source".', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["CartoValidationErrorTypes"].INCORRECT_TYPE);
        }
    }

    _checkViz (viz) {
        if (_utils_util__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(viz)) {
            throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["default"]('\'viz\'', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["CartoValidationErrorTypes"].MISSING_REQUIRED);
        }

        if (!(viz instanceof _Viz__WEBPACK_IMPORTED_MODULE_2__["default"])) {
            throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["default"](
                'The given object is not a valid \'viz\'. See "carto.Viz".',
                _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["CartoValidationErrorTypes"].INCORRECT_TYPE
            );
        }

        if (viz._boundLayer && viz._boundLayer !== this) {
            // Note the required 1 on 1 relationship between layer & viz
            throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["default"](
                'The given Viz object is already bound to another layer. Vizs cannot be shared between different layers.',
                _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["CartoValidationErrorTypes"].INCORRECT_VALUE
            );
        }
    }

    _getZoom () {
        return this.map.getZoom();
    }

    _freeSource () {
        if (this._source) {
            this._source.free();
        }
        this._renderLayer.freeDataframes();
    }
}

function _getRenderer (map, gl) {
    if (!renderers.get(map)) {
        const renderer = new _renderer_Renderer__WEBPACK_IMPORTED_MODULE_4__["default"]();
        renderer.initialize(gl);
        renderers.set(map, renderer);
    }
    return renderers.get(map);
}


/***/ }),

/***/ "./src/LayerConcurrencyHelper.js":
/*!***************************************!*\
  !*** ./src/LayerConcurrencyHelper.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LayerConcurrencyHelper; });
/* harmony import */ var _src_errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../src/errors/carto-runtime-error */ "./src/errors/carto-runtime-error.js");


/**
 * Helper to manage concurrent updates to a Layer.
 *
 * There are 2 type of changes in a layer's source or viz:
 *      - Major changes. Major changes are performed by the `Layer.update` method and they will override (have priority over) minor changes
 *      - Minor changes. Minor changes are performed by the `Layer.blendToViz` and `blendTo` method and they won't override concurrent calls to `Layer.update`
 *
 * @export
 * @class LayerConcurrency
 */
class LayerConcurrencyHelper {
    constructor () {
        this._majorNextUID = 0;
        this._majorCurrentUID = null;
        this._minorNextUID = 0;
        this._minorCurrentUID = null;
    }

    /**
     * Init a Major change
     *
     * @returns {Object} changeUID
     */
    initMajorChange () {
        return this._getChangeUID(true);
    }

    /**
     * Init a Minor change
     *
     * @returns {Object} changeUID
     */
    initMinorChange () {
        return this._getChangeUID(false);
    }

    /**
     * End a Major change, checking previously for concurrency problems
     *
     * @param {Object} changeUID
     */
    endMajorChange (changeUID) {
        this._detectConcurrentChanges(true, changeUID);
        this._setUID(changeUID);
    }

    /**
     * End a Minor change, checking previously for concurrency problems
     *
     * @param {Object} changeUID
     */
    endMinorChange (changeUID) {
        this._detectConcurrentChanges(false, changeUID);
        this._setUID(changeUID);
    }

    /**
     * Get an object with UID counters, that serve as a guard against concurrent changes
     * @param {Boolean} majorChange
     */
    _getChangeUID (majorChange) {
        let uid;
        if (majorChange) {
            uid = { major: this._majorNextUID, minor: 0 };
            this._majorNextUID++;
            this._minorNextUID = 1;
        } else {
            uid = { major: this._majorCurrentUID, minor: this._minorNextUID };
            this._minorNextUID++;
        }
        return uid;
    }

    /**
     * Check against concurrency problems (raise an error if any is found)
     * @param {Boolean} majorChange
     * @param {Object} changeUID
     */
    _detectConcurrentChanges (majorChange, changeUID) {
        if (majorChange) {
            if (this._majorCurrentUID > changeUID.major) {
                throw new _src_errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_0__["default"](`Another \`Layer.update()\` finished before this one:
                 Commit ${changeUID} overridden by commit ${this._majorCurrentUID}.`);
            }
        } else {
            if (this._majorCurrentUID > changeUID.major || (this._majorCurrentUID !== null && changeUID.major === null)) {
                throw new _src_errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_0__["default"](`Another \`Layer.update()\` finished before this viz change:
                 Commit ${changeUID} overridden by commit ${this._majorCurrentUID}.${this._minorCurrentUID}`);
            }
            if (this._minorCurrentUID > changeUID.minor) {
                throw new _src_errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_0__["default"](`Another \`viz change\` finished before this one:
                 Commit ${changeUID.major}.${changeUID.minor} overridden by commit ${this._majorCurrentUID}.${this._minorCurrentUID}`);
            }
        }
    }

    /**
     * Update internal counters
     *
     * @param {Object} changeUID
     */
    _setUID (changeUID) {
        this._majorCurrentUID = changeUID.major;
        this._minorCurrentUID = changeUID.minor;
    }
}


/***/ }),

/***/ "./src/Viz.js":
/*!********************!*\
  !*** ./src/Viz.js ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Viz; });
/* harmony import */ var _renderer_schema__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./renderer/schema */ "./src/renderer/schema.js");
/* harmony import */ var _renderer_shaders_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./renderer/shaders/index */ "./src/renderer/shaders/index.js");
/* harmony import */ var _renderer_shaders_shaderCompiler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderer/shaders/shaderCompiler */ "./src/renderer/shaders/shaderCompiler.js");
/* harmony import */ var _renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderer/viz/expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _renderer_viz_expressions_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./renderer/viz/expressions/base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _renderer_viz_expressions_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./renderer/viz/expressions/utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _renderer_viz_parser__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./renderer/viz/parser */ "./src/renderer/viz/parser.js");
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/util */ "./src/utils/util.js");
/* harmony import */ var _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../src/errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _src_errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../src/errors/carto-runtime-error */ "./src/errors/carto-runtime-error.js");
/* harmony import */ var _renderer_shaders_geometry_point_pointVertexShader_glsl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./renderer/shaders/geometry/point/pointVertexShader.glsl */ "./src/renderer/shaders/geometry/point/pointVertexShader.glsl");
/* harmony import */ var _renderer_shaders_geometry_point_pointVertexShader_glsl__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_renderer_shaders_geometry_point_pointVertexShader_glsl__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _renderer_shaders_geometry_point_pointFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./renderer/shaders/geometry/point/pointFragmentShader.glsl */ "./src/renderer/shaders/geometry/point/pointFragmentShader.glsl");
/* harmony import */ var _renderer_shaders_geometry_point_pointFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_renderer_shaders_geometry_point_pointFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _renderer_shaders_geometry_line_lineVertexShader_glsl__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./renderer/shaders/geometry/line/lineVertexShader.glsl */ "./src/renderer/shaders/geometry/line/lineVertexShader.glsl");
/* harmony import */ var _renderer_shaders_geometry_line_lineVertexShader_glsl__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_renderer_shaders_geometry_line_lineVertexShader_glsl__WEBPACK_IMPORTED_MODULE_12__);
/* harmony import */ var _renderer_shaders_geometry_line_lineFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./renderer/shaders/geometry/line/lineFragmentShader.glsl */ "./src/renderer/shaders/geometry/line/lineFragmentShader.glsl");
/* harmony import */ var _renderer_shaders_geometry_line_lineFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_renderer_shaders_geometry_line_lineFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _renderer_shaders_geometry_polygon_polygonVertexShader_glsl__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./renderer/shaders/geometry/polygon/polygonVertexShader.glsl */ "./src/renderer/shaders/geometry/polygon/polygonVertexShader.glsl");
/* harmony import */ var _renderer_shaders_geometry_polygon_polygonVertexShader_glsl__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_renderer_shaders_geometry_polygon_polygonVertexShader_glsl__WEBPACK_IMPORTED_MODULE_14__);
/* harmony import */ var _renderer_shaders_geometry_polygon_polygonFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./renderer/shaders/geometry/polygon/polygonFragmentShader.glsl */ "./src/renderer/shaders/geometry/polygon/polygonFragmentShader.glsl");
/* harmony import */ var _renderer_shaders_geometry_polygon_polygonFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_renderer_shaders_geometry_polygon_polygonFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_15__);
/* harmony import */ var _renderer_viz_expressions_Image__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./renderer/viz/expressions/Image */ "./src/renderer/viz/expressions/Image.js");
/* harmony import */ var _renderer_viz_defaultSVGs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./renderer/viz/defaultSVGs */ "./src/renderer/viz/defaultSVGs.js");
/* harmony import */ var _renderer_viz_expressions_Placement__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./renderer/viz/expressions/Placement */ "./src/renderer/viz/expressions/Placement.js");
/* harmony import */ var _renderer_viz_expressions_transformation_Translate__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./renderer/viz/expressions/transformation/Translate */ "./src/renderer/viz/expressions/transformation/Translate.js");
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./utils/geometry */ "./src/utils/geometry.js");
/* harmony import */ var _constants_viz__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./constants/viz */ "./src/constants/viz.js");























const DEFAULT_COLOR_EXPRESSION = () => _markDefault(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["rgb"](0, 0, 0));
const DEFAULT_WIDTH_EXPRESSION = () => _markDefault(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["number"](1));
const DEFAULT_STROKE_COLOR_EXPRESSION = () => _markDefault(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["rgb"](0, 0, 0));
const DEFAULT_STROKE_WIDTH_EXPRESSION = () => _markDefault(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["number"](0));
const DEFAULT_ORDER_EXPRESSION = () => _markDefault(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["noOrder"]());
const DEFAULT_FILTER_EXPRESSION = () => _markDefault(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["constant"](1));
const DEFAULT_SYMBOL_EXPRESSION = () => _markDefault(new _renderer_viz_expressions_Image__WEBPACK_IMPORTED_MODULE_16__["default"](_renderer_viz_defaultSVGs__WEBPACK_IMPORTED_MODULE_17__["default"].circle));
const DEFAULT_SYMBOLPLACEMENT_EXPRESSION = () => _markDefault(new _renderer_viz_expressions_Placement__WEBPACK_IMPORTED_MODULE_18__["default"](_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["constant"](0), _renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["constant"](1)));
const DEFAULT_TRANSFORM_EXPRESSION = () => _markDefault(new _renderer_viz_expressions_transformation_Translate__WEBPACK_IMPORTED_MODULE_19__["default"](_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["constant"](0), _renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["constant"](0)));
const DEFAULT_RESOLUTION = () => _markDefault(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["number"](1));
/**
 * A `vizSpec` object is used to create a {@link carto.Viz|Viz} and controlling multiple aspects.
 *
 * @typedef {Object} vizSpec
 * @name vizSpec
 * @api
 */

/**
* A Viz is one of the core elements of CARTO VL and defines how the data will be styled,
* displayed and processed. A Viz instance can only be bound to one layer.
*
*
* @param {string|vizSpec} definition - The definition of a viz. This parameter could be a `string` or a {@link vizSpec|vizSpec}  object
*
* @example <caption> Create a viz with black dots using the string constructor </caption>
* const viz = new carto.Viz(`
*   color: rgb(0,0,0)
* `);
*
* @example <caption> Create a viz with black dots using the vizSpec constructor </caption>
* const viz = new carto.Viz({
*   color: carto.expressions.rgb(0,0,0)
* });
*
* @constructor Viz
* @name carto.Viz
* @property {Color} color - fill color of points and polygons and color of lines, if used with `symbol` the color will override the original image RGB channels
* @property {Number} width - fill diameter of points, thickness of lines, not applicable to polygons
* @property {Color} strokeColor - stroke/border color of points and polygons, not applicable to lines
* @property {Number} strokeWidth - stroke width of points and polygons, not applicable to lines
* @property {Number} filter - filter features by removing from rendering and interactivity all the features that don't pass the test. In combination with {@link carto.expressions.animation} temporal maps can be created.
* @property {Image} symbol - show an image instead in the place of points. There is a list of built-in icons you can use by default in the {@link https://carto.com/developers/carto-vl/reference/#icons|Icons section}
* @property {Placement} symbolPlacement - when using `symbol`, offset to apply to the image
* @property {Transformation} transform - transformation to apply to the features in pixels. We can assign a {@link carto.expressions.translate|translation}, a {@link carto.expressions.rotate|rotation}, or a chain of those two.
* @property {Order} order - rendering order of the features, only applicable to points. See {@link carto.expressions.asc}, {@link carto.expressions.desc} and {@link carto.expressions.noOrder}
* @property {Number} resolution - resolution of the property-aggregation functions, only applicable to points. Default resolution is 1. Custom values must be greater than 0 and lower than 256, and power of 2 values work better (no visual artifacts). A resolution of N means points are aggregated to grid cells NxN pixels. Unlike {@link https://carto.com/developers/torque-js/guides/how-spatial-aggregation-works/|Torque resolution}, the aggregated points are placed in the centroid of the cluster, not in the center of the grid cell.
* @property {Object} variables - An object describing the variables used.
* @api
*
*/
class Viz {
    constructor (definition) {
        const vizSpec = this._getVizDefinition(definition);
        this._checkVizSpec(vizSpec);

        Object.keys(vizSpec).forEach(property => {
            this._defineProperty(property, vizSpec[property]);
        });

        if (!Object.keys(vizSpec).includes('variables')) {
            this._defineProperty('variables', {});
        }

        this.updated = true;
        this._changeCallback = null;

        this._updateRootExpressionList();
        this._updateRootExpressions();

        this._resolveAliases();
        this._validateAliasDAG();
    }

    /**
     * Get the geometry type of the visualization.
     * @readonly
     * @memberof carto.Viz
     * @api
     */
    get geometryType () {
        return this._geomType;
    }

    loadImages () {
        return Promise.all(this._getRootExpressions().map(expr => expr.loadImages()));
    }

    /*
     * There are cases when promise rejections are fine, such as when using
     * `blendTo` to change the viz synchronously.
    */
    _ignoreChangeRejections () {
        return {};
    }

    // Define a viz property, setting all the required getters, setters and creating a proxy for the variables object
    // These setters and the proxy allow us to re-render without requiring further action from the user
    _defineProperty (propertyName, propertyValue) {
        if (propertyName !== 'variables' && !_constants_viz__WEBPACK_IMPORTED_MODULE_21__["SUPPORTED_VIZ_PROPERTIES"].includes(propertyName)) {
            return;
        }
        Object.defineProperty(this, propertyName, {
            get: () => this['_' + propertyName],
            set: expr => {
                this['_' + propertyName] = Object(_renderer_viz_expressions_utils__WEBPACK_IMPORTED_MODULE_5__["implicitCast"])(expr);
                this._changed().catch(this._ignoreChangeRejections);
            }
        });

        let property = propertyValue;
        if (propertyName === 'variables') {
            let init = false;
            const handler = {
                get: (obj, prop) => {
                    return obj[prop];
                },
                set: (obj, prop, value) => {
                    value = Object(_renderer_viz_expressions_utils__WEBPACK_IMPORTED_MODULE_5__["implicitCast"])(value);

                    if (value instanceof _renderer_viz_expressions_base__WEBPACK_IMPORTED_MODULE_4__["default"]) {
                        value._variableName = prop;
                    }

                    obj[prop] = value;
                    this['__cartovl_variable_' + prop] = value;
                    if (init) {
                        this._changed().catch(this._ignoreChangeRejections);
                    }
                    return true;
                }
            };
            property = new Proxy({}, handler);
            Object.keys(propertyValue).map(varName => {
                property[varName] = propertyValue[varName];
            });
            init = true;
        }
        this['_' + propertyName] = property;
    }

    _getRootExpressions () {
        return this._rootExpressions;
    }

    _getRootStyleExpressions () {
        return this._rootStyleExpressions;
    }

    _updateRootExpressions () {
        this._getRootExpressions().forEach(expr => {
            expr.parent = this;
            expr.notify = this._changed.bind(this);
        });
    }

    isAnimated () {
        return this._getRootStyleExpressions().some(expr => expr.isAnimated());
    }

    isPlaying () {
        return this._getRootStyleExpressions().some(expr => expr.isPlaying());
    }

    onChange (callback) {
        this._changeCallback = callback;
    }

    _changed () {
        this._updateRootExpressionList();
        this._resolveAliases();
        this._validateAliasDAG();
        if (this._changeCallback) {
            return this._changeCallback(this);
        }
        return Promise.resolve(null);
    }

    _updateRootExpressionList () {
        const expressions = [..._constants_viz__WEBPACK_IMPORTED_MODULE_21__["SUPPORTED_VIZ_PROPERTIES"]].map(expression => this[expression]);
        const styleExpressions = [..._constants_viz__WEBPACK_IMPORTED_MODULE_21__["STYLE_VIZ_PROPERTIES"]].map(expression => this[expression]);
        const variables = [...Object.values(this.variables)];

        this._rootExpressions = [...expressions, ...variables];
        this._rootStyleExpressions = styleExpressions;
    }

    getMinimumNeededSchema () {
        return this._getRootExpressions()
            .filter(x => x && x._getMinimumNeededSchema)
            .map(expr => expr._getMinimumNeededSchema())
            .reduce(_renderer_schema__WEBPACK_IMPORTED_MODULE_0__["default"].union, _renderer_schema__WEBPACK_IMPORTED_MODULE_0__["default"].IDENTITY);
    }

    setDefaultsIfRequired (geomType) {
        this._geomType = geomType;
        if (this._appliedDefaults) {
            return;
        }
        let defaults = this._getDefaultGeomStyle(geomType);
        if (defaults) {
            this._appliedDefaults = true;
            if (this.color.default) {
                this.color = defaults.COLOR_EXPRESSION();
            }
            if (this.width.default) {
                this.width = defaults.WIDTH_EXPRESSION();
            }
            if (this.strokeColor.default) {
                this.strokeColor = defaults.STROKE_COLOR_EXPRESSION();
            }
            if (this.strokeWidth.default) {
                this.strokeWidth = defaults.STROKE_WIDTH_EXPRESSION();
            }
            this._updateRootExpressions();
        }
    }

    _getDefaultGeomStyle (geomType) {
        if (geomType === _utils_geometry__WEBPACK_IMPORTED_MODULE_20__["GEOMETRY_TYPE"].POINT) {
            return {
                COLOR_EXPRESSION: () => _markDefault(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["hex"]('#EE4D5A')),
                WIDTH_EXPRESSION: () => _markDefault(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["number"](7)),
                STROKE_COLOR_EXPRESSION: () => _markDefault(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["hex"]('#FFF')),
                STROKE_WIDTH_EXPRESSION: () => _markDefault(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["number"](1))
            };
        } else if (geomType === _utils_geometry__WEBPACK_IMPORTED_MODULE_20__["GEOMETRY_TYPE"].LINE) {
            return {
                COLOR_EXPRESSION: () => _markDefault(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["hex"]('#4CC8A3')),
                WIDTH_EXPRESSION: () => _markDefault(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["number"](1.5)),
                STROKE_COLOR_EXPRESSION: () => _markDefault(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["hex"]('#FFF')), // Not used in lines
                STROKE_WIDTH_EXPRESSION: () => _markDefault(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["number"](1)) // Not used in lines
            };
        } else if (geomType === _utils_geometry__WEBPACK_IMPORTED_MODULE_20__["GEOMETRY_TYPE"].POLYGON) {
            return {
                COLOR_EXPRESSION: () => _markDefault(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["hex"]('#826DBA')),
                WIDTH_EXPRESSION: () => _markDefault(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["number"](1)), // Not used in polygons
                STROKE_COLOR_EXPRESSION: () => _markDefault(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["hex"]('#FFF')),
                STROKE_WIDTH_EXPRESSION: () => _markDefault(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_3__["number"](1))
            };
        }
    }

    _resolveAliases () {
        this._getRootExpressions().forEach(expr => {
            expr._resolveAliases(this.variables);
        });
    }

    _validateAliasDAG () {
        const permanentMarkedSet = new Set();
        const temporarilyMarkedSet = new Set();
        const visit = node => {
            if (permanentMarkedSet.has(node)) {
                // Node is already a processed dependency
                return;
            }
            if (temporarilyMarkedSet.has(node)) {
                throw new _src_errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_9__["default"]('Viz contains a circular dependency');
            }
            temporarilyMarkedSet.add(node);
            node._getDependencies().forEach(visit);
            permanentMarkedSet.add(node);
        };
        const unmarked = this._getRootExpressions().map(
            expr => expr._getDependencies()
        ).reduce(
            (a, b) => [...a, ...b],
            []
        );
        while (unmarked.length) {
            visit(unmarked.pop());
        }
    }

    _bindMetadata (metadata) {
        this._colorShader = null;
        this._widthShader = null;
        this._strokeColorShader = null;
        this._strokeWidthShader = null;
        this._filterShader = null;
        this._symbolShader = null;
        this._pointShader = null;
        this._lineShader = null;
        this._polygonShader = null;
        this.metadata = metadata;
        this._getRootExpressions().forEach(expr => expr._bindMetadata(this.metadata));
        checkVizPropertyTypes(this);
    }

    get colorMetaShader () {
        return this._compileShader('colorShader', _renderer_shaders_index__WEBPACK_IMPORTED_MODULE_1__["default"].styler.colorShaderGLSL, { color: this.color });
    }
    get widthMetaShader () {
        return this._compileShader('widthShader', _renderer_shaders_index__WEBPACK_IMPORTED_MODULE_1__["default"].styler.widthShaderGLSL, { width: this.width });
    }
    get strokeColorMetaShader () {
        return this._compileShader('strokeColorShader', _renderer_shaders_index__WEBPACK_IMPORTED_MODULE_1__["default"].styler.colorShaderGLSL, { color: this.strokeColor });
    }
    get strokeWidthMetaShader () {
        return this._compileShader('strokeWidthShader', _renderer_shaders_index__WEBPACK_IMPORTED_MODULE_1__["default"].styler.widthShaderGLSL, { width: this.strokeWidth });
    }
    get filterMetaShader () {
        return this._compileShader('filterShader', _renderer_shaders_index__WEBPACK_IMPORTED_MODULE_1__["default"].styler.filterShaderGLSL, { filter: this.filter });
    }
    get symbolMetaShader () {
        return this._compileShader('symbolShader', _renderer_shaders_index__WEBPACK_IMPORTED_MODULE_1__["default"].symbolizer.symbolShaderGLSL, {
            symbol: this.symbol,
            symbolPlacement: this.symbolPlacement,
            transform: this.transform
        });
    }
    get pointMetaShader () {
        return this._compileShader('pointShader', { vertexShader: _renderer_shaders_geometry_point_pointVertexShader_glsl__WEBPACK_IMPORTED_MODULE_10___default.a, fragmentShader: _renderer_shaders_geometry_point_pointFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_11___default.a },
            { transform: this.transform });
    }
    get lineMetaShader () {
        return this._compileShader('lineShader', { vertexShader: _renderer_shaders_geometry_line_lineVertexShader_glsl__WEBPACK_IMPORTED_MODULE_12___default.a, fragmentShader: _renderer_shaders_geometry_line_lineFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_13___default.a },
            { transform: this.transform });
    }
    get polygonMetaShader () {
        return this._compileShader('polygonShader', { vertexShader: _renderer_shaders_geometry_polygon_polygonVertexShader_glsl__WEBPACK_IMPORTED_MODULE_14___default.a, fragmentShader: _renderer_shaders_geometry_polygon_polygonFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_15___default.a },
            { transform: this.transform });
    }

    _compileShader (shaderName, GLSL, expr) {
        if (!this['_' + shaderName]) {
            this['_' + shaderName] = Object(_renderer_shaders_shaderCompiler__WEBPACK_IMPORTED_MODULE_2__["compileShader"])(this.gl, GLSL, expr, this);
        }
        return this['_' + shaderName];
    }

    replaceChild (toReplace, replacer) {
        if (Object.values(this.variables).includes(toReplace)) {
            const varName = Object.keys(this.variables).find(varName => this.variables[varName] === toReplace);
            this.variables[varName] = replacer;
            replacer.parent = this;
            replacer.notify = toReplace.notify;
        } else {
            const propertyName = _constants_viz__WEBPACK_IMPORTED_MODULE_21__["SUPPORTED_VIZ_PROPERTIES"].find(propertyName => this[propertyName] === toReplace);
            if (propertyName) {
                this[propertyName] = replacer;
                replacer.parent = this;
                replacer.notify = toReplace.notify;
            } else {
                throw new _src_errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_9__["default"]('No child found');
            }
        }
    }

    /**
     * This function checks the input parameter `definition` returning always an object.
     * If the `definition` is an object it returns the same object.
     * If the `definition` is a string it returns the parsed string as an object.
     * Otherwise it throws an error.
     *
     * @param  {string|object} definition
     * @return {vizSpec}
     */
    _getVizDefinition (definition) {
        if (_utils_util__WEBPACK_IMPORTED_MODULE_7__["default"].isUndefined(definition)) {
            return this._setDefaults({});
        }
        if (_utils_util__WEBPACK_IMPORTED_MODULE_7__["default"].isObject(definition)) {
            return this._setDefaults(definition);
        }
        if (_utils_util__WEBPACK_IMPORTED_MODULE_7__["default"].isString(definition)) {
            return this._setDefaults(Object(_renderer_viz_parser__WEBPACK_IMPORTED_MODULE_6__["parseVizDefinition"])(definition));
        }
        throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_8__["default"](
            'viz \'definition\' should be a vizSpec object or a valid viz string.',
            _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_8__["CartoValidationErrorTypes"].INCORRECT_VALUE
        );
    }

    /**
     * Add default values to a vizSpec object.
     *
     * @param {vizSpec} vizSpec
     * @return {vizSpec}
     */
    _setDefaults (vizSpec) {
        if (_utils_util__WEBPACK_IMPORTED_MODULE_7__["default"].isUndefined(vizSpec.color)) {
            vizSpec.color = _utils_util__WEBPACK_IMPORTED_MODULE_7__["default"].isUndefined(vizSpec.symbol) ? DEFAULT_COLOR_EXPRESSION() : Object(_renderer_viz_expressions_utils__WEBPACK_IMPORTED_MODULE_5__["noOverrideColor"])();
        }
        if (_utils_util__WEBPACK_IMPORTED_MODULE_7__["default"].isUndefined(vizSpec.width)) {
            vizSpec.width = DEFAULT_WIDTH_EXPRESSION();
        }
        if (_utils_util__WEBPACK_IMPORTED_MODULE_7__["default"].isUndefined(vizSpec.strokeColor)) {
            vizSpec.strokeColor = DEFAULT_STROKE_COLOR_EXPRESSION();
        }
        if (_utils_util__WEBPACK_IMPORTED_MODULE_7__["default"].isUndefined(vizSpec.strokeWidth)) {
            vizSpec.strokeWidth = DEFAULT_STROKE_WIDTH_EXPRESSION();
        }
        if (_utils_util__WEBPACK_IMPORTED_MODULE_7__["default"].isUndefined(vizSpec.order)) {
            vizSpec.order = DEFAULT_ORDER_EXPRESSION();
        }
        if (_utils_util__WEBPACK_IMPORTED_MODULE_7__["default"].isUndefined(vizSpec.filter)) {
            vizSpec.filter = DEFAULT_FILTER_EXPRESSION();
        }
        if (_utils_util__WEBPACK_IMPORTED_MODULE_7__["default"].isUndefined(vizSpec.resolution)) {
            vizSpec.resolution = DEFAULT_RESOLUTION();
        }
        if (_utils_util__WEBPACK_IMPORTED_MODULE_7__["default"].isUndefined(vizSpec.symbol)) {
            vizSpec.symbol = DEFAULT_SYMBOL_EXPRESSION();
        }
        if (_utils_util__WEBPACK_IMPORTED_MODULE_7__["default"].isUndefined(vizSpec.symbolPlacement)) {
            vizSpec.symbolPlacement = DEFAULT_SYMBOLPLACEMENT_EXPRESSION();
        }
        if (_utils_util__WEBPACK_IMPORTED_MODULE_7__["default"].isUndefined(vizSpec.transform)) {
            vizSpec.transform = DEFAULT_TRANSFORM_EXPRESSION();
        }
        vizSpec.variables = vizSpec.variables || {};
        return vizSpec;
    }

    _checkResolution (resolution) {
        const resolutionValue = resolution instanceof _renderer_viz_expressions_base__WEBPACK_IMPORTED_MODULE_4__["default"]
            ? resolution.eval()
            : resolution;

        if (_utils_util__WEBPACK_IMPORTED_MODULE_7__["default"].isNumber(resolutionValue)) {
            if (resolution <= _constants_viz__WEBPACK_IMPORTED_MODULE_21__["MIN_RESOLUTION"]) {
                throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_8__["default"](
                    `'resolution' is ${resolution}, must be greater than ${_constants_viz__WEBPACK_IMPORTED_MODULE_21__["MIN_RESOLUTION"]}.`,
                    _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_8__["CartoValidationErrorTypes"].INCORRECT_VALUE
                );
            }

            if (resolution >= _constants_viz__WEBPACK_IMPORTED_MODULE_21__["MAX_RESOLUTION"]) {
                throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_8__["default"](
                    `'resolution' is ${resolution}, must be lower than ${_constants_viz__WEBPACK_IMPORTED_MODULE_21__["MAX_RESOLUTION"]}.`,
                    _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_8__["CartoValidationErrorTypes"].INCORRECT_VALUE
                );
            }
        } else {
            throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_8__["default"](
                '\'resolution\' property must be a number.',
                _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_8__["CartoValidationErrorTypes"].INCORRECT_TYPE
            );
        }
    }

    _applyImplitCastToNumericProperties (vizSpec) {
        vizSpec.filter = Object(_renderer_viz_expressions_utils__WEBPACK_IMPORTED_MODULE_5__["implicitCast"])(vizSpec.filter);
        vizSpec.resolution = Object(_renderer_viz_expressions_utils__WEBPACK_IMPORTED_MODULE_5__["implicitCast"])(vizSpec.resolution);
        vizSpec.strokeWidth = Object(_renderer_viz_expressions_utils__WEBPACK_IMPORTED_MODULE_5__["implicitCast"])(vizSpec.strokeWidth);
        vizSpec.symbol = Object(_renderer_viz_expressions_utils__WEBPACK_IMPORTED_MODULE_5__["implicitCast"])(vizSpec.symbol);
        vizSpec.symbolPlacement = Object(_renderer_viz_expressions_utils__WEBPACK_IMPORTED_MODULE_5__["implicitCast"])(vizSpec.symbolPlacement);
        vizSpec.transform = Object(_renderer_viz_expressions_utils__WEBPACK_IMPORTED_MODULE_5__["implicitCast"])(vizSpec.transform);
        vizSpec.width = Object(_renderer_viz_expressions_utils__WEBPACK_IMPORTED_MODULE_5__["implicitCast"])(vizSpec.width);
    }

    _checkVizSpec (vizSpec) {
        this._applyImplitCastToNumericProperties(vizSpec);
        this._checkResolution(vizSpec.resolution);

        _constants_viz__WEBPACK_IMPORTED_MODULE_21__["SUPPORTED_VIZ_PROPERTIES"].forEach((parameter) => {
            if (!(vizSpec[parameter] instanceof _renderer_viz_expressions_base__WEBPACK_IMPORTED_MODULE_4__["default"])) {
                throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_8__["default"](
                    `'${parameter}' parameter is not a valid viz Expresion.`,
                    _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_8__["CartoValidationErrorTypes"].INCORRECT_TYPE);
            }
        });

        for (let key in vizSpec) {
            if (key !== 'variables' && _constants_viz__WEBPACK_IMPORTED_MODULE_21__["SUPPORTED_VIZ_PROPERTIES"].indexOf(key) === -1) {
                console.warn(`Property '${key}' is not supported`);
            }
        }
    }

    /**
     * Stringify the visualization
     *
     * @returns {String}
     * @memberof carto.Viz
     * @api
     */
    toString () {
        const variables = Object
            .keys(this.variables)
            .map(varName => `@${varName}: ${this.variables[varName].toString()}`);

        const properties = _constants_viz__WEBPACK_IMPORTED_MODULE_21__["SUPPORTED_VIZ_PROPERTIES"]
            .map(property => `${property}: ${this[property].toString()}`);

        return [...variables, ...properties].join('\n');
    }
}

function checkVizPropertyTypes (viz) {
    const expectedTypePerProperty = {
        color: 'color',
        filter: 'number',
        order: 'orderer',
        resolution: 'number',
        strokeColor: 'color',
        strokeWidth: 'number',
        symbol: 'image',
        symbolPlacement: 'placement',
        transform: 'transformation',
        width: 'number'
    };

    Object.keys(expectedTypePerProperty).forEach((property) => {
        const currentType = viz[property].type;
        const expected = expectedTypePerProperty[property];
        if (currentType !== expected) {
            throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_8__["default"](
                `Viz property '${property}': must be of type '${expected}' but it was of type '${currentType}'`,
                _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_8__["CartoValidationErrorTypes"].INCORRECT_TYPE
            );
        }
    });
}

/**
 * Mark default expressions to apply the style defaults for each
 * geometry (point, line, polygon) when available.
 */
function _markDefault (expression) {
    expression.default = true;
    return expression;
}


/***/ }),

/***/ "./src/basemaps.js":
/*!*************************!*\
  !*** ./src/basemaps.js ***!
  \*************************/
/*! exports provided: voyager, darkmatter, positron */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "voyager", function() { return voyager; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "darkmatter", function() { return darkmatter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "positron", function() { return positron; });
/**
 * Voyager vector basemap
 *
 * @example <caption>Use Voyager vector basemap.</caption>
 * const map = new mapboxgl.Map({
 *   container: 'map',
 *   style: carto.basemaps.voyager
 * })
 *
 * @example <caption>Use Voyager vector basemap. (String)</caption>
 * const map = new mapboxgl.Map({
 *   container: 'map',
 *   style: carto.basemaps.voyager
 * })
 *
 * @memberof carto.basemaps
 * @name voyager
 * @api
 */
const voyager = 'https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json';

/**
 * Dark-Matter vector basemap
 *
 * @example <caption>Use Dark-Matter vector basemap.</caption>
 * const map = new mapboxgl.Map({
 *   container: 'map',
 *   style: carto.basemaps.darkmatter
 * })
 *
 * @example <caption>Use Dark-Matter vector basemap. (String)</caption>
 * const map = new mapboxgl.Map({
 *   container: 'map',
 *   style: carto.basemaps.darkmatter
 * })
 *
 * @memberof carto.basemaps
 * @name darkmatter
 * @api
 */
const darkmatter = 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json';

/**
 * Positron vector basemap
 *
 * @example <caption>Use Positron vector basemap.</caption>
 * const map = new mapboxgl.Map({
 *   container: 'map',
 *   style: carto.basemaps.positron
 * })
 *
 * @example <caption>Use Positron vector basemap. (String)</caption>
 * const map = new mapboxgl.Map({
 *   container: 'map',
 *   style: carto.basemaps.positron
 * })
 *
 * @memberof carto.basemaps
 * @name positron
 * @api
 */
const positron = 'https://basemaps.cartocdn.com/gl/positron-gl-style/style.json';


/***/ }),

/***/ "./src/client/WindshaftMetadata.js":
/*!*****************************************!*\
  !*** ./src/client/WindshaftMetadata.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WindshaftMetadata; });
/* harmony import */ var _sources_MVTMetadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sources/MVTMetadata */ "./src/sources/MVTMetadata.js");
/* harmony import */ var _codecs_windshaft__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../codecs/windshaft */ "./src/codecs/windshaft/index.js");



// // Windshaft metadata internal structure of properties
// properties: {
//     // There's an entry here for every column of the original dataset/SQL query
//     simple_value: { type: 'number', min: 10, max: 1000 },

//     // Now, that's all there's to it for other sources,
//     // but for Windshaft sources things more complicated:

//     // There might be multiple aggregated properties derived from one base column
//     value: {
//         type: 'number' // this is the type of the base column and all aggregated properties
//         aggregation: {
//             // actual properties received and decoded are _cdb_agg_sum_value and _cdb_avg_sum_value
//             sum: '_cdb_agg_sum_value',
//             avg: '_cdb_agg_sum_value'
//         }
//     },

//     // Then we can have dimension properties, also derived from a base column
//     // here time1 is a date column of the dataset/query; but what we receive is
//     // a _cdb_dim_month_time1 property of numeric type.
//     // these dimension properties are triggered by clusterMonth/clusterMonthIso etc
//     time1: {
//         type: 'date' // this is the type of the base column only,
//         min: '2017-01-01T00:00:00',  // stats of the base column
//         max: '2018-12-01T00:00:00',
//         dimension: {
//             type: 'number', // type of the actual property received and decoded
//             grouping: {},// (to be changed to group) grouping parameters
//             propertyName: "_cdb_dim_month_time1",
//             min: 1,      // actual stats of property _cdb_dim_month_time1
//             max: 24
//         }
//     },

//     // But wait, there's more, we can transfer a date dimension as an iso string property
//     // but then expose it as two date properties, one for the start of each period and
//     // one from the end (if not used, any of them may not be present)
//     // these dimension properties are triggered by clusterMonthStart/clusterMonthEnd etc.
//     time2: {
//         type: 'date' // this is the type of the base column only,
//         min: '2017-01-01T00:00:00',  // stats of the base column
//         max: '2018-12-01T00:00:00',
//         dimension: {
//             type: 'category', // type of the actual (source) property received internally
//             grouping: {},// (to be changed to group) grouping parameters
//             propertyName: "_cdb_dim_month_time1", // source property
//             min: '2017-01', // stats of property _cdb_dim_month_time1
//             max: '2017-12',
//             range: [
//                 // here come the actual decoded (internal) properties!!:
//                 // the types of these properties is 'date'
//                 '_cdb_dim_month_time1_start',
//                 '_cdb_dim_month_time1_end'
//             }
//         }
//     }
// }

class WindshaftMetadata extends _sources_MVTMetadata__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (...args) {
        super(...args);
        this.propertyKeys = [];
        this.baseNames = {};
        Object.keys(this.properties).forEach(baseName => {
            const property = this.properties[baseName];
            if (property.aggregations) {
                Object.values(property.aggregations).forEach(propName => {
                    this._addProperty(baseName, propName);
                });
            } else if (property.dimension) {
                if (property.dimension.range) {
                    property.dimension.range.forEach(rangePropertyName => {
                        this._addProperty(baseName, rangePropertyName, false);
                    });
                    // add source property too, for stats
                    this._addProperty(baseName, property.dimension.propertyName);
                } else {
                    this._addProperty(baseName, property.dimension.propertyName);
                }
            } else {
                this._addProperty(baseName, baseName);
            }
        });
    }

    _addProperty (baseName, propertyName, addToKeys = true) {
        this.baseNames[propertyName] = baseName;
        if (addToKeys) {
            this.propertyKeys.push(propertyName);
        }
    }

    _dimensionInfo (propertyName) {
        const baseName = this.baseName(propertyName) || propertyName;
        const column = this.properties[baseName];
        let dimension = null;
        if (baseName !== propertyName) {
            if (baseName !== propertyName && column.dimension) {
                dimension = column.dimension;
            }
        }
        const baseType = column.type;
        const sourceType = dimension ? dimensionBaseType(dimension) : baseType;
        // type of the dataframe properties
        const dataframeType = dimension ? dimensionType(dimension, propertyName) : sourceType;
        return { baseName, column, dimension, dataframeType, baseType, sourceType };
    }

    baseName (propertyName) {
        return this.baseNames[propertyName];
    }

    decodedProperties (propertyName) {
        const { dimension } = this._dimensionInfo(propertyName);
        if (dimension && dimension.grouping && dimension.range) {
            return dimension.range;
        }
        return super.decodedProperties(propertyName);
    }

    // Stats usage: (is internal, external or source representation preferable?)
    // * global aggregations
    // * coding/decoding
    stats (propertyName) {
        const { dimension } = this._dimensionInfo(propertyName);
        if (dimension && dimension.grouping) {
            return dimension;
        }
        return super.stats(propertyName);
    }

    setCodecs () {
        setMetadataCodecs(this);
    }

    sourcePropertyName (propertyName) {
        const baseName = this.baseName(propertyName);
        const dimension = this.properties[baseName].dimension;
        if (dimension && dimension.range) {
            return dimension.propertyName;
        }
        return propertyName;
    }
}

function dimensionType (dimension, propertyName) {
    if (dimension.range) {
        return 'date';
    }
    return dimension.type;
}

function dimensionBaseType (dimension) {
    return dimension.type;
}

function setMetadataCodecs (metadata) {
    // assign codecs
    // a single codec kept per base property
    // so, all its aggregations share the same encoding.
    // form a dimension, the kept codec is that of the dimension
    Object.keys(metadata.properties).forEach(baseName => {
        const property = metadata.properties[baseName];
        const baseType = property.type;
        if (baseType !== 'geometry') {
            const dimType = property.dimension ? property.dimension.type : null;
            const dimName = dimType ? property.dimension.propertyName : baseName;
            const actualDimType = (dimType === 'category' && property.dimension.range) ? 'timerange' : dimType;
            property.codec = Object(_codecs_windshaft__WEBPACK_IMPORTED_MODULE_1__["default"])(metadata, actualDimType || baseType, dimName || baseName);
        }
    });
}


/***/ }),

/***/ "./src/client/WindshaftRequestHelper.js":
/*!**********************************************!*\
  !*** ./src/client/WindshaftRequestHelper.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WindshaftRequestHelper; });
/* harmony import */ var _package__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../package */ "./package.json");
var _package__WEBPACK_IMPORTED_MODULE_0___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../../package */ "./package.json", 1);
/* harmony import */ var _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/carto-maps-api-error */ "./src/errors/carto-maps-api-error.js");



const REQUEST_GET_MAX_URL_LENGTH = 2048;

class WindshaftRequestHelper {
    constructor (conf, mapConfig) {
        this._conf = conf;
        this._mapConfig = mapConfig;

        this._auth = this._encodeParameter('api_key', this._conf.apiKey);
        this._client = this._encodeParameter('client', `vl-${_package__WEBPACK_IMPORTED_MODULE_0__["version"]}`);
    }

    /**
     * Make a request to Windshaft for a LayerGroup, dealing internally with errors in the Maps API
     */
    async getLayerGroup () {
        let response;
        try {
            response = await fetch(this._makeHttpRequest());
        } catch (error) {
            throw new _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_1__["default"](`Failed to connect to Maps API with your user('${this._conf.username}')`);
        }

        const layergroup = await response.json();
        if (!response.ok) {
            this._dealWithWindshaftErrors(response, layergroup);
        }

        return layergroup;
    }

    _makeHttpRequest () {
        const parameters = [this._auth, this._client, this._encodeParameter('config', this._mapConfigPayload())];
        const url = this._generateUrl(this._generateMapsApiUrl(), parameters);
        if (url.length < REQUEST_GET_MAX_URL_LENGTH) {
            return this._getRequest(url);
        }

        return this._postRequest();
    }

    _dealWithWindshaftErrors (response, layergroup) {
        if (response.status === 401) {
            throw new _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_1__["default"](
                `Unauthorized access to Maps API: invalid combination of user('${this._conf.username}') and apiKey('${this._conf.apiKey}')`,
                _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_1__["CartoMapsAPIErrorTypes"].SECURITY
            );
        } else if (response.status === 403) {
            throw new _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_1__["default"](
                `Unauthorized access to dataset: the provided apiKey('${this._conf.apiKey}') doesn't provide access to the requested data`,
                _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_1__["CartoMapsAPIErrorTypes"].SECURITY
            );
        }
        throw new _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_1__["default"](`${JSON.stringify(layergroup.errors)}`, _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_1__["CartoMapsAPIErrorTypes"].SQL);
    }

    _mapConfigPayload () {
        return JSON.stringify(this._mapConfig);
    }

    _getRequest (url) {
        return new Request(url, {
            method: 'GET',
            headers: {
                'Accept': 'application/json'
            }
        });
    }

    _postRequest () {
        const parameters = [this._auth, this._client];

        return new Request(this._generateUrl(this._generateMapsApiUrl(), parameters), {
            method: 'POST',
            headers: {
                'Accept': 'application/json',
                'Content-Type': 'application/json'
            },
            body: this._mapConfigPayload()
        });
    }

    _encodeParameter (name, value) {
        return `${name}=${encodeURIComponent(value)}`;
    }

    _generateUrl (url, parameters = []) {
        return `${url}?${parameters.join('&')}`;
    }

    _generateMapsApiUrl (path) {
        let url = `${this._conf.serverURL}/api/v1/map`;
        if (path) {
            url += path;
        }
        return url;
    }
}


/***/ }),

/***/ "./src/client/rsys.js":
/*!****************************!*\
  !*** ./src/client/rsys.js ***!
  \****************************/
/*! exports provided: wToR, rTiles, getRsysFromTile, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wToR", function() { return wToR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rTiles", function() { return rTiles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRsysFromTile", function() { return getRsysFromTile; });
/**
 * An RSys defines a local coordinate system that maps the coordinates
 * in the range -1 <= x <= +1; -1 <= y <= +1 to an arbitrary rectangle
 * in an external coordinate system. (e.g. Dataframe coordinates to World coordinates)
 * It is the combination of a translation and anisotropic scaling.
 * @typedef {Object} RSys - Renderer relative coordinate system
 * @property {RPoint} center - Position of the local system in external coordinates
 * @property {number} scale - Y-scale (local Y-distance / external Y-distance)
*/

/*
 * Random notes
 *
 * We can redefine Dataframe to use a Rsys instead of center, scale
 * and we can use an Rsys for the Renderer's canvas.
 *
 * Some interesting World coordinate systems:
 *
 * WM (Webmercator): represents a part of the world (excluding polar regions)
 * with coordinates in the range +/-WM_R for both X and Y. (positive orientation: E,N)
 *
 * NWMC (Normalized Webmercator Coordinates): represents the Webmercator *square*
 * with coordinates in the range +/-1. Results from dividing Webmercator coordinates
 * by WM_R. (positive orientation: E,N)
 *
 * TC (Tile coordinates): integers in [0, 2^Z) for zoom level Z. Example: the tile 0/0/0 (zoom, x, y) is the root tile.
 * (positive orientation: E,S)
 *
 * An RSys's rectangle (its bounds) is the area covered by the local coordinates in
 * the range +/-1.
 *
 * When an RSys external coordinate system is WM or NWMC, we can compute:
 * * Minimum zoom level for which tiles are no larger than the RSys rectangle:
 *   Math.ceil(Math.log2(1 / r.scale));
 * * Maximum zoom level for which tiles are no smaller than the rectangle:
 *   Math.floor(Math.log2(1 / r.scale));
 * (note that 1 / r.scale is the fraction of the World height that the local rectangle's height represents)
 *
 * We'll use the term World coordinates below for the *external* reference system
 * of an RSys (usually NWMC).
 */

/* eslint no-unused-vars: ["off"] */

/**
 * R coordinates to World
 * @param {RSys} r - ref. of the passed coordinates
 * @param {number} x - x coordinate in r
 * @param {number} y - y coordinate in r
 * @return {RPoint} World coordinates
 */
function rToW (r, x, y) {
    return { x: x * r.scale + r.center.x, y: y * r.scale + r.center.y };
}

/**
 * World coordinates to local RSys
 * @param {number} x - x W-coordinate
 * @param {number} y - y W-coordinate
 * @param {RSys} r - target ref. system
 * @return {RPoint} R coordinates
 */
function wToR (x, y, r) {
    return { x: (x - r.center.x) / r.scale, y: (y - r.center.y) / r.scale };
}

/**
 * RSys of a tile (mapping local tile coordinates in +/-1 to NWMC)
 * @param {number} x - TC x coordinate
 * @param {number} y - TC y coordinate
 * @param {number} z - Tile zoom level
 * @return {RSys}
 */
function tileRsys (x, y, z) {
    let max = Math.pow(2, z);
    return { scale: 1 / max, center: { x: 2 * (x + 0.5) / max - 1, y: 1 - 2 * (y + 0.5) / max } };
}

/**
 * TC tiles that intersect the local rectangle of an RSys
 * (with the largest tile size no larger than the rectangle)
 * @param {RSys} rsys
 * @return {Array} - array of TC tiles {x, y, z}
 */
function rTiles (zoom, bounds, viewportZoomToSourceZoom = Math.ceil, extend = 0) {
    const z = viewportZoomToSourceZoom(zoom);
    if (typeof z === 'number') {
        return wRectangleTiles(z, bounds, extend);
    }
    return [];
}

/**
 * TC tiles of a given zoom level that intersect a W rectangle
 * @param {number} z
 * @param {Array} wr - rectangle extents [minx, miny, maxx, maxy]
 * @param {number} ex - extend tiles rectangle. Default 0
 * @return {Array} - array of TC tiles {x, y, z}
 */
function wRectangleTiles (z, wr, ex = 0) {
    const [wMinx, wMiny, wMaxx, wMaxy] = wr;
    const n = (1 << z); // for 0 <= z <= 30 equals Math.pow(2, z)

    const clamp = x => Math.min(Math.max(x, 0), n - 1);
    // compute tile coordinate ranges
    const tMinx = clamp(Math.floor(n * (wMinx + 1) * 0.5)) - ex;
    const tMaxx = clamp(Math.ceil(n * (wMaxx + 1) * 0.5) - 1) + ex;
    const tMiny = clamp(Math.floor(n * (1 - wMaxy) * 0.5)) - ex;
    const tMaxy = clamp(Math.ceil(n * (1 - wMiny) * 0.5) - 1) + ex;
    let tiles = [];
    for (let x = tMinx; x <= tMaxx; ++x) {
        for (let y = tMiny; y <= tMaxy; ++y) {
            tiles.push({ x, y, z });
        }
    }
    return tiles;
}

/**
 * Get the Rsys of a tile where the Rsys's center is the tile center and the Rsys's scale is the tile extent.
 * @param {*} x
 * @param {*} y
 * @param {*} z
 * @returns {RSys}
 */
function getRsysFromTile (x, y, z) {
    return {
        center: {
            x: ((x + 0.5) / Math.pow(2, z)) * 2.0 - 1,
            y: (1.0 - (y + 0.5) / Math.pow(2, z)) * 2.0 - 1.0
        },
        scale: 1 / Math.pow(2, z)
    };
}

/* harmony default export */ __webpack_exports__["default"] = ({ rTiles, getRsysFromTile, wToR });


/***/ }),

/***/ "./src/client/windshaft-filtering.js":
/*!*******************************************!*\
  !*** ./src/client/windshaft-filtering.js ***!
  \*******************************************/
/*! exports provided: getFiltering, getSQLWhere, getAggregationFilters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFiltering", function() { return getFiltering; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSQLWhere", function() { return getSQLWhere; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAggregationFilters", function() { return getAggregationFilters; });
/* harmony import */ var _renderer_viz_expressions_binary_GreaterThan__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderer/viz/expressions/binary/GreaterThan */ "./src/renderer/viz/expressions/binary/GreaterThan.js");
/* harmony import */ var _renderer_viz_expressions_binary_GreaterThanOrEqualTo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/viz/expressions/binary/GreaterThanOrEqualTo */ "./src/renderer/viz/expressions/binary/GreaterThanOrEqualTo.js");
/* harmony import */ var _renderer_viz_expressions_binary_LessThan__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/viz/expressions/binary/LessThan */ "./src/renderer/viz/expressions/binary/LessThan.js");
/* harmony import */ var _renderer_viz_expressions_binary_LessThanOrEqualTo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderer/viz/expressions/binary/LessThanOrEqualTo */ "./src/renderer/viz/expressions/binary/LessThanOrEqualTo.js");
/* harmony import */ var _renderer_viz_expressions_binary_And__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../renderer/viz/expressions/binary/And */ "./src/renderer/viz/expressions/binary/And.js");
/* harmony import */ var _renderer_viz_expressions_binary_Or__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../renderer/viz/expressions/binary/Or */ "./src/renderer/viz/expressions/binary/Or.js");
/* harmony import */ var _renderer_viz_expressions_binary_Equals__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../renderer/viz/expressions/binary/Equals */ "./src/renderer/viz/expressions/binary/Equals.js");
/* harmony import */ var _renderer_viz_expressions_binary_NotEquals__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../renderer/viz/expressions/binary/NotEquals */ "./src/renderer/viz/expressions/binary/NotEquals.js");
/* harmony import */ var _renderer_viz_expressions_belongs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../renderer/viz/expressions/belongs */ "./src/renderer/viz/expressions/belongs.js");
/* harmony import */ var _renderer_viz_expressions_between__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../renderer/viz/expressions/between */ "./src/renderer/viz/expressions/between.js");
/* harmony import */ var _renderer_viz_expressions_basic_property__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../renderer/viz/expressions/basic/property */ "./src/renderer/viz/expressions/basic/property.js");
/* harmony import */ var _renderer_viz_expressions_blend__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../renderer/viz/expressions/blend */ "./src/renderer/viz/expressions/blend.js");
/* harmony import */ var _renderer_viz_expressions_transition__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../renderer/viz/expressions/transition */ "./src/renderer/viz/expressions/transition.js");
/* harmony import */ var _renderer_viz_expressions_basic_number__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../renderer/viz/expressions/basic/number */ "./src/renderer/viz/expressions/basic/number.js");
/* harmony import */ var _renderer_viz_expressions_basic_constant__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../renderer/viz/expressions/basic/constant */ "./src/renderer/viz/expressions/basic/constant.js");
/* harmony import */ var _renderer_viz_expressions_basic_category__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../renderer/viz/expressions/basic/category */ "./src/renderer/viz/expressions/basic/category.js");
/* harmony import */ var _renderer_viz_expressions_aggregation_cluster_ClusterAvg__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../renderer/viz/expressions/aggregation/cluster/ClusterAvg */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterAvg.js");
/* harmony import */ var _renderer_viz_expressions_aggregation_cluster_ClusterMax__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../renderer/viz/expressions/aggregation/cluster/ClusterMax */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterMax.js");
/* harmony import */ var _renderer_viz_expressions_aggregation_cluster_ClusterMin__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../renderer/viz/expressions/aggregation/cluster/ClusterMin */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterMin.js");
/* harmony import */ var _renderer_viz_expressions_aggregation_cluster_ClusterMode__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../renderer/viz/expressions/aggregation/cluster/ClusterMode */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterMode.js");
/* harmony import */ var _renderer_viz_expressions_aggregation_cluster_ClusterSum__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../renderer/viz/expressions/aggregation/cluster/ClusterSum */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterSum.js");






















class AggregationFiltering {
    /**
     * Generate aggregation filters:
     * This extracts, from the vizs filters, those compatible to be
     * executed through the Maps API aggregation API.
     * The extracted filters are in the format admitted by the Maps API
     * `filters` parameter.
     * Filters affecting dimensions (non-aggregated columns) can optionally
     * be extracted too, but it is more efficient to not do so and apply those
     * filters before aggregation.
     */
    constructor (options) {
        // exclusive mode: aggregate filters don't include pre-aggregate conditions (dimensions)
        // in that case pre-aggregate filters should always be applied, even with aggregation
        // (which can be more efficient)
        this._onlyAggregateFilters = options.exclusive;
    }

    // return (partial) filters as an object (JSON) in the format of the Maps API aggregation interface
    getFilters (vizFilter) {
        let filters = {};
        let filterList = this._and(vizFilter).filter(Boolean);
        for (let p of filterList) {
            let name = p.property;
            let existingFilter = filters[name];
            if (existingFilter) {
                if (this._compatibleAndFilters(existingFilter, p.filters)) {
                    // combine inequalities into a range
                    Object.assign(existingFilter[0], p.filters[0]);
                } else {
                    // can't AND-combine filters for the same property
                    return {};
                }
            } else {
                filters[name] = p.filters;
            }
        }
        return filters;
    }

    _and (f) {
        if (f.isA(_renderer_viz_expressions_binary_And__WEBPACK_IMPORTED_MODULE_4__["default"])) {
            return this._and(f.a).concat(this._and(f.b)).filter(Boolean);
        }
        return [this._or(f)].filter(Boolean);
    }

    _or (f) {
        if (f.isA(_renderer_viz_expressions_binary_Or__WEBPACK_IMPORTED_MODULE_5__["default"])) {
            let a = this._basicCondition(f.a);
            let b = this._basicCondition(f.b);
            if (a && b) {
                if (a.property === b.property) {
                    a.filters = a.filters.concat(b.filters);
                    return a;
                }
            }
        }
        return this._basicCondition(f);
    }

    _removeBlend (f) {
        if (f.isA(_renderer_viz_expressions_blend__WEBPACK_IMPORTED_MODULE_11__["default"]) && f.originalMix.isA(_renderer_viz_expressions_transition__WEBPACK_IMPORTED_MODULE_12__["default"])) {
            return f.b;
        }
        return f;
    }

    _basicCondition (f) {
        f = this._removeBlend(f);
        return this._between(f) ||
            this._equals(f) || this._notEquals(f) ||
            this._lessThan(f) || this._lessThanOrEqualTo(f) ||
            this._greaterThan(f) || this._greaterThanOrEqualTo(f) ||
            this._in(f) || this._notIn(f);
    }

    _value (f) {
        f = this._removeBlend(f);
        if (f.isA(_renderer_viz_expressions_basic_number__WEBPACK_IMPORTED_MODULE_13__["default"]) || f.isA(_renderer_viz_expressions_basic_constant__WEBPACK_IMPORTED_MODULE_14__["default"]) || f.isA(_renderer_viz_expressions_basic_category__WEBPACK_IMPORTED_MODULE_15__["default"])) {
            return f.value;
        }
    }

    _between (f) {
        if (f.isA(_renderer_viz_expressions_between__WEBPACK_IMPORTED_MODULE_9__["default"])) {
            let p = this._aggregation(f.input);
            let lo = p && this._value(f.lowerLimit);
            let hi = p && lo && this._value(f.upperLimit);
            if (hi) {
                p.filters.push({
                    greater_than_or_equal_to: lo,
                    less_than_or_equal_to: hi
                });
                return p;
            }
        }
    }

    _in (f) {
        if (f.isA(_renderer_viz_expressions_belongs__WEBPACK_IMPORTED_MODULE_8__["In"])) {
            let p = this._aggregation(f.input);
            let values = f.list.elems.map(c => this._value(c)).filter(v => v !== null);
            if (p && values.length > 0 && values.length === f.list.elems.length) {
                p.filters.push({
                    in: values
                });
                return p;
            }
        }
    }

    _notIn (f) {
        if (f.isA(_renderer_viz_expressions_belongs__WEBPACK_IMPORTED_MODULE_8__["Nin"])) {
            let p = this._aggregation(f.input);
            let values = f.list.elems.map(c => this._value(c)).filter(v => v !== null);
            if (p && values.length > 0 && values.length === f.list.elems.length) {
                p.filters.push({
                    not_in: values
                });
                return p;
            }
        }
    }

    _equals (f) {
        return this._cmpOp(f, _renderer_viz_expressions_binary_Equals__WEBPACK_IMPORTED_MODULE_6__["default"], 'equal');
    }

    _notEquals (f) {
        return this._cmpOp(f, _renderer_viz_expressions_binary_NotEquals__WEBPACK_IMPORTED_MODULE_7__["default"], 'not_equal');
    }

    _lessThan (f) {
        return this._cmpOp(f, _renderer_viz_expressions_binary_LessThan__WEBPACK_IMPORTED_MODULE_2__["default"], 'less_than', 'greater_than');
    }

    _lessThanOrEqualTo (f) {
        return this._cmpOp(f, _renderer_viz_expressions_binary_LessThanOrEqualTo__WEBPACK_IMPORTED_MODULE_3__["default"], 'less_than_or_equal_to', 'greater_than_or_equal_to');
    }

    _greaterThan (f) {
        return this._cmpOp(f, _renderer_viz_expressions_binary_GreaterThan__WEBPACK_IMPORTED_MODULE_0__["default"], 'greater_than', 'less_than');
    }

    _greaterThanOrEqualTo (f) {
        return this._cmpOp(f, _renderer_viz_expressions_binary_GreaterThanOrEqualTo__WEBPACK_IMPORTED_MODULE_1__["default"], 'greater_than_or_equal_to', 'less_than_or_equal_to');
    }

    _aggregation (f) {
        f = this._removeBlend(f);
        if (f.isA(_renderer_viz_expressions_aggregation_cluster_ClusterAvg__WEBPACK_IMPORTED_MODULE_16__["default"]) || f.isA(_renderer_viz_expressions_aggregation_cluster_ClusterMax__WEBPACK_IMPORTED_MODULE_17__["default"]) || f.isA(_renderer_viz_expressions_aggregation_cluster_ClusterMin__WEBPACK_IMPORTED_MODULE_18__["default"]) || f.isA(_renderer_viz_expressions_aggregation_cluster_ClusterMode__WEBPACK_IMPORTED_MODULE_19__["default"]) || f.isA(_renderer_viz_expressions_aggregation_cluster_ClusterSum__WEBPACK_IMPORTED_MODULE_20__["default"])) {
            let p = this._property(f.property);
            if (p) {
                p.property = f.propertyName;
                return p;
            }
        }
        if (this._onlyAggregateFilters) {
            // no filters on non-aggregate columns (i.e. dimensions) are generated
            // such filtering should be applied elsewhere
            return;
        }
        return this._property(f);
    }

    _property (f) {
        f = this._removeBlend(f);
        if (f.isA(_renderer_viz_expressions_basic_property__WEBPACK_IMPORTED_MODULE_10__["default"])) {
            return {
                property: f.name,
                filters: []
            };
        }
    }

    _cmpOp (f, opClass, opParam, inverseOpParam) {
        inverseOpParam = inverseOpParam || opParam;
        if (f.isA(opClass)) {
            let p = this._aggregation(f.a);
            let v = p && this._value(f.b);
            let op = opParam;
            if (!v) {
                p = this._aggregation(f.b);
                v = p && this._value(f.a);
                op = inverseOpParam;
            }
            if (v) {
                let filter = {};
                filter[op] = v;
                p.filters.push(filter);
                return p;
            }
        }
    }

    _compatibleAndFilters (a, b) {
        // check if a and b can be combined into a range filter
        if (a.length === 0 || b.length === 0) {
            return true;
        }
        if (a.length === 1 && b.length === 1) {
            const af = a[0];
            const bf = b[0];
            if (Object.keys(af).length === 1 && Object.keys(bf).length === 1) {
                const ka = Object.keys(af)[0];
                const kb = Object.keys(bf)[0];
                const lessOps = ['less_than', 'less_than_or_equal_to'];
                const greaterOps = ['greater_than', 'greater_than_or_equal_to'];
                return (lessOps.includes(ka) && greaterOps.includes(kb)) ||
                    (lessOps.includes(kb) && greaterOps.includes(ka));
            }
        }
        return false;
    }
}

class PreaggregationFiltering {
    /**
     * Generate pre-aggregation filters, i.e. filters that can be
     * applied to the dataset before aggregation.
     * This extracts, from the vizs filters, those compatible to be
     * executed before aggregation.
     * The extracted filters are in an internal tree-like format;
     * each node has a `type` property and various other parameters
     * that depend on the type.
     */

    // return (partial) filters as an object (JSON) representing the SQL syntax tree
    getFilter (vizFilter) {
        return this._filter(vizFilter);
    }

    _filter (f) {
        return this._and(f) || this._or(f) ||
            this._in(f) || this._notIn(f) ||
            this._between(f) ||
            this._equals(f) || this._notEquals(f) ||
            this._lessThan(f) || this._lessThanOrEqualTo(f) ||
            this._greaterThan(f) || this._greaterThanOrEqualTo(f) ||
            this._blend(f) || null;
    }

    _and (f) {
        if (f.isA(_renderer_viz_expressions_binary_And__WEBPACK_IMPORTED_MODULE_4__["default"])) {
            // we can ignore nonsupported (null) subexpressions that are combined with AND
            // and keep the supported ones as a partial filter
            const l = [this._filter(f.a), this._filter(f.b)].filter(Boolean).reduce((x, y) => x.concat(y), []);
            if (l.length) {
                if (l.length === 1) {
                    return l[0];
                }
                return {
                    type: 'and',
                    left: l[0],
                    right: l[1]
                };
            }
        }
    }

    _or (f) {
        if (f.isA(_renderer_viz_expressions_binary_Or__WEBPACK_IMPORTED_MODULE_5__["default"])) {
            // if any subexpression is not supported the OR combination isn't supported either
            let a = this._filter(f.a);
            let b = this._filter(f.b);
            if (a && b) {
                return {
                    type: 'or',
                    left: a,
                    right: b
                };
            }
        }
    }

    _lessThan (f) {
        return this._cmpOp(f, _renderer_viz_expressions_binary_LessThan__WEBPACK_IMPORTED_MODULE_2__["default"], 'lessThan');
    }

    _lessThanOrEqualTo (f) {
        return this._cmpOp(f, _renderer_viz_expressions_binary_LessThanOrEqualTo__WEBPACK_IMPORTED_MODULE_3__["default"], 'lessThanOrEqualTo');
    }

    _greaterThan (f) {
        return this._cmpOp(f, _renderer_viz_expressions_binary_GreaterThan__WEBPACK_IMPORTED_MODULE_0__["default"], 'greaterThan');
    }

    _greaterThanOrEqualTo (f) {
        return this._cmpOp(f, _renderer_viz_expressions_binary_GreaterThanOrEqualTo__WEBPACK_IMPORTED_MODULE_1__["default"], 'greaterThanOrEqualTo');
    }

    _equals (f) {
        return this._cmpOp(f, _renderer_viz_expressions_binary_Equals__WEBPACK_IMPORTED_MODULE_6__["default"], 'equals');
    }

    _notEquals (f) {
        return this._cmpOp(f, _renderer_viz_expressions_binary_NotEquals__WEBPACK_IMPORTED_MODULE_7__["default"], 'notEquals');
    }

    _cmpOp (f, opClass, type) {
        if (f.isA(opClass)) {
            let a = this._property(f.a) || this._value(f.a);
            let b = this._property(f.b) || this._value(f.b);
            if (a && b) {
                return {
                    type: type,
                    left: a,
                    right: b
                };
            }
        }
    }

    _blend (f) {
        if (f.isA(_renderer_viz_expressions_blend__WEBPACK_IMPORTED_MODULE_11__["default"]) && f.originalMix.isA(_renderer_viz_expressions_transition__WEBPACK_IMPORTED_MODULE_12__["default"])) {
            return this._filter(f.b);
        }
    }

    _property (f) {
        if (f.isA(_renderer_viz_expressions_basic_property__WEBPACK_IMPORTED_MODULE_10__["default"])) {
            return {
                type: 'property',
                property: f.name
            };
        }
    }

    _value (f) {
        if (f.isA(_renderer_viz_expressions_basic_number__WEBPACK_IMPORTED_MODULE_13__["default"]) || f.isA(_renderer_viz_expressions_basic_constant__WEBPACK_IMPORTED_MODULE_14__["default"]) || f.isA(_renderer_viz_expressions_basic_category__WEBPACK_IMPORTED_MODULE_15__["default"])) {
            return {
                type: 'value',
                value: f.value
            };
        }
    }

    _in (f) {
        if (f.isA(_renderer_viz_expressions_belongs__WEBPACK_IMPORTED_MODULE_8__["In"])) {
            let p = this._property(f.input);
            let values = f.list.elems.map(cat => this._value(cat));
            if (p && values.length > 0 && values.length === f.list.elems.length) {
                return {
                    type: 'in',
                    property: p.property,
                    values: values.map(v => v.value)
                };
            }
        }
    }

    _notIn (f) {
        if (f.isA(_renderer_viz_expressions_belongs__WEBPACK_IMPORTED_MODULE_8__["Nin"])) {
            let p = this._property(f.input);
            let values = f.list.elems.map(cat => this._value(cat));
            if (p && values.length > 0 && values.length === f.list.elems.length) {
                return {
                    type: 'notIn',
                    property: p.property,
                    values: values.map(v => v.value)
                };
            }
        }
    }

    _between (f) {
        if (f.isA(_renderer_viz_expressions_between__WEBPACK_IMPORTED_MODULE_9__["default"])) {
            let p = this._property(f.input);
            let lo = this._value(f.lowerLimit);
            let hi = this._value(f.upperLimit);
            if (p && lo && hi) {
                return {
                    type: 'between',
                    property: p.property,
                    lower: lo.value,
                    upper: hi.value
                };
            }
        }
    }
}

function getSQL (node) {
    if (node.type) {
        return `(${SQLGenerators[node.type](node)})`;
    }
    return sqlQ(node);
}

function sqlQ (value) {
    if (isFinite(value)) {
        return String(value);
    }
    return `'${value.replace(/\'/g, '\'\'')}'`;
}

function sqlId (id) {
    if (!id.match(/^[a-z\d_]+$/)) {
        id = `"${id.replace(/\"/g, '""')}"`;
    }
    return id;
}

function sqlSep (sep, ...args) {
    return args.map(arg => getSQL(arg)).join(sep);
}

const SQLGenerators = {
    'and': f => sqlSep(' AND ', f.left, f.right),
    'or': f => sqlSep(' OR ', f.left, f.right),
    'between': f => `${sqlId(f.property)} BETWEEN ${sqlQ(f.lower)} AND ${sqlQ(f.upper)}`,
    'in': f => `${sqlId(f.property)} IN (${sqlSep(',', ...f.values)})`,
    'notIn': f => `${sqlId(f.property)} NOT IN (${sqlSep(',', ...f.values)})`,
    'equals': f => sqlSep(' = ', f.left, f.right),
    'notEquals': f => sqlSep(' <> ', f.left, f.right),
    'lessThan': f => sqlSep(' < ', f.left, f.right),
    'lessThanOrEqualTo': f => sqlSep(' <= ', f.left, f.right),
    'greaterThan': f => sqlSep(' > ', f.left, f.right),
    'greaterThanOrEqualTo': f => sqlSep(' >= ', f.left, f.right),
    'property': f => sqlId(f.property),
    'value': f => sqlQ(f.value)
};

/**
 * Returns supported windshaft filters for the viz
 * @param {*} viz
 * @returns {Filtering}
 */
function getFiltering (viz, options = {}) {
    const aggrFiltering = new AggregationFiltering(options);
    const preFiltering = new PreaggregationFiltering(options);
    const filtering = {
        preaggregation: preFiltering.getFilter(viz.filter),
        aggregation: aggrFiltering.getFilters(viz.filter)
    };
    if (!filtering.preaggregation && !filtering.aggregation) {
        return null;
    }
    return filtering;
}

/**
 * Convert preaggregation filters (as generated by PreaggregationFiltering)
 * into an equivalent SQL WHERE expression.
 *
 * @param {Filtering} filtering
 */
function getSQLWhere (filtering) {
    filtering = filtering && filtering.preaggregation;
    let sql;
    if (filtering && Object.keys(filtering).length > 0) {
        sql = getSQL(filtering);
    }
    return sql ? 'WHERE ' + sql : '';
}

function getAggregationFilters (filtering) {
    return filtering && filtering.aggregation;
}


/***/ }),

/***/ "./src/client/windshaft.js":
/*!*********************************!*\
  !*** ./src/client/windshaft.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Windshaft; });
/* harmony import */ var _sources_MVT__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sources/MVT */ "./src/sources/MVT.js");
/* harmony import */ var _WindshaftMetadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WindshaftMetadata */ "./src/client/WindshaftMetadata.js");
/* harmony import */ var _renderer_Metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/Metadata */ "./src/renderer/Metadata.js");
/* harmony import */ var _renderer_schema__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../renderer/schema */ "./src/renderer/schema.js");
/* harmony import */ var _windshaft_filtering__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./windshaft-filtering */ "./src/client/windshaft-filtering.js");
/* harmony import */ var _WindshaftRequestHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WindshaftRequestHelper */ "./src/client/WindshaftRequestHelper.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../errors/carto-maps-api-error */ "./src/errors/carto-maps-api-error.js");
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/geometry */ "./src/utils/geometry.js");
/* harmony import */ var _constants_metadata__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../constants/metadata */ "./src/constants/metadata.js");













const SAMPLE_ROWS = 1000;
const MIN_FILTERING = 2000000;
const MAX_CATEGORIES = 32768;
const TILE_EXTENT = 2048;

class Windshaft {
    constructor (source) {
        this._source = source;
        this._exclusive = true;

        this._MNS = null;
        this.inProgressInstantiations = {};
    }

    bindLayer (addDataframe) {
        this._addDataframe = addDataframe;
        this._mvtClient.bindLayer(addDataframe);
    }

    _getInstantiationID (vizInfo, choices) {
        const { MNS, resolution, filtering } = vizInfo;

        return JSON.stringify({
            MNS: _renderer_schema__WEBPACK_IMPORTED_MODULE_3__["default"].simplify(MNS),
            resolution,
            filtering: choices.backendFilters ? filtering : null,
            options: choices
        });
    }

    /**
     * Should be called whenever the viz changes, even if metadata is not going to be used.
     * This not only computes metadata: it also updates the map (instantiates) for the new viz if needed
     * Returns  a promise to a Metadata
     * @param {*} viz
     */
    async getMetadata (viz) {
        const vizInfo = this._getServerInfoFrom(viz);

        if (this._needToInstantiateMap(vizInfo)) {
            const instantiationData = await this._repeatableInstantiate(vizInfo);
            this._updateStateAfterInstantiating(instantiationData);
        }

        return this.metadata;
    }

    /**
     * Get relevant info from Viz related to windshaft requests
     */
    _getServerInfoFrom (viz) {
        const MNS = this._getMinNeededSchemaFrom(viz);
        const resolution = viz.resolution.value;
        const filtering = _windshaft_filtering__WEBPACK_IMPORTED_MODULE_4__["getFiltering"](viz, { exclusive: this._exclusive });

        // TODO: properly document returned output at jsdoc (with typedef?)
        const vizInfo = { MNS, resolution, filtering }; // TODO this looks like a Type or even a Class
        return vizInfo;
    }

    /**
     * Get the minimum schema from the viz, validated and with DEFAULT_ID_PROPERTY
    */
    _getMinNeededSchemaFrom (viz) {
        const MNS = viz.getMinimumNeededSchema();
        this._checkAcceptableMNS(MNS);
        this._forceIncludeCartodbId(MNS);

        return MNS;
    }

    _forceIncludeCartodbId (MNS) {
        // Force to include DEFAULT_ID_PROPERTY in the MNS columns.
        // TODO: revisit this request to Maps API
        if (!MNS[_renderer_Metadata__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_ID_PROPERTY"]]) {
            MNS[_renderer_Metadata__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_ID_PROPERTY"]] = [{ type: _constants_metadata__WEBPACK_IMPORTED_MODULE_9__["aggregationTypes"].UNAGGREGATED }];
        }
    }

    requiresNewMetadata (viz) {
        const vizInfo = this._getServerInfoFrom(viz);
        return this._needToInstantiateMap(vizInfo);
    }

    _checkAcceptableMNS (MNS) {
        Object.keys(MNS).forEach(propertyName => {
            const usages = MNS[propertyName];
            const aggregatedUsage = usages.some(x => x.type === _constants_metadata__WEBPACK_IMPORTED_MODULE_9__["aggregationTypes"].AGGREGATED);
            const unAggregatedUsage = usages.some(x => x.type === _constants_metadata__WEBPACK_IMPORTED_MODULE_9__["aggregationTypes"].UNAGGREGATED);
            if (aggregatedUsage && unAggregatedUsage) {
                const aggregationUssages = JSON.stringify(usages.filter(x => x.type !== 'aggregated'));
                throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["default"](
                    `Incompatible combination of cluster aggregation usages (${aggregationUssages}) with unaggregated usage for property '${propertyName}'`,
                    _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["CartoValidationErrorTypes"].INCORRECT_VALUE
                );
            }
        });
    }

    /**
     * After calling getMetadata(), data for a viewport can be obtained with this function.
     * So long as the viz doesn't change, getData() can be called repeatedly for different
     * viewports. If viz changes getMetadata() should be called before requesting data
     * for the new viz.
     */
    getData (zoom, viewport) {
        if (this._mvtClient) {
            return this._mvtClient.requestData(zoom, viewport);// FIXME extend
        }
    }

    /**
     * Check if the map needs to be reinstantiated
     * This happens:
     *  - When the minimun required schema changed.
     *  - When the resolution changed.
     *  - When the filter conditions changed and the dataset should be server-filtered.
     */
    _needToInstantiateMap (vizInfo) {
        const { MNS, resolution, filtering } = vizInfo;

        const schemaChanged = _renderer_schema__WEBPACK_IMPORTED_MODULE_3__["default"].notEquals(this._MNS, MNS);
        const resolutionChanged = this.resolution !== resolution;
        const filteringChanged = JSON.stringify(this.filtering) !== JSON.stringify(filtering);
        const shouldBeServerFiltered = this.metadata && (this.metadata.featureCount > MIN_FILTERING);

        return schemaChanged || resolutionChanged || (filteringChanged && shouldBeServerFiltered);
    }

    _isInstantiated () {
        return !!this.metadata;
    }

    _instantiationChoices (metadata) {
        let choices = {
            backendFilters: true // default choices
        };

        const thereAreFeatures = metadata && metadata.featureCount >= 0;
        if (thereAreFeatures) {
            const shouldBeServerFiltered = metadata.featureCount > MIN_FILTERING;
            choices.backendFilters = shouldBeServerFiltered || !metadata.backendFiltersApplied;
        }

        return choices;
    }

    async _instantiateUncached (vizInfo, choices = { backendFilters: true }, overrideMetadata = null) {
        const { MNS, resolution, filtering } = vizInfo;

        const agg = await this._generateAggregation(MNS, resolution);
        let select = this._buildSelectClause(MNS);
        let aggSQL = this._buildQuery(select);

        const query = `(${aggSQL}) AS tmp`;

        let backendFilters = choices.backendFilters ? filtering : null;
        let backendFiltersApplied = false;
        if (backendFilters && this._requiresAggregation(MNS)) {
            agg.filters = _windshaft_filtering__WEBPACK_IMPORTED_MODULE_4__["getAggregationFilters"](backendFilters);
            if (agg.filters) {
                backendFiltersApplied = true;
            }
            if (!this._exclusive) {
                backendFilters = null;
            }
        }
        if (backendFilters) {
            const filteredSQL = this._buildQuery(select, backendFilters);
            backendFiltersApplied = backendFiltersApplied || filteredSQL !== aggSQL;
            aggSQL = filteredSQL;
        }

        const conf = this._getConfig();
        let { urlTemplates, metadata } = await this._getInstantiationPromise(query, conf, agg, aggSQL, select, overrideMetadata, MNS);
        metadata.backendFiltersApplied = backendFiltersApplied;

        return { MNS, resolution, filtering, metadata, urlTemplates };
    }

    _updateStateAfterInstantiating ({ MNS, resolution, filtering, metadata, urlTemplates }) {
        if (this._mvtClient) {
            this._mvtClient.free();
        }
        metadata.extent = TILE_EXTENT;
        this._mvtClient = new _sources_MVT__WEBPACK_IMPORTED_MODULE_0__["default"](urlTemplates, metadata);
        this._mvtClient._workerName = 'windshaft';
        this._mvtClient.bindLayer(this._addDataframe);
        this.urlTemplates = urlTemplates;
        this.metadata = metadata;
        this._MNS = MNS;
        this.filtering = filtering;
        this.resolution = resolution;
        this._checkLayerMeta(MNS);
    }

    async _instantiate (vizInfo, choices, metadata) {
        const id = this._getInstantiationID(vizInfo, choices);
        if (this.inProgressInstantiations[id]) {
            return this.inProgressInstantiations[id];
        }

        const instantiationPromise = this._instantiateUncached(vizInfo, choices, metadata);
        this.inProgressInstantiations[id] = instantiationPromise;
        return instantiationPromise;
    }

    async _repeatableInstantiate (vizInfo) {
        // TODO: we shouldn't reinstantiate just to not apply backend filters
        // (we'd need to add a choice comparison function argument to repeatablePromise)
        let finalMetadata = null;
        const initialChoices = this._instantiationChoices(this.metadata);
        const finalChoices = instantiation => {
            // first instantiation metadata is kept
            finalMetadata = instantiation.metadata;
            return this._instantiationChoices(instantiation.metadata);
        };

        return repeatablePromise(initialChoices, finalChoices, choices => this._instantiate(vizInfo, choices, finalMetadata));
    }

    _checkLayerMeta (MNS) {
        if (!this._isAggregated() && this._requiresAggregation(MNS)) {
            throw new _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_7__["default"]('Aggregation not supported for this dataset', _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_7__["CartoMapsAPIErrorTypes"].NOT_SUPPORTED);
        }
    }

    _isAggregated () {
        return this.metadata && this.metadata.isAggregated;
    }

    _requiresAggregation (MNS) {
        return Object.values(MNS).some(propertyUsages =>
            propertyUsages.some(u => u.type === _constants_metadata__WEBPACK_IMPORTED_MODULE_9__["aggregationTypes"].AGGREGATED)
        );
    }

    _generateAggregation (MNS, resolution) {
        let aggregation = {
            columns: {},
            dimensions: {},
            placement: 'centroid',
            resolution: resolution,
            threshold: 1
        };

        Object.keys(MNS)
            .forEach(propertyName => {
                if (propertyName !== _renderer_Metadata__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_ID_PROPERTY"]) {
                    const propertyUsages = MNS[propertyName];
                    propertyUsages.forEach(usage => {
                        if (usage.type === 'aggregated') {
                            aggregation.columns[_renderer_schema__WEBPACK_IMPORTED_MODULE_3__["default"].column.aggColumn(propertyName, usage.op)] = {
                                aggregate_function: usage.op,
                                aggregated_column: propertyName
                            };
                        } else if (usage.type === 'dimension') {
                            const dimension = usage.dimension;
                            const { group, format } = dimension;
                            const parameters = { column: propertyName, group, format };
                            aggregation.dimensions[dimension.propertyName] = parameters;
                        } else {
                            // automatic ungrouped dimension
                            // TODO:
                            // we should consider eliminating this and requiring
                            // all dimensions to be used through clusterXXX functions
                            aggregation.dimensions[propertyName] = {
                                column: propertyName
                            };
                        }
                    });
                }
            });

        return aggregation;
    }

    _buildSelectClause (MNS) {
        const columns = Object.keys(MNS).concat(['the_geom_webmercator', _renderer_Metadata__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_ID_PROPERTY"]]);
        return columns.filter((item, pos) => columns.indexOf(item) === pos); // get unique values
    }

    _buildQuery (select, filters) {
        const columns = select.map(column => `"${column}"`).join();
        const condition = filters ? _windshaft_filtering__WEBPACK_IMPORTED_MODULE_4__["getSQLWhere"](filters) : '';
        return `SELECT ${columns} FROM ${this._source._getFromClause()} ${condition}`;
    }

    _getConfig () {
        return {
            apiKey: this._source._apiKey,
            username: this._source._username,
            serverURL: this._source._serverURL
        };
    }

    free () {
        if (this._mvtClient) {
            this._mvtClient.free();
        }
    }

    async _getInstantiationPromise (query, conf, agg, aggSQL, columns, overrideMetadata, MNS) {
        const mapConfigAgg = this._getMapConfigAgg(agg, aggSQL);
        if (!overrideMetadata) {
            this._completeMapConfigWithColumns(mapConfigAgg, columns);
        }

        const layergroup = await this._getLayerGroupFromWindshaft(conf, mapConfigAgg);

        return {
            urlTemplates: layergroup.metadata.tilejson.vector.tiles,
            metadata: overrideMetadata || this._adaptMetadata(layergroup.metadata.layers[0].meta, agg, MNS)
        };
    }

    _getMapConfigAgg (agg, aggSQL) {
        const mapConfigAgg = {
            buffersize: {
                mvt: 1
            },
            layers: [
                {
                    type: 'mapnik',
                    options: {
                        sql: aggSQL,
                        aggregation: agg,
                        vector_extent: TILE_EXTENT,
                        vector_simplify_extent: TILE_EXTENT,
                        dates_as_numbers: true
                    }
                }
            ]
        };
        return mapConfigAgg;
    }

    _completeMapConfigWithColumns (mapConfigAgg, columns) {
        const excludedColumns = ['the_geom', 'the_geom_webmercator'];
        const includedColumns = columns.filter(name => !excludedColumns.includes(name));
        mapConfigAgg.layers[0].options.metadata = {
            geometryType: true,
            columnStats: {
                topCategories: MAX_CATEGORIES,
                includeNulls: true
            },
            dimensions: true,
            sample: {
                num_rows: SAMPLE_ROWS,
                include_columns: includedColumns // TODO: when supported by Maps API: exclude_columns: excludedColumns
            }
        };
    }

    async _getLayerGroupFromWindshaft (conf, mapConfigAgg) {
        const requestHelper = new _WindshaftRequestHelper__WEBPACK_IMPORTED_MODULE_5__["default"](conf, mapConfigAgg);
        return requestHelper.getLayerGroup();
    }

    _adaptMetadata (meta, agg, MNS) {
        meta.datesAsNumbers = meta.dates_as_numbers;
        const { stats, aggregation, datesAsNumbers } = meta;
        const featureCount = stats.hasOwnProperty('featureCount') ? stats.featureCount : stats.estimatedFeatureCount;
        const geomType = stats.geometryType && adaptGeometryType(stats.geometryType);

        const properties = stats.columns;
        Object.keys(agg.columns).forEach(aggName => {
            const basename = agg.columns[aggName].aggregated_column;
            const fnName = agg.columns[aggName].aggregate_function;

            if (!properties[basename].aggregations) {
                properties[basename].aggregations = {};
            }

            properties[basename].aggregations[fnName] = aggName;

            if (basename !== aggName) {
                properties[aggName] = JSON.parse(JSON.stringify(properties[basename]));
            }
        });

        Object.keys(agg.dimensions).forEach(dimName => {
            const dimension = agg.dimensions[dimName];
            if (stats.dimensions && stats.dimensions[dimName].type) {
                // otherwise, the dimension is a (legacy) ungrouped dimension
                const dimensionStats = stats.dimensions[dimName];
                const dimType = adaptColumnType(dimensionStats.type);
                const { column, ...params } = dimension;
                if (properties[column].dimension) {
                    throw new _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_7__["default"](`Multiple dimensions based on same column '${column}'.`, _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_7__["CartoMapsAPIErrorTypes"].NOT_SUPPORTED);
                }
                properties[column].dimension = {
                    propertyName: dimName,
                    grouping: Object.keys(params).length === 0 ? undefined : dimensionStats.params,
                    type: dimType,
                    // TODO: merge all properties of dimensionStats except params, type
                    min: dimensionStats.min,
                    max: dimensionStats.max
                };
                const range = MNS[column].some(c => c.range);

                if (range > 0) {
                    properties[column].dimension.range = ['start', 'end'].map(mode => `${dimName}_${mode}`);
                }
            }
        });

        Object.values(properties).map(property => {
            property.type = adaptColumnType(property.type);
        });

        Object.keys(properties).forEach(propertyName => {
            const property = properties[propertyName];
            if (property.type === 'category' && property.categories) {
                property.categories.forEach(category => {
                    category.name = category.category;
                    delete category.category;
                });
            } else if (datesAsNumbers && datesAsNumbers.includes(propertyName)) {
                property.type = 'date';
            }
        });

        if (geomType === _utils_geometry__WEBPACK_IMPORTED_MODULE_8__["GEOMETRY_TYPE"].POINT) {
            properties[_constants_metadata__WEBPACK_IMPORTED_MODULE_9__["CLUSTER_FEATURE_COUNT"]] = { type: 'number' };
        }

        return new _WindshaftMetadata__WEBPACK_IMPORTED_MODULE_1__["default"]({
            properties,
            featureCount,
            sample: stats.sample,
            geomType,
            isAggregated: aggregation.mvt,
            idProperty: _renderer_Metadata__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_ID_PROPERTY"]
        });
    }
}

function adaptGeometryType (type) {
    switch (type) {
        case 'ST_MultiPolygon':
        case 'ST_Polygon':
            return _utils_geometry__WEBPACK_IMPORTED_MODULE_8__["GEOMETRY_TYPE"].POLYGON;
        case 'ST_Point':
            return _utils_geometry__WEBPACK_IMPORTED_MODULE_8__["GEOMETRY_TYPE"].POINT;
        case 'ST_MultiLineString':
        case 'ST_LineString':
            return _utils_geometry__WEBPACK_IMPORTED_MODULE_8__["GEOMETRY_TYPE"].LINE;
        default:
            throw new _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_7__["default"](`Unimplemented geometry type '${type}'.`, _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_7__["CartoMapsAPIErrorTypes"].NOT_SUPPORTED);
    }
}

function adaptColumnType (type) {
    if (type === 'string') {
        return 'category';
    }
    return type;
}

// generate a promise under certain assumptions/choices; then if the result changes the assumptions,
// repeat the generation with the new information
async function repeatablePromise (initialAssumptions, assumptionsFromResult, promiseGenerator) {
    let promise = promiseGenerator(initialAssumptions);
    let result = await promise;
    let finalAssumptions = assumptionsFromResult(result);
    if (JSON.stringify(initialAssumptions) === JSON.stringify(finalAssumptions)) {
        return promise;
    } else {
        return promiseGenerator(finalAssumptions);
    }
}


/***/ }),

/***/ "./src/codecs/Base.js":
/*!****************************!*\
  !*** ./src/codecs/Base.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BaseCodec; });
// A Dataframe property Codec is used to transform between property value encodings.
// Three different encodings are handled:
// * The `source` encoding correspond to the format in which
//   the property values appear in the data sources (e.g. in MVT)
// * The `internal` encoding is used in Dataframe properties
//   apt for GPU consumption.
// * The `external` encoding is the format in which feature
//   properties are presented to the user
//   (e.g. `property.eval(feature)` or `globalMin(property)`)
// The Codec base class serves both as a base for derived codecs.
// Codecs are associated to source properties.
// There are two kind of codecs:
// * Scalar (simple) encoder: source value is encoded as a single internal value
// * Range encoder: a source value encodes as a pair [lo, hi] of values.
class BaseCodec {
    constructor (metadata, propertyName) {
        if (metadata && propertyName) {
            this._baseName = metadata.baseName(propertyName);
        }
    }

    isRange () {
        return false;
    }

    isIdentity () {
        return false;
    }

    // Convert source encoding to internal;
    // Result is an array [lo, hi] for ranges and a value for scalar codecs
    // Used to encode sources into dataframe properties.
    sourceToInternal (metadata, v) {
        return v;
    }

    // Convert internal encoding to external;
    // Input may be one for scalar, or two values (hi, lo) for ranges.
    // Used to present dataframe features.
    internalToExternal (metadata, v) {
        return v;
    }

    // Convert external encoding back to source values.
    // Used to generate SQL filters: (apply to constant/global)
    externalToSource (metadata, v) {
        return v;
    }

    // Convert source encoding to external encoding.
    // Used to present source stats values (global aggregations)
    // to match the format of constant expressions.
    sourceToExternal (metadata, v) {
        return this.internalToExternal(metadata, this.sourceToInternal(metadata, v));
    }

    // Convert external to internal encoding.
    // Result is a value for scalar codecs
    // and [lo, hi] for range codecs.
    // used to to apply filters in GLSL inlined code;
    // evaluate binary operations property vs external (constant/global
    externalToInternal (metadata, v) {
        return this.sourceToInternal(metadata, this.externalToSource(metadata, v));
    }

    // Generate GLSL inline expression to map a property value
    // to the internal encoding of another property.
    // Used to bind some binary operations between properties.
    inlineInternalMatch (thisValue, _otherCodec) {
        return `${thisValue}`;
    }
}


/***/ }),

/***/ "./src/codecs/Category.js":
/*!********************************!*\
  !*** ./src/codecs/Category.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CategoryCodec; });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base */ "./src/codecs/Base.js");


class CategoryCodec extends _Base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    sourceToInternal (metadata, propertyValue) {
        return metadata.categorizeString(this._baseName, propertyValue);
    }

    internalToExternal (metadata, propertyValue) {
        return metadata.IDToCategory.get(propertyValue);
    }

    sourceToExternal (metadata, propertyValue) {
        return propertyValue;
    }

    externalToSource (metadata, v) {
        return v;
    }
}


/***/ }),

/***/ "./src/codecs/Date.js":
/*!****************************!*\
  !*** ./src/codecs/Date.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DateCodec; });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base */ "./src/codecs/Base.js");
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/util */ "./src/utils/util.js");



class DateCodec extends _Base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (metadata, propertyName) {
        super(metadata, propertyName);

        const { min } = metadata.stats(propertyName);
        this._min_date = _utils_util__WEBPACK_IMPORTED_MODULE_1__["castDate"](min);
        this._min_ms = this._min_date.getTime();
    }

    sourceToInternal (metadata, propertyValue) {
        // numbers (epoch in milliseconds) or Dates are accepted
        return _utils_util__WEBPACK_IMPORTED_MODULE_1__["castDate"](propertyValue).getTime() - this._min_ms;
    }

    internalToExternal (metadata, propertyValue) {
        let value = propertyValue;
        value += this._min_ms;
        return _utils_util__WEBPACK_IMPORTED_MODULE_1__["msToDate"](value);
    }

    externalToSource (metadata, v) {
        return v.getTime();
    }

    sourceToExternal (metadata, v) {
        return _utils_util__WEBPACK_IMPORTED_MODULE_1__["castDate"](v);
    }

    inlineInternalMatch (thisValue, otherCodec) {
        const offset = otherCodec._min_ms - this._min_ms;
        return `(${thisValue}-${offset.toFixed(20)})`;
    }
}


/***/ }),

/***/ "./src/codecs/Identity.js":
/*!********************************!*\
  !*** ./src/codecs/Identity.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IdentityCodec; });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base */ "./src/codecs/Base.js");


// The Identity codec class serves
// as the default, identity encoding, in which all three
// encodings are exactly the same.
class IdentityCodec extends _Base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    isIdentity () {
        return true;
    }

    sourceToInternal (metadata, v) {
        return v;
    }

    internalToExternal (metadata, v) {
        return v;
    }

    sourceToExternal (metadata, v) {
        return v;
    }

    externalToSource (metadata, v) {
        return v;
    }

    externalToInternal (metadata, v) {
        return v;
    }
}


/***/ }),

/***/ "./src/codecs/Number.js":
/*!******************************!*\
  !*** ./src/codecs/Number.js ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NumberCodec; });
/* harmony import */ var _Identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Identity */ "./src/codecs/Identity.js");
/* harmony import */ var _renderer_viz_expressions_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/viz/expressions/constants */ "./src/renderer/viz/expressions/constants.js");



class NumberCodec extends _Identity__WEBPACK_IMPORTED_MODULE_0__["default"] {
    sourceToInternal (metadata, propertyValue) {
        if (isNaN(propertyValue) || propertyValue == null) {
            propertyValue = _renderer_viz_expressions_constants__WEBPACK_IMPORTED_MODULE_1__["FP32_DESIGNATED_NULL_VALUE"];
        }
        return propertyValue;
    }

    internalToExternal (metadata, value) {
        if (value === _renderer_viz_expressions_constants__WEBPACK_IMPORTED_MODULE_1__["FP32_DESIGNATED_NULL_VALUE"]) {
            value = null;
        }
        return value;
    }

    externalToInternal (metadata, value) {
        if (value === null) {
            value = _renderer_viz_expressions_constants__WEBPACK_IMPORTED_MODULE_1__["FP32_DESIGNATED_NULL_VALUE"];
        }
        return value;
    }
}


/***/ }),

/***/ "./src/codecs/index.js":
/*!*****************************!*\
  !*** ./src/codecs/index.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return codecFactory; });
/* harmony import */ var _Number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Number */ "./src/codecs/Number.js");
/* harmony import */ var _Category__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Category */ "./src/codecs/Category.js");
/* harmony import */ var _Date__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Date */ "./src/codecs/Date.js");
/* harmony import */ var _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors/carto-runtime-error */ "./src/errors/carto-runtime-error.js");





function codecFactory (metadata, type, propertyName) {
    switch (type) {
        case 'number':
            return new _Number__WEBPACK_IMPORTED_MODULE_0__["default"](metadata, propertyName);
        case 'category':
            return new _Category__WEBPACK_IMPORTED_MODULE_1__["default"](metadata, propertyName);
        case 'date':
            return new _Date__WEBPACK_IMPORTED_MODULE_2__["default"](metadata, propertyName);
        default:
            throw new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_3__["default"](
                `Feature property value of type '${type}' cannot be decoded.`,
                _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_3__["CartoRuntimeErrorTypes"].NOT_SUPPORTED
            );
    }
}


/***/ }),

/***/ "./src/codecs/mvt/Category.js":
/*!************************************!*\
  !*** ./src/codecs/mvt/Category.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MVTCategoryCodec; });
/* harmony import */ var _Category__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Category */ "./src/codecs/Category.js");
/* harmony import */ var _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../errors/carto-runtime-error */ "./src/errors/carto-runtime-error.js");



class MVTCategoryCodec extends _Category__WEBPACK_IMPORTED_MODULE_0__["default"] {
    sourceToInternal (metadata, propertyValue) {
        const propertyValueType = typeof propertyValue;
        if (propertyValue !== null && propertyValueType !== 'undefined' && propertyValueType !== 'string') {
            // In general Codecs are unique per original base property, not per source property,
            // but for the generic MVT sources we don't support multiple source properties per base property (e.g. aggregations)
            // so it would suffice to keep the property name in the Codec class.
            // For more general solutions we'd need to provide the source property name as an argument to this method.
            throw new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_1__["default"](
                `MVT decoding error. Metadata property '${this._baseName}' is of type 'category' but the MVT tile contained a feature property of type '${propertyValueType}': '${propertyValue}'`,
                _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_1__["CartoRuntimeErrorTypes"].MVT
            );
        }
        return super.sourceToInternal(metadata, propertyValue);
    }
}


/***/ }),

/***/ "./src/codecs/mvt/Number.js":
/*!**********************************!*\
  !*** ./src/codecs/mvt/Number.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MVTNumberCodec; });
/* harmony import */ var _Number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Number */ "./src/codecs/Number.js");
/* harmony import */ var _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../errors/carto-runtime-error */ "./src/errors/carto-runtime-error.js");



class MVTNumberCodec extends _Number__WEBPACK_IMPORTED_MODULE_0__["default"] {
    sourceToInternal (metadata, propertyValue) {
        const propertyValueType = typeof propertyValue;
        if (propertyValue !== null && propertyValueType !== 'undefined' && propertyValueType !== 'number') {
            throw new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_1__["default"](
                `MVT decoding error. Metadata property '${this._baseName}' is of type 'number' but the MVT tile contained a feature property of type '${propertyValueType}': '${propertyValue}'`,
                _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_1__["CartoRuntimeErrorTypes"].MVT
            );
        }
        return super.sourceToInternal(metadata, propertyValue);
    }
}


/***/ }),

/***/ "./src/codecs/mvt/index.js":
/*!*********************************!*\
  !*** ./src/codecs/mvt/index.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MVTCodecFactory; });
/* harmony import */ var _Number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Number */ "./src/codecs/mvt/Number.js");
/* harmony import */ var _Category__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Category */ "./src/codecs/mvt/Category.js");
/* harmony import */ var _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../errors/carto-runtime-error */ "./src/errors/carto-runtime-error.js");




function MVTCodecFactory (metadata, type, propertyName) {
    switch (type) {
        case 'number':
            return new _Number__WEBPACK_IMPORTED_MODULE_0__["default"](metadata, propertyName);
        case 'category':
            return new _Category__WEBPACK_IMPORTED_MODULE_1__["default"](metadata, propertyName);
        default:
            throw new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_2__["default"](
                `MVT decoding error. Feature property value of type '${type}' cannot be decoded.`,
                _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_2__["CartoRuntimeErrorTypes"].MVT
            );
    }
}


/***/ }),

/***/ "./src/codecs/windshaft/TimeRange.js":
/*!*******************************************!*\
  !*** ./src/codecs/windshaft/TimeRange.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TimeRangeCodec; });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Base */ "./src/codecs/Base.js");
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/util */ "./src/utils/util.js");



class TimeRangeCodec extends _Base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (metadata, propertyName) {
        super(metadata, propertyName);

        const stats = metadata.stats(propertyName);
        const { min } = stats;
        const timeZone = stats.grouping && stats.grouping.timezone;
        const timeRange = _utils_util__WEBPACK_IMPORTED_MODULE_1__["timeRange"]({ timeZone, iso: min });

        this._min = timeRange.startValue / 1000;
        this._timeZone = timeZone;
    }

    isRange () {
        return true;
    }

    sourceToInternal (metadata, propertyValue) {
        const timeRange = _utils_util__WEBPACK_IMPORTED_MODULE_1__["timeRange"]({ iso: propertyValue });
        return [timeRange.startValue / 1000, timeRange.endValue / 1000].map(v => (v - this._min));
    }

    internalToExternal (metadata, [lo, hi]) {
        return _utils_util__WEBPACK_IMPORTED_MODULE_1__["timeRange"]({
            start: (lo + this._min) * 1000,
            end: (hi + this._min) * 1000,
            timeZone: this._timeZone
        });
    }

    externalToSource (metadata, v) {
        return _utils_util__WEBPACK_IMPORTED_MODULE_1__["castTimeRange"](v, this._timeZone)._iso;
    }

    sourceToExternal (metadata, v) {
        return _utils_util__WEBPACK_IMPORTED_MODULE_1__["timeRange"]({ iso: v, timeZone: this._timeZone });
    }

    inlineInternalMatch (thisValue, otherCodec) {
        const offset = otherCodec._min.getTime() - this._min.getTime();
        return `(${thisValue}-${offset.toFixed(20)})`;
    }
}


/***/ }),

/***/ "./src/codecs/windshaft/WindshaftDate.js":
/*!***********************************************!*\
  !*** ./src/codecs/windshaft/WindshaftDate.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WindshaftDateCodec; });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Base */ "./src/codecs/Base.js");
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/util */ "./src/utils/util.js");



class WindshaftDateCodec extends _Base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (metadata, propertyName) {
        super(metadata, propertyName);

        const { min } = metadata.stats(propertyName);
        this._min_ms = min * 1000;
        this._min_date = _utils_util__WEBPACK_IMPORTED_MODULE_1__["msToDate"](this._min_ms);
    }

    sourceToInternal (metadata, propertyValue) {
        return _utils_util__WEBPACK_IMPORTED_MODULE_1__["msToDate"](propertyValue * 1000) - this._min_date;
    }

    internalToExternal (metadata, propertyValue) {
        let value = propertyValue;
        value += this._min_ms;
        return _utils_util__WEBPACK_IMPORTED_MODULE_1__["msToDate"](value);
    }

    externalToSource (metadata, v) {
        return v.getTime() / 1000;
    }

    sourceToExternal (metadata, v) {
        return asDate(v);
    }

    inlineInternalMatch (thisValue, otherCodec) {
        const offset = otherCodec._min_ms - this._min_ms;
        return `(${thisValue}-${offset.toFixed(20)})`;
    }
}

// convert seconds epoch (source encoding) or Date to Date
function asDate (value) {
    if (value instanceof Date) {
        return value;
    }
    return _utils_util__WEBPACK_IMPORTED_MODULE_1__["msToDate"](value * 1000);
}


/***/ }),

/***/ "./src/codecs/windshaft/index.js":
/*!***************************************!*\
  !*** ./src/codecs/windshaft/index.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return windshaftCodecFactory; });
/* harmony import */ var _Number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Number */ "./src/codecs/Number.js");
/* harmony import */ var _Category__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Category */ "./src/codecs/Category.js");
/* harmony import */ var _WindshaftDate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WindshaftDate */ "./src/codecs/windshaft/WindshaftDate.js");
/* harmony import */ var _TimeRange__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TimeRange */ "./src/codecs/windshaft/TimeRange.js");
/* harmony import */ var _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../errors/carto-maps-api-error */ "./src/errors/carto-maps-api-error.js");






function windshaftCodecFactory (metadata, type, propertyName) {
    switch (type) {
        case 'number':
            return new _Number__WEBPACK_IMPORTED_MODULE_0__["default"](metadata, propertyName);
        case 'category':
            return new _Category__WEBPACK_IMPORTED_MODULE_1__["default"](metadata, propertyName);
        case 'date':
            return new _WindshaftDate__WEBPACK_IMPORTED_MODULE_2__["default"](metadata, propertyName);
        case 'timerange':
            return new _TimeRange__WEBPACK_IMPORTED_MODULE_3__["default"](metadata, propertyName);
        default:
            throw new _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_4__["default"](
                `Windshaft MVT decoding error. Feature property value of type '${type}' cannot be decoded.`,
                _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_4__["CartoMapsAPIErrorTypes"].NOT_SUPPORTED);
    }
}


/***/ }),

/***/ "./src/constants/layer.js":
/*!********************************!*\
  !*** ./src/constants/layer.js ***!
  \********************************/
/*! exports provided: RESOLUTION_ZOOMLEVEL_ZERO */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RESOLUTION_ZOOMLEVEL_ZERO", function() { return RESOLUTION_ZOOMLEVEL_ZERO; });
const RESOLUTION_ZOOMLEVEL_ZERO = 512;


/***/ }),

/***/ "./src/constants/metadata.js":
/*!***********************************!*\
  !*** ./src/constants/metadata.js ***!
  \***********************************/
/*! exports provided: AGG_PREFIX, DIM_PREFIX, CLUSTER_FEATURE_COUNT, aggregationTypes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AGG_PREFIX", function() { return AGG_PREFIX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DIM_PREFIX", function() { return DIM_PREFIX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CLUSTER_FEATURE_COUNT", function() { return CLUSTER_FEATURE_COUNT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "aggregationTypes", function() { return aggregationTypes; });
const AGG_PREFIX = '_cdb_agg_';
const DIM_PREFIX = '_cdb_dim_';
const CLUSTER_FEATURE_COUNT = '_cdb_feature_count';
const aggregationTypes = {
    AGGREGATED: 'aggregated',
    UNAGGREGATED: 'unaggregated',
    UNKNOWN: 'unknown'
};


/***/ }),

/***/ "./src/constants/viz.js":
/*!******************************!*\
  !*** ./src/constants/viz.js ***!
  \******************************/
/*! exports provided: SUPPORTED_VIZ_PROPERTIES, STYLE_VIZ_PROPERTIES, MIN_RESOLUTION, MAX_RESOLUTION */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SUPPORTED_VIZ_PROPERTIES", function() { return SUPPORTED_VIZ_PROPERTIES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STYLE_VIZ_PROPERTIES", function() { return STYLE_VIZ_PROPERTIES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MIN_RESOLUTION", function() { return MIN_RESOLUTION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MAX_RESOLUTION", function() { return MAX_RESOLUTION; });
const SUPPORTED_VIZ_PROPERTIES = [
    'color',
    'filter',
    'order',
    'resolution',
    'strokeColor',
    'strokeWidth',
    'symbol',
    'symbolPlacement',
    'transform',
    'width'
];

const STYLE_VIZ_PROPERTIES = [
    'color',
    'filter',
    'order',
    'strokeColor',
    'strokeWidth',
    'symbol',
    'symbolPlacement',
    'transform',
    'width'
];

const MIN_RESOLUTION = 0;
const MAX_RESOLUTION = 256;


/***/ }),

/***/ "./src/errors/carto-error.js":
/*!***********************************!*\
  !*** ./src/errors/carto-error.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CartoError; });
/**
 * Represents an error in the carto library.
 *
 * @typedef {Object} CartoError
 * @property {String} message - A short error description
 * @property {String} name - The name of the error "CartoError"
 * @property {String} type - The type of the error "CartoError"
 * @property {Object} originalError - An object containing the internal/original error
 *
 * @event CartoError
 * @api
 */

/**
 * @namespace CartoErrors
 * @api
 *
*/
class CartoError extends Error {
    /**
     * Build a cartoError from a generic error.
     * @constructor
     *
     * @return {CartoError} A well formed object representing the error.
     */
    constructor (error) {
        if (!error) {
            throw Error('Invalid CartoError, a message is mandatory');
        }

        if (!error.message) {
            throw Error('Invalid CartoError, a message is mandatory');
        }

        if (!error.type) {
            throw Error('Invalid CartoError, a type is mandatory');
        }

        super(`${error.type} ${error.message}`);
        this.name = 'CartoError';
        this.type = error.type;
        this.originalError = error;
    }
}


/***/ }),

/***/ "./src/errors/carto-maps-api-error.js":
/*!********************************************!*\
  !*** ./src/errors/carto-maps-api-error.js ***!
  \********************************************/
/*! exports provided: default, CartoMapsAPIErrorTypes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CartoMapsAPIError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CartoMapsAPIErrorTypes", function() { return CartoMapsAPIErrorTypes; });
/* harmony import */ var _carto_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./carto-error */ "./src/errors/carto-error.js");


/**
 * Utility to build a cartoError related to MapsAPI errors.
 *
 * @return {CartoError} A well formed object representing the error.
 */

/**
 * CartoMapsAPIError types:
 * - [Error]
 * - [Not supported]
 * - [Security]
 *
 * @name CartoMapsAPIError
 * @memberof CartoError
 * @api
*/

class CartoMapsAPIError extends _carto_error__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (message, type = CartoMapsAPIErrorTypes.DEFAULT) {
        super({ message, type });
        this.name = 'CartoMapsAPIError';
    }
}

const CartoMapsAPIErrorTypes = {
    DEFAULT: '[Error]',
    SQL: '[SQL]',
    NOT_SUPPORTED: '[Not supported]',
    SECURITY: '[Security]'
};


/***/ }),

/***/ "./src/errors/carto-parsing-error.js":
/*!*******************************************!*\
  !*** ./src/errors/carto-parsing-error.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CartoParsingError; });
/* harmony import */ var _carto_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./carto-error */ "./src/errors/carto-error.js");


/**
 * Utility to build a cartoError related to Parsing errors.
 *
 * @return {CartoError} A well formed object representing the error.
 */

/**
 * CartoParsingError types:
 * - [Error]
 *
 * @name CartoParsingError
 * @memberof CartoError
 * @api
*/

class CartoParsingError extends _carto_error__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (message) {
        const type = '[Error]';
        super({ message, type });
        this.name = 'CartoParsingError';
    }
}


/***/ }),

/***/ "./src/errors/carto-runtime-error.js":
/*!*******************************************!*\
  !*** ./src/errors/carto-runtime-error.js ***!
  \*******************************************/
/*! exports provided: default, CartoRuntimeErrorTypes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CartoRuntimeError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CartoRuntimeErrorTypes", function() { return CartoRuntimeErrorTypes; });
/* harmony import */ var _carto_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./carto-error */ "./src/errors/carto-error.js");


/**
 * Utility to build a cartoError related to Runtime errors.
 *
 * @return {CartoError} A well formed object representing the error.
 */

/**
 * CartoRuntimeError types:
 * - [Error]
 * - [Not supported]
 * - [WebGL]
 * - [MVT]
 *
 * @name CartoRuntimeError
 * @memberof CartoError
 * @api
*/
class CartoRuntimeError extends _carto_error__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (message, type = CartoRuntimeErrorTypes.DEFAULT) {
        super({ message, type });
        this.name = 'CartoRuntimeError';
    }
}

const CartoRuntimeErrorTypes = {
    DEFAULT: '[Error]',
    NOT_SUPPORTED: '[Not supported]',
    WEB_GL: '[WebGL]',
    MVT: '[MVT]'
};


/***/ }),

/***/ "./src/errors/carto-validation-error.js":
/*!**********************************************!*\
  !*** ./src/errors/carto-validation-error.js ***!
  \**********************************************/
/*! exports provided: default, CartoValidationErrorTypes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CartoValidationError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CartoValidationErrorTypes", function() { return CartoValidationErrorTypes; });
/* harmony import */ var _carto_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./carto-error */ "./src/errors/carto-error.js");


/**
 * Utility to build a cartoError related to validation errors.
 *
 * @return {CartoError} A well formed object representing the error.
 */

/**
 * CartoValidationError types:
 * - [Error]
 * - [Missing required property]
 * - [Property with an incorrect type]
 * - [Incorrect value]
 * - [Too many arguments]
 * - [Not enough arguments]
 * - [Wrong number of arguments]
 *
 * @name CartoValidationError
 * @memberof CartoError
 * @api
*/
class CartoValidationError extends _carto_error__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (message, type = CartoValidationErrorTypes.DEFAULT) {
        super({ message, type });
        this.name = 'CartoValidationError';
    }
}

const CartoValidationErrorTypes = {
    DEFAULT: '[Error]',
    MISSING_REQUIRED: '[Missing required property]',
    INCORRECT_TYPE: '[Property with an incorrect type]',
    INCORRECT_VALUE: '[Incorrect value]',
    TOO_MANY_ARGS: '[Too many arguments]',
    NOT_ENOUGH_ARGS: '[Not enough arguments]',
    WRONG_NUMBER_ARGS: '[Wrong number of arguments]'
};


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: version, on, off, isBrowserSupported, unsupportedBrowserReasons, setDefaultAuth, setDefaultConfig, source, expressions, Layer, Viz, Interactivity, basemaps, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "source", function() { return source; });
/* harmony import */ var _setup_auth_service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setup/auth-service */ "./src/setup/auth-service.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setDefaultAuth", function() { return _setup_auth_service__WEBPACK_IMPORTED_MODULE_0__["setDefaultAuth"]; });

/* harmony import */ var _setup_config_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setup/config-service */ "./src/setup/config-service.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setDefaultConfig", function() { return _setup_config_service__WEBPACK_IMPORTED_MODULE_1__["setDefaultConfig"]; });

/* harmony import */ var _Viz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Viz */ "./src/Viz.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Viz", function() { return _Viz__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _interactivity_Interactivity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interactivity/Interactivity */ "./src/interactivity/Interactivity.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Interactivity", function() { return _interactivity_Interactivity__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _Layer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Layer */ "./src/Layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Layer", function() { return _Layer__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./renderer/viz/expressions */ "./src/renderer/viz/expressions.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "expressions", function() { return _renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_5__; });
/* harmony import */ var _sources_Dataset__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./sources/Dataset */ "./src/sources/Dataset.js");
/* harmony import */ var _sources_GeoJSON__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sources/GeoJSON */ "./src/sources/GeoJSON.js");
/* harmony import */ var _sources_MVT__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./sources/MVT */ "./src/sources/MVT.js");
/* harmony import */ var _sources_bigquery_BQTileset__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./sources/bigquery/BQTileset */ "./src/sources/bigquery/BQTileset.js");
/* harmony import */ var _sources_SQL__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./sources/SQL */ "./src/sources/SQL.js");
/* harmony import */ var _utils_events__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/events */ "./src/utils/events.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "on", function() { return _utils_events__WEBPACK_IMPORTED_MODULE_11__["on"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "off", function() { return _utils_events__WEBPACK_IMPORTED_MODULE_11__["off"]; });

/* harmony import */ var _renderer_Renderer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./renderer/Renderer */ "./src/renderer/Renderer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowserSupported", function() { return _renderer_Renderer__WEBPACK_IMPORTED_MODULE_12__["isBrowserSupported"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "unsupportedBrowserReasons", function() { return _renderer_Renderer__WEBPACK_IMPORTED_MODULE_12__["unsupportedBrowserReasons"]; });

/* harmony import */ var _basemaps__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./basemaps */ "./src/basemaps.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "basemaps", function() { return _basemaps__WEBPACK_IMPORTED_MODULE_13__; });
/* harmony import */ var _package_json__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../package.json */ "./package.json");
var _package_json__WEBPACK_IMPORTED_MODULE_14___namespace = /*#__PURE__*/__webpack_require__.t(/*! ../package.json */ "./package.json", 1);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version", function() { return _package_json__WEBPACK_IMPORTED_MODULE_14__["version"]; });

/**
 *  @namespace carto
 *  @api
 *
 *  @description
 *  The CARTO VL functionality is exposed through the **carto** namespace including:
 *
 * Current version:
 * - {@link carto.version|carto.version}
 *
 * Setup:
 * - {@link carto.setDefaultAuth|carto.setDefaultAuth}
 * - {@link carto.setDefaultConfig|carto.setDefaultConfig}
 *
 * CARTO Basemaps:
 * - {@link carto.basemaps.voyager|carto.basemaps.voyager}
 * - {@link carto.basemaps.darkmatter|carto.basemaps.darkmatter}
 * - {@link carto.basemaps.positron|carto.basemaps.positron}
 *
 * Source:
 * - {@link carto.source.Dataset|carto.source.Dataset}
 * - {@link carto.source.GeoJSON|carto.source.GeoJSON}
 * - {@link carto.source.MVT|carto.source.MVT}
 * - {@link carto.source.SQL|carto.source.SQL}
 *
 * Layer:
 * - {@link carto.Layer|carto.Layer}
 *
 * Viz:
 * - {@link carto.Viz|carto.Viz}
 *
 * Expressions:
 * - {@link carto.expressions|carto.expressions}
 *
 * Interactivity:
 * - {@link carto.Interactivity|carto.Interactivity}
 */















/**
 *  @namespace carto.basemaps
 *  @description Use CARTO basemaps for your map visualization. Here you have more information about our {@link https://carto.com/location-data-services/basemaps/|basemaps}.
 *  @api
 */



/**
 * The version of CARTO VL in use as specified in `package.json` and the GitHub release.
 *
 * @var {String} version
 *
 * @memberof carto
 * @api
 */


const source = { Dataset: _sources_Dataset__WEBPACK_IMPORTED_MODULE_6__["default"], SQL: _sources_SQL__WEBPACK_IMPORTED_MODULE_10__["default"], GeoJSON: _sources_GeoJSON__WEBPACK_IMPORTED_MODULE_7__["default"], MVT: _sources_MVT__WEBPACK_IMPORTED_MODULE_8__["default"], BigQueryTileset: _sources_bigquery_BQTileset__WEBPACK_IMPORTED_MODULE_9__["default"] };


/* harmony default export */ __webpack_exports__["default"] = ({ version: _package_json__WEBPACK_IMPORTED_MODULE_14__["version"], on: _utils_events__WEBPACK_IMPORTED_MODULE_11__["on"], off: _utils_events__WEBPACK_IMPORTED_MODULE_11__["off"], setDefaultAuth: _setup_auth_service__WEBPACK_IMPORTED_MODULE_0__["setDefaultAuth"], setDefaultConfig: _setup_config_service__WEBPACK_IMPORTED_MODULE_1__["setDefaultConfig"], source, expressions: _renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_5__, Layer: _Layer__WEBPACK_IMPORTED_MODULE_4__["default"], Viz: _Viz__WEBPACK_IMPORTED_MODULE_2__["default"], Interactivity: _interactivity_Interactivity__WEBPACK_IMPORTED_MODULE_3__["default"], basemaps: _basemaps__WEBPACK_IMPORTED_MODULE_13__ });


/***/ }),

/***/ "./src/interactivity/Interactivity.js":
/*!********************************************!*\
  !*** ./src/interactivity/Interactivity.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Interactivity; });
/* harmony import */ var mitt__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mitt */ "./node_modules/mitt/dist/mitt.es.js");
/* harmony import */ var _Layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Layer */ "./src/Layer.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");




const EVENTS = [
    'featureClick',
    'featureClickOut',
    'featureEnter',
    'featureHover',
    'featureLeave'
];

const MAP_STATE = {
    IDLE: 'idle',
    MOVING: 'moving'
};

class Interactivity {
    /**
    *
    * Interactivity purpose is to allow the reception and management of user-generated events, like clicking, over layer features.
    *
    * To create a Interactivity object a {@link carto.Layer} or an array with several {@link carto.Layer} is required.
    * Events fired from interactivity objects will refer to the features of these layer/s and only these layer/s.
    * Moreover, when using an array of layers, the order of the features in the events will be determined by the order of these layers in the layerList.
    *
    * @param {carto.Layer|carto.Layer[]} layerList - {@link carto.Layer} or array of {@link carto.Layer}, events will be fired based on the features of these layers. The array cannot be empty, and all the layers must be attached to the same map.
    * @param {Object} [options={}] - Object containing interactivity options
    * @param {boolean} [options.autoChangePointer=true] - A boolean flag indicating if the cursor should change when the mouse is over a feature.
    *
    * @example
    * const interactivity = new carto.Interactivity(layer);
    * interactivity.on('click', event => {
    *   style(event.features);
    *   show(event.coordinates);
    * });
    *
    * @fires featureClick
    * @fires featureClickOut
    * @fires featureHover
    * @fires featureEnter
    * @fires featureLeave
    * @throws CartoError
    *
    * @constructor Interactivity
    * @name carto.Interactivity
    * @api
    */
    constructor (layerList, options = { autoChangePointer: true }) {
        if (layerList instanceof _Layer__WEBPACK_IMPORTED_MODULE_1__["default"]) {
            layerList = [layerList]; // Allow one layer as input
        }
        preCheckLayerList(layerList);
        this._init(layerList, options);
    }

    /**
     * Register an event handler for the given type.
     *
     * @param {String} eventName - Type of event to listen for
     * @param {function} callback - Function to call in response to given event, function will be called with a {@link carto.FeatureEvent}
     * @memberof carto.Interactivity
     * @instance
     * @api
     */
    on (eventName, callback) {
        checkEvent(eventName);
        const currentCount = this._numListeners[eventName] || 0;
        this._numListeners[eventName] = currentCount + 1;
        return this._emitter.on(eventName, callback);
    }

    /**
     * Remove an event handler for the given type.
     *
     * @param {String} eventName - Type of event to unregister
     * @param {function} callback - Handler function to unregister
     * @memberof carto.Interactivity
     * @instance
     * @api
     */
    off (eventName, callback) {
        checkEvent(eventName);
        const currentCount = this._numListeners[eventName];
        this._numListeners[eventName] = currentCount - 1;
        return this._emitter.off(eventName, callback);
    }

    /**
    * Interactivity enabled property. When enabled, it can emit events
    *
    * @type {boolean}
    * @memberof carto.Interactivity
    * @instance
    * @api
    */
    get isEnabled () {
        return this._enabled && this._mapState !== MAP_STATE.MOVING;
    }

    /**
     * Change interactivity state to disabled, so no event will be emitted
     *
     * @memberof carto.Interactivity
     * @instance
     * @api
     */
    disable () {
        this._enabled = false;
    }

    /**
     * Change interactivity state to enabled, so events can be emitted
     *
     * @memberof carto.Interactivity
     * @instance
     * @api
     */
    enable () {
        this._enabled = true;
    }

    _init (layerList, options) {
        this._enabled = true;
        this._mapState = MAP_STATE.IDLE;
        this._emitter = Object(mitt__WEBPACK_IMPORTED_MODULE_0__["default"])();
        this._layerList = layerList;
        this._prevHoverFeatures = [];
        this._prevClickFeatures = [];
        this._numListeners = {};
        this._isAutoChangePointerEnabled = options.autoChangePointer;

        const allLayersReadyPromises = layerList.map(layer => layer._context);
        return Promise.all(allLayersReadyPromises)
            .then(() => {
                postCheckLayerList(layerList);
                this._map = layerList[0].map;

                this._subscribeToLayerEvents(layerList);
                this._subscribeToMapEvents(this._map);

                if (this._isAutoChangePointerEnabled) {
                    this._setInteractiveCursor();
                }
            });
    }

    _setInteractiveCursor () {
        if (!this._map.__carto_interactivities) {
            this._map.__carto_interactivities = new Set();
        }
        this.on('featureHover', event => this._onFeatureHover(event, this._map));
    }

    _onFeatureHover (event, map) {
        if (event.features.length) {
            map.__carto_interactivities.add(this);
        } else {
            map.__carto_interactivities.delete(this);
        }
        map.getCanvas().style.cursor = (map.__carto_interactivities.size > 0) ? 'pointer' : '';
    }

    _subscribeToMapEvents (map) {
        this._onMouseMoveBound = this._onMouseMove.bind(this);
        map.on('mousemove', this._onMouseMoveBound);

        this._onClickBound = this._onClick.bind(this);
        map.on('click', this._onClickBound);

        this._disableWhileMovingMap(map);
    }

    _unsubscribeToMapEvents (map) {
        map.off('mousemove', this._onMouseMoveBound);
        map.off('click', this._onClickBound);
    }

    _disableWhileMovingMap (map) {
        map.on('movestart', () => {
            this._setMapState(MAP_STATE.MOVING);
        });

        map.on('moveend', () => {
            this._setMapState(MAP_STATE.IDLE);
        });
    }

    _setMapState (state) {
        this._mapState = state;
    }

    _subscribeToLayerEvents (layers) {
        layers.forEach(layer => {
            layer.on('updated', this._onLayerUpdated.bind(this));
            layer.on('removed', this._onLayerRemoved.bind(this));
        });
    }

    _onLayerUpdated () {
        this._onMouseMove(this._mouseEvent, true);
    }

    _onLayerRemoved (layer) {
        this._removeLayerFromInteractivity(layer);

        if (this._isAutoChangePointerEnabled) {
            this._onFeatureHover({ features: [] }, this._map);
        }

        if (!this._layerList.length) {
            this._unsubscribeToMapEvents(this._map);
        }
    }

    _removeLayerFromInteractivity (layer) {
        const layerIndex = this._layerList.indexOf(layer);

        if (layerIndex === -1) {
            return;
        }

        this._layerList.splice(layerIndex, 1);
    }

    _onMouseMove (event, emulated) {
        // Store mouse event to be used in `onLayerUpdated`
        this._mouseEvent = event;

        if (!this.isEnabled) {
            return;
        }

        if (!event ||
            (!this._numListeners['featureEnter'] &&
                !this._numListeners['featureHover'] &&
                !this._numListeners['featureLeave'])) {
            return;
        }

        const featureEvent = this._createFeatureEvent(event);

        const featuresLeft = this._manageFeatureLeaveEvent(featureEvent);
        const featuresEntered = this._manageFeatureEnterEvent(featureEvent);

        this._prevHoverFeatures = featureEvent.features;
        this._manageFeatureHoverEvent(featureEvent, { featuresLeft, featuresEntered }, emulated);
    }

    _manageFeatureLeaveEvent (featureEvent) {
        const featuresLeft = this._getDiffFeatures(this._prevHoverFeatures, featureEvent.features);
        this._fireEventIfFeatures('featureLeave', { featureEvent, eventFeatures: featuresLeft });
        return featuresLeft;
    }

    _manageFeatureEnterEvent (featureEvent) {
        const featuresEntered = this._getDiffFeatures(featureEvent.features, this._prevHoverFeatures);
        this._fireEventIfFeatures('featureEnter', { featureEvent, eventFeatures: featuresEntered });
        return featuresEntered;
    }

    _manageFeatureHoverEvent (featureEvent, { featuresLeft, featuresEntered }, emulated) {
        // If the event comes from a real mouse move, trigger always (because coordinates and position have changed)
        // If the event comes from an animated event, trigger only when features have changed (because position is the same)
        if (!emulated || (emulated && (featuresLeft.length || featuresEntered.length))) {
            // Launch hover event
            this._fireEvent('featureHover', featureEvent);
        }
    }

    _fireEventIfFeatures (eventName, { featureEvent, eventFeatures }) {
        if (eventFeatures.length > 0) {
            this._fireEvent(eventName, {
                coordinates: featureEvent.coordinates,
                position: featureEvent.position,
                features: eventFeatures
            });
        }
    }

    _onClick (event) {
        if (!this.isEnabled) {
            return;
        }

        if (!this._numListeners['featureClick'] &&
            !this._numListeners['featureClickOut']) {
            return;
        }

        const featureEvent = this._createFeatureEvent(event);
        this._manageClickOutEvent(featureEvent);

        this._prevClickFeatures = featureEvent.features;

        // Launch click event
        this._fireEvent('featureClick', featureEvent);
    }

    _manageClickOutEvent (featureEvent) {
        const featuresClickedOut = this._getDiffFeatures(this._prevClickFeatures, featureEvent.features);
        this._fireEventIfFeatures('featureClickOut', { featureEvent, eventFeatures: featuresClickedOut });
        return featuresClickedOut;
    }

    _createFeatureEvent (eventData) {
        // a potentially very intensive task
        const features = this._getFeaturesAtPosition(eventData.point);
        return {
            coordinates: eventData.lngLat,
            position: eventData.point,
            features
        };
    }

    _fireEvent (type, featureEvent) {
        this._emitter.emit(type, featureEvent);
    }

    _getFeaturesAtPosition (point) {
        return [].concat(...this._layerList.map(layer => layer.getFeaturesAtPosition(point)));
    }

    /**
     * Return the difference between the feature arrays A and B.
     * The output value is also an array of features.
     */
    _getDiffFeatures (featuresA, featuresB) {
        const IDs = this._getFeatureIDs(featuresB);
        return featuresA.filter(feature => !IDs.includes(feature.id));
    }

    _getFeatureIDs (features) {
        return features.map(feature => feature.id);
    }
}

function preCheckLayerList (layerList) {
    if (!Array.isArray(layerList)) {
        throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
            'Invalid layer list, parameter must be an array of "carto.Layer" objects.',
            _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_TYPE
        );
    }

    if (!layerList.length) {
        throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
            'Invalid argument, layer list must not be empty.',
            _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_VALUE
        );
    }

    if (!layerList.every(layer => layer instanceof _Layer__WEBPACK_IMPORTED_MODULE_1__["default"])) {
        throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
            'Invalid layer, layer must be an instance of "carto.Layer".',
            _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_TYPE
        );
    }
}

function postCheckLayerList (layerList) {
    if (!layerList.every(layer => layer.map === layerList[0].map)) {
        throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
            'Invalid argument, all layers must belong to the same map.',
            _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_VALUE
        );
    }
}

function checkEvent (eventName) {
    if (!EVENTS.includes(eventName)) {
        throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
            `Unrecognized event: '${eventName}'. Available events: ${EVENTS.join(', ')}.`,
            _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_VALUE
        );
    }
}


/***/ }),

/***/ "./src/interactivity/blendUtils.js":
/*!*****************************************!*\
  !*** ./src/interactivity/blendUtils.js ***!
  \*****************************************/
/*! exports provided: generateResetFunction, generateBlenderFunction */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateResetFunction", function() { return generateResetFunction; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "generateBlenderFunction", function() { return generateBlenderFunction; });
/* harmony import */ var _renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderer/viz/expressions */ "./src/renderer/viz/expressions.js");


function generateResetFunction (propertyName, id, customizedFeatures, viz, idProperty) {
    return function reset (duration = 500) {
        if (customizedFeatures[id] && customizedFeatures[id][propertyName]) {
            customizedFeatures[id][propertyName].replaceChild(
                customizedFeatures[id][propertyName].mix,
                // transition(0) is used to ensure that blend._predraw() "GC" collects it
                Object(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_0__["blend"])(Object(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_0__["notEquals"])(Object(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_0__["property"])(idProperty), id), Object(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_0__["transition"])(0), Object(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_0__["transition"])(duration))
            );
            viz[propertyName].notify();
            customizedFeatures[id][propertyName] = undefined;
        }
    };
}

function generateBlenderFunction (propertyName, id, customizedFeatures, viz, trackFeatureViz, idProperty, parseVizExpression) {
    return function generatedBlendTo (newExpression, duration = 500) {
        if (typeof newExpression === 'string') {
            newExpression = parseVizExpression(newExpression);
        }
        if (customizedFeatures[id] && customizedFeatures[id][propertyName]) {
            customizedFeatures[id][propertyName].a.blendTo(newExpression, duration);
            return;
        }
        const blendExpr = Object(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_0__["blend"])(
            newExpression,
            viz[propertyName],
            Object(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_0__["blend"])(1, Object(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_0__["notEquals"])(Object(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_0__["property"])(idProperty), id), Object(_renderer_viz_expressions__WEBPACK_IMPORTED_MODULE_0__["transition"])(duration))
        );
        trackFeatureViz(id, propertyName, blendExpr, customizedFeatures);
        viz.replaceChild(
            viz[propertyName],
            blendExpr
        );
        viz[propertyName].notify();
    };
}


/***/ }),

/***/ "./src/interactivity/commonFeature.js":
/*!********************************************!*\
  !*** ./src/interactivity/commonFeature.js ***!
  \********************************************/
/*! exports provided: getCompoundFeature */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCompoundFeature", function() { return getCompoundFeature; });

function _getGeomPropertiesFromPieces (pieces) {
    const geomPropertiesFromPieces = pieces.map(piece => {
        const [x, y] = piece.getRenderedCentroid();
        const aabb = piece._rawFeature._dataframe._aabb[piece._rawFeature._index];
        return { centroid: { x, y }, aabb };
    });

    const geomProperties = geomPropertiesFromPieces.filter(piece => {
        const { x, y } = piece.centroid;
        return !(isNaN(x) || isNaN(y));
    });

    return geomProperties;
}

/**
 * Get a 'compound Feature'. It is a Feature created from a set of 'feature' pieces
 * @param {Array} featurePieces
 */
function getCompoundFeature (featurePieces) {
    const exemplar = featurePieces[0];
    if (featurePieces.length === 1) return exemplar;

    const geomProperties = _getGeomPropertiesFromPieces(featurePieces);
    Object.defineProperty(exemplar, 'getRenderedCentroid', {
        get: function () {
            const getRenderedCentroid = () => {
                // average of centroids ponderated by aabb size
                const [weightedXs, weightedYs, totalSize] = geomProperties.reduce((accumulator, currentValue) => {
                    const { minx, miny, maxx, maxy } = currentValue.aabb;
                    const size = (maxx - minx) * (maxy - miny);
                    const pX = currentValue.centroid.x * size;
                    const pY = currentValue.centroid.y * size;
                    return [accumulator[0] + pX, accumulator[1] + pY, accumulator[2] + size];
                }, [0, 0, 0]);

                return [weightedXs / totalSize, weightedYs / totalSize];
            };
            return getRenderedCentroid;
        }
    });

    return exemplar;
}


/***/ }),

/***/ "./src/interactivity/feature.js":
/*!**************************************!*\
  !*** ./src/interactivity/feature.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Feature; });
/* harmony import */ var _featureVizProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./featureVizProperty */ "./src/interactivity/featureVizProperty.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _constants_viz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/viz */ "./src/constants/viz.js");




/**
 * @namespace Features
 * @description CARTO VL Features are objects that contain information of the visualization.
 * @api
 */

/**
 *
 * FeatureEvent objects are fired by {@link carto.Interactivity|Interactivity} objects.
 *
 * @typedef {Object} FeatureEvent
 * @property {Object} coordinates - LongLat coordinates in { lng, lat } form
 * @property {Object} position - Pixel coordinates in { x, y } form
 * @property {Feature[]} features - Array of {@link Feature}
 * @api
 */

/**
 * featureClick events are fired when the user clicks on features. The list of features behind the cursor is provided.
 *
 * @event featureClick
 * @type {FeatureEvent}
 * @api
 */

/**
 * featureClickOut events are fired when the user clicks outside a feature that was clicked in the last featureClick event.
 * The list of features that were clicked before and that are no longer behind this new click is provided.
 *
 * @event featureClickOut
 * @type {FeatureEvent}
 * @api
 */

/**
 * featureEnter events are fired when the user moves the cursor and the movement implies that a non-previously hovered feature (as reported by featureHover or featureLeave) is now under the cursor.
 * The list of features that are now behind the cursor and that weren't before is provided.
 *
 * @event featureEnter
 * @type {FeatureEvent}
 * @api
 */

/**
 * featureHover events are fired when the user moves the cursor.
 * The list of features behind the cursor is provided.
 *
 * @event featureHover
 * @type {FeatureEvent}
 * @api
 */

/**
 * featureLeave events are fired when the user moves the cursor and the movement implies that a previously hovered feature (as reported by featureHover or featureEnter) is no longer behind the cursor.
 * The list of features that are no longer behind the cursor and that were before is provided.
 *
 * @event featureLeave
 * @type {FeatureEvent}
 * @api
 */

/**
 *
 * Feature objects are provided by {@link FeatureEvent} events.
 *
 * @constructor Feature
 * @typedef {Object} Feature
 * @property {number} id - Unique identification code
 * @property {FeatureVizProperty} color
 * @property {FeatureVizProperty} filter
 * @property {FeatureVizProperty} order
 * @property {FeatureVizProperty} resolution
 * @property {FeatureVizProperty} strokeColor
 * @property {FeatureVizProperty} strokeWidth
 * @property {FeatureVizProperty} symbol
 * @property {FeatureVizProperty} symbolPlacement
 * @property {FeatureVizProperty} transform
 * @property {FeatureVizProperty} width
 * @property {FeatureVizProperty[]} variables - Declared variables in the viz object
 * @property {function} blendTo - Blend custom feature vizs by fading in `duration` milliseconds
 * @property {function} reset - Reset custom feature vizs by fading out `duration` milliseconds, where `duration` is the first parameter to reset
 * @property {function} getRenderedCentroid - Get centroid from the displayed geometry as [longitude, latitude]. When using lines and polygons in a MVT source, it can be different from canonical feature's centroid (it can be the centroid from just some client-side pieces). Useful for labeling.
 * @api
 */

class Feature {
    constructor (rawFeature, { viz, customizedFeatures, trackFeatureViz, idProperty }, publicFeatureProperties = []) {
        this.id = rawFeature[idProperty];

        this._rawFeature = rawFeature;
        this._featureVizParams = { rawFeature, viz, customizedFeatures, trackFeatureViz, idProperty };

        this._defineVizProperties();
        this._defineVizVariables();
        this._defineFeatureProperties(publicFeatureProperties);
    }

    _defineVizProperties () {
        _constants_viz__WEBPACK_IMPORTED_MODULE_2__["SUPPORTED_VIZ_PROPERTIES"].forEach((property) => {
            this[property] = this._buildFeatureVizProperty(property);
        });
    }

    _buildFeatureVizProperty (name) {
        const { rawFeature, viz, customizedFeatures, trackFeatureViz, idProperty } = this._featureVizParams;
        return new _featureVizProperty__WEBPACK_IMPORTED_MODULE_0__["default"](name, rawFeature, viz, customizedFeatures, trackFeatureViz, idProperty);
    }

    _defineVizVariables () {
        const variables = {};
        const vizVariables = this._featureVizParams.viz.variables;
        Object.keys(vizVariables).forEach(varName => {
            const name = `__cartovl_variable_${varName}`;
            variables[varName] = this._buildFeatureVizProperty(name);
        });
        this.variables = variables;
    }

    _defineFeatureProperties (featurePropertyNames) {
        featurePropertyNames.forEach(prop => {
            Object.defineProperty(this, prop, {
                get: function () {
                    return this._rawFeature[prop];
                }
            });
        });
    }

    blendTo (newVizProperties, duration = 500) {
        Object.keys(newVizProperties).forEach((property) => {
            if (!(_constants_viz__WEBPACK_IMPORTED_MODULE_2__["SUPPORTED_VIZ_PROPERTIES"].includes(property))) {
                throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["default"](
                    `Property '${property}' is not a valid viz property`,
                    _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["CartoValidationErrorTypes"].INCORRECT_VALUE
                );
            }
            const newValue = newVizProperties[property];
            this[property].blendTo(newValue, duration);
        });
    }

    reset (duration = 500) {
        _constants_viz__WEBPACK_IMPORTED_MODULE_2__["SUPPORTED_VIZ_PROPERTIES"].forEach((property) => {
            this[property].reset(duration);
        });

        for (let key in this.variables) {
            this.variables[key].reset(duration);
        }
    }

    getRenderedCentroid () {
        return this._rawFeature._dataframe.getRenderedCentroid(this._rawFeature._index);
    }
}


/***/ }),

/***/ "./src/interactivity/featureVizProperty.js":
/*!*************************************************!*\
  !*** ./src/interactivity/featureVizProperty.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FeatureVizProperty; });
/* harmony import */ var _blendUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blendUtils */ "./src/interactivity/blendUtils.js");
/* harmony import */ var _renderer_viz_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/viz/parser */ "./src/renderer/viz/parser.js");



/**
 *
 * FeatureVizProperty objects can be accessed through {@link Feature} objects.
 *
 * @typedef {Object} FeatureVizProperty
 * @property {function} blendTo - Change the feature viz by blending to a destination viz expression `expr` in `duration` milliseconds, where `expr` is the first parameter and `duration` the last one
 * @property {function} reset - Reset custom feature viz property by fading out `duration` milliseconds, where `duration` is the first parameter to reset
 * @property {function} value - Getter that evaluates the property and returns the computed value
 * @api
 */
class FeatureVizProperty {
    constructor (propertyName, feature, viz, customizedFeatures, trackFeatureViz, idProperty) {
        this._propertyName = propertyName;
        this._properties = feature;
        this._viz = viz;

        this.blendTo = Object(_blendUtils__WEBPACK_IMPORTED_MODULE_0__["generateBlenderFunction"])(propertyName, feature[idProperty], customizedFeatures, viz, trackFeatureViz, idProperty, _renderer_viz_parser__WEBPACK_IMPORTED_MODULE_1__["parseVizExpression"]);
        this.reset = Object(_blendUtils__WEBPACK_IMPORTED_MODULE_0__["generateResetFunction"])(propertyName, feature[idProperty], customizedFeatures, viz, idProperty);
    }

    get value () {
        return this._viz[this._propertyName].eval(this._properties);
    }

    eval (...properties) {
        const props = [];
        properties.forEach((property) => {
            const prop = {};
            prop[property] = this._properties[property];
            props.push(prop);
        });

        return this._viz[this._propertyName].eval(props);
    }
}


/***/ }),

/***/ "./src/interactivity/lightweightFeature.js":
/*!*************************************************!*\
  !*** ./src/interactivity/lightweightFeature.js ***!
  \*************************************************/
/*! exports provided: genLightweightFeatureClass */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "genLightweightFeatureClass", function() { return genLightweightFeatureClass; });
/* harmony import */ var _blendUtils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./blendUtils */ "./src/interactivity/blendUtils.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _constants_viz__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/viz */ "./src/constants/viz.js");




/**
 * Generate a lightweight Feature-like class
 * Its main purpouse is to define a light class to improve performance when creating a
 * high number of features (see `viewportFeatures`)
 *
 * @param {*} propertyNames
 * @param {*} renderLayer
 * @returns FeatureLike class
 */
function genLightweightFeatureClass (propertyNames, renderLayer) {
    const cls = class LightweightFeature {
        constructor (rawFeature) {
            this._rawFeature = rawFeature;
            this._featureProperties = null;
        }
    };

    _defineIdProperty(cls.prototype, renderLayer);
    _defineVizProperties(cls.prototype, renderLayer);
    _defineVizVariables(cls.prototype, renderLayer);
    _defineFeatureProperties(cls.prototype, propertyNames);
    _defineRootBlendToMethod(cls.prototype);
    _defineRootResetMethod(cls.prototype);
    _defineGetRenderedCentroidMethod(cls.prototype);

    return cls;
}

function _defineIdProperty (targetObject, renderLayer) {
    Object.defineProperty(targetObject, 'id', {
        get: function () {
            const idProperty = renderLayer.viz.metadata.idProperty;
            return this._rawFeature[idProperty];
        },
        configurable: true
    });
}

function _defineVizProperties (targetObject, renderLayer) {
    _constants_viz__WEBPACK_IMPORTED_MODULE_2__["SUPPORTED_VIZ_PROPERTIES"].forEach(property => {
        _createLightweightFeatureVizProperty(targetObject, renderLayer, property);
    });
}

function _createLightweightFeatureVizProperty (targetObject, renderLayer, prop, propName = prop) {
    const { customizedFeatures, viz, trackFeatureViz, parseVizExpression } = renderLayer;
    const idProperty = viz.metadata.idProperty;
    const blender = (featureId) => {
        return Object(_blendUtils__WEBPACK_IMPORTED_MODULE_0__["generateBlenderFunction"])(prop, featureId, customizedFeatures, viz, trackFeatureViz, idProperty, parseVizExpression);
    };
    const reset = (featureId) => {
        return Object(_blendUtils__WEBPACK_IMPORTED_MODULE_0__["generateResetFunction"])(prop, featureId, customizedFeatures, viz, idProperty);
    };

    Object.defineProperty(targetObject, propName, {
        get: function () {
            return {
                blendTo: (...args) => {
                    return blender(this.id)(...args);
                },
                reset: (...args) => {
                    return reset(this.id)(...args);
                },
                value: viz[prop].eval(this._rawFeature)
            };
        }
    });
}

function _defineVizVariables (targetObject, renderLayer) {
    Object.defineProperty(targetObject, 'variables', {
        get: function () {
            const variables = {};

            // To allow the use of this.id in `_createLightweightFeatureVizProperty`
            Object.defineProperty(variables, 'id', {
                get: function () { return this.id; }
            });

            // viz variables
            const vizVariables = renderLayer.viz.variables;
            Object.keys(vizVariables).forEach(varName => {
                const name = `__cartovl_variable_${varName}`;
                _createLightweightFeatureVizProperty(variables, renderLayer, name, varName);
            });
            return variables;
        }
    });
}

function _defineFeatureProperties (targetObject, propertyNames) {
    Object.defineProperty(targetObject, 'properties', {
        get: function () {
            if (this._featureProperties === null) {
                this._featureProperties = {};

                propertyNames.forEach(({ property, variable }) => {
                    const propertyName = variable || property;
                    this._featureProperties[propertyName] = this._rawFeature[property];
                });
            }
            return this._featureProperties;
        }
    });
}

function _defineRootBlendToMethod (targetObject) {
    Object.defineProperty(targetObject, 'blendTo', {
        get: function () {
            const blendTo = (newVizProperties, duration = 500) => {
                Object.keys(newVizProperties).forEach((property) => {
                    if (!(_constants_viz__WEBPACK_IMPORTED_MODULE_2__["SUPPORTED_VIZ_PROPERTIES"].includes(property))) {
                        throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["default"](
                            `Property '${property}' is not a valid viz property`,
                            _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["CartoValidationErrorTypes"].INCORRECT_VALUE
                        );
                    }
                    const newValue = newVizProperties[property];
                    this[property].blendTo(newValue, duration);
                });
            };
            return blendTo;
        }
    });
}

function _defineRootResetMethod (targetObject) {
    Object.defineProperty(targetObject, 'reset', {
        get: function () {
            const reset = (duration = 500) => {
                _constants_viz__WEBPACK_IMPORTED_MODULE_2__["SUPPORTED_VIZ_PROPERTIES"].forEach((property) => {
                    this[property].reset(duration);
                });
                for (let key in this.variables) {
                    this.variables[key].reset(duration);
                }
            };
            return reset;
        }
    });
}

function _defineGetRenderedCentroidMethod (targetObject) {
    Object.defineProperty(targetObject, 'getRenderedCentroid', {
        get: function () {
            const getRenderedCentroid = () => {
                return this._rawFeature._dataframe.getRenderedCentroid(this._rawFeature._index);
            };
            return getRenderedCentroid;
        },
        configurable: true
    });
}


/***/ }),

/***/ "./src/renderer/Metadata.js":
/*!**********************************!*\
  !*** ./src/renderer/Metadata.js ***!
  \**********************************/
/*! exports provided: DEFAULT_ID_PROPERTY, IDENTITY, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_ID_PROPERTY", function() { return DEFAULT_ID_PROPERTY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IDENTITY", function() { return IDENTITY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Metadata; });
/* harmony import */ var _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors/carto-runtime-error */ "./src/errors/carto-runtime-error.js");
/* harmony import */ var _codecs_Identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../codecs/Identity */ "./src/codecs/Identity.js");
/* harmony import */ var _viz_expressions_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./viz/expressions/constants */ "./src/renderer/viz/expressions/constants.js");




const DEFAULT_MVT_EXTENT = 4096;
const DEFAULT_ID_PROPERTY = 'cartodb_id';

// The IDENTITY metadata contains zero properties
const IDENTITY = {
    properties: {}
};

class Metadata {
    constructor ({ properties, featureCount, sample, geomType, isAggregated, idProperty, extent } = { properties: {} }) {
        this.properties = properties;
        this.featureCount = featureCount;
        this.sample = sample;
        this.geomType = geomType;
        this.isAggregated = isAggregated;
        this.idProperty = idProperty || DEFAULT_ID_PROPERTY;
        if (!this.properties.hasOwnProperty(this.idProperty)) {
            this.properties[this.idProperty] = { type: 'number' };
        }

        this.categoryToID = new Map();
        this.IDToCategory = new Map();
        this.numCategories = 0;
        this.extent = extent || DEFAULT_MVT_EXTENT;

        Object.values(properties).map(property => {
            property.categories = property.categories || [];
            property.categories.map(category => this.categorizeString(property, category.name, true));
        });

        this.propertyKeys = Object.keys(properties);
    }

    setCodecs () {
        throw new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_0__["default"]('You must call "setCodecs" once you have determined the proper subclass');
    }

    categorizeString (propertyName, category, init = false) {
        if (category === undefined) {
            category = null;
        }
        if (this.categoryToID.has(category)) {
            return this.categoryToID.get(category);
        }
        if (!init && category !== null) {
            this.properties[propertyName].categories.push({
                name: category,
                frequency: Number.NaN
            });
        }
        const categoryId = category === null ? _viz_expressions_constants__WEBPACK_IMPORTED_MODULE_2__["FP32_DESIGNATED_NULL_VALUE"] : this.numCategories;
        this.categoryToID.set(category, categoryId);
        this.IDToCategory.set(categoryId, category);
        this.numCategories++;
        return categoryId;
    }

    // dataframe properties into which a single source property is decoded
    // TODO: rename as encodedProperties or dataframeProperties
    decodedProperties (propertyName) {
        return [propertyName];
    }

    // property of the data origin (dataset, query) from which
    // a (source or dataframe) property is derived
    baseName (propertyName) {
        return propertyName;
    }

    // property transferred from the source from which
    // a (source or dataframe) property it so be computed
    // TODO: move to windshaft metadata
    sourcePropertyName (propertyName) {
        return propertyName;
    }

    stats (propertyName) {
        return this.properties[propertyName];
    }

    codec (propertyName) {
        const name = this.baseName(propertyName);

        return this.properties[name] && this.properties[name].codec
            ? this.properties[name].codec
            : new _codecs_Identity__WEBPACK_IMPORTED_MODULE_1__["default"]();
    }
}


/***/ }),

/***/ "./src/renderer/RenderLayer.js":
/*!*************************************!*\
  !*** ./src/renderer/RenderLayer.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderLayer; });
/* harmony import */ var _interactivity_feature__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../interactivity/feature */ "./src/interactivity/feature.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/geometry */ "./src/utils/geometry.js");
/* harmony import */ var _interactivity_commonFeature__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../interactivity/commonFeature */ "./src/interactivity/commonFeature.js");





class RenderLayer {
    constructor () {
        this.dataframes = [];
        this.renderer = null;
        this.viz = null;
        this.type = null;
        this.customizedFeatures = {};
        this.idProperty = null;
    }

    // Performance-intensive. The required allocation and copy of resources will happen synchronously.
    // To achieve good performance, avoid multiple calls within the same event, particularly with large dataframes.
    addDataframe (dataframe) {
        if (this.type) {
            this._checkDataframeType(dataframe);
        }
        this.type = dataframe.type;
        if (this.renderer) {
            dataframe.bindRenderer(this.renderer);
        }
        this.dataframes.push(dataframe);
        this.idProperty = dataframe.metadata.idProperty;
    }

    setRenderer (renderer) {
        this.renderer = renderer;
        this.dataframes.forEach(d => d.bindRenderer(renderer));
    }

    setViz (viz) {
        this.viz = viz;
    }

    getActiveDataframes () {
        this.dataframes = this.dataframes.filter(df => !df.freed);
        let active = this.dataframes.filter(df => df.active && df.numVertex);
        if (active.length && active[0].orderID !== undefined) {
            active = active.sort((a, b) => a.orderID - b.orderID);
        }
        return active;
    }

    hasDataframes () {
        return this.getActiveDataframes().length > 0;
    }

    getNumFeatures () {
        return this.getActiveDataframes().map(d => d.numFeatures).reduce((x, y) => x + y, 0);
    }

    _checkDataframeType (dataframe) {
        if (this.type !== dataframe.type) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["default"](
                'Layer dataframes must always be of the same type',
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["CartoValidationErrorTypes"].INCORRECT_TYPE
            );
        }
    }

    getFeaturesAtPosition (pos) {
        if (!this.viz) {
            return [];
        }

        const noPossiblePartialFeatures = (this.viz.geometryType === _utils_geometry__WEBPACK_IMPORTED_MODULE_2__["GEOMETRY_TYPE"].POINT);
        if (noPossiblePartialFeatures) {
            return this._getPointFeaturesAtPosition(pos);
        } else {
            return this._getPartialFeaturesAtPosition(pos);
        }
    }

    _getPointFeaturesAtPosition (pos) {
        const rawFeatures = this._getRawFeaturesAtPosition(pos);
        return rawFeatures.map((raw) => { return this._buildFeatureFromRaw(raw); });
    }

    _buildFeatureFromRaw (rawFeature) {
        const { viz, customizedFeatures, trackFeatureViz, idProperty } = this;
        const featureVizParams = { viz, customizedFeatures, trackFeatureViz, idProperty };
        return new _interactivity_feature__WEBPACK_IMPORTED_MODULE_0__["default"](rawFeature, featureVizParams);
    }

    _getRawFeaturesAtPosition (pos) {
        const rawFeatures = [].concat(...this.getActiveDataframes().map(df =>
            df.getFeaturesAtPosition(pos, this.viz)
        ));
        return rawFeatures;
    }

    _getPartialFeaturesAtPosition (pos) {
        const rawFeatures = this._getRawFeaturesAtPosition(pos);
        if (rawFeatures.length === 0) return [];

        const rawPartialFeatures = this._getPartialFeaturesFromSingle(rawFeatures);

        const compoundFeatures = this._getCompoundFeaturesFrom(rawPartialFeatures);
        return compoundFeatures;
    }

    _getCompoundFeaturesFrom (rawPartialFeatures) {
        const features = [];
        for (let featureId in rawPartialFeatures) {
            const viewporFeaturePieces = rawPartialFeatures[featureId];
            const featurePieces = viewporFeaturePieces.map((raw) => { return this._buildFeatureFromRaw(raw); });
            features.push(Object(_interactivity_commonFeature__WEBPACK_IMPORTED_MODULE_3__["getCompoundFeature"])(featurePieces));
        }
        return features;
    }

    /**
     * Get all the pieces from rawFeatures.
     * Returns an Object, where each key includes an array with (potentially) several feature pieces
     */
    _getPartialFeaturesFromSingle (rawFeatures) {
        const featuresIds = new Set(rawFeatures.map(raw => raw[this.idProperty]));
        return this.getAllPiecesPerFeature(featuresIds);
    }

    /**
     * Gather all feature pieces in the dataframes
     */
    getAllPiecesPerFeature (featureIds) {
        const piecesPerFeature = {};
        featureIds.forEach((featureId) => { piecesPerFeature[featureId] = []; });

        const dataframes = this.getActiveDataframes();
        dataframes.forEach(dataframe => {
            this._addPartialFeaturesIfExistIn(dataframe, featureIds, piecesPerFeature);
        });

        return piecesPerFeature;
    }

    /**
     * Add all the feature pieces, with selected featureIds, if present in the dataframe.
     */
    _addPartialFeaturesIfExistIn (dataframe, featureIds, result) {
        for (let i = 0; i < dataframe.numFeatures; i++) {
            const feature = dataframe.getFeature(i);
            const currentFeatureId = feature[this.idProperty];

            if (featureIds.has(currentFeatureId)) {
                const pieces = result[currentFeatureId];
                pieces.push(feature);
            }
        }
    }

    trackFeatureViz (featureID, vizProperty, newViz, customizedFeatures) {
        customizedFeatures[featureID] = customizedFeatures[featureID] || {};
        customizedFeatures[featureID][vizProperty] = newViz;
    }

    freeDataframes () {
        this.dataframes.map(df => df.free());
        this.dataframes = [];
        this.type = null;
    }
}


/***/ }),

/***/ "./src/renderer/Renderer.js":
/*!**********************************!*\
  !*** ./src/renderer/Renderer.js ***!
  \**********************************/
/*! exports provided: FILTERING_THRESHOLD, RTT_WIDTH, MIN_VERTEX_TEXTURE_IMAGE_UNITS_NEEDED, default, isBrowserSupported, unsupportedBrowserReasons */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FILTERING_THRESHOLD", function() { return FILTERING_THRESHOLD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RTT_WIDTH", function() { return RTT_WIDTH; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MIN_VERTEX_TEXTURE_IMAGE_UNITS_NEEDED", function() { return MIN_VERTEX_TEXTURE_IMAGE_UNITS_NEEDED; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Renderer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowserSupported", function() { return isBrowserSupported; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unsupportedBrowserReasons", function() { return unsupportedBrowserReasons; });
/* harmony import */ var _shaders__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shaders */ "./src/renderer/shaders/index.js");
/* harmony import */ var _viz_expressions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./viz/expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors/carto-runtime-error */ "./src/errors/carto-runtime-error.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/lib/gl-matrix.js");
/* harmony import */ var _constants_layer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants/layer */ "./src/constants/layer.js");
/* harmony import */ var _viz_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./viz/parser */ "./src/renderer/viz/parser.js");
/* harmony import */ var _viz_expressions_aggregation_viewport_ViewportAggCalculator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./viz/expressions/aggregation/viewport/ViewportAggCalculator */ "./src/renderer/viz/expressions/aggregation/viewport/ViewportAggCalculator.js");
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/geometry */ "./src/utils/geometry.js");









const INITIAL_TIMESTAMP = Date.now();
let timestamp = INITIAL_TIMESTAMP;
requestAnimationFrame(refreshClock);
function refreshClock () {
    timestamp = (Date.now() - INITIAL_TIMESTAMP) / 1000.0;
    requestAnimationFrame(refreshClock);
}

/**
 * The renderer use fuzzy logic where < 0.5 means false and >= 0.5 means true
 */
const FILTERING_THRESHOLD = 0.5;

/**
 * @typedef {Object} RPoint - Point in renderer coordinates space
 * @property {number} x
 * @property {number} y
 */

/**
 * @description The Render To Texture Width limits the maximum number of features per dataframe: *maxFeatureCount = RTT_WIDTH^2*
 *
 * Large RTT_WIDTH values are unsupported by hardware. Limits vary on each machine.
 * Support starts to drop from 2048, with a drastic reduction in support for more than 4096 pixels.
 *
 * Large values imply a small overhead too.
 */
const RTT_WIDTH = 1024;

const MIN_VERTEX_TEXTURE_IMAGE_UNITS_NEEDED = 8;

/**
 * @description Renderer constructor. Use it to create a new renderer bound to the provided canvas.
 * Initialization will be done synchronously.
 * The function will fail in case that a WebGL context cannot be created this can happen because of the following reasons:
 *   * The provided canvas element is invalid
 *   * The browser or the machine doesn't support WebGL or the required WebGL extension and minimum parameter values
 * @jsapi
 * @memberOf renderer
 * @constructor
 * @param {HTMLElement} canvas - the WebGL context will be created on this element
 */

class Renderer {
    constructor (canvas) {
        if (canvas) {
            this.gl = getValidWebGLContextOrThrow(canvas);
            this._initGL(this.gl);
        }
        this._center = { x: 0, y: 0 };
        this._zoom = 1;
        this.RTT_WIDTH = RTT_WIDTH;
        this.dataframes = [];
    }

    /**
     * Initialize renderer
     * @param {WebGLRenderingContext} gl - WebGL context
     */
    initialize (gl) {
        gl = getValidWebGLContextOrThrow(null, gl);
        this._initGL(gl);
    }

    _initGL (gl) {
        this.gl = gl;
        this._initShaders();

        this.auxFB = gl.createFramebuffer();

        // Create a VBO that covers the entire screen
        // Use a "big" triangle instead of a square for performance and simplicity
        this.bigTriangleVBO = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.bigTriangleVBO);
        const vertices = new Float32Array([
            10.0, -10.0,
            0.0, 10.0,
            -10.0, -10.0
        ]);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

        // Create a 1x1 RGBA texture set to [0,0,0,0]
        // Needed because sometimes we don't really use some textures within the shader, but they are declared anyway.
        this.zeroTex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, this.zeroTex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,
            1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
            new Uint8Array(4));
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        this._AATex = gl.createTexture(); // Antialiasing
        this._AAFB = gl.createFramebuffer();

        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.bindTexture(gl.TEXTURE_2D, this.zeroTex);
    }

    _getAspect () {
        if (this.gl) {
            return this.gl.canvas.width / this.gl.canvas.height;
        }
        return 1;
    }

    renderLayer (renderLayer, drawMetadata) {
        this.drawMetadata = drawMetadata;
        const dataframes = renderLayer.getActiveDataframes();
        const viz = renderLayer.viz;
        if (!viz) {
            return;
        }
        const gl = this.gl;

        this._updateDataframeMatrices(dataframes);

        renderLayer.parseVizExpression = _viz_parser__WEBPACK_IMPORTED_MODULE_5__["parseVizExpression"]; // Important! to avoid a circular dependency problem (eg. viewportFeatures)
        Object(_viz_expressions_aggregation_viewport_ViewportAggCalculator__WEBPACK_IMPORTED_MODULE_6__["runViewportAggregations"])(renderLayer);

        if (!dataframes.length) {
            return;
        }
        viz._getRootExpressions().map(expr => expr._dataReady());

        gl.enable(gl.CULL_FACE); // this enables an optimization but it forces a particular vertices orientation
        gl.disable(gl.BLEND);
        gl.disable(gl.DEPTH_TEST);
        gl.disable(gl.STENCIL_TEST);
        gl.depthMask(false);
        gl.bindFramebuffer(gl.FRAMEBUFFER, this.auxFB);

        // To execute once per daframe and style property
        // (geometries, properties and ids have been already loaded to GPU)
        const styleDataframe = (dataframe, dataframeTexture, metashader, vizExpr) => {
            const shader = metashader.shader;
            const textureId = metashader.textureIds;

            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, dataframeTexture, 0);
            gl.viewport(0, 0, RTT_WIDTH, dataframe.getSize().height);
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(shader.program);
            // Enforce that property texture TextureUnit don't clash with auxiliar ones
            drawMetadata.freeTexUnit = Object.keys(textureId).length;
            vizExpr._setTimestamp(timestamp);
            vizExpr._preDraw(shader.program, drawMetadata, gl);

            Object.keys(textureId).forEach((name, i) => {
                gl.activeTexture(gl.TEXTURE0 + i);
                gl.bindTexture(gl.TEXTURE_2D, dataframe.getPropertyTexture(name));
                gl.uniform1i(textureId[name], i);
            });

            gl.enableVertexAttribArray(shader.vertexAttribute);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.bigTriangleVBO);
            gl.vertexAttribPointer(shader.vertexAttribute, 2, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.TRIANGLES, 0, 3);
            gl.disableVertexAttribArray(shader.vertexAttribute);
        };

        // Draw dataframe style textures
        dataframes.map(dataframe => styleDataframe(dataframe, dataframe.texColor, viz.colorMetaShader, viz.color));
        if (dataframes[0].type !== _utils_geometry__WEBPACK_IMPORTED_MODULE_7__["GEOMETRY_TYPE"].POLYGON) {
            dataframes.map(dataframe => styleDataframe(dataframe, dataframe.texWidth, viz.widthMetaShader, viz.width));
        }
        if (dataframes[0].type !== _utils_geometry__WEBPACK_IMPORTED_MODULE_7__["GEOMETRY_TYPE"].LINE) {
            dataframes.map(dataframe => styleDataframe(dataframe, dataframe.texStrokeColor, viz.strokeColorMetaShader, viz.strokeColor));
            dataframes.map(dataframe => styleDataframe(dataframe, dataframe.texStrokeWidth, viz.strokeWidthMetaShader, viz.strokeWidth));
        }
        dataframes.map(dataframe => styleDataframe(dataframe, dataframe.texFilter, viz.filterMetaShader, viz.filter));

        // Final drawing (to screen). In the case of lines / polygons, there is an extra step (for antialiasing)
        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
        gl.enable(gl.BLEND);

        if (renderLayer.type === _utils_geometry__WEBPACK_IMPORTED_MODULE_7__["GEOMETRY_TYPE"].POINT) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        } else {
            // lines & polygon (antialiasing)
            const antialiasingScale = (window.devicePixelRatio || 1) >= 2 ? 1 : 2;
            gl.bindFramebuffer(gl.FRAMEBUFFER, this._AAFB);
            const [w, h] = [gl.drawingBufferWidth, gl.drawingBufferHeight];

            if (w !== this._width || h !== this._height) {
                gl.bindTexture(gl.TEXTURE_2D, this._AATex);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,
                    w * antialiasingScale, h * antialiasingScale, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._AATex, 0);

                const renderbuffer = gl.createRenderbuffer();
                gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
                gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w * antialiasingScale, h * antialiasingScale);
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);

                [this._width, this._height] = [w, h];
            }
            gl.viewport(0, 0, w * antialiasingScale, h * antialiasingScale);
            gl.clear(gl.COLOR_BUFFER_BIT);
        }

        const { orderingMins, orderingMaxs } = getOrderingRenderBuckets(renderLayer);

        if (dataframes[0].type === _utils_geometry__WEBPACK_IMPORTED_MODULE_7__["GEOMETRY_TYPE"].LINE || dataframes[0].type === _utils_geometry__WEBPACK_IMPORTED_MODULE_7__["GEOMETRY_TYPE"].POLYGON) {
            gl.clearDepth(1);
            gl.depthRange(0, 1);
            gl.depthFunc(gl.NOTEQUAL);
            gl.depthMask(true);
            gl.enable(gl.DEPTH_TEST);
        }

        const renderDrawPass = orderingIndex => dataframes.forEach(dataframe => {
            let freeTexUnit = 0;
            let metaRenderer = null;
            if (!viz.symbol.default) {
                metaRenderer = viz.symbolMetaShader;
            } else if (dataframe.type === _utils_geometry__WEBPACK_IMPORTED_MODULE_7__["GEOMETRY_TYPE"].POINT) {
                metaRenderer = viz.pointMetaShader;
            } else if (dataframe.type === _utils_geometry__WEBPACK_IMPORTED_MODULE_7__["GEOMETRY_TYPE"].LINE) {
                metaRenderer = viz.lineMetaShader;
            } else {
                metaRenderer = viz.polygonMetaShader;
            }
            const renderer = metaRenderer.shader;
            gl.useProgram(renderer.program);

            // Set filtering condition on "... AND feature is in current order bucket"
            gl.uniform1f(renderer.orderMinWidth, orderingMins[orderingIndex]);
            gl.uniform1f(renderer.orderMaxWidth, orderingMaxs[orderingIndex]);

            // Define some scalar uniforms
            gl.uniform1f(renderer.normalScale, 1 / (Math.pow(2, drawMetadata.zoomLevel) * _constants_layer__WEBPACK_IMPORTED_MODULE_4__["RESOLUTION_ZOOMLEVEL_ZERO"] * dataframe.scale));
            gl.uniform2f(renderer.resolution, gl.canvas.width / window.devicePixelRatio, gl.canvas.height / window.devicePixelRatio);

            gl.enableVertexAttribArray(renderer.vertexPositionAttribute);
            gl.bindBuffer(gl.ARRAY_BUFFER, dataframe.vertexBuffer);
            gl.vertexAttribPointer(renderer.vertexPositionAttribute, 2, gl.FLOAT, false, 0, 0);

            gl.enableVertexAttribArray(renderer.featureIdAttr);
            gl.bindBuffer(gl.ARRAY_BUFFER, dataframe.featureIDBuffer);
            gl.vertexAttribPointer(renderer.featureIdAttr, 2, gl.FLOAT, false, 0, 0);

            if (dataframe.type === _utils_geometry__WEBPACK_IMPORTED_MODULE_7__["GEOMETRY_TYPE"].LINE || dataframe.type === _utils_geometry__WEBPACK_IMPORTED_MODULE_7__["GEOMETRY_TYPE"].POLYGON) {
                gl.enableVertexAttribArray(renderer.normalAttr);
                gl.bindBuffer(gl.ARRAY_BUFFER, dataframe.normalBuffer);
                gl.vertexAttribPointer(renderer.normalAttr, 2, gl.FLOAT, false, 0, 0);
            }

            // Common Style textures
            gl.activeTexture(gl.TEXTURE0 + freeTexUnit);
            gl.bindTexture(gl.TEXTURE_2D, dataframe.texColor);
            gl.uniform1i(renderer.colorTexture, freeTexUnit);
            freeTexUnit++;

            gl.activeTexture(gl.TEXTURE0 + freeTexUnit);
            gl.bindTexture(gl.TEXTURE_2D, dataframe.texFilter);
            gl.uniform1i(renderer.filterTexture, freeTexUnit);
            freeTexUnit++;

            // Specific Style textures
            if (dataframe.type === 'point' || dataframe.type === 'line') {
                gl.activeTexture(gl.TEXTURE0 + freeTexUnit);
                gl.bindTexture(gl.TEXTURE_2D, dataframe.texWidth);
                gl.uniform1i(renderer.widthTexture, freeTexUnit);
                freeTexUnit++;
            }

            if (!viz.symbol.default) {
                const textureId = metaRenderer.textureIds;
                // Enforce that property texture and style texture TextureUnits don't clash with auxiliar ones
                drawMetadata.freeTexUnit = freeTexUnit + Object.keys(textureId).length;
                viz.symbol._setTimestamp(timestamp);
                viz.symbol._preDraw(renderer.program, drawMetadata, gl);

                viz.symbolPlacement._setTimestamp(timestamp);
                viz.symbolPlacement._preDraw(renderer.program, drawMetadata, gl);

                freeTexUnit = drawMetadata.freeTexUnit;

                Object.keys(textureId).forEach(name => {
                    gl.activeTexture(gl.TEXTURE0 + freeTexUnit);
                    gl.bindTexture(gl.TEXTURE_2D, dataframe.getPropertyTexture(name));
                    gl.uniform1i(textureId[name], freeTexUnit);
                    freeTexUnit++;
                });
            } else if (dataframe.type !== _utils_geometry__WEBPACK_IMPORTED_MODULE_7__["GEOMETRY_TYPE"].LINE) {
                // Lines don't support stroke
                gl.activeTexture(gl.TEXTURE0 + freeTexUnit);
                gl.bindTexture(gl.TEXTURE_2D, dataframe.texStrokeColor);
                gl.uniform1i(renderer.strokeColorTexture, freeTexUnit);
                freeTexUnit++;

                gl.activeTexture(gl.TEXTURE0 + freeTexUnit);
                gl.bindTexture(gl.TEXTURE_2D, dataframe.texStrokeWidth);
                gl.uniform1i(renderer.strokeWidthTexture, freeTexUnit);
                freeTexUnit++;
            }

            if (dataframe.type === _utils_geometry__WEBPACK_IMPORTED_MODULE_7__["GEOMETRY_TYPE"].LINE || dataframe.type === _utils_geometry__WEBPACK_IMPORTED_MODULE_7__["GEOMETRY_TYPE"].POLYGON) {
                gl.clear(gl.DEPTH_BUFFER_BIT); // antialising-related
            }

            if (!viz.transform.default) {
                const textureId = metaRenderer.textureIds;
                // Enforce that property texture and style texture TextureUnits don't clash with auxiliar ones
                drawMetadata.freeTexUnit = freeTexUnit + Object.keys(textureId).length;
                viz.transform._setTimestamp(timestamp);
                viz.transform._preDraw(renderer.program, drawMetadata, gl);

                freeTexUnit = drawMetadata.freeTexUnit;

                Object.keys(textureId).forEach(name => {
                    gl.activeTexture(gl.TEXTURE0 + freeTexUnit);
                    gl.bindTexture(gl.TEXTURE_2D, dataframe.getPropertyTexture(name));
                    gl.uniform1i(textureId[name], freeTexUnit);
                    freeTexUnit++;
                });

                gl.uniform2f(renderer.resolution, gl.canvas.width, gl.canvas.height); // remove it ? (duplicated)
            }

            gl.uniformMatrix4fv(renderer.matrix, false, dataframe.matrix);

            gl.drawArrays(gl.TRIANGLES, 0, dataframe.numVertex);

            // Some cleaning...
            gl.disableVertexAttribArray(renderer.vertexPositionAttribute);
            gl.disableVertexAttribArray(renderer.featureIdAttr);
            if (dataframe.type === _utils_geometry__WEBPACK_IMPORTED_MODULE_7__["GEOMETRY_TYPE"].LINE || dataframe.type === _utils_geometry__WEBPACK_IMPORTED_MODULE_7__["GEOMETRY_TYPE"].POLYGON) {
                gl.disableVertexAttribArray(renderer.normalAttr);
                gl.disable(gl.DEPTH_TEST);
            }
        });
        orderingMins.map((_, orderingIndex) => {
            renderDrawPass(orderingIndex);
        });

        if (renderLayer.type !== _utils_geometry__WEBPACK_IMPORTED_MODULE_7__["GEOMETRY_TYPE"].POINT) {
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);

            gl.useProgram(this._aaBlendShader.program);

            gl.activeTexture(gl.TEXTURE0);
            gl.bindTexture(gl.TEXTURE_2D, this._AATex);
            gl.uniform1i(this._aaBlendShader.readTU, 0);

            gl.enableVertexAttribArray(this._aaBlendShader.vertexAttribute);
            gl.bindBuffer(gl.ARRAY_BUFFER, this.bigTriangleVBO);
            gl.vertexAttribPointer(this._aaBlendShader.vertexAttribute, 2, gl.FLOAT, false, 0, 0);

            gl.drawArrays(gl.TRIANGLES, 0, 3);
            gl.disableVertexAttribArray(this._aaBlendShader.vertexAttribute);
        }

        gl.disable(gl.CULL_FACE); // ? not needed from v0.50?
    }

    _updateDataframeMatrices (dataframes) {
        dataframes.forEach(dataframe => {
            let m2 = [];
            let m3 = [];
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__["mat4"].copy(m2, this.matrix);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__["mat4"].identity(m3);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__["mat4"].translate(m3, m3, [0.5, 0.5, 0]);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__["mat4"].scale(m3, m3, [0.5, -0.5, 1]);

            gl_matrix__WEBPACK_IMPORTED_MODULE_3__["mat4"].translate(m3, m3, [dataframe.center.x, dataframe.center.y, 0]);
            gl_matrix__WEBPACK_IMPORTED_MODULE_3__["mat4"].scale(m3, m3, [dataframe.scale, dataframe.scale, 1]);

            gl_matrix__WEBPACK_IMPORTED_MODULE_3__["mat4"].multiply(m2, m2, m3);
            dataframe.matrix = m2;
        });
    }

    /**
     * Initialize static shaders
     */
    _initShaders () {
        this._aaBlendShader = new _shaders__WEBPACK_IMPORTED_MODULE_0__["default"].AABlender(this.gl);
    }
}

function getOrderingRenderBuckets (renderLayer) {
    const orderer = renderLayer.viz.order;
    const MAX_SIZE = 1030;
    let orderingMins = [0];
    let orderingMaxs = [MAX_SIZE];
    // We divide the ordering into 64 buckets of 2 pixels each, since the size limit is 127 pixels
    const NUM_BUCKETS = 64;
    if (orderer.isA(_viz_expressions__WEBPACK_IMPORTED_MODULE_1__["Asc"])) {
        orderingMins = Array.from({ length: NUM_BUCKETS }, (_, i) => ((NUM_BUCKETS - 1) - i) * 2);
        orderingMaxs = Array.from({ length: NUM_BUCKETS }, (_, i) => i === 0 ? MAX_SIZE : ((NUM_BUCKETS - 1) - i + 1) * 2);
    } else if (orderer.isA(_viz_expressions__WEBPACK_IMPORTED_MODULE_1__["Desc"])) {
        orderingMins = Array.from({ length: NUM_BUCKETS }, (_, i) => i * 2);
        orderingMaxs = Array.from({ length: NUM_BUCKETS }, (_, i) => i === (NUM_BUCKETS - 1) ? MAX_SIZE : (i + 1) * 2);
    }
    return {
        orderingMins,
        orderingMaxs
    };
}

function getValidWebGLContextOrThrow (canvas, gl) {
    const reasons = unsupportedBrowserReasons(canvas, gl, true);
    if (reasons.length > 0) {
        throw reasons[0];
    }
    return gl;
}

function isBrowserSupported (canvas, gl) {
    const reasons = unsupportedBrowserReasons(canvas, gl);
    return reasons.length === 0;
}

function unsupportedBrowserReasons (canvas, gl, early = false) {
    const reasons = [];
    if (!gl) {
        if (!canvas) {
            canvas = document.createElement('canvas');
        }
        gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
    }
    if (!gl) {
        reasons.push(new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_2__["default"]('WebGL 1 is unsupported', _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_2__["CartoRuntimeErrorTypes"].WEB_GL));
        return reasons;
    }

    const OESTextureFloat = gl.getExtension('OES_texture_float');
    if (!OESTextureFloat) {
        reasons.push(new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_2__["default"]('WebGL extension \'OES_texture_float\' is unsupported', _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_2__["CartoRuntimeErrorTypes"].WEB_GL));
        if (early) {
            return reasons;
        }
    }

    const supportedRTT = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);
    if (supportedRTT < RTT_WIDTH) {
        reasons.push(
            new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_2__["default"](
                `WebGL parameter 'gl.MAX_RENDERBUFFER_SIZE' is below the requirement: ${supportedRTT} < ${RTT_WIDTH}`,
                _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_2__["CartoRuntimeErrorTypes"].WEB_GL
            )
        );
    }

    const vertexTextureImageUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
    if (vertexTextureImageUnits < MIN_VERTEX_TEXTURE_IMAGE_UNITS_NEEDED) {
        reasons.push(
            new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_2__["default"](
                `WebGL parameter 'gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS' is below the requirement: ${vertexTextureImageUnits} < ${MIN_VERTEX_TEXTURE_IMAGE_UNITS_NEEDED}`,
                _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_2__["CartoRuntimeErrorTypes"].WEB_GL
            )
        );
    }

    return reasons;
}


/***/ }),

/***/ "./src/renderer/dataframe/Dataframe.js":
/*!*********************************************!*\
  !*** ./src/renderer/dataframe/Dataframe.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Dataframe; });
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/geometry */ "./src/utils/geometry.js");
/* harmony import */ var _DummyDataframe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DummyDataframe */ "./src/renderer/dataframe/DummyDataframe.js");
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/util */ "./src/utils/util.js");
/* harmony import */ var _viewportFeature__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./viewportFeature */ "./src/renderer/dataframe/viewportFeature.js");
/* harmony import */ var _FeatureIdsHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./FeatureIdsHelper */ "./src/renderer/dataframe/FeatureIdsHelper.js");
/* harmony import */ var _ViewportHelper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ViewportHelper */ "./src/renderer/dataframe/ViewportHelper.js");









// Maximum number of property textures that will be uploaded automatically to the GPU
// in a non-lazy manner
const MAX_GPU_AUTO_UPLOAD_TEXTURE_LIMIT = 32;

const featureClassCache = new Map();

class Dataframe extends _DummyDataframe__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor (...args) {
        super(...args);

        this._initHelpers();
    }

    _initHelpers () {
        if (!this._featureIdsHelper) {
            this._featureIdsHelper = new _FeatureIdsHelper__WEBPACK_IMPORTED_MODULE_4__["default"](this);
        }

        if (!this._viewportHelper) {
            this._viewportHelper = new _ViewportHelper__WEBPACK_IMPORTED_MODULE_5__["default"](this);
        }
    }

    /**
     * Loads all the relevant information to the WebGL context, provided by the renderer.
     * This includes:
     *   - the textures for each property
     *   - the buffers for vertices & normals
     *   - the auxiliary textures for style properties
     *
     * This method is very intensive in terms of computations, loading potentially a lot of CPU data to the GPU
     *
     */
    bindRenderer (renderer) {
        this.renderer = renderer;

        this._initHelpers();

        // Load alphanumeric properties to WebGL textures
        this.addProperties();

        // Load geometry-related data to WebGL buffers
        this._loadVertices();
        this._loadNormals();
        this._loadFeatureIds();

        // Create auxiliary WebGL style textures
        this._createEmptyStyleTextures();
    }

    /**
     * Gets width & height size, considering RTT_WIDTH and the number of features
     */
    getSize () {
        const width = this.renderer.RTT_WIDTH;
        const height = Math.ceil(this.numFeatures / width);
        return { width, height };
    }

    /**
     * Gets the WebGL context from the renderer
     */
    _getGL () {
        return this.renderer.gl;
    }

    /**
     * Creates the WebGL `vertexBuffer` and loads there the vertices
     */
    _loadVertices () {
        const gl = this._getGL();
        const vertices = this.decodedGeom.vertices;

        this.vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    }

    /**
     * Creates the WebGL `normalBuffer` and loads there the normals, if they exist
     */
    _loadNormals () {
        const gl = this._getGL();
        const normals = this.decodedGeom.normals;

        if (normals) {
            this.normalBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
        }
    }

    /**
     * Creates the WebGL `featureIDBuffer` and loads there the featureIds per vertex
     */
    _loadFeatureIds () {
        const gl = this._getGL();
        const ids = this._featureIdsHelper.getFeatureIds();

        this.featureIDBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this.featureIDBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, ids, gl.STATIC_DRAW);
    }

    getFeaturesAtPosition (position, viz) {
        if (!this.matrix) {
            return [];
        }

        switch (this.type) {
            case _utils_geometry__WEBPACK_IMPORTED_MODULE_0__["GEOMETRY_TYPE"].POINT:
                return this._viewportHelper.getPointsAtPosition(position, viz);
            case _utils_geometry__WEBPACK_IMPORTED_MODULE_0__["GEOMETRY_TYPE"].LINE:
            case _utils_geometry__WEBPACK_IMPORTED_MODULE_0__["GEOMETRY_TYPE"].POLYGON:
                return this._viewportHelper.getFeaturesAtPositionFromTriangles(this.type, position, viz);
            default:
                return [];
        }
    }

    inViewport (featureIndex) {
        if (!this.matrix) {
            return false;
        }

        switch (this.type) {
            case _utils_geometry__WEBPACK_IMPORTED_MODULE_0__["GEOMETRY_TYPE"].POINT:
                return this._viewportHelper.isPointInViewport(featureIndex);
            case _utils_geometry__WEBPACK_IMPORTED_MODULE_0__["GEOMETRY_TYPE"].LINE:
            case _utils_geometry__WEBPACK_IMPORTED_MODULE_0__["GEOMETRY_TYPE"].POLYGON:
                return this._viewportHelper.isPolygonInViewport(featureIndex);
            default:
                return false;
        }
    }

    getRenderedCentroid (featureIndex) {
        const centroid = { ...this._centroids[featureIndex] };
        centroid.x = centroid.x * this.scale + this.center.x;
        centroid.y = centroid.y * this.scale + this.center.y;
        const g = this._unprojectFromWebMercator(centroid);
        return [g.lng, g.lat];
    }

    getPropertyTexture (propertyName) {
        const encodedPropertyName = this._encodePropertyName(propertyName);

        if (this.propertyTex[encodedPropertyName]) {
            return this.propertyTex[encodedPropertyName];
        }

        this._loadPropertyValuesToTexture(propertyName);
        return this.propertyTex[encodedPropertyName];
    }

    /**
      * Creates a WebGL texture for that property and loads the property values,
      * if they exist
     */
    _loadPropertyValuesToTexture (propertyName) {
        const gl = this._getGL(); // Dataframe is already bound to this context, "hot update" it
        const propertiesFloat32Array = this.properties[propertyName];
        const encodedPropertyName = this._encodePropertyName(propertyName);

        const { width, height } = this.getSize();

        if (propertiesFloat32Array) {
            this.propertyTex[encodedPropertyName] = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.propertyTex[encodedPropertyName]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA,
                width, height, 0, gl.ALPHA, gl.FLOAT,
                propertiesFloat32Array);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        }
    }

    _encodePropertyName (propertyName) {
        return `_${propertyName}`;
    }

    free () {
        this._freeWebGLElements();

        Object.keys(this).forEach(key => {
            this[key] = null;
        });

        this.freed = true;
    }

    _freeWebGLElements () {
        if (!this.propertyTex) {
            return;
        }

        const gl = this._getGL();

        this.propertyTex.map(tex => gl.deleteTexture(tex));

        gl.deleteTexture(this.texColor);
        gl.deleteTexture(this.texStrokeColor);
        gl.deleteTexture(this.texWidth);
        gl.deleteTexture(this.texStrokeWidth);
        gl.deleteTexture(this.texFilter);

        gl.deleteBuffer(this.vertexBuffer);
        gl.deleteBuffer(this.featureIDBuffer);
    }

    /**
     * Converts a point {x, y} in WebMercator to {lng, lat}
     */
    _unprojectFromWebMercator ({ x, y }) {
        const DEG2RAD = Math.PI / 180;
        const EARTH_RADIUS = 6378137;
        return {
            lng: x * _utils_util__WEBPACK_IMPORTED_MODULE_2__["WM_R"] / EARTH_RADIUS / DEG2RAD,
            lat: (Math.atan(Math.pow(Math.E, y * _utils_util__WEBPACK_IMPORTED_MODULE_2__["WM_R"] / EARTH_RADIUS)) - Math.PI / 4) * 2 / DEG2RAD
        };
    }

    /**
     * Defines a `ViewportFeature` class dynamically, with the proper getters
     * to access its properties, if that doesn't exist yet in the `featureClassCache`
     */
    _genFeatureClass () {
        if (featureClassCache.has(this.metadata)) {
            this._featureClass = featureClassCache.get(this.metadata);
            return;
        }

        const cls = Object(_viewportFeature__WEBPACK_IMPORTED_MODULE_3__["genViewportFeatureClass"])(this.metadata);

        featureClassCache.set(this.metadata, cls);
        this._featureClass = cls;
    }

    /**
     * Builds a feature object for an index, copying all the properties.
     */
    getFeature (index) {
        if (!this.cachedFeatures) {
            this.cachedFeatures = new Array(this.numFeatures);
        }

        if (this.cachedFeatures[index] !== undefined) {
            return this.cachedFeatures[index];
        }

        if (!this._featureClass) {
            this._genFeatureClass();
        }

        const feature = new this._featureClass(index, this);
        this.cachedFeatures[index] = feature;
        return feature;
    }

    /**
     * Adds new properties to the dataframe or overwrite previously stored ones,
     * using metadata properties.
     *
     * These are all the relevant alphanumeric properties, which have been previously encoded
     * in a form like {propertyName: Float32Array}
     *
     */
    addProperties () {
        for (let i = 0; i < this.metadata.propertyKeys.length; i++) {
            const propertyName = this.metadata.propertyKeys[i];
            this._addProperty(propertyName);
        }

        this._genFeatureClass();
    }

    /**
     * If below GPU auto upload texture limit, it ensures that a WebGL texture is ready with
     * the values for that property already loaded
     */
    _addProperty (propertyName) {
        if (Object.keys(this.propertyTex).length < MAX_GPU_AUTO_UPLOAD_TEXTURE_LIMIT) {
            this.getPropertyTexture(propertyName);
        }
    }

    _createEmptyStyleTextures () {
        this.texColor = this._createStyleDataframeTexture();
        this.texWidth = this._createStyleDataframeTexture();
        this.texStrokeColor = this._createStyleDataframeTexture();
        this.texStrokeWidth = this._createStyleDataframeTexture();
        this.texFilter = this._createStyleDataframeTexture();
    }

    /**
     * Creates a new empty WebGL texture.
     * It just reserves the space for this 'intermediate texture'
     */
    _createStyleDataframeTexture () {
        // TODO we are wasting 75% of the memory for the scalar attributes (width, strokeWidth),
        // since RGB components are discarded
        const gl = this._getGL();
        const { width, height } = this.getSize();

        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,
            width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE,
            null); // empty!
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        return texture;
    }
}


/***/ }),

/***/ "./src/renderer/dataframe/DummyDataframe.js":
/*!**************************************************!*\
  !*** ./src/renderer/dataframe/DummyDataframe.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DummyDataframe; });
/* harmony import */ var _decoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../decoder */ "./src/renderer/decoder/index.js");
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/geometry */ "./src/utils/geometry.js");



class DummyDataframe {
    constructor ({ active, center, properties, propertiesArrayBuffer, scale, type, geom, size, metadata, x, y, z }) {
        this.active = active;
        this.center = center;
        this.properties = properties;
        this.propertiesArrayBuffer = propertiesArrayBuffer;
        this.scale = scale;
        this.type = type;
        this.decodedGeom = Object(_decoder__WEBPACK_IMPORTED_MODULE_0__["decodeGeom"])(type, geom);

        this.numVertex = (type === _utils_geometry__WEBPACK_IMPORTED_MODULE_1__["GEOMETRY_TYPE"].POINT) ? size * 3 : this.decodedGeom.vertices.length / 2;
        this.numFeatures = type === _utils_geometry__WEBPACK_IMPORTED_MODULE_1__["GEOMETRY_TYPE"].POINT ? size : this.decodedGeom.breakpoints.length || this.numVertex;
        this.propertyTex = [];
        this.metadata = metadata;
        this.propertyCount = 0;
        this.x = x;
        this.y = y;
        this.z = z;

        this._aabb = Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_1__["computeAABB"])(geom, type);
        this._centroids = Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_1__["computeCentroids"])(this.decodedGeom, type);

        this.t1 = [0.1, 0.1, 0.1, 0.1];
        this.t2 = [0.1, 0.1, 0.1, 0.1];
        this.t3 = [0.1, 0.1, 0.1, 0.1];
        this.t4 = [0.1, 0.1, 0.1, 0.1];
    }
}


/***/ }),

/***/ "./src/renderer/dataframe/FeatureIdsHelper.js":
/*!****************************************************!*\
  !*** ./src/renderer/dataframe/FeatureIdsHelper.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FeatureIdsHelper; });
class FeatureIdsHelper {
    constructor (dataframe) {
        this.dataframe = dataframe;
    }

    // References pointing to dataframe, to be in sync with its updates
    get decodedGeom () { return this.dataframe.decodedGeom; }
    get numFeatures () { return this.dataframe.numFeatures; }

    /**
     * Gets the featureId per each vertice.
     */
    getFeatureIds () {
        const breakpoints = this.decodedGeom.breakpoints;
        const isPointType = !breakpoints.length;

        if (isPointType) {
            return this._getFeatureIdsForPoints();
        } else {
            return this._getFeatureIdsForLinesOrPolygons();
        }
    }

    _getFeatureIdsForPoints () {
        const numVertices = this.decodedGeom.vertices.length;
        let { tableX, tableY } = this._createTablesXY();

        const ids = new Float32Array(numVertices);
        const inc = 1 / (1024 * 64);
        let index = 0;

        for (let i = 0; i < numVertices; i += 6) {
            ids[i + 0] = tableX[index];
            ids[i + 1] = tableY[index];

            if (ids[i + 0] === 0) {
                ids[i + 0] += inc;
            }
            if (ids[i + 1] === 0) {
                ids[i + 1] += inc;
            }

            ids[i + 2] = -ids[i + 0];
            ids[i + 3] = ids[i + 1];

            ids[i + 4] = ids[i + 0];
            ids[i + 5] = -ids[i + 1];
            index++;
        }

        return ids;
    }

    _getFeatureIdsForLinesOrPolygons () {
        const numVertices = this.decodedGeom.vertices.length;
        let { tableX, tableY } = this._createTablesXY();
        const breakpoints = this.decodedGeom.breakpoints;

        const ids = new Float32Array(numVertices);
        let index = 0;

        for (let i = 0; i < numVertices; i += 2) {
            while (i === breakpoints[index]) {
                index++;
            }
            ids[i + 0] = tableX[index];
            ids[i + 1] = tableY[index];
        }

        return ids;
    }

    _createTablesXY () {
        let tableX = {};
        let tableY = {};

        const { height, width } = this.dataframe.getSize();

        for (let k = 0; k < this.numFeatures; k++) {
            // Transform integer ID into a `vec2` to overcome WebGL 1 limitations,
            // output IDs will be in the `vec2([0,1], [0,1])` range
            tableX[k] = (k % width) / (width - 1);
            tableY[k] = height > 1 ? Math.floor(k / width) / (height - 1) : 0.5;
        }

        return { tableX, tableY };
    }
}


/***/ }),

/***/ "./src/renderer/dataframe/ProjectionHelper.js":
/*!****************************************************!*\
  !*** ./src/renderer/dataframe/ProjectionHelper.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ProjectionHelper; });
class ProjectionHelper {
    constructor (dataframe) {
        this.dataframe = dataframe;
    }

    // Reference pointing to dataframe, to be in sync with its updates
    get matrix () { return this.dataframe.matrix; }

    toNDC (x, y) {
        const { ox, oy, ow } = this.toClipSpace(x, y);

        // Normalize by W
        return { x: ox / ow, y: oy / ow };
    }

    toClipSpace (x, y) {
        const matrix = this.matrix;
        const ox = matrix[0] * x + matrix[4] * y + matrix[12];
        const oy = matrix[1] * x + matrix[5] * y + matrix[13];
        const ow = matrix[3] * x + matrix[7] * y + matrix[15];

        return { ox, oy, ow };
    }
}


/***/ }),

/***/ "./src/renderer/dataframe/ViewportHelper.js":
/*!**************************************************!*\
  !*** ./src/renderer/dataframe/ViewportHelper.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewportHelper; });
/* harmony import */ var _utils_collision__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/collision */ "./src/utils/collision.js");
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/geometry */ "./src/utils/geometry.js");
/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Renderer */ "./src/renderer/Renderer.js");
/* harmony import */ var _constants_layer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../constants/layer */ "./src/constants/layer.js");
/* harmony import */ var _ProjectionHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ProjectionHelper */ "./src/renderer/dataframe/ProjectionHelper.js");






const AABBTestResults = {
    INSIDE: 1,
    OUTSIDE: -1,
    INTERSECTS: 0
};

const SIZE_SATURATION_PX = 1024;

class ViewportHelper {
    constructor (dataframe) {
        this.dataframe = dataframe;

        this.getFeature = dataframe.getFeature.bind(dataframe);
        this._getGL = dataframe._getGL.bind(dataframe);
        this._projection = new _ProjectionHelper__WEBPACK_IMPORTED_MODULE_4__["default"](dataframe);
    }

    // References pointing to dataframe, to be in sync with its updates
    get decodedGeom () { return this.dataframe.decodedGeom; }
    get _aabb () { return this.dataframe._aabb; }
    get numFeatures () { return this.dataframe.numFeatures; }
    get renderer () { return this.dataframe.renderer; }
    get matrix () { return this.dataframe.matrix; }
    get scale () { return this.dataframe.scale; }

    /**
     * Checks if the point is inside the viewport.
     */
    isPointInViewport (featureIndex) {
        const vertices = this.decodedGeom.vertices;
        const x = vertices[6 * featureIndex + 0];
        const y = vertices[6 * featureIndex + 1];

        const { ox, oy, ow } = this._projection.toClipSpace(x, y);

        // Checks in Clip Space if the point is inside the viewport
        // See https://www.khronos.org/opengl/wiki/Vertex_Post-Processing#Clipping
        const inside = ox > -ow && ox < ow && oy > -ow && oy < ow;
        return inside;
    }

    /**
     * Checks if the polygon is inside the viewport.
     */
    isPolygonInViewport (featureIndex) {
        const featureAABB = this._aabb[featureIndex];
        const aabbResult = this._compareAABBs(featureAABB);

        if (aabbResult === AABBTestResults.INTERSECTS) {
            const vertices = this.decodedGeom.vertices;
            const normals = this.decodedGeom.normals;
            const range = this.decodedGeom.featureIDToVertexIndex.get(featureIndex);
            return this._isPolygonCollidingViewport(vertices, normals, range.start, range.end);
        }

        return aabbResult === AABBTestResults.INSIDE;
    }

    /**
     * Get canvas size in pixels, in a {WIDTH, HEIGHT} object, using the devicePixelRatio
     */
    _getCanvasSizeInPixels () {
        const canvas = this._getGL().canvas;
        const WIDTH = canvas.width / window.devicePixelRatio;
        const HEIGHT = canvas.height / window.devicePixelRatio;

        return { WIDTH, HEIGHT };
    }

    _compareAABBs (featureAABB) {
        if (featureAABB === null) {
            return AABBTestResults.OUTSIDE;
        }

        const corners1 = this._projection.toNDC(featureAABB.minx, featureAABB.miny);
        const corners2 = this._projection.toNDC(featureAABB.minx, featureAABB.maxy);
        const corners3 = this._projection.toNDC(featureAABB.maxx, featureAABB.miny);
        const corners4 = this._projection.toNDC(featureAABB.maxx, featureAABB.maxy);

        const featureStrokeAABB = {
            minx: Math.min(corners1.x, corners2.x, corners3.x, corners4.x),
            miny: Math.min(corners1.y, corners2.y, corners3.y, corners4.y),
            maxx: Math.max(corners1.x, corners2.x, corners3.x, corners4.x),
            maxy: Math.max(corners1.y, corners2.y, corners3.y, corners4.y)
        };

        const viewportAABB = {
            minx: -1,
            miny: -1,
            maxx: 1,
            maxy: 1
        };

        switch (true) {
            case this._isFeatureAABBInsideViewport(featureStrokeAABB, viewportAABB):
                return AABBTestResults.INSIDE;
            case this._isFeatureAABBOutsideViewport(featureStrokeAABB, viewportAABB):
                return AABBTestResults.OUTSIDE;
            default:
                return AABBTestResults.INTERSECTS;
        }
    }

    _isPolygonCollidingViewport (vertices, normals, start, end) { // NORMALS??? FIXME TODO
        if (!this.matrix) {
            return false;
        }

        const aabb = { minx: -1, miny: -1, maxx: 1, maxy: 1 };
        for (let i = start; i < end; i += 6) {
            const v1 = this._projection.toNDC(vertices[i + 0], vertices[i + 1]);
            const v2 = this._projection.toNDC(vertices[i + 2], vertices[i + 3]);
            const v3 = this._projection.toNDC(vertices[i + 4], vertices[i + 5]);

            const triangle = [{
                x: v1.x,
                y: v1.y
            }, {
                x: v2.x,
                y: v2.y
            }, {
                x: v3.x,
                y: v3.y
            }];

            if (Object(_utils_collision__WEBPACK_IMPORTED_MODULE_0__["triangleCollides"])(triangle, aabb)) {
                return true;
            }
        }

        return false;
    }

    _isFeatureAABBInsideViewport (featureAABB, viewportAABB) {
        return (featureAABB.minx >= viewportAABB.minx && featureAABB.maxx <= viewportAABB.maxx &&
            featureAABB.miny >= viewportAABB.miny && featureAABB.maxy <= viewportAABB.maxy);
    }

    _isFeatureAABBOutsideViewport (featureAABB, viewportAABB) {
        return (featureAABB.minx > viewportAABB.maxx || featureAABB.miny > viewportAABB.maxy ||
            featureAABB.maxx < viewportAABB.minx || featureAABB.maxy < viewportAABB.miny);
    }

    getPointsAtPosition (position, viz) {
        const points = this.decodedGeom.vertices;

        // FIXME: points.length includes rejected points (out of tile)
        // so we use numFeatures here, but should fix the points size
        const features = [];
        for (let i = 0; i < this.numFeatures * 6; i += 6) {
            const featureIndex = i / 6;
            const feature = this.getFeature(featureIndex);

            if (this._isFeatureFiltered(feature, viz.filter)) {
                continue;
            }

            const point = { x: points[i], y: points[i + 1] };
            const { center, radius } = this._getCircleFor(point, feature, viz);

            const inside = Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_1__["pointInCircle"])(position, center, radius);
            if (inside) {
                features.push(feature);
            }
        }

        return features;
    }

    _isFeatureFiltered (feature, filterExpression) {
        return filterExpression.eval(feature) < _Renderer__WEBPACK_IMPORTED_MODULE_2__["FILTERING_THRESHOLD"];
    }

    /**
     * Gets a circle for that point of the feature, considering the viz properties
     * (symbolPlacement, transform, width and strokeWidth).
     *
     * It is expressed as {center, radius}, using pixel coordinates
     */
    _getCircleFor (point, feature, viz) {
        const { WIDTH, HEIGHT } = this._getCanvasSizeInPixels();

        const center = this._projection.toNDC(point.x, point.y);

        // Project to pixel space
        center.x *= 0.5;
        center.y *= -0.5;
        center.x += 0.5;
        center.y += 0.5;
        center.x *= WIDTH;
        center.y *= HEIGHT;

        const radius = this._computePointRadius(feature, viz);

        if (!viz.symbol.default) {
            const symbolOffset = viz.symbolPlacement.eval(feature);
            center.x += symbolOffset[0] * radius;
            center.y -= symbolOffset[1] * radius;
        }

        if (!viz.transform.default) {
            const vizOffset = viz.transform.eval(feature);
            center.x += vizOffset.x;
            center.y -= vizOffset.y;
        }

        return { center, radius };
    }

    getFeaturesAtPositionFromTriangles (geometryType, position, viz) {
        const vertices = this.decodedGeom.vertices;
        const normals = this.decodedGeom.normals;
        const breakpoints = this.decodedGeom.breakpoints;

        const features = [];
        // Linear search for all features
        // Tests triangles since we already have the triangulated form
        // Moreover, with an acceleration structure and triangle testing features could be subdivided easily
        let featureIndex = -1;
        let strokeWidthScale;
        const offset = { x: 0, y: 0 };

        const { WIDTH, HEIGHT } = this._getCanvasSizeInPixels();

        for (let i = 0; i < vertices.length; i += 6) {
            if (i === 0 || i >= breakpoints[featureIndex]) {
                featureIndex++;
                const feature = this.getFeature(featureIndex);

                if (!viz.transform.default) {
                    const vizOffset = viz.transform.eval(feature);
                    offset.x = vizOffset[0];
                    offset.y = vizOffset[1];
                }

                strokeWidthScale = geometryType === _utils_geometry__WEBPACK_IMPORTED_MODULE_1__["GEOMETRY_TYPE"].LINE
                    ? this._computeLineWidthScale(feature, viz)
                    : this._computePolygonWidthScale(feature, viz);

                if (this._isFeatureFiltered(feature, viz.filter) ||
                    !this._isPointInAABB(position, offset,
                        geometryType === _utils_geometry__WEBPACK_IMPORTED_MODULE_1__["GEOMETRY_TYPE"].LINE
                            ? viz.width.eval(feature)
                            : viz.strokeWidth.eval(feature)
                        ,
                        featureIndex)
                ) {
                    i = breakpoints[featureIndex] - 6;
                    continue;
                }
            }

            const v1 = this._projection.toNDC(
                vertices[i + 0] + normals[i + 0] * strokeWidthScale,
                vertices[i + 1] + normals[i + 1] * strokeWidthScale
            );

            const v2 = this._projection.toNDC(
                vertices[i + 2] + normals[i + 2] * strokeWidthScale,
                vertices[i + 3] + normals[i + 3] * strokeWidthScale
            );

            const v3 = this._projection.toNDC(
                vertices[i + 4] + normals[i + 4] * strokeWidthScale,
                vertices[i + 5] + normals[i + 5] * strokeWidthScale
            );

            v1.x *= 0.5;
            v1.y *= -0.5;
            v1.x += 0.5;
            v1.y += 0.5;

            v2.x *= 0.5;
            v2.y *= -0.5;
            v2.x += 0.5;
            v2.y += 0.5;

            v3.x *= 0.5;
            v3.y *= -0.5;
            v3.x += 0.5;
            v3.y += 0.5;

            const inside = Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_1__["pointInTriangle"])(position,
                { x: v1.x * WIDTH + offset.x, y: v1.y * HEIGHT - offset.y },
                { x: v2.x * WIDTH + offset.x, y: v2.y * HEIGHT - offset.y },
                { x: v3.x * WIDTH + offset.x, y: v3.y * HEIGHT - offset.y });

            if (inside) {
                features.push(this.getFeature(featureIndex));
                // Don't repeat a feature if the point is on a shared (by two triangles) edge
                // Also, don't waste CPU cycles
                i = breakpoints[featureIndex] - 6;
            }
        }

        return features;
    }

    _isPointInAABB (point, offset, widthScale, featureIndex) {
        // Transform AABB from tile space to NDC space
        const aabb = this._aabb[featureIndex];
        if (aabb === null || !this.matrix) {
            return false;
        }

        const corners1 = this._projection.toNDC(aabb.minx, aabb.miny);
        const corners2 = this._projection.toNDC(aabb.minx, aabb.maxy);
        const corners3 = this._projection.toNDC(aabb.maxx, aabb.miny);
        const corners4 = this._projection.toNDC(aabb.maxx, aabb.maxy);

        const ndcAABB = {
            minx: Math.min(corners1.x, corners2.x, corners3.x, corners4.x),
            miny: Math.min(corners1.y, corners2.y, corners3.y, corners4.y),
            maxx: Math.max(corners1.x, corners2.x, corners3.x, corners4.x),
            maxy: Math.max(corners1.y, corners2.y, corners3.y, corners4.y)
        };

        const { WIDTH, HEIGHT } = this._getCanvasSizeInPixels();

        const ox = 2 * offset.x / WIDTH;
        const oy = 2 * offset.y / HEIGHT;
        const ndcPoint = {
            x: point.x / WIDTH * 2 - 1,
            y: -(point.y / HEIGHT * 2 - 1)
        };

        const pointAABB = {
            minx: ndcPoint.x + ox - widthScale * 2 / WIDTH,
            miny: ndcPoint.y - oy - widthScale * 2 / HEIGHT,
            maxx: ndcPoint.x + ox + widthScale * 2 / WIDTH,
            maxy: ndcPoint.y - oy + widthScale * 2 / HEIGHT
        };

        return !this._isFeatureAABBOutsideViewport(ndcAABB, pointAABB);
    }

    _computePointRadius (feature, viz) {
        const widthPixels = Math.min(viz.width.eval(feature), SIZE_SATURATION_PX);
        const strokeWidthPixels = Math.min(viz.strokeWidth.eval(feature), SIZE_SATURATION_PX);
        const diameter = widthPixels + strokeWidthPixels;
        return diameter / 2;
    }

    _computeLineWidthScale (feature, viz) {
        const diameter = Math.min(viz.width.eval(feature), SIZE_SATURATION_PX);
        return diameter / 2 / this.scale / this._resolutionForZoomLevel();
    }

    _computePolygonWidthScale (feature, viz) {
        const diameter = Math.min(viz.strokeWidth.eval(feature), SIZE_SATURATION_PX);
        return diameter / 2 / this.scale / this._resolutionForZoomLevel();
    }

    _resolutionForZoomLevel () {
        return (Math.pow(2, this.renderer.drawMetadata.zoomLevel) * _constants_layer__WEBPACK_IMPORTED_MODULE_3__["RESOLUTION_ZOOMLEVEL_ZERO"]);
    }
}


/***/ }),

/***/ "./src/renderer/dataframe/viewportFeature.js":
/*!***************************************************!*\
  !*** ./src/renderer/dataframe/viewportFeature.js ***!
  \***************************************************/
/*! exports provided: genViewportFeatureClass */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "genViewportFeatureClass", function() { return genViewportFeatureClass; });
/**
 * Function to create dynamically a ViewportFeature class, with the proper getters
 * to access its properties, as declared in the `metadata`
 */
function genViewportFeatureClass (metadata) {
    const classTemplate = class ViewportFeature {
        constructor (index, dataframe) {
            this._index = index;
            this._dataframe = dataframe;
        }
    };
    Object.defineProperties(classTemplate.prototype, buildGettersFrom(metadata));

    return classTemplate;
}

function buildGettersFrom (metadata) {
    const getters = {};
    metadata.propertyKeys.forEach(propertyName => {
        const codec = metadata.codec(propertyName);
        if (codec.isRange()) {
            const decodedProperties = metadata.decodedProperties(propertyName);
            getters[propertyName] = {
                get: function () {
                    const index = this._index;
                    const args = decodedProperties.map(name => this._dataframe.properties[name][index]);
                    return codec.internalToExternal(metadata, args);
                }
            };
        } else {
            getters[propertyName] = {
                get: function () {
                    const index = this._index;
                    const value = this._dataframe.properties[propertyName][index];
                    return codec.internalToExternal(metadata, value);
                }
            };
        }
    });
    return getters;
}


/***/ }),

/***/ "./src/renderer/decoder/common.js":
/*!****************************************!*\
  !*** ./src/renderer/decoder/common.js ***!
  \****************************************/
/*! exports provided: addLineString, resizeBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addLineString", function() { return addLineString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resizeBuffer", function() { return resizeBuffer; });
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/geometry */ "./src/utils/geometry.js");


/**
 * Create a triangulated lineString: zero-sized, vertex-shader expanded triangle list
 * with `miter` joins. For angle < 60 joins are automatically adjusted to `bevel`.
 * https://github.com/CartoDB/carto-vl/wiki/Line-rendering
 */
function addLineString (lineString, geomBuffer, index, isPolygon, skipCallback) {
    let prevPoint, currentPoint;
    let prevNormal, nextNormal;
    let drawLine;

    // We need at least two points
    if (lineString.length >= 4) {
        // Initialize the first two points
        prevPoint = [lineString[0], lineString[1]];
        let i = 2;
        // The second point may be the same as the first one, iterate to find the first different one
        for (;i <= lineString.length; i += 2) {
            currentPoint = [lineString[i], lineString[i + 1]];
            if (prevPoint[0] !== currentPoint[0] || prevPoint[1] !== currentPoint[1]) {
                i += 2;
                break;
            }
        }
        prevNormal = Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_0__["getLineNormal"])(prevPoint, currentPoint);
        for (;i <= lineString.length; i += 2) {
            drawLine = !(skipCallback && skipCallback(i));

            let nextPoint;
            // With lines, the ending point won't have a nextPoint
            if (i <= lineString.length - 2) {
                nextPoint = [lineString[i], lineString[i + 1]];
            } else if (isPolygon) {
                nextPoint = [lineString[2], lineString[3]];
            }

            if (drawLine &&
                !(prevPoint[0] === currentPoint[0] && prevPoint[1] === currentPoint[1])) {
                // First triangle
                geomBuffer.vertices[index] = prevPoint[0];
                geomBuffer.normals[index++] = -prevNormal[0];
                geomBuffer.vertices[index] = prevPoint[1];
                geomBuffer.normals[index++] = -prevNormal[1];
                geomBuffer.vertices[index] = prevPoint[0];
                geomBuffer.normals[index++] = prevNormal[0];
                geomBuffer.vertices[index] = prevPoint[1];
                geomBuffer.normals[index++] = prevNormal[1];
                geomBuffer.vertices[index] = currentPoint[0];
                geomBuffer.normals[index++] = prevNormal[0];
                geomBuffer.vertices[index] = currentPoint[1];
                geomBuffer.normals[index++] = prevNormal[1];

                // Second triangle
                geomBuffer.vertices[index] = prevPoint[0];
                geomBuffer.normals[index++] = -prevNormal[0];
                geomBuffer.vertices[index] = prevPoint[1];
                geomBuffer.normals[index++] = -prevNormal[1];
                geomBuffer.vertices[index] = currentPoint[0];
                geomBuffer.normals[index++] = prevNormal[0];
                geomBuffer.vertices[index] = currentPoint[1];
                geomBuffer.normals[index++] = prevNormal[1];
                geomBuffer.vertices[index] = currentPoint[0];
                geomBuffer.normals[index++] = -prevNormal[0];
                geomBuffer.vertices[index] = currentPoint[1];
                geomBuffer.normals[index++] = -prevNormal[1];
            }

            if (nextPoint && !(nextPoint[0] === currentPoint[0] && nextPoint[1] === currentPoint[1])) {
                nextNormal = Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_0__["getLineNormal"])(currentPoint, nextPoint);

                if (drawLine) {
                    // `turnLeft` indicates that the nextLine turns to the left
                    // `joinNormal` contains the direction and size for the `miter` vertex
                    //  If this is not defined means that the join must be `bevel`.
                    let { turnLeft, joinNormal } = Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_0__["getJoinNormal"])(prevNormal, nextNormal);

                    let leftNormal = turnLeft ? prevNormal : Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_0__["neg"])(nextNormal);
                    let rightNormal = turnLeft ? nextNormal : Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_0__["neg"])(prevNormal);

                    // Third triangle
                    geomBuffer.vertices[index] = currentPoint[0];
                    geomBuffer.normals[index++] = 0;
                    geomBuffer.vertices[index] = currentPoint[1];
                    // Mark vertex to be stroke in PolygonShader with the
                    // non-zero value 1e-37, so it validates the expression
                    // `normal != vec2(0.)` without affecting the vertex position.
                    geomBuffer.normals[index++] = isPolygon ? 1e-37 : 0;
                    geomBuffer.vertices[index] = currentPoint[0];
                    geomBuffer.normals[index++] = leftNormal[0];
                    geomBuffer.vertices[index] = currentPoint[1];
                    geomBuffer.normals[index++] = leftNormal[1];
                    geomBuffer.vertices[index] = currentPoint[0];
                    geomBuffer.normals[index++] = rightNormal[0];
                    geomBuffer.vertices[index] = currentPoint[1];
                    geomBuffer.normals[index++] = rightNormal[1];

                    if (joinNormal) {
                        // Forth triangle
                        geomBuffer.vertices[index] = currentPoint[0];
                        geomBuffer.normals[index++] = joinNormal[0];
                        geomBuffer.vertices[index] = currentPoint[1];
                        geomBuffer.normals[index++] = joinNormal[1];
                        geomBuffer.vertices[index] = currentPoint[0];
                        geomBuffer.normals[index++] = rightNormal[0];
                        geomBuffer.vertices[index] = currentPoint[1];
                        geomBuffer.normals[index++] = rightNormal[1];
                        geomBuffer.vertices[index] = currentPoint[0];
                        geomBuffer.normals[index++] = leftNormal[0];
                        geomBuffer.vertices[index] = currentPoint[1];
                        geomBuffer.normals[index++] = leftNormal[1];
                    }
                }
            } else {
                nextNormal = prevNormal;
            }

            // Update the variables for the next iteration
            prevPoint = currentPoint;
            currentPoint = nextPoint;
            prevNormal = nextNormal;
        }
    }
    return index;
}

/**
 * Resize a Float32Array buffer in an efficient way
 */
function resizeBuffer (oldBuffer, newSize) {
    const newBuffer = new Float32Array(newSize);
    newBuffer.set(oldBuffer);
    return newBuffer;
}


/***/ }),

/***/ "./src/renderer/decoder/index.js":
/*!***************************************!*\
  !*** ./src/renderer/decoder/index.js ***!
  \***************************************/
/*! exports provided: decodeGeom */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeGeom", function() { return decodeGeom; });
/* harmony import */ var _pointDecoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pointDecoder */ "./src/renderer/decoder/pointDecoder.js");
/* harmony import */ var _lineDecoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lineDecoder */ "./src/renderer/decoder/lineDecoder.js");
/* harmony import */ var _polygonDecoder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polygonDecoder */ "./src/renderer/decoder/polygonDecoder.js");
/* harmony import */ var _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../errors/carto-runtime-error */ "./src/errors/carto-runtime-error.js");
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/geometry */ "./src/utils/geometry.js");






function decodeGeom (geomType, geom) {
    switch (geomType) {
        case _utils_geometry__WEBPACK_IMPORTED_MODULE_4__["GEOMETRY_TYPE"].POINT:
            return Object(_pointDecoder__WEBPACK_IMPORTED_MODULE_0__["decodePoint"])(geom);
        case _utils_geometry__WEBPACK_IMPORTED_MODULE_4__["GEOMETRY_TYPE"].LINE:
            return Object(_lineDecoder__WEBPACK_IMPORTED_MODULE_1__["decodeLine"])(geom);
        case _utils_geometry__WEBPACK_IMPORTED_MODULE_4__["GEOMETRY_TYPE"].POLYGON:
            return Object(_polygonDecoder__WEBPACK_IMPORTED_MODULE_2__["decodePolygon"])(geom);
        default:
            throw new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_3__["default"](
                `Unimplemented geometry type: '${geomType}'.`,
                _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_3__["CartoRuntimeErrorTypes"].NOT_SUPPORTED
            );
    }
}


/***/ }),

/***/ "./src/renderer/decoder/lineDecoder.js":
/*!*********************************************!*\
  !*** ./src/renderer/decoder/lineDecoder.js ***!
  \*********************************************/
/*! exports provided: decodeLine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeLine", function() { return decodeLine; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "./src/renderer/decoder/common.js");


// If the geometry type is GEOMETRY_TYPE.LINE it will generate the appropriate zero-sized, vertex-shader expanded triangle list with `miter` and `bevel` joins.
// The geom will be an array of coordinates in this case

const STATIC_INITIAL_BUFFER_SIZE = 1024 * 1024; // 4 MB
const MAX_VERTICES_COORDINATES_PER_SEGMENT = 24;

let index = 0;
let geomBuffer = {
    vertices: new Float32Array(STATIC_INITIAL_BUFFER_SIZE),
    normals: new Float32Array(STATIC_INITIAL_BUFFER_SIZE)
};

function decodeLine (geometry) {
    let breakpoints = []; // Array of indices (to vertexArray) that separate each feature
    let featureIDToVertexIndex = new Map();

    index = 0;
    for (let i = 0; i < geometry.length; i++) {
        const feature = geometry[i];
        for (let j = 0; j < feature.length; j++) {
            // Increase buffers size if required
            resizeBuffers(MAX_VERTICES_COORDINATES_PER_SEGMENT * feature[j].length);

            // Add line string
            index = Object(_common__WEBPACK_IMPORTED_MODULE_0__["addLineString"])(feature[j], geomBuffer, index);
        }

        featureIDToVertexIndex.set(breakpoints.length, breakpoints.length === 0
            ? { start: 0, end: index }
            : { start: featureIDToVertexIndex.get(breakpoints.length - 1).end, end: index });

        breakpoints.push(index);
    }

    const verticesArrayBuffer = new ArrayBuffer(4 * index);
    const normalsArrayBuffer = new ArrayBuffer(4 * index);
    const vertices = new Float32Array(verticesArrayBuffer);
    const normals = new Float32Array(normalsArrayBuffer);
    for (let i = 0; i < index; i++) {
        vertices[i] = geomBuffer.vertices[i];
        normals[i] = geomBuffer.normals[i];
    }
    return {
        vertices,
        normals,
        verticesArrayBuffer,
        normalsArrayBuffer,
        featureIDToVertexIndex,
        breakpoints
    };
}

// Resize buffers as needed if `additionalSize` floats overflow the current buffers.
function resizeBuffers (additionalSize) {
    const minimumNeededSize = index + additionalSize;
    if (minimumNeededSize > geomBuffer.vertices.length) {
        const newSize = 2 * minimumNeededSize;
        geomBuffer.vertices = Object(_common__WEBPACK_IMPORTED_MODULE_0__["resizeBuffer"])(geomBuffer.vertices, newSize);
        geomBuffer.normals = Object(_common__WEBPACK_IMPORTED_MODULE_0__["resizeBuffer"])(geomBuffer.normals, newSize);
    }
}


/***/ }),

/***/ "./src/renderer/decoder/pointDecoder.js":
/*!**********************************************!*\
  !*** ./src/renderer/decoder/pointDecoder.js ***!
  \**********************************************/
/*! exports provided: decodePoint */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodePoint", function() { return decodePoint; });
// If the geometry type is GEOMETRY_TYPE.POINT it will pass through the geom (the vertex array)

function decodePoint (verticesArrayBuffer) {
    return {
        verticesArrayBuffer: verticesArrayBuffer,
        vertices: new Float32Array(verticesArrayBuffer),
        breakpoints: []
    };
}


/***/ }),

/***/ "./src/renderer/decoder/polygonDecoder.js":
/*!************************************************!*\
  !*** ./src/renderer/decoder/polygonDecoder.js ***!
  \************************************************/
/*! exports provided: decodePolygon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodePolygon", function() { return decodePolygon; });
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! earcut */ "./node_modules/earcut/src/earcut.js");
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(earcut__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ "./src/renderer/decoder/common.js");



// If the geometry type is GEOMETRY_TYPE.POLYGON it will triangulate the polygon list (geom)
// geom will be a list of polygons in which each polygon will have a flat array of vertices and a list of holes indices
// Example:
/*   let geom = [{
       flat: [
         0.,0., 1.,0., 1.,1., 0.,1., 0.,0, //A square
         0.25,0.25, 0.75,0.25, 0.75,0.75, 0.25,0.75, 0.25,0.25//A small square
       ]
       holes: [5]
     }]
*/

const STATIC_INITIAL_BUFFER_SIZE = 1024 * 1024 * 2; // 8 MB
const VERTEX_COORDINATES_PER_TRIANGLE = 2;
const MAX_VERTICES_COORDINATES_PER_SEGMENT = 24;

let index = 0;
let geomBuffer = {
    vertices: new Float32Array(STATIC_INITIAL_BUFFER_SIZE),
    normals: new Float32Array(STATIC_INITIAL_BUFFER_SIZE)
};

function decodePolygon (geometry) {
    let breakpoints = []; // Array of indices (to vertexArray) that separate each feature
    let featureIDToVertexIndex = new Map();

    index = 0;
    for (let i = 0; i < geometry.length; i++) {
        const feature = geometry[i];
        for (let j = 0; j < feature.length; j++) {
            const polygon = feature[j];
            const triangles = earcut__WEBPACK_IMPORTED_MODULE_0__(polygon.flat, polygon.holes);

            // Increase buffers size if required
            resizeBuffers(VERTEX_COORDINATES_PER_TRIANGLE * triangles.length +
                MAX_VERTICES_COORDINATES_PER_SEGMENT * polygon.flat.length);

            // Add polygon
            for (let k = 0; k < triangles.length; k++) {
                addVertex(polygon.flat, 2 * triangles[k]);
            }

            // Add polygon stroke
            index = Object(_common__WEBPACK_IMPORTED_MODULE_1__["addLineString"])(polygon.flat, geomBuffer, index, true, (pointIndex) => {
                // Skip adding the line which connects two rings OR is clipped
                return polygon.holes.includes((pointIndex - 2) / 2) || isClipped(polygon, pointIndex - 4, pointIndex - 2);
            });
        }

        featureIDToVertexIndex.set(breakpoints.length, breakpoints.length === 0
            ? { start: 0, end: index }
            : { start: featureIDToVertexIndex.get(breakpoints.length - 1).end, end: index });

        breakpoints.push(index);
    }

    const verticesArrayBuffer = new ArrayBuffer(4 * index);
    const normalsArrayBuffer = new ArrayBuffer(4 * index);
    const vertices = new Float32Array(verticesArrayBuffer);
    const normals = new Float32Array(normalsArrayBuffer);
    for (let i = 0; i < index; i++) {
        vertices[i] = geomBuffer.vertices[i];
        normals[i] = geomBuffer.normals[i];
    }
    return {
        vertices,
        normals,
        verticesArrayBuffer,
        normalsArrayBuffer,
        featureIDToVertexIndex,
        breakpoints
    };
}

// Resize buffers as needed if `additionalSize` floats overflow the current buffers
function resizeBuffers (additionalSize) {
    const minimumNeededSize = index + additionalSize;
    if (minimumNeededSize > geomBuffer.vertices.length) {
        const newSize = 2 * minimumNeededSize;
        geomBuffer.vertices = Object(_common__WEBPACK_IMPORTED_MODULE_1__["resizeBuffer"])(geomBuffer.vertices, newSize);
        geomBuffer.normals = Object(_common__WEBPACK_IMPORTED_MODULE_1__["resizeBuffer"])(geomBuffer.normals, newSize);
    }
}

// Add vertex in triangles.
function addVertex (array, vertexIndex) {
    geomBuffer.vertices[index] = array[vertexIndex];
    geomBuffer.normals[index++] = 0;
    geomBuffer.vertices[index] = array[vertexIndex + 1];
    geomBuffer.normals[index++] = 0;
}

function isClipped (polygon, i, j) {
    if (polygon.clipped.includes(i) && polygon.clipped.includes(j)) {
        if (polygon.clippedType[polygon.clipped.indexOf(i)] &
            polygon.clippedType[polygon.clipped.indexOf(j)]) {
            return true;
        }
    }
    return false;
}


/***/ }),

/***/ "./src/renderer/schema.js":
/*!********************************!*\
  !*** ./src/renderer/schema.js ***!
  \********************************/
/*! exports provided: IDENTITY, union, equals, notEquals, column, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IDENTITY", function() { return IDENTITY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "union", function() { return union; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notEquals", function() { return notEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "column", function() { return column; });
/* harmony import */ var _constants_metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/metadata */ "./src/constants/metadata.js");


const IDENTITY = {};

/*
const mns = {
    price:  [{type: 'unaggregated'}],
    amount: [{type: 'aggregated', op: 'avg'}, {type: 'aggregated', op: 'max'}}],
    dow:    [{type: 'dimension', dimension: { group: {units: 'dayOfWeek'}}}]
};

*/

function union (a, b) {
    const result = {};
    const propertyNames = new Set(Object.keys(a).concat(Object.keys(b)));
    propertyNames.forEach(propertyName => {
        const aUsages = a[propertyName] || [];
        const bUsages = b[propertyName] || [];
        const combinedUsage = [...aUsages, ...bUsages];
        result[propertyName] = combinedUsage;
    });
    return result;
}

function equals (a, b) {
    if (!a || !b) {
        return false;
    }
    return JSON.stringify(simplify(a)) === JSON.stringify(simplify(b));
}

function notEquals (a, b) {
    return !equals(a, b);
}

function simplify (MNS) {
    const result = {};
    const propertyNames = Object.keys(MNS).sort();
    propertyNames.forEach(propertyName => {
        // Stringify and Set to remove duplicates
        let usage = [...new Set(MNS[propertyName].map(u => JSON.stringify(u)))];
        usage.sort();
        usage = usage.map(u => JSON.parse(u));
        result[propertyName] = usage;
    });
    return result;
}

// column information functions
const column = {
    aggColumn (name, aggFN) {
        return `${_constants_metadata__WEBPACK_IMPORTED_MODULE_0__["AGG_PREFIX"]}${aggFN}_${name}`;
    },
    dimColumn (name, groupBy) {
        return `${_constants_metadata__WEBPACK_IMPORTED_MODULE_0__["DIM_PREFIX"]}${groupBy}_${name}`;
    }
};

/* harmony default export */ __webpack_exports__["default"] = ({ column, equals, notEquals, union, IDENTITY, simplify });


/***/ }),

/***/ "./src/renderer/shaders/Cache.js":
/*!***************************************!*\
  !*** ./src/renderer/shaders/Cache.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Cache; });
/**
 * Keep a cacheTo avoid recompiling webgl programs and shaders.
 * We need a different shader per webgl context so we use a 2 level cache where at the first level
 * the webgl context is the key and at the second level the shader code is the cache key.
 */
class Cache {
    constructor () {
        this.caches = new WeakMap();
    }

    get (gl, shadercode) {
        if (this.caches.has(gl)) {
            let cache = this.caches.get(gl);

            return cache[shadercode];
        }
    }

    set (gl, shadercode, shader) {
        if (this.caches.has(gl)) {
            let cache = this.caches.get(gl);
            cache[shadercode] = shader;
        } else {
            let cache = {};
            cache[shadercode] = shader;
            this.caches.set(gl, cache);
        }
    }

    has (gl, shadercode) {
        return this.get(gl, shadercode) !== undefined;
    }
}


/***/ }),

/***/ "./src/renderer/shaders/common/antialiasing/AntiAliasingShader.js":
/*!************************************************************************!*\
  !*** ./src/renderer/shaders/common/antialiasing/AntiAliasingShader.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AntiAliasingShader; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils */ "./src/renderer/shaders/utils.js");
/* harmony import */ var _antialiasingFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./antialiasingFragmentShader.glsl */ "./src/renderer/shaders/common/antialiasing/antialiasingFragmentShader.glsl");
/* harmony import */ var _antialiasingFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_antialiasingFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _antialiasingVertexShader_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./antialiasingVertexShader.glsl */ "./src/renderer/shaders/common/antialiasing/antialiasingVertexShader.glsl");
/* harmony import */ var _antialiasingVertexShader_glsl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_antialiasingVertexShader_glsl__WEBPACK_IMPORTED_MODULE_2__);




class AntiAliasingShader {
    constructor (gl) {
        Object.assign(this, Object(_utils__WEBPACK_IMPORTED_MODULE_0__["compileProgram"])(gl, _antialiasingVertexShader_glsl__WEBPACK_IMPORTED_MODULE_2___default.a, _antialiasingFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_1___default.a));
        this.vertexAttribute = gl.getAttribLocation(this.program, 'vertex');
        this.readTU = gl.getUniformLocation(this.program, 'aaTex');
    }
}


/***/ }),

/***/ "./src/renderer/shaders/common/antialiasing/antialiasingFragmentShader.glsl":
/*!**********************************************************************************!*\
  !*** ./src/renderer/shaders/common/antialiasing/antialiasingFragmentShader.glsl ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n\nvarying  vec2 uv;\n\nuniform sampler2D aaTex;\n\nvoid main(void) {\n    vec4 aa = texture2D(aaTex, uv);\n    gl_FragColor = aa;\n}\n"

/***/ }),

/***/ "./src/renderer/shaders/common/antialiasing/antialiasingVertexShader.glsl":
/*!********************************************************************************!*\
  !*** ./src/renderer/shaders/common/antialiasing/antialiasingVertexShader.glsl ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\nattribute vec2 vertex;\n\nvarying  vec2 uv;\n\nvoid main(void) {\n    uv = vertex*0.5+vec2(0.5);\n    gl_Position = vec4(vertex, 0.5, 1.);\n}\n"

/***/ }),

/***/ "./src/renderer/shaders/geometry/line/lineFragmentShader.glsl":
/*!********************************************************************!*\
  !*** ./src/renderer/shaders/geometry/line/lineFragmentShader.glsl ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n\nvarying lowp vec4 color;\n\nvoid main(void) {\n    gl_FragColor = color;\n}\n"

/***/ }),

/***/ "./src/renderer/shaders/geometry/line/lineVertexShader.glsl":
/*!******************************************************************!*\
  !*** ./src/renderer/shaders/geometry/line/lineVertexShader.glsl ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "// Line Vertex Shader\nprecision highp float;\n\nattribute vec2 vertexPosition;\nattribute vec2 featureID;\nattribute vec2 normal;\n\nuniform float normalScale;\nuniform vec2 resolution;\nuniform mat4 matrix;\n\nuniform sampler2D colorTex;\nuniform sampler2D widthTex;\nuniform sampler2D filterTex;\n\nvarying lowp vec4 color;\n\nfloat decodeWidth(vec2 enc) {\n  return enc.x*(255.*4.) + 4.*enc.y;\n}\n\n$propertyPreface\n$transform_preface\n\nvoid main(void) {\n    color = texture2D(colorTex, featureID);\n    float filtering = texture2D(filterTex, featureID).a;\n    color.a *= filtering;\n    color.rgb *= color.a; // premultiplied-alpha\n    float size = decodeWidth(texture2D(widthTex, featureID).rg);\n\n    // 64 is computed based on RTT_WIDTH and the depth buffer precision\n    // 64 = 2^(BUFFER_BITS)/RTT_WIDTH = 2^16/1024 = 64\n    float z = featureID.y * 63. / 64. + featureID.x / (64.);\n\n    // Set z range (-1, 1)\n    z = z * 2. - 1.;\n\n    vec2 n = normal*size*normalScale;\n    vec4 p =  matrix*vec4(vertexPosition+n, 0., 1.);\n    p/=p.w;\n\n    p.xy = $transform_inline(p.xy*resolution)/resolution;\n    if (size==0. || color.a==0.){\n        p.x=10000.;\n    }\n    p.z=z;\n    gl_Position  = p;\n}\n"

/***/ }),

/***/ "./src/renderer/shaders/geometry/point/pointFragmentShader.glsl":
/*!**********************************************************************!*\
  !*** ./src/renderer/shaders/geometry/point/pointFragmentShader.glsl ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n\nvarying lowp vec4 color;\nvarying lowp vec4 stroke;\nvarying highp float dp;\nvarying highp float fillScale;\nvarying highp float strokeScale;\nvarying highp vec2 pointCoord;\n\nfloat distanceAntialias(vec2 p){\n    // return length(p) > 1 ? 0. : 1. ; // to disable antialias\n    return 1. - smoothstep(1.-dp*1.4142, 1.+dp*1.4142, length(p));\n}\n\nvoid main(void) {\n    vec2 p = pointCoord;\n    vec4 c = color;\n\n    vec4 s = stroke;\n\n    c.a *= distanceAntialias(p*fillScale);\n    c.rgb*=c.a;\n\n    s.a *= distanceAntialias(p);\n    s.a *= 1.-distanceAntialias((strokeScale)*p);\n    s.rgb*=s.a;\n\n    c=s+(1.-s.a)*c;\n\n    gl_FragColor = c;\n}\n"

/***/ }),

/***/ "./src/renderer/shaders/geometry/point/pointVertexShader.glsl":
/*!********************************************************************!*\
  !*** ./src/renderer/shaders/geometry/point/pointVertexShader.glsl ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n\nattribute vec2 vertexPosition;\nattribute vec2 featureID;\n\nuniform float orderMinWidth;\nuniform float orderMaxWidth;\nuniform vec2 resolution;\nuniform mat4 matrix;\n\nuniform sampler2D colorTex;\nuniform sampler2D widthTex;\nuniform sampler2D strokeColorTex;\nuniform sampler2D strokeWidthTex;\nuniform sampler2D filterTex;\n\nvarying highp vec4 color;\nvarying highp vec4 stroke;\nvarying highp float dp;\nvarying highp float fillScale;\nvarying highp float strokeScale;\nvarying highp vec2 pointCoord;\n\nfloat decodeWidth(vec2 enc) {\n  return enc.x*(255.*4.) + 4.*enc.y;\n}\n\n$propertyPreface\n$transform_preface\n\nvec2 transform(vec2 p){\n    return $transform_inline(p*resolution*0.5)/resolution*2.;\n}\n\nvoid main(void) {\n  color = texture2D(colorTex, abs(featureID));\n  stroke = texture2D(strokeColorTex, abs(featureID));\n  float filtering = texture2D(filterTex, abs(featureID)).a;\n  color.a *= filtering;\n  stroke.a *= filtering;\n  float size = decodeWidth(texture2D(widthTex, abs(featureID)).rg);\n  float fillSize = size;\n  float strokeSize = decodeWidth(texture2D(strokeWidthTex, abs(featureID)).rg);\n  size += strokeSize;\n  fillScale = min(size / fillSize, 1.);\n  strokeScale = size / max(0.001, (fillSize - strokeSize));\n  if (fillScale == strokeScale) {\n    stroke.a = 0.;\n  }\n  dp = 1.0 / (size + 1.);\n  float sizeNormalizer = (size +1.)/size;\n\n  vec4 p =  matrix*vec4(vertexPosition, 0., 1.);\n  p/=p.w;\n  vec2 size2 = (2.*size+4.)/resolution;\n\n    if (featureID.y<0.){\n        pointCoord = vec2(0.866025, -0.5)*2.*sizeNormalizer;\n        p.xy += transform(size2*vec2(0.866025, -0.5));\n    }else if (featureID.x<0.){\n        pointCoord = vec2(-0.866025, -0.5)*2.*sizeNormalizer;\n        p.xy += transform(size2*vec2(-0.866025, -0.5));\n    }else{\n        pointCoord = vec2(0., 1.)*2.*sizeNormalizer;\n        p.xy += transform(vec2(0.,size2.y));\n    }\n\n  if (size == 0. || (stroke.a == 0. && color.a == 0.) || size < orderMinWidth || size >= orderMaxWidth) {\n    p.z = p.w*2.;\n  }\n\n  gl_Position = p;\n}\n"

/***/ }),

/***/ "./src/renderer/shaders/geometry/polygon/polygonFragmentShader.glsl":
/*!**************************************************************************!*\
  !*** ./src/renderer/shaders/geometry/polygon/polygonFragmentShader.glsl ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision lowp float;\n\nvarying lowp vec4 color;\n\nvoid main(void) {\n    gl_FragColor = color;\n}\n"

/***/ }),

/***/ "./src/renderer/shaders/geometry/polygon/polygonVertexShader.glsl":
/*!************************************************************************!*\
  !*** ./src/renderer/shaders/geometry/polygon/polygonVertexShader.glsl ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision mediump float;\n\nattribute vec2 vertexPosition;\nattribute vec2 featureID;\nattribute vec2 normal;\n\nuniform float normalScale;\nuniform vec2 resolution;\n\nuniform sampler2D colorTex;\nuniform sampler2D strokeColorTex;\nuniform sampler2D strokeWidthTex;\nuniform sampler2D filterTex;\nuniform mat4 matrix;\n\nvarying lowp vec4 color;\n\nfloat decodeWidth(vec2 enc) {\n  return enc.x*(255.*4.) + 4.*enc.y;\n}\n\n$propertyPreface\n$transform_preface\n\nvoid main(void) {\n    // 64 is computed based on RTT_WIDTH and the depth buffer precision\n    // 64 = 2^(BUFFER_BITS)/RTT_WIDTH = 2^16/1024 = 64\n    float z = featureID.y * 63. / 64. + featureID.x / 64.;\n\n    vec4 c;\n    if (normal == vec2(0.)){\n        c = texture2D(colorTex, featureID);\n    }else{\n        z = mod(z + (z > 0.5 ? -1./64. : 1./64.), 1.);\n        c = texture2D(strokeColorTex, featureID);\n    }\n    z = 2.*z - 1.;\n    float filtering = texture2D(filterTex, featureID).a;\n    c.a *= filtering;\n    float size = decodeWidth(texture2D(strokeWidthTex, featureID).rg);\n\n    vec2 n = normal*size*normalScale;\n    vec4 p =  matrix*vec4(vertexPosition+n, 0., 1.);\n    p/=p.w;\n\n    p.xy = $transform_inline(p.xy*resolution*0.5)/resolution*2.;\n\n    if (c.a==0.){\n        p.x=10000.;\n    }\n    p.z=z;\n    color = vec4(c.rgb*c.a, c.a);\n    gl_Position  = p;\n}\n"

/***/ }),

/***/ "./src/renderer/shaders/index.js":
/*!***************************************!*\
  !*** ./src/renderer/shaders/index.js ***!
  \***************************************/
/*! exports provided: styler, symbolizer, AABlender, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AABlender", function() { return AABlender; });
/* harmony import */ var _common_antialiasing_AntiAliasingShader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common/antialiasing/AntiAliasingShader */ "./src/renderer/shaders/common/antialiasing/AntiAliasingShader.js");
/* harmony import */ var _styler_stylerShaders__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./styler/stylerShaders */ "./src/renderer/shaders/styler/stylerShaders.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "styler", function() { return _styler_stylerShaders__WEBPACK_IMPORTED_MODULE_1__; });
/* harmony import */ var _symbolizer_symbolizerShaders__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./symbolizer/symbolizerShaders */ "./src/renderer/shaders/symbolizer/symbolizerShaders.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "symbolizer", function() { return _symbolizer_symbolizerShaders__WEBPACK_IMPORTED_MODULE_2__; });




const AABlender = _common_antialiasing_AntiAliasingShader__WEBPACK_IMPORTED_MODULE_0__["default"];



/* harmony default export */ __webpack_exports__["default"] = ({
    styler: _styler_stylerShaders__WEBPACK_IMPORTED_MODULE_1__,
    symbolizer: _symbolizer_symbolizerShaders__WEBPACK_IMPORTED_MODULE_2__,
    AABlender
});


/***/ }),

/***/ "./src/renderer/shaders/shaderCompiler.js":
/*!************************************************!*\
  !*** ./src/renderer/shaders/shaderCompiler.js ***!
  \************************************************/
/*! exports provided: compileShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compileShader", function() { return compileShader; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/renderer/shaders/utils.js");


class IDGenerator {
    constructor () {
        this._ids = new Map();
    }

    getID (expression) {
        if (this._ids.has(expression)) {
            return this._ids.get(expression);
        }
        const id = this._ids.size;
        this._ids.set(expression, id);
        return id;
    }
}

function compileShader (gl, template, expressions) {
    let tid = {};
    const getPropertyAccessCode = name => {
        if (tid[name] === undefined) {
            tid[name] = Object.keys(tid).length;
        }
        return `texture2D(propertyTex${tid[name]}, abs(featureID)).a`;
    };

    let codes = {};

    const idGen = new IDGenerator();

    Object.keys(expressions).forEach(exprName => {
        const expr = expressions[exprName];
        expr._setUID(idGen);
        const exprCodes = expr._applyToShaderSource(getPropertyAccessCode);
        codes[exprName + '_preface'] = exprCodes.preface;
        codes[exprName + '_inline'] = exprCodes.inline;
    });

    codes.propertyPreface = Object.keys(tid).map(name => `uniform sampler2D propertyTex${tid[name]};`).join('\n');

    const shader = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["createShaderFromTemplate"])(gl, template, codes);

    Object.keys(tid).map(name => {
        tid[name] = gl.getUniformLocation(shader.program, `propertyTex${tid[name]}`);
    });

    Object.values(expressions).forEach(expr => {
        expr._postShaderCompile(shader.program, gl);
    });

    return {
        shader,
        textureIds: tid,
        _codes: codes,
        _template: template
    };
}


/***/ }),

/***/ "./src/renderer/shaders/styler/stylerEncodeWidth.glsl":
/*!************************************************************!*\
  !*** ./src/renderer/shaders/styler/stylerEncodeWidth.glsl ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "vec2 encodeWidth(float x) {\n    if (!(x<=0. || x>=0.) ){\n        // Convert NaN widths to `0`\n        // Do not remove this, some GPUs will convert NaN floats to 1. when\n        // packing the shader output to a RGBA UNSIGNED BYTE textures\n        x = 0.;\n    }\n    float high, low;\n    x = clamp(x, 0., 1023.);\n    high = floor(x/4.);\n    low = (x-high*4.)/4.;\n    return vec2(high/255., low);\n}\n\n$width_preface\n"

/***/ }),

/***/ "./src/renderer/shaders/styler/stylerFragmentShader.glsl":
/*!***************************************************************!*\
  !*** ./src/renderer/shaders/styler/stylerFragmentShader.glsl ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n\nvarying vec2 uv;\n\nvec2 featureID;\n\n$propertyPreface\n$style_preface\n\nvoid main(void) {\n    featureID = abs(uv);\n    gl_FragColor = $style_inline;\n}\n"

/***/ }),

/***/ "./src/renderer/shaders/styler/stylerShaders.js":
/*!******************************************************!*\
  !*** ./src/renderer/shaders/styler/stylerShaders.js ***!
  \******************************************************/
/*! exports provided: colorShaderGLSL, filterShaderGLSL, widthShaderGLSL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "colorShaderGLSL", function() { return colorShaderGLSL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "filterShaderGLSL", function() { return filterShaderGLSL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "widthShaderGLSL", function() { return widthShaderGLSL; });
/* harmony import */ var _stylerEncodeWidth_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stylerEncodeWidth.glsl */ "./src/renderer/shaders/styler/stylerEncodeWidth.glsl");
/* harmony import */ var _stylerEncodeWidth_glsl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_stylerEncodeWidth_glsl__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _stylerFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stylerFragmentShader.glsl */ "./src/renderer/shaders/styler/stylerFragmentShader.glsl");
/* harmony import */ var _stylerFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_stylerFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _stylerVertexShader_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stylerVertexShader.glsl */ "./src/renderer/shaders/styler/stylerVertexShader.glsl");
/* harmony import */ var _stylerVertexShader_glsl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_stylerVertexShader_glsl__WEBPACK_IMPORTED_MODULE_2__);




const colorShaderGLSL = {
    vertexShader: `${_stylerVertexShader_glsl__WEBPACK_IMPORTED_MODULE_2___default.a}`,
    fragmentShader: `${_stylerFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_1___default.a}`
        .replace('$style_inline', '$color_inline')
        .replace('$style_preface', '$color_preface')
};

const filterShaderGLSL = {
    vertexShader: `${_stylerVertexShader_glsl__WEBPACK_IMPORTED_MODULE_2___default.a}`,
    fragmentShader: `${_stylerFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_1___default.a}`
        .replace('$style_inline', 'vec4($filter_inline)')
        .replace('$style_preface', '$filter_preface')
};

const widthShaderGLSL = {
    vertexShader: `${_stylerVertexShader_glsl__WEBPACK_IMPORTED_MODULE_2___default.a}`,
    fragmentShader: `${_stylerFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_1___default.a}`
        .replace('$style_inline', 'vec4(encodeWidth($width_inline), vec2(0.))')
        .replace('$style_preface', `${_stylerEncodeWidth_glsl__WEBPACK_IMPORTED_MODULE_0___default.a}`)
};


/***/ }),

/***/ "./src/renderer/shaders/styler/stylerVertexShader.glsl":
/*!*************************************************************!*\
  !*** ./src/renderer/shaders/styler/stylerVertexShader.glsl ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\nattribute vec2 vertex;\n\nvarying  vec2 uv;\n\nvoid main(void) {\n    uv = vertex*0.5+vec2(0.5);\n    gl_Position = vec4(vertex, 0.5, 1.);\n}\n"

/***/ }),

/***/ "./src/renderer/shaders/symbolizer/symbolizerFragmentShader.glsl":
/*!***********************************************************************!*\
  !*** ./src/renderer/shaders/symbolizer/symbolizerFragmentShader.glsl ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n\nvarying highp vec2 featureIDVar;\nvarying highp vec4 color;\nvarying highp vec2 pointCoord;\nvarying highp float filtering;\n\n$symbol_preface\n$propertyPreface\n\nvoid main(void) {\n    vec2 featureID = abs(featureIDVar);\n    vec2 imageUV = pointCoord;\n    imageUV.x = imageUV.x * 0.5 + 0.5;\n    vec4 symbolColor = $symbol_inline;\n    vec4 noOverrideColor = vec4(1., 1., 1., 0.);\n\n    vec4 c;\n    if (color != noOverrideColor){\n        c = color * vec4(vec3(1), symbolColor.a);\n    }else{\n        c = symbolColor;\n    }\n    c.a *= filtering;\n    if (imageUV!=clamp(imageUV, 0.,1.)){\n        c.a = 0.;\n    }\n\n    gl_FragColor = vec4(c.rgb*c.a, c.a);\n}\n"

/***/ }),

/***/ "./src/renderer/shaders/symbolizer/symbolizerShaders.js":
/*!**************************************************************!*\
  !*** ./src/renderer/shaders/symbolizer/symbolizerShaders.js ***!
  \**************************************************************/
/*! exports provided: symbolShaderGLSL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "symbolShaderGLSL", function() { return symbolShaderGLSL; });
/* harmony import */ var _symbolizerFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./symbolizerFragmentShader.glsl */ "./src/renderer/shaders/symbolizer/symbolizerFragmentShader.glsl");
/* harmony import */ var _symbolizerFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_symbolizerFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _symbolizerVertexShader_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./symbolizerVertexShader.glsl */ "./src/renderer/shaders/symbolizer/symbolizerVertexShader.glsl");
/* harmony import */ var _symbolizerVertexShader_glsl__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_symbolizerVertexShader_glsl__WEBPACK_IMPORTED_MODULE_1__);



const symbolShaderGLSL = {
    vertexShader: `${_symbolizerVertexShader_glsl__WEBPACK_IMPORTED_MODULE_1___default.a}`,
    fragmentShader: `${_symbolizerFragmentShader_glsl__WEBPACK_IMPORTED_MODULE_0___default.a}`
};


/***/ }),

/***/ "./src/renderer/shaders/symbolizer/symbolizerVertexShader.glsl":
/*!*********************************************************************!*\
  !*** ./src/renderer/shaders/symbolizer/symbolizerVertexShader.glsl ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "precision highp float;\n\nattribute vec2 vertexPosition;\nattribute vec2 featureID;\n\nuniform float orderMinWidth;\nuniform float orderMaxWidth;\nuniform float devicePixelRatio;\nuniform vec2 resolution;\nuniform mat4 matrix;\n\nuniform sampler2D colorTex;\nuniform sampler2D widthTex;\nuniform sampler2D filterTex;\n\nvarying highp vec2 featureIDVar;\nvarying highp vec4 color;\nvarying highp vec2 pointCoord;\nvarying highp float filtering;\n\nfloat decodeWidth(vec2 enc) {\n  return enc.x*(255.*4.) + 4.*enc.y;\n}\n\n$symbolPlacement_preface\n$propertyPreface\n$transform_preface\n\nvec2 transform(vec2 p){\n    return $transform_inline(2.*p)/resolution;\n}\n\n// We'll need a square inscribed in a triangle\n// The triangle will be equilateral\n// The square side length will be equal to 1\n// Each triangle edge length will be equal to 1+2*A (by definition of A)\n// The triangle height will be equal to H by definition\n// The square inscription will generate 3 smaller triangles\n// Each one of these will have an hypotenuse equal to Y\n//\n// Therefore:\n// Y*sin(60) = 1  =>  Y = 2 / sqrt(3)\n// A=Y*cos(60)    =>  A = 1 / sqrt(3)\n// tan(60) = H / (0.5 + A)   =>  H = sqrt(3)*(0.5 + 1 / sqrt(3))\n#define A (0.577350269189625)\n#define H (1.86603)\n\nvoid main(void) {\n    featureIDVar = abs(featureID);\n    color = texture2D(colorTex, abs(featureID));\n    filtering = texture2D(filterTex, abs(featureID)).a;\n\n    float size = decodeWidth(texture2D(widthTex, abs(featureID)).rg);\n\n    vec4 p =  matrix*vec4(vertexPosition, 0., 1.);\n    p/=p.w;\n\n    if (featureID.y<0.){\n        pointCoord = vec2((0.5+A)/(0.5), 0.);\n        p.xy += transform(size*vec2(0.5+A, -H/2. + (H/2. - 0.5) ));\n    }else if (featureID.x<0.){\n        pointCoord = vec2(-(0.5+A)/(0.5), 0.);\n        p.xy += transform(size*vec2(-(0.5+A), -H/2. + (H/2. - 0.5)));\n    }else{\n        pointCoord = vec2(0., H);\n        p.xy += transform(size*vec2(0., H/2. + (H/2. - 0.5)));\n    }\n    pointCoord.y = 1.-pointCoord.y;\n\n\n    p.xy += ($symbolPlacement_inline)*size/resolution;\n\n\n    vec4 noOverrideColor = vec4(1., 1., 1., 0.);\n    bool alphaButNotOverrideColor = (color.a==0. && color != noOverrideColor);\n\n    if (size==0. || alphaButNotOverrideColor || size<orderMinWidth || size>=orderMaxWidth){\n        p.x=10000.;\n    }\n\n    gl_Position  = p;\n}\n"

/***/ }),

/***/ "./src/renderer/shaders/utils.js":
/*!***************************************!*\
  !*** ./src/renderer/shaders/utils.js ***!
  \***************************************/
/*! exports provided: compileProgram, createShaderFromTemplate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "compileProgram", function() { return compileProgram; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createShaderFromTemplate", function() { return createShaderFromTemplate; });
/* harmony import */ var _Cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cache */ "./src/renderer/shaders/Cache.js");
/* harmony import */ var _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../errors/carto-runtime-error */ "./src/errors/carto-runtime-error.js");



let programID = 1;
const shaderCache = new _Cache__WEBPACK_IMPORTED_MODULE_0__["default"]();
const programCache = new _Cache__WEBPACK_IMPORTED_MODULE_0__["default"]();

/**
 * Compile a webgl program.
 * Use a cache to improve speed.
 *
 * @param {WebGLRenderingContext} gl - The context where the program will be executed
 * @param {String} glslvertexShader - vertex shader code
 * @param {String} glslfragmentShader - fragment shader code
 */
function compileProgram (gl, glslvertexShader, glslfragmentShader) {
    const code = glslvertexShader + glslfragmentShader;

    if (programCache.has(gl, code)) {
        return programCache.get(gl, code);
    }

    const shader = {};
    const vertexShader = _compileShader(gl, glslvertexShader, gl.VERTEX_SHADER);
    const fragmentShader = _compileShader(gl, glslfragmentShader, gl.FRAGMENT_SHADER);

    shader.program = gl.createProgram();

    gl.attachShader(shader.program, vertexShader);
    gl.attachShader(shader.program, fragmentShader);
    gl.linkProgram(shader.program);
    gl.deleteShader(vertexShader);
    gl.deleteShader(fragmentShader);

    if (!gl.getProgramParameter(shader.program, gl.LINK_STATUS)) {
        throw new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_1__["default"](`Unable to link the shader program: ${gl.getProgramInfoLog(shader.program)}.`, _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_1__["CartoRuntimeErrorTypes"].WEB_GL);
    }

    shader.programID = programID++;
    programCache.set(gl, code, shader);

    return shader;
}

function _compileShader (gl, sourceCode, type) {
    if (shaderCache.has(gl, sourceCode)) {
        return shaderCache.get(gl, sourceCode);
    }

    const shader = gl.createShader(type);
    gl.shaderSource(shader, sourceCode);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        const log = gl.getShaderInfoLog(shader);
        gl.deleteShader(shader);
        throw new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_1__["default"](`An error occurred compiling the shaders: ${log}\nSource:\n${sourceCode}`, _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_1__["CartoRuntimeErrorTypes"].WEB_GL);
    }

    shaderCache.set(gl, sourceCode, shader);

    return shader;
}

function createShaderFromTemplate (gl, glslTemplate, codes) {
    let vertexShader = glslTemplate.vertexShader;
    let fragmentShader = glslTemplate.fragmentShader;

    Object.keys(codes).forEach(codeName => {
        vertexShader = vertexShader.replace('$' + codeName, codes[codeName]);
        fragmentShader = fragmentShader.replace('$' + codeName, codes[codeName]);
    });

    const shader = compileProgram(gl, vertexShader, fragmentShader);

    shader.vertexPositionAttribute = gl.getAttribLocation(shader.program, 'vertexPosition');
    shader.featureIdAttr = gl.getAttribLocation(shader.program, 'featureID');
    shader.normalAttr = gl.getAttribLocation(shader.program, 'normal');

    shader.colorTexture = gl.getUniformLocation(shader.program, 'colorTex');
    shader.strokeColorTexture = gl.getUniformLocation(shader.program, 'strokeColorTex');
    shader.strokeWidthTexture = gl.getUniformLocation(shader.program, 'strokeWidthTex');
    shader.widthTexture = gl.getUniformLocation(shader.program, 'widthTex');
    shader.orderMinWidth = gl.getUniformLocation(shader.program, 'orderMinWidth');
    shader.orderMaxWidth = gl.getUniformLocation(shader.program, 'orderMaxWidth');
    shader.filterTexture = gl.getUniformLocation(shader.program, 'filterTex');
    shader.normalScale = gl.getUniformLocation(shader.program, 'normalScale');
    shader.resolution = gl.getUniformLocation(shader.program, 'resolution');
    shader.matrix = gl.getUniformLocation(shader.program, 'matrix');

    return shader;
}


/***/ }),

/***/ "./src/renderer/viz/colorspaces.js":
/*!*****************************************!*\
  !*** ./src/renderer/viz/colorspaces.js ***!
  \*****************************************/
/*! exports provided: sRGBToCielab, cielabToSRGB, interpolateRGBAinCieLAB */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sRGBToCielab", function() { return sRGBToCielab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cielabToSRGB", function() { return cielabToSRGB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolateRGBAinCieLAB", function() { return interpolateRGBAinCieLAB; });
/* harmony import */ var _expressions_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expressions/utils */ "./src/renderer/viz/expressions/utils.js");


function sRGBToCielab (srgb) {
    return XYZToCieLab(sRGBToXYZ(srgb));
}
function cielabToSRGB (cielab) {
    return XYZToSRGB(cielabToXYZ(cielab));
}

function interpolateRGBAinCieLAB (rgbColorA, rgbColorB, m) {
    const cielabColorA = sRGBToCielab({
        r: rgbColorA.r / 255,
        g: rgbColorA.g / 255,
        b: rgbColorA.b / 255,
        a: rgbColorA.a
    });

    const cielabColorB = sRGBToCielab({
        r: rgbColorB.r / 255,
        g: rgbColorB.g / 255,
        b: rgbColorB.b / 255,
        a: rgbColorB.a
    });

    const cielabInterpolated = {
        l: (1 - m) * cielabColorA.l + m * cielabColorB.l,
        a: (1 - m) * cielabColorA.a + m * cielabColorB.a,
        b: (1 - m) * cielabColorA.b + m * cielabColorB.b,
        alpha: (1 - m) * cielabColorA.alpha + m * cielabColorB.alpha
    };

    const rgbaColor = cielabToSRGB(cielabInterpolated);

    return {
        r: Math.round(rgbaColor.r * 255),
        g: Math.round(rgbaColor.g * 255),
        b: Math.round(rgbaColor.b * 255),
        a: rgbaColor.a
    };
}

// Following functionality has been inspired by http://www.getreuer.info/home/colorspace
// License:
/*
License (BSD)
Copyright  20052010, Pascal Getreuer
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE U
*/

// Convert sRGB to CIE XYZ with the D65 white point
function sRGBToXYZ (srgb) {
    // Poynton, "Frequently Asked Questions About Color," page 10
    // Wikipedia: http://en.wikipedia.org/wiki/SRGB
    // Wikipedia: http://en.wikipedia.org/wiki/CIE_1931_color_space
    const { r, g, b, a } = sRGBToLinearRGB(srgb);
    return {
        x: (0.4123955889674142161 * r + 0.3575834307637148171 * g + 0.1804926473817015735 * b),
        y: (0.2125862307855955516 * r + 0.7151703037034108499 * g + 0.07220049864333622685 * b),
        z: (0.01929721549174694484 * r + 0.1191838645808485318 * g + 0.9504971251315797660 * b),
        a
    };
}

function sRGBToLinearRGB ({ r, g, b, a }) {
    // http://en.wikipedia.org/wiki/SRGB
    const inverseGammaCorrection = t =>
        t <= 0.0404482362771076 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);
    return {
        r: inverseGammaCorrection(r),
        g: inverseGammaCorrection(g),
        b: inverseGammaCorrection(b),
        a
    };
}
function linearRGBToSRGB ({ r, g, b, a }) {
    // http://en.wikipedia.org/wiki/SRGB
    const gammaCorrection = t =>
        t <= 0.0031306684425005883 ? 12.92 * t : 1.055 * Math.pow(t, 0.416666666666666667) - 0.055;
    return {
        r: gammaCorrection(r),
        g: gammaCorrection(g),
        b: gammaCorrection(b),
        a
    };
}

const WHITEPOINT_D65_X = 0.950456;
const WHITEPOINT_D65_Y = 1.0;
const WHITEPOINT_D65_Z = 1.088754;

// Convert CIE XYZ to CIE L*a*b* (CIELAB) with the D65 white point
function XYZToCieLab ({ x, y, z, a }) {
    // Wikipedia: http://en.wikipedia.org/wiki/Lab_color_space

    const xn = WHITEPOINT_D65_X;
    const yn = WHITEPOINT_D65_Y;
    const zn = WHITEPOINT_D65_Z;

    const f = t =>
        t >= 8.85645167903563082e-3
            ? Math.pow(t, 0.333333333333333) : (841.0 / 108.0) * t + 4.0 / 29.0;

    return {
        l: 116 * f(y / yn) - 16,
        a: 500 * (f(x / xn) - f(y / yn)),
        b: 200 * (f(y / yn) - f(z / zn)),
        alpha: a
    };
}

// Convert CIE XYZ to sRGB with the D65 white point
function XYZToSRGB ({ x, y, z, a }) {
    // Poynton, "Frequently Asked Questions About Color," page 10
    // Wikipedia: http://en.wikipedia.org/wiki/SRGB
    // Wikipedia: http://en.wikipedia.org/wiki/CIE_1931_color_space

    // Convert XYZ to linear RGB
    const r = Object(_expressions_utils__WEBPACK_IMPORTED_MODULE_0__["clamp"])(3.2406 * x - 1.5372 * y - 0.4986 * z, 0, 1);
    const g = Object(_expressions_utils__WEBPACK_IMPORTED_MODULE_0__["clamp"])(-0.9689 * x + 1.8758 * y + 0.0415 * z, 0, 1);
    const b = Object(_expressions_utils__WEBPACK_IMPORTED_MODULE_0__["clamp"])(0.0557 * x - 0.2040 * y + 1.0570 * z, 0, 1);

    return linearRGBToSRGB({ r, g, b, a });
}

// Convert CIE L*a*b* (CIELAB) to CIE XYZ with the D65 white point
function cielabToXYZ ({ l, a, b, alpha }) {
    // Wikipedia: http://en.wikipedia.org/wiki/Lab_color_space

    const f = t =>
        ((t >= 0.206896551724137931)
            ? ((t) * (t) * (t)) : (108.0 / 841.0) * ((t) - (4.0 / 29.0)));

    return {
        x: WHITEPOINT_D65_X * f((l + 16) / 116 + a / 500),
        y: WHITEPOINT_D65_Y * f((l + 16) / 116),
        z: WHITEPOINT_D65_Z * f((l + 16) / 116 - b / 200),
        a: alpha
    };
}


/***/ }),

/***/ "./src/renderer/viz/defaultSVGs.js":
/*!*****************************************!*\
  !*** ./src/renderer/viz/defaultSVGs.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const DEFAULT_SYMBOLS_URL = 'https://libs.cartocdn.com/carto-vl/assets/symbols';

const bicycle = `${DEFAULT_SYMBOLS_URL}/bicycle.svg`;
const building = `${DEFAULT_SYMBOLS_URL}/building.svg`;
const bus = `${DEFAULT_SYMBOLS_URL}/bus.svg`;
const car = `${DEFAULT_SYMBOLS_URL}/car.svg`;
const circle = `${DEFAULT_SYMBOLS_URL}/circle.svg`;
const circleOutline = `${DEFAULT_SYMBOLS_URL}/circleOutline.svg`;
const cross = `${DEFAULT_SYMBOLS_URL}/cross.svg`;
const house = `${DEFAULT_SYMBOLS_URL}/house.svg`;
const flag = `${DEFAULT_SYMBOLS_URL}/flag.svg`;
const marker = `${DEFAULT_SYMBOLS_URL}/marker.svg`;
const markerOutline = `${DEFAULT_SYMBOLS_URL}/markerOutline.svg`;
const plus = `${DEFAULT_SYMBOLS_URL}/plus.svg`;
const square = `${DEFAULT_SYMBOLS_URL}/square.svg`;
const squareOutline = `${DEFAULT_SYMBOLS_URL}/squareOutline.svg`;
const star = `${DEFAULT_SYMBOLS_URL}/star.svg`;
const starOutline = `${DEFAULT_SYMBOLS_URL}/starOutline.svg`;
const triangle = `${DEFAULT_SYMBOLS_URL}/triangle.svg`;
const triangleOutline = `${DEFAULT_SYMBOLS_URL}/triangleOutline.svg`;

/* harmony default export */ __webpack_exports__["default"] = ({
    bicycle,
    building,
    bus,
    car,
    circle,
    circleOutline,
    cross,
    house,
    flag,
    marker,
    markerOutline,
    plus,
    square,
    squareOutline,
    star,
    starOutline,
    triangle,
    triangleOutline
});


/***/ }),

/***/ "./src/renderer/viz/expressions.js":
/*!*****************************************!*\
  !*** ./src/renderer/viz/expressions.js ***!
  \*****************************************/
/*! exports provided: number, category, list, rgb, rgba, transition, nin, in, between, mul, div, add, sub, pow, mod, greaterThan, greaterThanOrEqualTo, lessThan, lessThanOrEqualTo, equals, notEquals, and, or, gt, gte, lt, lte, eq, neq, blend, buckets, cielab, clusterAvg, clusterMax, clusterMin, clusterMode, clusterSum, clusterCount, clusterTime, constant, image, svg, hex, hsl, hsla, hsv, hsva, cubic, ilinear, linear, namedColor, now, opacity, asc, desc, noOrder, width, reverse, property, prop, globalQuantiles, viewportQuantiles, globalEqIntervals, viewportEqIntervals, globalStandardDev, viewportStandardDev, ramp, time, date, timeRange, top, fade, animation, log, sqrt, sin, cos, tan, sign, abs, isNull, not, floor, ceil, variable, var, viewportAvg, viewportMax, viewportMin, viewportSum, viewportCount, viewportPercentile, viewportHistogram, viewportFeatures, globalAvg, globalMax, globalMin, globalSum, globalCount, globalPercentile, globalHistogram, zoom, scaled, zoomrange, placement, translate, rotate, alphaNormalize, HOLD, TRUE, FALSE, PI, E, BICYCLE, BUILDING, BUS, CAR, CIRCLE, CIRCLE_OUTLINE, CROSS, FLAG, HOUSE, MARKER, MARKER_OUTLINE, PLUS, SQUARE, SQUARE_OUTLINE, STAR, STAR_OUTLINE, TRIANGLE, TRIANGLE_OUTLINE, ALIGN_CENTER, ALIGN_BOTTOM, palettes, Asc, Desc */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "number", function() { return number; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "category", function() { return category; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "list", function() { return list; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgb", function() { return rgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rgba", function() { return rgba; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transition", function() { return transition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nin", function() { return nin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "in", function() { return in_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "between", function() { return between; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow", function() { return pow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mod", function() { return mod; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterThan", function() { return greaterThan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "greaterThanOrEqualTo", function() { return greaterThanOrEqualTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessThan", function() { return lessThan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lessThanOrEqualTo", function() { return lessThanOrEqualTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "notEquals", function() { return notEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "and", function() { return and; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "or", function() { return or; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gt", function() { return gt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gte", function() { return gte; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lt", function() { return lt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lte", function() { return lte; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "eq", function() { return eq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "neq", function() { return neq; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blend", function() { return blend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buckets", function() { return buckets; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cielab", function() { return cielab; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clusterAvg", function() { return clusterAvg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clusterMax", function() { return clusterMax; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clusterMin", function() { return clusterMin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clusterMode", function() { return clusterMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clusterSum", function() { return clusterSum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clusterCount", function() { return clusterCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clusterTime", function() { return clusterTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "constant", function() { return constant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "image", function() { return image; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "svg", function() { return svg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hex", function() { return hex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsl", function() { return hsl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsla", function() { return hsla; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsv", function() { return hsv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hsva", function() { return hsva; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cubic", function() { return cubic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ilinear", function() { return ilinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "linear", function() { return linear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "namedColor", function() { return namedColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "now", function() { return now; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "opacity", function() { return opacity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asc", function() { return asc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "desc", function() { return desc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "noOrder", function() { return noOrder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "width", function() { return width; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "reverse", function() { return reverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "property", function() { return property; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prop", function() { return property; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalQuantiles", function() { return globalQuantiles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "viewportQuantiles", function() { return viewportQuantiles; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalEqIntervals", function() { return globalEqIntervals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "viewportEqIntervals", function() { return viewportEqIntervals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalStandardDev", function() { return globalStandardDev; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "viewportStandardDev", function() { return viewportStandardDev; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ramp", function() { return ramp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "time", function() { return time; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "date", function() { return time; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timeRange", function() { return timeRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "top", function() { return top; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fade", function() { return fade; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "animation", function() { return animation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "log", function() { return log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrt", function() { return sqrt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return tan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sign", function() { return sign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "abs", function() { return abs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNull", function() { return isNull; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "not", function() { return not; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variable", function() { return variable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "var", function() { return variable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "viewportAvg", function() { return viewportAvg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "viewportMax", function() { return viewportMax; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "viewportMin", function() { return viewportMin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "viewportSum", function() { return viewportSum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "viewportCount", function() { return viewportCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "viewportPercentile", function() { return viewportPercentile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "viewportHistogram", function() { return viewportHistogram; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "viewportFeatures", function() { return viewportFeatures; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalAvg", function() { return globalAvg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalMax", function() { return globalMax; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalMin", function() { return globalMin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalSum", function() { return globalSum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalCount", function() { return globalCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalPercentile", function() { return globalPercentile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "globalHistogram", function() { return globalHistogram; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zoom", function() { return zoom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaled", function() { return scaled; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zoomrange", function() { return zoomrange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "placement", function() { return placement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "alphaNormalize", function() { return alphaNormalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HOLD", function() { return HOLD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRUE", function() { return TRUE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FALSE", function() { return FALSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PI", function() { return PI; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "E", function() { return E; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BICYCLE", function() { return BICYCLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BUILDING", function() { return BUILDING; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BUS", function() { return BUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CAR", function() { return CAR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CIRCLE", function() { return CIRCLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CIRCLE_OUTLINE", function() { return CIRCLE_OUTLINE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CROSS", function() { return CROSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FLAG", function() { return FLAG; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HOUSE", function() { return HOUSE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MARKER", function() { return MARKER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MARKER_OUTLINE", function() { return MARKER_OUTLINE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PLUS", function() { return PLUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SQUARE", function() { return SQUARE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SQUARE_OUTLINE", function() { return SQUARE_OUTLINE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STAR", function() { return STAR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STAR_OUTLINE", function() { return STAR_OUTLINE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRIANGLE", function() { return TRIANGLE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TRIANGLE_OUTLINE", function() { return TRIANGLE_OUTLINE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ALIGN_CENTER", function() { return ALIGN_CENTER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ALIGN_BOTTOM", function() { return ALIGN_BOTTOM; });
/* harmony import */ var _expressions_transition__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./expressions/transition */ "./src/renderer/viz/expressions/transition.js");
/* harmony import */ var _expressions_belongs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./expressions/belongs */ "./src/renderer/viz/expressions/belongs.js");
/* harmony import */ var _expressions_between__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./expressions/between */ "./src/renderer/viz/expressions/between.js");
/* harmony import */ var _expressions_binary_Add__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./expressions/binary/Add */ "./src/renderer/viz/expressions/binary/Add.js");
/* harmony import */ var _expressions_binary_And__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./expressions/binary/And */ "./src/renderer/viz/expressions/binary/And.js");
/* harmony import */ var _expressions_binary_Div__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./expressions/binary/Div */ "./src/renderer/viz/expressions/binary/Div.js");
/* harmony import */ var _expressions_binary_Equals__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./expressions/binary/Equals */ "./src/renderer/viz/expressions/binary/Equals.js");
/* harmony import */ var _expressions_binary_GreaterThan__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./expressions/binary/GreaterThan */ "./src/renderer/viz/expressions/binary/GreaterThan.js");
/* harmony import */ var _expressions_binary_GreaterThanOrEqualTo__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./expressions/binary/GreaterThanOrEqualTo */ "./src/renderer/viz/expressions/binary/GreaterThanOrEqualTo.js");
/* harmony import */ var _expressions_binary_LessThan__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./expressions/binary/LessThan */ "./src/renderer/viz/expressions/binary/LessThan.js");
/* harmony import */ var _expressions_binary_LessThanOrEqualTo__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./expressions/binary/LessThanOrEqualTo */ "./src/renderer/viz/expressions/binary/LessThanOrEqualTo.js");
/* harmony import */ var _expressions_binary_Mod__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./expressions/binary/Mod */ "./src/renderer/viz/expressions/binary/Mod.js");
/* harmony import */ var _expressions_binary_Mul__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./expressions/binary/Mul */ "./src/renderer/viz/expressions/binary/Mul.js");
/* harmony import */ var _expressions_binary_NotEquals__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./expressions/binary/NotEquals */ "./src/renderer/viz/expressions/binary/NotEquals.js");
/* harmony import */ var _expressions_binary_Or__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./expressions/binary/Or */ "./src/renderer/viz/expressions/binary/Or.js");
/* harmony import */ var _expressions_binary_Pow__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./expressions/binary/Pow */ "./src/renderer/viz/expressions/binary/Pow.js");
/* harmony import */ var _expressions_binary_Sub__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./expressions/binary/Sub */ "./src/renderer/viz/expressions/binary/Sub.js");
/* harmony import */ var _expressions_blend__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./expressions/blend */ "./src/renderer/viz/expressions/blend.js");
/* harmony import */ var _expressions_buckets__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./expressions/buckets */ "./src/renderer/viz/expressions/buckets.js");
/* harmony import */ var _expressions_basic_category__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./expressions/basic/category */ "./src/renderer/viz/expressions/basic/category.js");
/* harmony import */ var _expressions_color_CIELab__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./expressions/color/CIELab */ "./src/renderer/viz/expressions/color/CIELab.js");
/* harmony import */ var _expressions_aggregation_cluster_ClusterAvg__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./expressions/aggregation/cluster/ClusterAvg */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterAvg.js");
/* harmony import */ var _expressions_aggregation_cluster_ClusterMax__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./expressions/aggregation/cluster/ClusterMax */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterMax.js");
/* harmony import */ var _expressions_aggregation_cluster_ClusterMin__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./expressions/aggregation/cluster/ClusterMin */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterMin.js");
/* harmony import */ var _expressions_aggregation_cluster_ClusterMode__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./expressions/aggregation/cluster/ClusterMode */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterMode.js");
/* harmony import */ var _expressions_aggregation_cluster_ClusterSum__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./expressions/aggregation/cluster/ClusterSum */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterSum.js");
/* harmony import */ var _expressions_aggregation_cluster_ClusterCount__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./expressions/aggregation/cluster/ClusterCount */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterCount.js");
/* harmony import */ var _expressions_aggregation_cluster_ClusterTime__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./expressions/aggregation/cluster/ClusterTime */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterTime.js");
/* harmony import */ var _expressions_basic_constant__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./expressions/basic/constant */ "./src/renderer/viz/expressions/basic/constant.js");
/* harmony import */ var _expressions_color_hex__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./expressions/color/hex */ "./src/renderer/viz/expressions/color/hex.js");
/* harmony import */ var _expressions_color_hsl__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./expressions/color/hsl */ "./src/renderer/viz/expressions/color/hsl.js");
/* harmony import */ var _expressions_color_hsv__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./expressions/color/hsv */ "./src/renderer/viz/expressions/color/hsv.js");
/* harmony import */ var _expressions_interpolators__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./expressions/interpolators */ "./src/renderer/viz/expressions/interpolators.js");
/* harmony import */ var _expressions_linear__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./expressions/linear */ "./src/renderer/viz/expressions/linear.js");
/* harmony import */ var _expressions_color_NamedColor__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./expressions/color/NamedColor */ "./src/renderer/viz/expressions/color/NamedColor.js");
/* harmony import */ var _expressions_now__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./expressions/now */ "./src/renderer/viz/expressions/now.js");
/* harmony import */ var _expressions_basic_number__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./expressions/basic/number */ "./src/renderer/viz/expressions/basic/number.js");
/* harmony import */ var _expressions_color_Opacity__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./expressions/color/Opacity */ "./src/renderer/viz/expressions/color/Opacity.js");
/* harmony import */ var _expressions_ordering__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./expressions/ordering */ "./src/renderer/viz/expressions/ordering.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Asc", function() { return _expressions_ordering__WEBPACK_IMPORTED_MODULE_38__["Asc"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Desc", function() { return _expressions_ordering__WEBPACK_IMPORTED_MODULE_38__["Desc"]; });

/* harmony import */ var _expressions_color_palettes__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./expressions/color/palettes */ "./src/renderer/viz/expressions/color/palettes.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "palettes", function() { return _expressions_color_palettes__WEBPACK_IMPORTED_MODULE_39__["default"]; });

/* harmony import */ var _expressions_reverse_Reverse__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./expressions/reverse/Reverse */ "./src/renderer/viz/expressions/reverse/Reverse.js");
/* harmony import */ var _expressions_basic_property__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./expressions/basic/property */ "./src/renderer/viz/expressions/basic/property.js");
/* harmony import */ var _expressions_classification_GlobalEqIntervals__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./expressions/classification/GlobalEqIntervals */ "./src/renderer/viz/expressions/classification/GlobalEqIntervals.js");
/* harmony import */ var _expressions_classification_GlobalQuantiles__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./expressions/classification/GlobalQuantiles */ "./src/renderer/viz/expressions/classification/GlobalQuantiles.js");
/* harmony import */ var _expressions_classification_GlobalStandardDev__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./expressions/classification/GlobalStandardDev */ "./src/renderer/viz/expressions/classification/GlobalStandardDev.js");
/* harmony import */ var _expressions_classification_ViewportEqIntervals__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./expressions/classification/ViewportEqIntervals */ "./src/renderer/viz/expressions/classification/ViewportEqIntervals.js");
/* harmony import */ var _expressions_classification_ViewportQuantiles__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./expressions/classification/ViewportQuantiles */ "./src/renderer/viz/expressions/classification/ViewportQuantiles.js");
/* harmony import */ var _expressions_classification_ViewportStandardDev__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./expressions/classification/ViewportStandardDev */ "./src/renderer/viz/expressions/classification/ViewportStandardDev.js");
/* harmony import */ var _expressions_Ramp__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./expressions/Ramp */ "./src/renderer/viz/expressions/Ramp.js");
/* harmony import */ var _expressions_basic_List__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./expressions/basic/List */ "./src/renderer/viz/expressions/basic/List.js");
/* harmony import */ var _expressions_color_rgb__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./expressions/color/rgb */ "./src/renderer/viz/expressions/color/rgb.js");
/* harmony import */ var _expressions_time__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./expressions/time */ "./src/renderer/viz/expressions/time.js");
/* harmony import */ var _expressions_timeRange__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./expressions/timeRange */ "./src/renderer/viz/expressions/timeRange.js");
/* harmony import */ var _expressions_top__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./expressions/top */ "./src/renderer/viz/expressions/top.js");
/* harmony import */ var _expressions_Fade__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./expressions/Fade */ "./src/renderer/viz/expressions/Fade.js");
/* harmony import */ var _expressions_Animation__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./expressions/Animation */ "./src/renderer/viz/expressions/Animation.js");
/* harmony import */ var _expressions_unary__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./expressions/unary */ "./src/renderer/viz/expressions/unary.js");
/* harmony import */ var _expressions_basic_variable__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./expressions/basic/variable */ "./src/renderer/viz/expressions/basic/variable.js");
/* harmony import */ var _expressions_aggregation_viewport_ViewportAvg__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./expressions/aggregation/viewport/ViewportAvg */ "./src/renderer/viz/expressions/aggregation/viewport/ViewportAvg.js");
/* harmony import */ var _expressions_aggregation_viewport_ViewportMax__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./expressions/aggregation/viewport/ViewportMax */ "./src/renderer/viz/expressions/aggregation/viewport/ViewportMax.js");
/* harmony import */ var _expressions_aggregation_viewport_ViewportMin__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./expressions/aggregation/viewport/ViewportMin */ "./src/renderer/viz/expressions/aggregation/viewport/ViewportMin.js");
/* harmony import */ var _expressions_aggregation_viewport_ViewportSum__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./expressions/aggregation/viewport/ViewportSum */ "./src/renderer/viz/expressions/aggregation/viewport/ViewportSum.js");
/* harmony import */ var _expressions_aggregation_viewport_ViewportCount__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./expressions/aggregation/viewport/ViewportCount */ "./src/renderer/viz/expressions/aggregation/viewport/ViewportCount.js");
/* harmony import */ var _expressions_aggregation_viewport_ViewportPercentile__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./expressions/aggregation/viewport/ViewportPercentile */ "./src/renderer/viz/expressions/aggregation/viewport/ViewportPercentile.js");
/* harmony import */ var _expressions_histogram_ViewportHistogram__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./expressions/histogram/ViewportHistogram */ "./src/renderer/viz/expressions/histogram/ViewportHistogram.js");
/* harmony import */ var _expressions_histogram_GlobalHistogram__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./expressions/histogram/GlobalHistogram */ "./src/renderer/viz/expressions/histogram/GlobalHistogram.js");
/* harmony import */ var _expressions_viewportFeatures__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./expressions/viewportFeatures */ "./src/renderer/viz/expressions/viewportFeatures.js");
/* harmony import */ var _expressions_aggregation_global_GlobalAvg__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./expressions/aggregation/global/GlobalAvg */ "./src/renderer/viz/expressions/aggregation/global/GlobalAvg.js");
/* harmony import */ var _expressions_aggregation_global_GlobalCount__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./expressions/aggregation/global/GlobalCount */ "./src/renderer/viz/expressions/aggregation/global/GlobalCount.js");
/* harmony import */ var _expressions_aggregation_global_GlobalMax__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./expressions/aggregation/global/GlobalMax */ "./src/renderer/viz/expressions/aggregation/global/GlobalMax.js");
/* harmony import */ var _expressions_aggregation_global_GlobalMin__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./expressions/aggregation/global/GlobalMin */ "./src/renderer/viz/expressions/aggregation/global/GlobalMin.js");
/* harmony import */ var _expressions_aggregation_global_GlobalSum__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./expressions/aggregation/global/GlobalSum */ "./src/renderer/viz/expressions/aggregation/global/GlobalSum.js");
/* harmony import */ var _expressions_aggregation_global_GlobalPercentile__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./expressions/aggregation/global/GlobalPercentile */ "./src/renderer/viz/expressions/aggregation/global/GlobalPercentile.js");
/* harmony import */ var _expressions_zoom__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./expressions/zoom */ "./src/renderer/viz/expressions/zoom.js");
/* harmony import */ var _expressions_Placement__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./expressions/Placement */ "./src/renderer/viz/expressions/Placement.js");
/* harmony import */ var _expressions_Image__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./expressions/Image */ "./src/renderer/viz/expressions/Image.js");
/* harmony import */ var _expressions_SVG__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./expressions/SVG */ "./src/renderer/viz/expressions/SVG.js");
/* harmony import */ var _defaultSVGs__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./defaultSVGs */ "./src/renderer/viz/defaultSVGs.js");
/* harmony import */ var _expressions_Zoomrange__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./expressions/Zoomrange */ "./src/renderer/viz/expressions/Zoomrange.js");
/* harmony import */ var _expressions_Scaled__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./expressions/Scaled */ "./src/renderer/viz/expressions/Scaled.js");
/* harmony import */ var _expressions_AlphaNormalize__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./expressions/AlphaNormalize */ "./src/renderer/viz/expressions/AlphaNormalize.js");
/* harmony import */ var _expressions_transformation_Translate__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./expressions/transformation/Translate */ "./src/renderer/viz/expressions/transformation/Translate.js");
/* harmony import */ var _expressions_transformation_Rotate__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./expressions/transformation/Rotate */ "./src/renderer/viz/expressions/transformation/Rotate.js");
/**
 *  Expressions are used to define visualizations, a visualization (viz) is a set named properties and variables and its corresponding values: expressions.
 *  A viz has the following properties:
 *
 *  - **color**: fill color of points and polygons and color of lines
 *  - **strokeColor**: stroke/border color of points and polygons, not applicable to lines
 *  - **width**: fill diameter of points, thickness of lines, not applicable to polygons
 *  - **strokeWidth**: stroke width of points and polygons, not applicable to lines
 *  - **filter**: filter features by removing from rendering and interactivity all the features that don't pass the test.
 *  - **symbol** - show an image instead in the place of points
 *  - **symbolPlacement** - when using `symbol`, offset to apply to the image
 *  - **order**: - rendering order of the features, only applicable to points. See {@link carto.expressions.asc}, {@link carto.expressions.desc} and {@link carto.expressions.noOrder}
 *  - **resolution**: - resolution of the property-aggregation functions, only applicable to points. Default resolution is 1. Custom values must be greater than 0 and lower than 256. A resolution of N means points are aggregated to grid cells NxN pixels. Unlinke {@link https://carto.com/developers/torque-js/guides/how-spatial-aggregation-works/|Torque resolution}, the aggregated points are placed in the centroid of the cluster, not in the center of the grid cell.
 *
 * For example the point diameter could be using the `add` expression:
 *
 * ```javascript
 * const viz = new carto.Viz({
 *   width: carto.expressions.add(5, 5)  // Equivalent to `width: 10`
 * });
 * ```
 *
 * You can use dataset properties inside expressions. Imagine we are representing cities in a map,
 * we can make the point width proportional to the population using the `property`/`prop` expression.
 *
 * ```javascript
 * const viz = new carto.Viz({
 *   width: carto.expressions.prop('population')
 * });
 * ```
 *
 * Multiple expressions can be combined to form more powerful ones,
 * for example lets divide the population between a number using the `div` expression to make points smaller:
 *
 * ```javascript
 * const s = carto.expressions; // We use this alias along documentation.
 * const viz = new carto.Viz({
 *   width: s.div(
 *     s.prop('population'),
 *     10000
 *  )
 * });
 * ```
 *
 * All these expressions can be used also in a String API form. This API is a more compact way to create and use expressions.
 * It has shortcut notation to access your feature properties using the `$` symbol. It also allows inline comments using the JavaScript syntax.
 *
 * ```javascript
 * const viz = new carto.Viz(`
 *   width: $population / 10000  // Size proportional to the population for each feature
 * `);
 * ```
 *
 * Although the combination of expressions is very powerful, you must be aware of the different types to produce valid combinations.
 * For example, the previous example is valid since we assumed that 'population' is a numeric property, it won't be valid if
 * it was a categorical property. Each expression defines some restrictions regarding their parameters, particularly, the
 * type of their parameters.
 *
 * The most important types are:
 *  - **Number** expression. Expressions that contains numbers, both integers and floating point numbers. Boolean types are emulated by this type, being 0 false, and 1 true.
 *  - **Category** expression. Expressions that contains categories. Categories can have a limited set of values, like the country or the region of a feature.
 *  - **Color** expression. Expressions that contains colors. An alpha or transparency channel is included in this type.
 *
 * @namespace carto.expressions
 * @api
 */

/**
 * Depending on the output, each expression has a different type
 *
 * @namespace Types
 * @api
 */

/**
 * Type of Numeric Expressions.
 *
 * Associated to expressions that return is an integer or float. When these expressions are evaluated it should return a JavaScript number.
 *
 * JavaScript numbers are automatically converted to Numeric Expressions.
 *
 * @typedef {} Number
 * @name Number
 * @memberof Types
 * @api
 */

/**
 * Type of Category Expressions.
 *
 * Associated to expressions that return is a category string. When these expressions are evaluated it should return a JavaScript string.
 *
 * JavaScript strings are automatically converted to Category Expressions.
 *
 * @typedef {} Category
 * @name Category
 * @memberof Types
 * @api
 */

/**
 * Type of Color Expressions.
 *
 * Associated to expressions that return a color. When these expressions are evaluated it should return a RGBA object like:
 *
 * ```
 * { r: 255, g: 255, b: 255, a: 1.0 }
 * ```
 *
 * @typedef {} Color
 * @name Color
 * @memberof Types
 * @api
 */

/**
 * Type of Date Expressions.
 *
 * @typedef {} Date
 * @name Date
 * @memberof Types
 * @api
 */

/**
 * Type of Fade Expressions.
 *
 * @typedef {} Fade
 * @name Fade
 * @memberof Types
 * @api
 */

/**
 * Type of Palette Expressions.
 *
 * More information in {@link carto.expressions.palettes|carto.expressions.palettes}.
 *
 * @typedef {} Palette
 * @name Palette
 * @memberof Types
 * @api
 */

/**
 * Type of Image Expressions.
 *
 * More information in {@link carto.expressions.image|carto.expressions.image}.
 *
 * @typedef {} Image
 * @name Image
 * @memberof Types
 * @api
 */

/**
 * Type of Transformation expressions.
 *
 * More information in {@link carto.expressions.rotate|carto.expressions.rotate} and {@link carto.expressions.translate|carto.expressions.translate} expressions.
 *
 * @typedef {} Transformation
 * @name Transformation
 * @memberof Types
 * @api
 */

/**
 * Type of Placement expressions.
 *
 * More information in {@link carto.expressions.placement|carto.expressions.placement} expression.
 *
 * @typedef {} Placement
 * @name Placement
 * @memberof Types
 * @api
 */

/**
 * Type of Ordered Expressions.
 *
 * Order expressions are {@link carto.expressions.asc|carto.expressions.asc}, {@link carto.expressions.desc|carto.expressions.desc} and {@link carto.expressions.noOrder|carto.expressions.noOrder}.
 *
 * @typedef {} Order
 * @name Order
 * @memberof Types
 * @api
 */

/**
 * @namespace Constants
 * @api
 *
*/

/**
 * Constant FALSE value. Equivalent to `carto.expressions.constant(0)`
 *
 * @name FALSE
 * @memberof Constants
 * @api
*/

/**
 * Constant TRUE value. Equivalent to `carto.expressions.constant(1)`
 *
 * @name TRUE
 * @memberof Constants
 * @api
*/

/**
 * Constant ALIGN_CENTER translation. Equivalent to `carto.expressions.translate(0, 0)`.
 * Read more about translation in {@link carto.expressions.translate|carto.expressions.translate}
 *
 * @name ALIGN_CENTER
 * @memberof Constants
 * @api
*/

/**
 * Constant ALIGN_BOTTOM translation. Equivalent to `carto.expressions.translate(0, 1)`.
 * Read more about translation in {@link carto.expressions.translate|carto.expressions.translate}
 *
 * @name ALIGN_BOTTOM
 * @memberof Constants
 * @api
*/

/**
 * Constant PI number.
 *
 * @name PI
 * @memberof Constants
 * @api
*/

/**
 * Constant E number.
 *
 * @name E
 * @memberof Constants
 * @api
*/

/**
 * Constant HOLD number. Max Safe Integer number to be used to "hold" the Fade expression.
 * Read more about fading in {@link carto.expressions.fade|carto.expressions.fade}
 *
 * @name HOLD
 * @memberof Constants
 * @api
*/

/**
 * @namespace Icons
 * @api
 *
*/

/**
 * Constant BICYCLE icon.
 * Read more about how to use constant icons in {@link carto.expressions.image|carto.expressions.image}.
 * They can also be used in an array, as it is shown in {@link carto.expressions.ramp|carto.expressions.ramp}.
 * There is a list with all the default {@link icons.showcase|icons} available.
 *
 * @name BICYCLE
 * @memberof Icons
 * @api
*/

/**
 * Constant BUILDING icon.
 * Read more about how to use constant icons in {@link carto.expressions.image|carto.expressions.image}.
 * They can also be used in an array, as it is shown in {@link carto.expressions.ramp|carto.expressions.ramp}.
 * There is a list with all the default {@link icons.showcase|icons} available.
 *
 * @name BUILDING
 * @memberof Icons
 * @api
*/

/**
 * Constant BUS icon.
 * Read more about how to use constant icons in {@link carto.expressions.image|carto.expressions.image}.
 * They can also be used in an array, as it is shown in {@link carto.expressions.ramp|carto.expressions.ramp}.
 * There is a list with all the default {@link icons.showcase|icons} available.
 *
 * @name BUS
 * @memberof Icons
 * @api
*/

/**
 * Constant CAR icon.
 * Read more about how to use constant icons in {@link carto.expressions.image|carto.expressions.image}.
 * They can also be used in an array, as it is shown in {@link carto.expressions.ramp|carto.expressions.ramp}.
 * There is a list with all the default {@link icons.showcase|icons} available.
 *
 * @name CAR
 * @memberof Icons
 * @api
*/

/**
 * Constant CIRCLE icon.
 * Read more about how to use constant icons in {@link carto.expressions.image|carto.expressions.image}.
 * They can also be used in an array, as it is shown in {@link carto.expressions.ramp|carto.expressions.ramp}.
 * There is a list with all the default {@link icons.showcase|icons} available.
 *
 * @name CIRCLE
 * @memberof Icons
 * @api
*/

/**
 * Constant CIRCLE_OUTLINE icon.
 * Read more about how to use constant icons in {@link carto.expressions.image|carto.expressions.image}.
 * They can also be used in an array, as it is shown in {@link carto.expressions.ramp|carto.expressions.ramp}.
 * There is a list with all the default {@link icons.showcase|icons} available.
 *
 * @name CIRCLE_OUTLINE
 * @memberof Icons
 * @api
*/

/**
 * Constant CROSS icon.
 * Read more about how to use constant icons in {@link carto.expressions.image|carto.expressions.image}.
 * They can also be used in an array, as it is shown in {@link carto.expressions.ramp|carto.expressions.ramp}.
 * There is a list with all the default {@link icons.showcase|icons} available.
 *
 * @name CROSS
 * @memberof Icons
 * @api
*/

/**
 * Constant FLAG icon.
 * Read more about how to use constant icons in {@link carto.expressions.image|carto.expressions.image}.
 * They can also be used in an array, as it is shown in {@link carto.expressions.ramp|carto.expressions.ramp}.
 * There is a list with all the default {@link icons.showcase|icons} available.
 *
 * @name FLAG
 * @memberof Icons
 * @api
*/

/**
 * Constant HOUSE icon.
 * Read more about how to use constant icons in {@link carto.expressions.image|carto.expressions.image}.
 * They can also be used in an array, as it is shown in {@link carto.expressions.ramp|carto.expressions.ramp}.
 * There is a list with all the default {@link icons.showcase|icons} available.
 *
 * @name HOUSE
 * @memberof Icons
 * @api
*/

/**
 * Constant MARKER icon.
 * Read more about how to use constant icons in {@link carto.expressions.image|carto.expressions.image}.
 * They can also be used in an array, as it is shown in {@link carto.expressions.ramp|carto.expressions.ramp}.
 * There is a list with all the default {@link icons.showcase|icons} available.
 *
 * @name MARKER
 * @memberof Icons
 * @api
*/

/**
 * Constant MARKER_OUTLINE icon.
 * Read more about how to use constant icons in {@link carto.expressions.image|carto.expressions.image}.
 * They can also be used in an array, as it is shown in {@link carto.expressions.ramp|carto.expressions.ramp}.
 * There is a list with all the default {@link icons.showcase|icons} available.
 *
 * @name MARKER_OUTLINE
 * @memberof Icons
 * @api
*/

/**
 * Constant SQUARE icon.
 * Read more about how to use constant icons in {@link carto.expressions.image|carto.expressions.image}.
 * They can also be used in an array, as it is shown in {@link carto.expressions.ramp|carto.expressions.ramp}.
 * There is a list with all the default {@link icons.showcase|icons} available.
 *
 * @name SQUARE
 * @memberof Icons
 * @api
*/

/**
 * Constant SQUARE_OUTLINE icon.
 * Read more about how to use constant icons in {@link carto.expressions.image|carto.expressions.image}.
 * They can also be used in an array, as it is shown in {@link carto.expressions.ramp|carto.expressions.ramp}.
 * There is a list with all the default {@link icons.showcase|icons} available.
 *
 * @name SQUARE_OUTLINE
 * @memberof Icons
 * @api
*/

/**
 * Constant STAR icon.
 * Read more about how to use constant icons in {@link carto.expressions.image|carto.expressions.image}.
 * They can also be used in an array, as it is shown in {@link carto.expressions.ramp|carto.expressions.ramp}.
 * There is a list with all the default {@link icons.showcase|icons} available.
 *
 * @name STAR
 * @memberof Icons
 * @api
*/

/**
 * Constant STAR_OUTLINE icon.
 * Read more about how to use constant icons in {@link carto.expressions.image|carto.expressions.image}.
 * They can also be used in an array, as it is shown in {@link carto.expressions.ramp|carto.expressions.ramp}.
 * There is a list with all the default {@link icons.showcase|icons} available.
 *
 * @name STAR_OUTLINE
 * @memberof Icons
 * @api
*/

/**
 * Constant TRIANGLE icon.
 * Read more about how to use constant icons in {@link carto.expressions.image|carto.expressions.image}.
 * They can also be used in an array, as it is shown in {@link carto.expressions.ramp|carto.expressions.ramp}.
 * There is a list with all the default {@link icons.showcase|icons} available.
 *
 * @name TRIANGLE
 * @memberof Icons
 * @api
*/

/**
 * Constant TRIANGLE_OUTLINE icon.
 * Read more about how to use constant icons in {@link carto.expressions.image|carto.expressions.image}.
 * They can also be used in an array, as it is shown in {@link carto.expressions.ramp|carto.expressions.ramp}.
 * There is a list with all the default {@link icons.showcase|icons} available.
 *
 * @name TRIANGLE_OUTLINE
 * @memberof Icons
 * @api
*/








// Binary Operations

































































































































/* Expose classes as constructor functions */

const number = (...args) => new _expressions_basic_number__WEBPACK_IMPORTED_MODULE_36__["default"](...args);
const category = (...args) => new _expressions_basic_category__WEBPACK_IMPORTED_MODULE_19__["default"](...args);
const list = (...args) => new _expressions_basic_List__WEBPACK_IMPORTED_MODULE_49__["default"](...args);
const rgb = (...args) => new _expressions_color_rgb__WEBPACK_IMPORTED_MODULE_50__["RGB"](...args);
const rgba = (...args) => new _expressions_color_rgb__WEBPACK_IMPORTED_MODULE_50__["RGBA"](...args);
const transition = (...args) => new _expressions_transition__WEBPACK_IMPORTED_MODULE_0__["default"](...args);

const in_ = (...args) => new _expressions_belongs__WEBPACK_IMPORTED_MODULE_1__["In"](...args);
const nin = (...args) => new _expressions_belongs__WEBPACK_IMPORTED_MODULE_1__["Nin"](...args);


const between = (...args) => new _expressions_between__WEBPACK_IMPORTED_MODULE_2__["default"](...args);

const mul = (...args) => new _expressions_binary_Mul__WEBPACK_IMPORTED_MODULE_12__["default"](...args);
const div = (...args) => new _expressions_binary_Div__WEBPACK_IMPORTED_MODULE_5__["default"](...args);
const add = (...args) => new _expressions_binary_Add__WEBPACK_IMPORTED_MODULE_3__["default"](...args);
const sub = (...args) => new _expressions_binary_Sub__WEBPACK_IMPORTED_MODULE_16__["default"](...args);
const pow = (...args) => new _expressions_binary_Pow__WEBPACK_IMPORTED_MODULE_15__["default"](...args);
const mod = (...args) => new _expressions_binary_Mod__WEBPACK_IMPORTED_MODULE_11__["default"](...args);
const greaterThan = (...args) => new _expressions_binary_GreaterThan__WEBPACK_IMPORTED_MODULE_7__["default"](...args);
const greaterThanOrEqualTo = (...args) => new _expressions_binary_GreaterThanOrEqualTo__WEBPACK_IMPORTED_MODULE_8__["default"](...args);
const lessThan = (...args) => new _expressions_binary_LessThan__WEBPACK_IMPORTED_MODULE_9__["default"](...args);
const lessThanOrEqualTo = (...args) => new _expressions_binary_LessThanOrEqualTo__WEBPACK_IMPORTED_MODULE_10__["default"](...args);
const equals = (...args) => new _expressions_binary_Equals__WEBPACK_IMPORTED_MODULE_6__["default"](...args);
const notEquals = (...args) => new _expressions_binary_NotEquals__WEBPACK_IMPORTED_MODULE_13__["default"](...args);
const and = (...args) => new _expressions_binary_And__WEBPACK_IMPORTED_MODULE_4__["default"](...args);
const or = (...args) => new _expressions_binary_Or__WEBPACK_IMPORTED_MODULE_14__["default"](...args);
const gt = greaterThan;
const gte = greaterThanOrEqualTo;
const lt = lessThan;
const lte = lessThanOrEqualTo;
const eq = equals;
const neq = notEquals;

const blend = (...args) => new _expressions_blend__WEBPACK_IMPORTED_MODULE_17__["default"](...args);

const buckets = (...args) => new _expressions_buckets__WEBPACK_IMPORTED_MODULE_18__["default"](...args);

const cielab = (...args) => new _expressions_color_CIELab__WEBPACK_IMPORTED_MODULE_20__["default"](...args);

const clusterAvg = (...args) => new _expressions_aggregation_cluster_ClusterAvg__WEBPACK_IMPORTED_MODULE_21__["default"](...args);
const clusterMax = (...args) => new _expressions_aggregation_cluster_ClusterMax__WEBPACK_IMPORTED_MODULE_22__["default"](...args);
const clusterMin = (...args) => new _expressions_aggregation_cluster_ClusterMin__WEBPACK_IMPORTED_MODULE_23__["default"](...args);
const clusterMode = (...args) => new _expressions_aggregation_cluster_ClusterMode__WEBPACK_IMPORTED_MODULE_24__["default"](...args);
const clusterSum = (...args) => new _expressions_aggregation_cluster_ClusterSum__WEBPACK_IMPORTED_MODULE_25__["default"](...args);
const clusterCount = (...args) => new _expressions_aggregation_cluster_ClusterCount__WEBPACK_IMPORTED_MODULE_26__["default"](...args);

const clusterTime = (...args) => new _expressions_aggregation_cluster_ClusterTime__WEBPACK_IMPORTED_MODULE_27__["default"](...args);

const constant = (...args) => new _expressions_basic_constant__WEBPACK_IMPORTED_MODULE_28__["default"](...args);

const image = (...args) => new _expressions_Image__WEBPACK_IMPORTED_MODULE_75__["default"](...args);

const svg = (...args) => new _expressions_SVG__WEBPACK_IMPORTED_MODULE_76__["default"](...args);

const hex = (...args) => new _expressions_color_hex__WEBPACK_IMPORTED_MODULE_29__["default"](...args);

const hsl = (...args) => new _expressions_color_hsl__WEBPACK_IMPORTED_MODULE_30__["HSL"](...args);
const hsla = (...args) => new _expressions_color_hsl__WEBPACK_IMPORTED_MODULE_30__["HSLA"](...args);

const hsv = (...args) => new _expressions_color_hsv__WEBPACK_IMPORTED_MODULE_31__["HSV"](...args);
const hsva = (...args) => new _expressions_color_hsv__WEBPACK_IMPORTED_MODULE_31__["HSVA"](...args);

const cubic = (...args) => new _expressions_interpolators__WEBPACK_IMPORTED_MODULE_32__["Cubic"](...args);
const ilinear = (...args) => new _expressions_interpolators__WEBPACK_IMPORTED_MODULE_32__["ILinear"](...args);

const linear = (...args) => new _expressions_linear__WEBPACK_IMPORTED_MODULE_33__["default"](...args);

const namedColor = (...args) => new _expressions_color_NamedColor__WEBPACK_IMPORTED_MODULE_34__["default"](...args);

const now = (...args) => new _expressions_now__WEBPACK_IMPORTED_MODULE_35__["default"](...args);

const opacity = (...args) => new _expressions_color_Opacity__WEBPACK_IMPORTED_MODULE_37__["default"](...args);

const asc = (...args) => new _expressions_ordering__WEBPACK_IMPORTED_MODULE_38__["Asc"](...args);
const desc = (...args) => new _expressions_ordering__WEBPACK_IMPORTED_MODULE_38__["Desc"](...args);
const noOrder = (...args) => new _expressions_ordering__WEBPACK_IMPORTED_MODULE_38__["NoOrder"](...args);
const width = (...args) => new _expressions_ordering__WEBPACK_IMPORTED_MODULE_38__["Width"](...args);

const reverse = (...args) => new _expressions_reverse_Reverse__WEBPACK_IMPORTED_MODULE_40__["default"](...args);

const property = (...args) => new _expressions_basic_property__WEBPACK_IMPORTED_MODULE_41__["default"](...args);


const globalQuantiles = (...args) => new _expressions_classification_GlobalQuantiles__WEBPACK_IMPORTED_MODULE_43__["default"](...args);
const viewportQuantiles = (...args) => new _expressions_classification_ViewportQuantiles__WEBPACK_IMPORTED_MODULE_46__["default"](...args);

const globalEqIntervals = (...args) => new _expressions_classification_GlobalEqIntervals__WEBPACK_IMPORTED_MODULE_42__["default"](...args);
const viewportEqIntervals = (...args) => new _expressions_classification_ViewportEqIntervals__WEBPACK_IMPORTED_MODULE_45__["default"](...args);

const globalStandardDev = (...args) => new _expressions_classification_GlobalStandardDev__WEBPACK_IMPORTED_MODULE_44__["default"](...args);
const viewportStandardDev = (...args) => new _expressions_classification_ViewportStandardDev__WEBPACK_IMPORTED_MODULE_47__["default"](...args);

const ramp = (...args) => new _expressions_Ramp__WEBPACK_IMPORTED_MODULE_48__["default"](...args);

const time = (...args) => new _expressions_time__WEBPACK_IMPORTED_MODULE_51__["default"](...args);


const timeRange = (...args) => new _expressions_timeRange__WEBPACK_IMPORTED_MODULE_52__["default"](...args);

const top = (...args) => new _expressions_top__WEBPACK_IMPORTED_MODULE_53__["default"](...args);

const fade = (...args) => new _expressions_Fade__WEBPACK_IMPORTED_MODULE_54__["Fade"](...args);
const animation = (...args) => new _expressions_Animation__WEBPACK_IMPORTED_MODULE_55__["Animation"](...args);

const log = (...args) => new _expressions_unary__WEBPACK_IMPORTED_MODULE_56__["Log"](...args);
const sqrt = (...args) => new _expressions_unary__WEBPACK_IMPORTED_MODULE_56__["Sqrt"](...args);
const sin = (...args) => new _expressions_unary__WEBPACK_IMPORTED_MODULE_56__["Sin"](...args);
const cos = (...args) => new _expressions_unary__WEBPACK_IMPORTED_MODULE_56__["Cos"](...args);
const tan = (...args) => new _expressions_unary__WEBPACK_IMPORTED_MODULE_56__["Tan"](...args);
const sign = (...args) => new _expressions_unary__WEBPACK_IMPORTED_MODULE_56__["Sign"](...args);
const abs = (...args) => new _expressions_unary__WEBPACK_IMPORTED_MODULE_56__["Abs"](...args);
const isNull = (...args) => new _expressions_unary__WEBPACK_IMPORTED_MODULE_56__["IsNull"](...args);
const not = (...args) => new _expressions_unary__WEBPACK_IMPORTED_MODULE_56__["Not"](...args);
const floor = (...args) => new _expressions_unary__WEBPACK_IMPORTED_MODULE_56__["Floor"](...args);
const ceil = (...args) => new _expressions_unary__WEBPACK_IMPORTED_MODULE_56__["Ceil"](...args);

const variable = (...args) => Object(_expressions_basic_variable__WEBPACK_IMPORTED_MODULE_57__["default"])(...args);


const viewportAvg = (...args) => new _expressions_aggregation_viewport_ViewportAvg__WEBPACK_IMPORTED_MODULE_58__["default"](...args);
const viewportMax = (...args) => new _expressions_aggregation_viewport_ViewportMax__WEBPACK_IMPORTED_MODULE_59__["default"](...args);
const viewportMin = (...args) => new _expressions_aggregation_viewport_ViewportMin__WEBPACK_IMPORTED_MODULE_60__["default"](...args);
const viewportSum = (...args) => new _expressions_aggregation_viewport_ViewportSum__WEBPACK_IMPORTED_MODULE_61__["default"](...args);
const viewportCount = (...args) => new _expressions_aggregation_viewport_ViewportCount__WEBPACK_IMPORTED_MODULE_62__["default"](...args);
const viewportPercentile = (...args) => new _expressions_aggregation_viewport_ViewportPercentile__WEBPACK_IMPORTED_MODULE_63__["default"](...args);
const viewportHistogram = (...args) => new _expressions_histogram_ViewportHistogram__WEBPACK_IMPORTED_MODULE_64__["default"](...args);
const viewportFeatures = (...args) => new _expressions_viewportFeatures__WEBPACK_IMPORTED_MODULE_66__["default"](...args);
const globalAvg = (...args) => new _expressions_aggregation_global_GlobalAvg__WEBPACK_IMPORTED_MODULE_67__["default"](...args);
const globalMax = (...args) => new _expressions_aggregation_global_GlobalMax__WEBPACK_IMPORTED_MODULE_69__["default"](...args);
const globalMin = (...args) => new _expressions_aggregation_global_GlobalMin__WEBPACK_IMPORTED_MODULE_70__["default"](...args);
const globalSum = (...args) => new _expressions_aggregation_global_GlobalSum__WEBPACK_IMPORTED_MODULE_71__["default"](...args);
const globalCount = (...args) => new _expressions_aggregation_global_GlobalCount__WEBPACK_IMPORTED_MODULE_68__["default"](...args);
const globalPercentile = (...args) => new _expressions_aggregation_global_GlobalPercentile__WEBPACK_IMPORTED_MODULE_72__["default"](...args);
const globalHistogram = (...args) => new _expressions_histogram_GlobalHistogram__WEBPACK_IMPORTED_MODULE_65__["default"](...args);

const zoom = (...args) => new _expressions_zoom__WEBPACK_IMPORTED_MODULE_73__["default"](...args);
const scaled = (...args) => new _expressions_Scaled__WEBPACK_IMPORTED_MODULE_79__["default"](...args);
const zoomrange = (...args) => new _expressions_Zoomrange__WEBPACK_IMPORTED_MODULE_78__["default"](...args);

const placement = (...args) => new _expressions_Placement__WEBPACK_IMPORTED_MODULE_74__["default"](...args);
const translate = (...args) => new _expressions_transformation_Translate__WEBPACK_IMPORTED_MODULE_81__["default"](...args);
const rotate = (...args) => new _expressions_transformation_Rotate__WEBPACK_IMPORTED_MODULE_82__["default"](...args);
const alphaNormalize = (...args) => new _expressions_AlphaNormalize__WEBPACK_IMPORTED_MODULE_80__["default"](...args);

const HOLD = new _expressions_basic_constant__WEBPACK_IMPORTED_MODULE_28__["default"](Number.MAX_SAFE_INTEGER);
const TRUE = new _expressions_basic_constant__WEBPACK_IMPORTED_MODULE_28__["default"](1);
const FALSE = new _expressions_basic_constant__WEBPACK_IMPORTED_MODULE_28__["default"](0);
const PI = new _expressions_basic_constant__WEBPACK_IMPORTED_MODULE_28__["default"](Math.PI);
const E = new _expressions_basic_constant__WEBPACK_IMPORTED_MODULE_28__["default"](Math.E);

const BICYCLE = new _expressions_Image__WEBPACK_IMPORTED_MODULE_75__["default"](_defaultSVGs__WEBPACK_IMPORTED_MODULE_77__["default"].bicycle);
const BUILDING = new _expressions_Image__WEBPACK_IMPORTED_MODULE_75__["default"](_defaultSVGs__WEBPACK_IMPORTED_MODULE_77__["default"].building);
const BUS = new _expressions_Image__WEBPACK_IMPORTED_MODULE_75__["default"](_defaultSVGs__WEBPACK_IMPORTED_MODULE_77__["default"].bus);
const CAR = new _expressions_Image__WEBPACK_IMPORTED_MODULE_75__["default"](_defaultSVGs__WEBPACK_IMPORTED_MODULE_77__["default"].car);
const CIRCLE = new _expressions_Image__WEBPACK_IMPORTED_MODULE_75__["default"](_defaultSVGs__WEBPACK_IMPORTED_MODULE_77__["default"].circle);
const CIRCLE_OUTLINE = new _expressions_Image__WEBPACK_IMPORTED_MODULE_75__["default"](_defaultSVGs__WEBPACK_IMPORTED_MODULE_77__["default"].circleOutline);
const CROSS = new _expressions_Image__WEBPACK_IMPORTED_MODULE_75__["default"](_defaultSVGs__WEBPACK_IMPORTED_MODULE_77__["default"].cross);
const FLAG = new _expressions_Image__WEBPACK_IMPORTED_MODULE_75__["default"](_defaultSVGs__WEBPACK_IMPORTED_MODULE_77__["default"].flag);
const HOUSE = new _expressions_Image__WEBPACK_IMPORTED_MODULE_75__["default"](_defaultSVGs__WEBPACK_IMPORTED_MODULE_77__["default"].house);
const MARKER = new _expressions_Image__WEBPACK_IMPORTED_MODULE_75__["default"](_defaultSVGs__WEBPACK_IMPORTED_MODULE_77__["default"].marker);
const MARKER_OUTLINE = new _expressions_Image__WEBPACK_IMPORTED_MODULE_75__["default"](_defaultSVGs__WEBPACK_IMPORTED_MODULE_77__["default"].markerOutline);
const PLUS = new _expressions_Image__WEBPACK_IMPORTED_MODULE_75__["default"](_defaultSVGs__WEBPACK_IMPORTED_MODULE_77__["default"].plus);
const SQUARE = new _expressions_Image__WEBPACK_IMPORTED_MODULE_75__["default"](_defaultSVGs__WEBPACK_IMPORTED_MODULE_77__["default"].square);
const SQUARE_OUTLINE = new _expressions_Image__WEBPACK_IMPORTED_MODULE_75__["default"](_defaultSVGs__WEBPACK_IMPORTED_MODULE_77__["default"].squareOutline);
const STAR = new _expressions_Image__WEBPACK_IMPORTED_MODULE_75__["default"](_defaultSVGs__WEBPACK_IMPORTED_MODULE_77__["default"].star);
const STAR_OUTLINE = new _expressions_Image__WEBPACK_IMPORTED_MODULE_75__["default"](_defaultSVGs__WEBPACK_IMPORTED_MODULE_77__["default"].starOutline);
const TRIANGLE = new _expressions_Image__WEBPACK_IMPORTED_MODULE_75__["default"](_defaultSVGs__WEBPACK_IMPORTED_MODULE_77__["default"].triangle);
const TRIANGLE_OUTLINE = new _expressions_Image__WEBPACK_IMPORTED_MODULE_75__["default"](_defaultSVGs__WEBPACK_IMPORTED_MODULE_77__["default"].triangleOutline);

const ALIGN_CENTER = new _expressions_Placement__WEBPACK_IMPORTED_MODULE_74__["default"](constant(0), constant(0));
const ALIGN_BOTTOM = new _expressions_Placement__WEBPACK_IMPORTED_MODULE_74__["default"](constant(0), constant(1));




/***/ }),

/***/ "./src/renderer/viz/expressions/AlphaNormalize.js":
/*!********************************************************!*\
  !*** ./src/renderer/viz/expressions/AlphaNormalize.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AlphaNormalize; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _basic_property__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./basic/property */ "./src/renderer/viz/expressions/basic/property.js");





/**
 * Override the opacity (alpha channel) of a color to normalize the input color by a normalizer property.
 *
 * This is implemented as `opacity(input, normalizer/globalMax(normalizer))
 *
 * @param {Color} input - input color to normalize
 * @param {Number} normalizer - numeric property that will be used to normalize the input color
 * @return {Color}
 *
 * @example <caption>Normalize an input property ($winner_party) by a second property ($voters).</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.alphaNormalize(
 *              s.ramp(s.prop('winner_party'), [red, blue]),
 *              s.prop('voters')
 *          )
 * });
 *
 * @example <caption>Normalize an input property ($winner_party) by a second property ($voters). (String)</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: alphaNormalize(
 *              ramp($winner_party, [red, blue]),
 *              $voters
 *          )
 * });
 *
 * @memberof carto.expressions
 * @name alphaNormalize
 * @function
 * @api
 */
class AlphaNormalize extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (input, normalizer) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkMaxArguments"])(arguments, 2, 'alphaNormalize');
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkExpression"])('alphaNormalize', 'input', 0, input);
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkExpression"])('alphaNormalize', 'normalizer', 1, normalizer);

        super({ _impostor: Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["opacity"])(input, Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["div"])(normalizer, Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["globalMax"])(normalizer))) });
        this._input = input;
        this._normalizer = normalizer;
        this.type = 'color';
        this.inlineMaker = inline => inline._impostor;
    }

    _bindMetadata (meta) {
        this._input._bindMetadata(meta);
        this._normalizer._bindMetadata(meta);
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkType"])('alphaNormalize', 'input', 0, 'color', this._input);
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkType"])('alphaNormalize', 'normalizer', 1, 'number', this._normalizer);
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkInstance"])('alphaNormalize', 'normalizer', 1, _basic_property__WEBPACK_IMPORTED_MODULE_3__["default"], this._normalizer);
        super._bindMetadata(meta);
    }

    get value () {
        return this._impostor.value;
    }

    eval (feature) {
        return this._impostor.eval(feature);
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/Animation.js":
/*!***************************************************!*\
  !*** ./src/renderer/viz/expressions/Animation.js ***!
  \***************************************************/
/*! exports provided: Animation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Animation", function() { return Animation; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _AnimationGeneral__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AnimationGeneral */ "./src/renderer/viz/expressions/AnimationGeneral.js");
/* harmony import */ var _AnimationRange__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./AnimationRange */ "./src/renderer/viz/expressions/AnimationRange.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _Fade__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Fade */ "./src/renderer/viz/expressions/Fade.js");






/**
 * Create an animated temporal filter (animation). Read more about the {@link expression.Animation|Animation Class}
 *
 * @param {Number} input input to base the temporal filter,
 * if input is a property, the beginning and end of the animation will be determined by the minimum and maximum timestamps of the property on the dataset,
 * this can be problematic if outliers are present. Otherwise input must be a number expression in which 0 means beginning of the animation and 1 means end.
 * If `input` is NULL or NaN the filter won't be passed at any moment of the animation.
 *
 * It can be combined with linear and time expressions.
 * @param {Number} duration duration of the animation in seconds, optional, defaults to 10 seconds
 * @param {Fade} fade fadeIn/fadeOut configuration, optional, defaults to 0.15 seconds of fadeIn and 0.15 seconds of fadeOut
 * @return {Number}
 *
 * @example <caption>Temporal map by $day (of numeric type), with a duration of 40 seconds, fadeIn of 0.1 seconds and fadeOut of 0.3 seconds.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: 2,
 *   color: s.ramp(s.linear(s.clusterAvg(s.prop('temp'), 0, 30)), s.palettes.TEALROSE),
 *   filter: s.animation(s.prop('day'), 40, s.fade(0.1, 0.3))
 * });
 *
 * @example <caption>Temporal map by $day (of numeric type), with a duration of 40 seconds, fadeIn of 0.1 seconds and fadeOut of 0.3 seconds. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: 2
 *   color: ramp(linear(clusterAvg($temp), 0,30), tealrose)
 *   filter: animation($day, 40, fade(0.1, 0.3))
 * `);
 *
 * @example <caption>Temporal map by $date (of date type), with a duration of 40 seconds, fadeIn of 0.1 seconds and fadeOut of 0.3 seconds.</caption>
 * const viz = new carto.Viz({
 *   width: 2,
 *   color: s.ramp(s.linear(s.clusterAvg(s.prop('temp'), 0, 30)), s.palettes.TEALROSE),
 *   filter: s.animation(s.linear(s.prop('date'), s.time('2022-03-09T00:00:00Z'), s.time('2033-08-12T00:00:00Z')), 40, s.fade(0.1, 0.3))
 * });
 *
 * @example <caption>Temporal map by $date (of date type), with a duration of 40 seconds, fadeIn of 0.1 seconds and fadeOut of 0.3 seconds. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: 2
 *   color: ramp(linear(clusterAvg($temp), 0,30), tealrose)
 *   filter: animation(linear($date, time('2022-03-09T00:00:00Z'), time('2033-08-12T00:00:00Z')), 40, fade(0.1, 0.3))
 * `);
 * Animation class
 *
 * This class is instanced automatically by using the `animation` function. It is documented for its methods.
 *
 * @memberof carto.expressions
 * @name animation
 * @function
 * @api
*/

/**
 * Animation class
 *
 * This class is instanced automatically by using the `animation` function. It is documented for its methods.
 *
 * @name expressions.Animation
 * @abstract
 * @hideconstructor
 * @class
 * @api
 */

class Animation extends _base__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor (input, duration = 10, fade = new _Fade__WEBPACK_IMPORTED_MODULE_4__["Fade"]()) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_0__["checkMaxArguments"])(arguments, 3, 'animation');
        duration = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["implicitCast"])(duration);
        input = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["implicitCast"])(input);
        super({ input, duration, fade });
    }
    _resolveAliases (aliases) {
        this._getChildren().map(child => child._resolveAliases(aliases));
        if (this.input.type === 'timerange') {
            Object.setPrototypeOf(this, _AnimationRange__WEBPACK_IMPORTED_MODULE_2__["default"].prototype);
        } else {
            Object.setPrototypeOf(this, _AnimationGeneral__WEBPACK_IMPORTED_MODULE_1__["default"].prototype);
        }
        this._init();
    }
    _bindMetadata (metadata) {
        this._resolveAliases({});
        this._bindMetadata(metadata);
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/AnimationGeneral.js":
/*!**********************************************************!*\
  !*** ./src/renderer/viz/expressions/AnimationGeneral.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimationGeneral; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _basic_property__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basic/property */ "./src/renderer/viz/expressions/basic/property.js");
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../utils/util */ "./src/utils/util.js");
/* harmony import */ var _aggregation_cluster_ClusterTime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./aggregation/cluster/ClusterTime */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterTime.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _Fade__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Fade */ "./src/renderer/viz/expressions/Fade.js");








let waitingForLayer = new Set();
let waitingForOthers = new Set();

class AnimationGeneral extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (input, duration = 10, fade = new _Fade__WEBPACK_IMPORTED_MODULE_6__["Fade"]()) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_5__["checkMaxArguments"])(arguments, 3, 'animation');
        duration = Object(_utils__WEBPACK_IMPORTED_MODULE_5__["implicitCast"])(duration);
        input = Object(_utils__WEBPACK_IMPORTED_MODULE_5__["implicitCast"])(input);
        super({ input, duration, fade });
        this._init();
    }
    _init () {
        const input = this.input;
        const originalInput = input;

        if (input.isA(_basic_property__WEBPACK_IMPORTED_MODULE_1__["default"]) || (input.isA(_aggregation_cluster_ClusterTime__WEBPACK_IMPORTED_MODULE_3__["default"]) && input.type === 'timerange')) {
            this._input = Object(_expressions__WEBPACK_IMPORTED_MODULE_4__["linear"])(input, Object(_expressions__WEBPACK_IMPORTED_MODULE_4__["globalMin"])(input), Object(_expressions__WEBPACK_IMPORTED_MODULE_4__["globalMax"])(input), 'start');
        } else {
            this._input = this.input;
        }
        this.childrenNames = this.childrenNames.filter(x => x === '_input');
        this.childrenNames.push('_input');
        this.childrenNames.push('fade');
        this.childrenNames.push('duration');

        this.type = 'number';
        this._originalInput = originalInput;
        this._paused = false;
        this.progress = Object(_expressions__WEBPACK_IMPORTED_MODULE_4__["number"])(0);
        this.childrenNames.push('progress');

        this.expressionName = 'animation';

        this.preface = `
        #ifndef ANIMATION
        #define ANIMATION

        float animation(float _input, float progress, float duration, float fadeIn, float fadeOut){
            float x = 0.;

            // Check for NaN
            if (_input <= 0.0 || 0.0 <= _input){
                x = 1. - clamp(abs(_input - progress) * duration / (_input > progress ? fadeIn: fadeOut), 0., 1.);
            }

            return x;
        }

        #endif
    `;

        this.inlineMaker = inline => `animation(${inline._input}, ${inline.progress}, ${inline.duration}, ${inline.fade.in}, ${inline.fade.out})`;

        waitingForLayer.add(this);
        if (!this._paused) {
            this._paused = 'default';
        }
    }

    toString () {
        return `${this.expressionName}(${this._input.toString()}, ${this.duration.toString()}, ${this.fade.toString()})`;
    }

    _bindMetadata (metadata) {
        this._input._bindMetadata(metadata);
        this.progress._bindMetadata(metadata);
        this.fade._bindMetadata(metadata);
        this.duration._bindMetadata(metadata);

        Object(_utils__WEBPACK_IMPORTED_MODULE_5__["checkType"])('animation', 'input', 0, ['number', 'date', 'timerange'], this._originalInput);
        Object(_utils__WEBPACK_IMPORTED_MODULE_5__["checkType"])('animation', 'duration', 1, 'number', this.duration);

        Object(_utils__WEBPACK_IMPORTED_MODULE_5__["checkType"])('animation', 'fade', 2, 'fade', this.fade);
        Object(_utils__WEBPACK_IMPORTED_MODULE_5__["checkFeatureIndependent"])('animation', 'duration', 1, this.duration);
    }

    isAnimated () {
        return true;
    }

    _dataReady () {
        if (waitingForLayer.has(this)) {
            waitingForLayer.delete(this);
            waitingForOthers.add(this);
        }
        // setTimeout is needed to avoid the possibility of a de-synchronization of 1 frame
        // if the last layer to be loaded is not the first one on the painting loop
        setTimeout(() => {
            if (waitingForOthers.has(this)) {
                waitingForLayer = new Set([...waitingForLayer].filter(expr => {
                    while (expr.parent) {
                        expr = expr.parent;
                    }
                    if (expr._getRootExpressions) {
                        // The animation hasn't been removed from the viz
                        return true;
                    }
                    return false;
                }));
                if (waitingForLayer.size > 0) {
                    return;
                }
                [...waitingForOthers.values()].map(anim => {
                    if (anim._paused === 'default') {
                        anim.play();
                    }
                });
                waitingForOthers.clear();
            }
        }, 0);
    }

    _postShaderCompile (program, gl) {
        super._postShaderCompile(program, gl);
    }

    _setTimestamp (timestamp) {
        super._setTimestamp(timestamp);

        if (this._paused && this._lastTime === undefined) {
            return;
        }

        let deltaTime = 0;
        const speed = 1 / this.duration.value;

        if (this._lastTime !== undefined) {
            deltaTime = timestamp - this._lastTime;
        }

        this._lastTime = timestamp;

        if (this._paused) {
            return;
        }

        this.progress.value = (this.progress.value + speed * deltaTime) % 1;
    }

    eval (feature) {
        const input = this._input.eval(feature);

        if (input === null) {
            return 0;
        }

        const progress = this.progress.value;
        const duration = this.duration.value;
        const fadeIn = this.fade.fadeIn.eval(feature);
        const fadeOut = this.fade.fadeOut.eval(feature);

        const output = 1 - Object(_utils__WEBPACK_IMPORTED_MODULE_5__["clamp"])(Math.abs(input - progress) * duration / (input > progress ? fadeIn : fadeOut), 0, 1);

        return output;
    }

    /**
     * Get the current time stamp of the animation
     *
     * @returns {Number|Date} Current time stamp of the animation. If the animation is based on a numeric expression this will output a number, if it is based on a date expression it will output a date
     *
     * @example <caption>Using the `getProgressValue` method to get the animation current value.</caption>
     * const s = carto.expressions;
     * let animationExpr = s.animation(s.linear(s.prop('saledate'), 1991, 2017), 20, s.fade(0.7, 0.4));
     * const animationStyle = {
     *   color: s.ramp(s.linear(s.prop('priceperunit'), 2000, 1010000), [s.rgb(0, 255, 0), s.rgb(255, 0, 0)]),
     *   width: s.mul(s.sqrt(s.prop('priceperunit')), 0.05),
     *   filter: animationExpr
     * };
     * layer.on('updated', () => {
     *   let currTime = Math.floor(animationExpr.getProgressValue());
     *   document.getElementById('timestamp').innerHTML = currTime;
     * });
     *
     * @memberof expressions.Animation
     * @name getProgressValue
     * @instance
     * @api
     */
    getProgressValue () {
        const progress = this.progress.value;
        return this._input.converse(progress);
    }

    /**
     * Set the time stamp of the animation
     * @api
     * @memberof expressions.Animation
     * @instance
     * @name setCurrent
     * @param {Date|number} value - A JavaScript Date object with the new animation time
     */
    setTimestamp (timestamp) {
        const date = Object(_utils_util__WEBPACK_IMPORTED_MODULE_2__["castDate"])(timestamp);
        const [tmin, tmax] = this._input.limits();

        if (date.getTime() < tmin) {
            throw new RangeError('animation.setTimestamp requires the date parameter to be higher than the lower limit');
        }
        if (date.getTime() > tmax) {
            throw new RangeError('animation.setTimestamp requires the date parameter to be lower than the higher limit');
        }

        this.progress.value = (date.getTime() - tmin) / (tmax - tmin);
    }

    /**
     * Get the animation progress.
     *
     * @returns {Number} A number representing the progress. 0 when the animation just started and 1 at the end of the cycle.
     * @api
     * @instance
     * @memberof expressions.Animation
     * @name getProgressPct
     */
    getProgressPct () {
        return this.progress.value;
    }

    /**
     * Set the animation progress from 0 to 1.
     * @param {number} progress - A number in the [0-1] range setting the animation progress.
     * @api
     * @instance
     * @memberof expressions.Animation
     * @name setProgressPct
     */
    setProgressPct (progress) {
        progress = Number.parseFloat(progress);

        if (progress < 0 || progress > 1) {
            throw new TypeError(`animation.setProgressPct requires a number between 0 and 1 as parameter but got: ${progress}`);
        }

        this.progress.value = progress;
    }

    /**
     * Returns whether the animation is playing or not
     *
     * @api
     * @memberof expressions.Animation
     * @instance
     * @name isPlaying
     */
    isPlaying () {
        return this._paused === false;
    }

    /**
     * Pause the animation
     *
     * @api
     * @memberof expressions.Animation
     * @instance
     * @name pause
     */
    pause () {
        this._paused = true;
    }

    /**
     * Play/resume the animation
     *
     * @api
     * @memberof expressions.Animation
     * @instance
     * @name play
     */
    play () {
        this._paused = false;
        this.notify();
    }

    /**
     * Stops the animation
     *
     * @api
     * @memberof expressions.Animation
     * @instance
     * @name stop
     */
    stop () {
        this.progress.value = 0;
        this._paused = true;
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/AnimationRange.js":
/*!********************************************************!*\
  !*** ./src/renderer/viz/expressions/AnimationRange.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimationRange; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _Fade__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Fade */ "./src/renderer/viz/expressions/Fade.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _AnimationGeneral__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AnimationGeneral */ "./src/renderer/viz/expressions/AnimationGeneral.js");





class AnimationRange extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    _init () {
        const input = this.input;
        const duration = this.duration;
        const fade = this.fade;

        const start = Object(_expressions__WEBPACK_IMPORTED_MODULE_2__["linear"])(input, Object(_expressions__WEBPACK_IMPORTED_MODULE_2__["globalMin"])(input), Object(_expressions__WEBPACK_IMPORTED_MODULE_2__["globalMax"])(input), 'start');

        const input2 = {};
        Object.keys(input).forEach(key => { input2[key] = input[key]; });

        Object.setPrototypeOf(input2, input);

        const end = Object(_expressions__WEBPACK_IMPORTED_MODULE_2__["linear"])(input2, Object(_expressions__WEBPACK_IMPORTED_MODULE_2__["globalMin"])(input2), Object(_expressions__WEBPACK_IMPORTED_MODULE_2__["globalMax"])(input2), 'end');
        const startAnim = new _AnimationGeneral__WEBPACK_IMPORTED_MODULE_3__["default"](start, duration, new _Fade__WEBPACK_IMPORTED_MODULE_1__["Fade"](fade.fadeIn, _expressions__WEBPACK_IMPORTED_MODULE_2__["HOLD"]));
        const endAnim = new _AnimationGeneral__WEBPACK_IMPORTED_MODULE_3__["default"](end, duration, new _Fade__WEBPACK_IMPORTED_MODULE_1__["Fade"](_expressions__WEBPACK_IMPORTED_MODULE_2__["HOLD"], fade.fadeOut));
        const combinedAnimation = Object(_expressions__WEBPACK_IMPORTED_MODULE_2__["mul"])(startAnim, endAnim);

        this.combinedAnimation = combinedAnimation;
        this.childrenNames.push('combinedAnimation');
        combinedAnimation.parent = this;

        this.type = 'number';

        this._startAnim = startAnim;
        this._endAnim = endAnim;

        this.expressionName = 'animation';
        this.inlineMaker = inline => inline.combinedAnimation;
    }
    _bindMetadata (metadata) {
        this.combinedAnimation._bindMetadata(metadata);
    }

    eval (feature) {
        return this.combinedAnimation.eval(feature);
    }

    isAnimated () {
        return true;
    }

    isPlaying () {
        return this._startAnim.isPlaying();
    }

    getProgressValue () {
        return this._startAnim.getProgressValue();
    }

    getProgressPct () {
        return this._startAnim.getProgressPct();
    }

    setProgressPct (progress) {
        this._startAnim.setProgressPct(progress);
        this._endAnim.setProgressPct(progress);
    }

    pause () {
        this._startAnim.pause();
        this._endAnim.pause();
    }

    play () {
        this._startAnim.play();
        this._endAnim.play();
        this._endAnim.setProgressPct(this._startAnim.getProgressPct());
    }

    stop () {
        this._startAnim.stop();
        this._endAnim.stop();
    }

    toString () {
        return `${this.expressionName}(${this._input.toString()}, ${this.duration.toString()}, ${this.fade.toString()})`;
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/BucketsGLSLHelper.js":
/*!***********************************************************!*\
  !*** ./src/renderer/viz/expressions/BucketsGLSLHelper.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BucketsGLSLHelper; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "./src/renderer/viz/expressions/constants.js");


/*
    Once the number of buckets exceed 27, 'memory exhausted' problems are common at glsl compile time.
    Here we set a little lower value to keep comparisons in just one if-else-if expression.
    Beyond that value, N independent if expressions will be created.
    That's a bit more inefficient but it consumes less memory, allowing for example a bigger
    number of different icons in a viz
*/
const SAFE_NUMBER_ELSE_IF_COMPARISONS = 20;

class BucketsGLSLHelper {
    constructor (buckets) {
        this.buckets = buckets;
    }

    applyToShaderSource (getGLSLforProperty) {
        // Get children sources
        const childSourcesArray = this.buckets.childrenNames.map(name => this.buckets[name]._applyToShaderSource(getGLSLforProperty));
        let childSources = {};
        childSourcesArray.map((source, index) => {
            childSources[this.buckets.childrenNames[index]] = source;
        });

        // Get coode for buckets comparisons
        const funcName = `buckets${this.buckets._uid}`;
        const elif = this._getComparisons(childSources);
        const funcBody = this.buckets.list.elems.map(elif).join('');

        const preface = `float ${funcName}(float x){
            ${funcBody}
            return ${this.buckets.input.type === 'category' ? _constants__WEBPACK_IMPORTED_MODULE_0__["OTHERS_GLSL_VALUE"] : (this.buckets.numCategories - 1).toFixed(20)};
        }`;

        return {
            preface: this.buckets._prefaceCode(childSources.input.preface + childSources.list.preface + preface),
            inline: `${funcName}(${childSources.input.inline})`
        };
    }

    /**
     * Get if-expressions to compare each value with the corresponding buckets
     */
    _getComparisons (childSources) {
        const cmp = this.buckets.input.type === 'category' ? '==' : '<';

        // When there is "OTHERS" we don't need to take it into account
        const divisor = this.buckets.numCategoriesWithoutOthers - 1 || 1;

        let elif;
        if (divisor <= SAFE_NUMBER_ELSE_IF_COMPARISONS) {
            // just one expression, with one 'if' & several 'else if'
            elif = (_, index) =>
                `${index > 0 ? 'else' : ''} if (x${cmp}(${childSources.list.inline[index]})){
                return ${index}./${divisor.toFixed(20)};
            }`;
        } else {
            // multiple, independent, 'if' expressions (order is assumed)
            elif = (_, index) =>
                `if (x${cmp}(${childSources.list.inline[index]})){
                return ${index}./${divisor.toFixed(20)};
            }`;
        }
        return elif;
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/CategoryIndex.js":
/*!*******************************************************!*\
  !*** ./src/renderer/viz/expressions/CategoryIndex.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CategoryIndex; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ "./src/renderer/viz/expressions/constants.js");




const SQRT_MAX_CATEGORIES_PER_PROPERTY = 256;

/**
* Transform a categorical property into a per-property category index. The evaluated result returns a value between 0 and 1.
* The dataset must contain less than 65536 (256 * 256) different categories.
*
* @param {Category} property - The property to be evaluated, must be categorical
* @return {Category}
*
* @example <caption> Color by $city using the CARTOColor Prism by assigning different color in Prism to each category.</caption>
* const s = carto.expressions;
* const viz = new carto.Viz({
*   color: s.ramp(s.categoryIndex(s.prop('city')), s.palettes.PRISM)
* });
*
* @example <caption> Color by $city using the CARTOColor Prism by assigning different color in Prism to each category. (String)</caption>
* const viz = new carto.Viz(`
*   color: ramp(categoryIndex($city), PRISM)
* `);
*
* @memberof carto.expressions
* @name categoryIndex
* @function
* @api
*/
class CategoryIndex extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (property) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'categoryIndex');

        property = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(property);

        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('categoryIndex', 'property', 0, property);
        super({ property });
        this._numTranslatedCategories = null;
        this.type = 'category';

        this._translatePixels = new Float32Array(SQRT_MAX_CATEGORIES_PER_PROPERTY * SQRT_MAX_CATEGORIES_PER_PROPERTY);
        this._translateArray = [];
        this._numTranslatedCategories = 0;
        this._numTranslatedCategoriesGL = 0;
    }

    get numCategories () {
        return this.metaColumn.categories.length;
    }

    get metaColumn () {
        const propertyName = this.property.propertyName;
        return this._metadata.properties[propertyName]
            ? this._metadata.properties[propertyName]
            : this._metadata.properties[this.property.name];
    }

    get numCategoriesWithoutOthers () {
        return this.numCategories;
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('categoryIndex', 'property', 0, 'category', this.property);
        this._metadata = metadata;
        this._calcTranslated();
    }

    get value () {
        return this.eval();
    }

    eval (feature) {
        const name = this.property.eval(feature);
        const id = this._metadata.categoryToID.get(name);

        return this._translateArray[id];
    }

    _preDraw (program, drawMetadata, gl) {
        gl.activeTexture(gl.TEXTURE0 + drawMetadata.freeTexUnit);

        if (this._numTranslatedCategoriesGL !== this.numCategories) {
            this._numTranslatedCategoriesGL = this.numCategories;
            this._calcTranslated();
            this._translateTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this._translateTexture);
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, SQRT_MAX_CATEGORIES_PER_PROPERTY, SQRT_MAX_CATEGORIES_PER_PROPERTY, 0, gl.ALPHA, gl.FLOAT, this._translatePixels);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        } else {
            gl.bindTexture(gl.TEXTURE_2D, this._translateTexture);
        }

        gl.uniform1i(this._getBinding(program).texRampTranslateLoc, drawMetadata.freeTexUnit);
        drawMetadata.freeTexUnit++;
    }

    _applyToShaderSource (getGLSLforProperty) {
        const max = SQRT_MAX_CATEGORIES_PER_PROPERTY.toFixed(20);
        const property = this.property._applyToShaderSource(getGLSLforProperty);
        return {
            inline: `ramp_translate${this._uid}(${property.inline})`,
            preface: `
                    uniform sampler2D texRampTranslate${this._uid};
                    float ramp_translate${this._uid}(float s){
                        vec2 v = vec2(mod(s, ${max}), floor(s / ${max}));
                        return texture2D(texRampTranslate${this._uid}, v/${max}).a;
                    }`
        };
    }

    _postShaderCompile (program, gl) {
        this._getBinding(program).texRampTranslateLoc = gl.getUniformLocation(program, `texRampTranslate${this._uid}`);
    }

    _calcTranslated () {
        const numCategories = this.numCategories;

        if (this._numTranslatedCategories !== numCategories) {
            this._numTranslatedCategories = numCategories;

            for (let i = 0; i < numCategories; i++) {
                const id = this._metadata.categoryToID.get(this.metaColumn.categories[i].name);
                const value = i / (numCategories - 1);
                const vec2Id = {
                    x: id % SQRT_MAX_CATEGORIES_PER_PROPERTY,
                    y: Math.floor(id / SQRT_MAX_CATEGORIES_PER_PROPERTY)
                };

                this._translatePixels[SQRT_MAX_CATEGORIES_PER_PROPERTY * vec2Id.y + vec2Id.x] = value;
                this._translateArray.push(value);
            }
        }
    }

    getLegendData (options) {
        const categories = this._metadata.properties[this.property.propertyName].categories;
        const categoriesLength = categories.length;
        const divisor = categoriesLength - 1;
        let data = [];

        for (let i = 0; i < categoriesLength; i++) {
            const category = categories[i];
            const key = category.name;
            const value = i / divisor;

            data.push({ key, value });
        }

        if (options.order && options.order === _constants__WEBPACK_IMPORTED_MODULE_2__["SORT_DESC"]) {
            data = data.sort((a, b) => b.key - a.key);
        }

        return { data };
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/Fade.js":
/*!**********************************************!*\
  !*** ./src/renderer/viz/expressions/Fade.js ***!
  \**********************************************/
/*! exports provided: Fade */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fade", function() { return Fade; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");



/**
 * Create a FadeIn/FadeOut configuration. See `animation` for more details.
 *
 * @param {Number} param1 - Expression of type number or Number
 * @param {Number} param2 - Expression of type number or Number
 * @return {Fade}
 *
 * @example <caption>Fade in of 0.1 seconds, fade out of 0.3 seconds.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   filter: s.animation(s.prop('day'), 40, s.fade(0.1, 0.3))
 * });
 *
 * @example <caption>Fade in of 0.1 seconds, fade out of 0.3 seconds. (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: animation($day, 40, fade(0.1, 0.3))
 * `);
 *
 * @example<caption>Fade in and fade out of 0.5 seconds.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   filter: s.animation(s.prop('day'), 40, s.fade(0.5))
 * });
 *
 * @example<caption>Fade in and fade out of 0.5 seconds. (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: animation($day, 40, fade(0.5))
 * `);
 *
 * @example<caption>Fade in of 0.3 seconds without fading out.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   filter: s.animation(s.prop('day'), 40, s.fade(0.1, s.HOLD))
 * });
 *
 * @example<caption>Fade in of 0.3 seconds without fading out. (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: animation($day, 40, fade(0.3, HOLD))
 * `);
 *
 * @memberof carto.expressions
 * @name fade
 * @function
 * @api
*/

const DEFAULT_FADE = 0.15;
const DEFAULT_PARAM = undefined;

class Fade extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (param1 = DEFAULT_PARAM, param2 = DEFAULT_PARAM) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 2, 'fade');

        let fadeIn = param1 === DEFAULT_PARAM
            ? Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(DEFAULT_FADE)
            : Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(param1);

        let fadeOut = param2 === DEFAULT_PARAM
            ? fadeIn
            : Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(param2);

        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('fade', 'param1', 0, fadeIn);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('fade', 'param2', 1, fadeOut);

        super({ fadeIn, fadeOut });

        this.type = 'fade';

        this.inlineMaker = (inline) => ({
            in: inline.fadeIn,
            out: inline.fadeOut
        });
    }

    get value () {
        return {
            fadeIn: this.fadeIn.value,
            fadeOut: this.fadeOut.value
        };
    }

    eval (feature) {
        return {
            fadeIn: this.fadeIn.eval(feature),
            fadeOut: this.fadeOut.eval(feature)
        };
    }

    _bindMetadata (meta) {
        super._bindMetadata(meta);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('fade', 'param1', 0, 'number', this.fadeIn);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('fade', 'param2', 1, 'number', this.fadeOut);
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/Image.js":
/*!***********************************************!*\
  !*** ./src/renderer/viz/expressions/Image.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Image; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");



/**
 * Image. Load an image and use it as a symbol.
 *
 * Note: image RGB color will be overridden if the viz `color` property is set.
 *
 * @param {String} url - Image path
 *
 * @example <caption>Load a svg image.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   symbol: s.image('./marker.svg')
 * });
 *
 * @example <caption>Load a svg image. (String)</caption>
 * const viz = new carto.Viz(`
 *    symbol: image('./marker.svg')
 * `);
 * @memberof carto.expressions
 * @name image
 * @function
 * @api
*/

class Image extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (url) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'image');
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkString"])('image', 'url', 0, url);
        super({});
        this.type = 'image';
        this.canvas = null;
        this.url = url;
        this._promise = new Promise((resolve, reject) => {
            this.image = new window.Image();
            this.image.onload = () => {
                this.canvas = _getCanvasFromImage(this.image);
                this.image = null;
                resolve();
            };
            this.image.onerror = reject;
            this.image.crossOrigin = 'anonymous';
            this.image.src = this.url;
        });
    }

    loadImages () {
        this.count = this.count + 1 || 1;
        return this._promise;
    }

    keepDefaultsOnBlend () {
        // Keep default image color if setting a symbol after viz initialization with defaults
        if (this.default && this.parent.color.default) {
            this.parent.color = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["noOverrideColor"])();
        }
    }

    get value () {
        return this.url;
    }

    eval () {
        return this.value;
    }

    getLegendData (options) {
        return {
            name: 'image',
            data: [{
                key: 'url',
                value: this.url
            }]
        };
    }

    _free (gl) {
        if (this.texture) {
            gl.deleteTexture(this.texture);
        }
    }

    _applyToShaderSource () {
        return {
            preface: this._prefaceCode(`uniform sampler2D texSprite${this._uid};`),
            inline: `texture2D(texSprite${this._uid}, imageUV).rgba`
        };
    }

    _postShaderCompile (program, gl) {
        this._getBinding(program)._texLoc = gl.getUniformLocation(program, `texSprite${this._uid}`);
    }

    _preDraw (program, drawMetadata, gl) {
        if (!this.init && this.canvas) {
            this.init = true;
            gl.activeTexture(gl.TEXTURE0 + drawMetadata.freeTexUnit);
            this.texture = gl.createTexture();
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.canvas);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            gl.generateMipmap(gl.TEXTURE_2D);
            this.canvas = null;
        }

        if (this.texture) {
            gl.activeTexture(gl.TEXTURE0 + drawMetadata.freeTexUnit);
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.uniform1i(this._getBinding(program)._texLoc, drawMetadata.freeTexUnit);
            drawMetadata.freeTexUnit++;
        }
    }
}

function _getCanvasFromImage (img) {
    const CANVAS_SIZE = 256;
    const canvas = document.createElement('canvas');
    canvas.width = CANVAS_SIZE;
    canvas.height = CANVAS_SIZE;

    const ctx = canvas.getContext('2d');

    const max = Math.max(img.width, img.height);
    const width = img.width / max * CANVAS_SIZE;
    const height = img.height / max * CANVAS_SIZE;

    ctx.drawImage(img, (CANVAS_SIZE - width) / 2, (CANVAS_SIZE - height) / 2, width, height);

    return canvas;
}


/***/ }),

/***/ "./src/renderer/viz/expressions/ListImage.js":
/*!***************************************************!*\
  !*** ./src/renderer/viz/expressions/ListImage.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ListImage; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");



/**
 * ImageList. Load an array of images and use them as a symbols.
 *
 * Note: images RGB color will be overridden if the viz `color` property is set.
 *
 * @internal
 */
class ListImage extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    _bindMetadata (meta) {
        super._bindMetadata(meta);
        this.numImages = this.elems.length;
        this._getChildren().forEach((image, i) => Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('imageArray', `imageArray[${i}]`, 0, 'image', image));
    }

    eval (feature) {
        return this.elems.map(elem => elem.eval(feature));
    }

    _applyToShaderSource () {
        return {
            preface: this._prefaceCode(`
                uniform sampler2D atlas${this._uid};

                vec4 atlas${this._uid}Fn(vec2 imageUV, float category) {
                    return texture2D(atlas${this._uid}, imageUV/16. + vec2(mod(category, 16.), floor(category/16.))/16. ).rgba;
                }
            `),
            inline: `atlas${this._uid}Fn`
        };
    }

    _postShaderCompile (program, gl) {
        this._getBinding(program).texLoc = gl.getUniformLocation(program, `atlas${this._uid}`);
    }

    _preDraw (program, drawMetadata, gl) {
        this.init = true;
        for (let i = 0; i < this.numImages; i++) {
            const image = this[`image-${i}`];
            this.init = this.init && image.canvas;
        }

        if (this.init && !this.texture) {
            const textureAtlasSize = 4096;
            const imageSize = 256;

            gl.activeTexture(gl.TEXTURE0 + drawMetadata.freeTexUnit);
            this.texture = gl.createTexture();
            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureAtlasSize, textureAtlasSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            let offsetX = 0;
            let offsetY = 0;
            for (let i = 0; i < this.numImages; i++) {
                const image = this[`image-${i}`];
                // get image, push image to texture atlas
                gl.texSubImage2D(gl.TEXTURE_2D, 0, offsetX, offsetY, gl.RGBA, gl.UNSIGNED_BYTE, image.canvas);
                offsetX += imageSize;

                if (offsetX + imageSize > textureAtlasSize) {
                    offsetX = 0;
                    offsetY += imageSize;
                }
            }

            gl.generateMipmap(gl.TEXTURE_2D);
        }

        if (this.texture) {
            gl.activeTexture(gl.TEXTURE0 + drawMetadata.freeTexUnit);
            gl.bindTexture(gl.TEXTURE_2D, this.texture);
            gl.uniform1i(this._getBinding(program).texLoc, drawMetadata.freeTexUnit);
            drawMetadata.freeTexUnit++;
        }
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/ListTransform.js":
/*!*******************************************************!*\
  !*** ./src/renderer/viz/expressions/ListTransform.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ListTransform; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");



class ListTransform extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    _bindMetadata (meta) {
        super._bindMetadata(meta);
        this._getChildren().forEach((transform, i) => Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('ListTransformation', `ListTransformation[${i}]`, 0, 'transformation', transform));
        this.type = 'transformation';
    }

    eval (feature) {
        return this.elems.map(elem => elem.eval(feature));
    }

    _applyToShaderSource (getGLSLforProperty) {
        const childGLSL = this.elems.map(elem => elem._applyToShaderSource(getGLSLforProperty));
        return {
            preface: this._prefaceCode(`
                ${childGLSL.map(c => c.preface).join('\n')}

                vec2 listTransform${this._uid}(vec2 p) {
                    ${childGLSL.map(c => `p = ${c.inline}(p);`).join('\n')}
                    return p;
                }
            `),
            inline: `listTransform${this._uid}`
        };
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/Placement.js":
/*!***************************************************!*\
  !*** ./src/renderer/viz/expressions/Placement.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Placement; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");



/**
 * Placement. Define an image offset relative to its size. Where:
 * - `symbolPlacement: placement(1,1)` means to align the bottom left corner of the image with the point center.
 * - `symbolPlacement: placement(0,0)` means to align the center of the image with the point center.
 * - `symbolPlacement: placement(-1,-1)` means to align the top right corner of the image with the point center.
 *
 * ```
 *           |1
 *           |
 *           |
 * -1 -------+------- 1
 *           |
 *           |
 *         -1|
 * ```
 *
 * You can also use `align_center` and `align_bottom` to set the simbol placement as follows:
 * - `symbolPlacement: align_bottom` is equivalent to `symbolPlacement: placement(0, 1)`
 * - `symbolPlacement: align_center` is equivalent to `symbolPlacement: placement(0, 0)`
 *
 * @param {number} x - first numeric expression that indicates the image offset in the X direction.
 * @param {number} y - second numeric expression that indicates the image offset in the Y direction.
 * @return {Placement} Numeric expression
 *
 * @example <caption>Setting the aligment to the top corner of the image.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   symbol: s.image('./marker.svg').
 *   symbolPlacement: s.placement(1, 0)
 * });
 *
 * @example <caption>Setting the aligment to the top corner of the image. (String)</caption>
 * const viz = new carto.Viz(`
 *   symbol: image('./marker.svg')
 *   symbolPlacement: placement(1, 0)
 * `);
 *
 * @memberof carto.expressions
 * @name placement
 * @function
 * @api
 */

class Placement extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (x, y) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 2, 'placement');

        x = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(x);
        y = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(y);
        super({ x, y });
        this.inlineMaker = inline => `vec2(${inline.x}, ${inline.y})`;
        this.type = 'placement';
    }

    get value () {
        return [this.x.value, this.y.value];
    }

    eval (feature) {
        return [this.x.eval(feature), this.y.eval(feature)];
    }

    _bindMetadata (meta) {
        super._bindMetadata(meta);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('placement', 'x', 0, 'number', this.x);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('placement', 'y', 1, 'number', this.y);
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/Ramp.js":
/*!**********************************************!*\
  !*** ./src/renderer/viz/expressions/Ramp.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Ramp; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _RampImage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RampImage */ "./src/renderer/viz/expressions/RampImage.js");
/* harmony import */ var _RampGeneric__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./RampGeneric */ "./src/renderer/viz/expressions/RampGeneric.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants */ "./src/renderer/viz/expressions/constants.js");







/**
* Create a ramp: a mapping between an input (numeric or categorical) and an output (number, colors and/or images)
*
* When the input has the same number of categories (without taking the "others" category into account).
* Then, each input category will have a one to one match with an output value.
*
* Some case examples:
* `ramp(buckets($product, ['A, 'B', 'C']), [house, car, bus])`
* `ramp(buckets($price, [20, 50, 120]), [1, 10, 4, 12])`
* `ramp(top($product, 3), [blue, yellow, green])`
* `ramp(globalQuantiles($price, 3), [red, yellow, green])`
*
* When the input has different number of categories or the input is a linear expression.
* Then it will interpolate the output values (Note: this is not supported if output values are images)
*
* Some case examples:
* `ramp(linear($price, 1, 10) [green, yellow, red])`
* `ramp(buckets($product, ['A, 'B', 'C'], [red, blue]))
* - When the input is a categorical property, we wrap it automatically in a CategoryIndex expression
* `ramp($product, Prism)` (equivalent to `ramp($categoryIndex($product)), Prism)`
* - When the input is a numeric property, we wrap it automatically in a Linear expression.
* `ramp($price, Prism)` (equivalent to `ramp($linear($price)), Prism)`
*
* The "others" value is setted by default, depending on the output type:
* - If it is "Number", the "others" value is 1.
* - If it is "Color" from a color array (i.e: [red, yellow, green]), the "others" value is the gray color.
* - If it is "Color" from a cartocolor palette (i.e: Prism), the "others" value is the last color of the palette.
* - If it is "Image", the "others" value is a circle.
*
* If we add a third parameter, the "others" default value will be overridden by this one
*
* @param {Number|Category} input - The input expression to give a color
* @param {Palette|Color[]|Number[]} palette - The color palette that is going to be used
* @param {Number|Color|Image} [others] - Value that overrides the default value for "others"
* @return {Number|Color|Image}
*
* @example <caption>Mapping categories to numbers, colors and images.</caption>
* const s = carto.expressions;
* const viz = new carto.Viz({
*   width: s.ramp(s.buckets(s.prop('product'), ['A, 'B', 'C']), [1, 2, 3])
*   color: s.ramp(s.buckets(s.prop('product'), ['A, 'B', 'C']), s.palettes.PRISM)
*   strokeColor: s.ramp(s.buckets(s.prop('product'), ['A, 'B', 'C']), [s.namedColor('red'), s.namedColor('yellow'), s.namedColor('green')])
*   symbol: s.ramp(s.buckets(s.prop('product'), ['A, 'B', 'C']), [s.HOUSE, s.CAR, s.BUS])
* });
*
* @example <caption>Mapping categories to numbers, colors and images. (String)</caption>
* const viz = new carto.Viz(`
*   width: ramp(buckets($product), ['A, 'B', 'C']), [1, 2, 3])
*   color: ramp(buckets($product), ['A, 'B', 'C']), Prism)
*   strokeColor: ramp(buckets($product), ['A, 'B', 'C']), [red, yellow, green])
*   symbol: ramp(buckets($product), ['A, 'B', 'C']), [house, car, bus])
* `);
*
* @example <caption>Mapping classified numeric properties to numbers, colors and images.</caption>
* const s = carto.expressions;
* const viz = new carto.Viz({
*   width: s.ramp(s.buckets(s.prop('price'), [40, 100]), [1, 2, 3])
*   color: s.ramp(s.buckets(s.prop('price'), [40, 100]), s.palettes.PRISM)
*   strokeColor: s.ramp(s.buckets(s.prop('price'), [40, 100]), [s.namedColor('red'), s.namedColor('yellow'), s.namedColor(green)])
*   symbol: s.ramp(s.buckets(s.prop('price'), [40, 100]), [s.HOUSE), s.CAR, s.BUS])
* });
*
* @example <caption>Mapping classified numeric properties to numbers, colors and images. (String)</caption>
* const viz = new carto.Viz(`
*   width: ramp(buckets($price, [40, 100]), [1, 2, 3])
*   color: ramp(buckets($price, [40, 100]), Prism)
*   strokeColor: ramp(buckets($price, [40, 100]), [red, yellow, green])
*   symbol: ramp(buckets($price, [40, 100]), [house, car, bus])
* `);
*
* @example <caption>Override default values.</caption>
* const s = carto.expressions;
* const viz = new carto.Viz({
*   width: s.ramp(s.top(s.prop('price'), 3), [1, 2, 3], 0)
*   strokeColor: s.ramp(s.top(s.prop('price'), 3), Prism, s.namedColor('red'))
*   color: s.ramp(s.top(s.prop('price'), 3), [s.namedColor('blue'), s.namedColor('red'), s.namedColor('yellow')], s.namedColor(black))
*   symbol: s.ramp(s.top(s.prop('price'), 3), [s.HOUSE, s.CAR, s.BUS], s.CROSS)
* });
*
* @example <caption>Override default values. (String)</caption>
* const viz = new carto.Viz(`
*   width: ramp(top($price, 3), [1, 2, 3], 0)
*   strokeColor: ramp(top($price, 3), Prism, red)
*   color: ramp(top($price, 3), [blue, red, yellow], black)
*   symbol: ramp(top($price, 3), [house, car, bus], cross)
* `);
*
* @memberof carto.expressions
* @name ramp
* @function
* @api
*/

/**
 * Ramp Class
 *
 * A mapping between an input (numeric or categorical) and an output (number, colors and/or images)
 * This class is instanced automatically by using the `ramp` function. It is documented for its methods.
 * Read more about ramp expression at {@link carto.expressions.ramp}.
 *
 * @name expressions.Ramp
 * @abstract
 * @hideconstructor
 * @class
 * @api
 */
class Ramp extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (input, palette, others = _constants__WEBPACK_IMPORTED_MODULE_4__["DEFAULT_RAMP_OTHERS"]) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 3, 'ramp');

        input = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(input);
        palette = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(palette);

        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('ramp', 'input', 0, input);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('ramp', 'palette', 1, palette);

        if (others !== _constants__WEBPACK_IMPORTED_MODULE_4__["DEFAULT_RAMP_OTHERS"]) {
            others = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(others);
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('ramp', 'others', 2, others);
        }

        super({ input, palette });
        this.palette = palette;
        this.others = others;
        this.type = palette.type;
        this._defaultOthers = others === _constants__WEBPACK_IMPORTED_MODULE_4__["DEFAULT_RAMP_OTHERS"];
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);
        switch (this.palette.type) {
            case 'image-list':
                Object.setPrototypeOf(this, _RampImage__WEBPACK_IMPORTED_MODULE_2__["default"].prototype);
                break;
            default:
                Object.setPrototypeOf(this, _RampGeneric__WEBPACK_IMPORTED_MODULE_3__["default"].prototype);
                break;
        }

        return this._bindMetadata(metadata);
    }

    /**
     * Get a legend for the ramp.
     *
     * Note: This method works only for feature property independent outputs.
     * Example:
     * - This works: `ramp($price, [5, 15])`
     * - This does not work: `ramp($price, [5, $amount])`
     *
     * @param {Object} config - Optional configuration
     * @param {String} config.othersLabel - Name for other category values. Defaults to 'CARTO_VL_OTHERS'.
     * @param {String} config.order - Set order to 'DESC' or 'ASC' to sort legend values.
     * @param {Number} config.samples - Number of samples for numeric values to be returned. Defaults to 10. The maximum number of samples is 100.
     * @return {Object} - `{ type, data }`. 'type' could be category or number. Data is an array of { key, value } objects. 'key' depends on the expression type. 'value' is the result evaluated by the ramp. There is more information in the examples.
     * @api
     * @example <caption>Get legend for a color ramp of a categorical property.</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz({
     *   color: s.ramp(s.prop('vehicles'), s.palettes.PRISM)
     * });
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegendData();
     *   // legend = {
     *   //    type: 'category',
     *   //    name: '$vehicles',
     *   //    data: [
     *   //       { key: 'Bicycle', value: { r: 95, g: 70, b: 144, a: 1 } },
     *   //       { key: 'Car', value: { r: 29, g: 105, b: 150, a: 1 } },
     *   //       { key: 'Bus', value: { r: 56, g: 166, b: 165, a: 1 } },
     *   //       { key: 'CARTO_VL_OTHERS', value: { r: 15, g: 133, b: 84, a: 1 } }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get legend for a color ramp of a categorical property. (String)</caption>
     * const viz = new carto.Viz(`
     *   color: ramp($vehicles, PRISM)
     * );
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegendData();
     *   // legend = {
     *   //    type: 'category',
     *   //    name: '$vehicles',
     *   //    data: [
     *   //       { key: 'Bicycle', value: { r: 95, g: 70, b: 144, a: 1 } },
     *   //       { key: 'Car', value: { r: 29, g: 105, b: 150, a: 1 } },
     *   //       { key: 'Bus', value: { r: 56, g: 166, b: 165, a: 1 } },
     *   //       { key: 'CARTO_VL_OTHERS', value: { r: 15, g: 133, b: 84, a: 1 } }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get legend for an image ramp of a categorical property.</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz({
     *   symbol: s.ramp(s.prop('vehicles'), [s.BICYCLE, s.CAR, s.BUS])
     * });
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.symbol.getLegendData();
     *   // legend = {
     *   //    type: 'category',
     *   //    name: '$vehicles',
     *   //    data: [
     *   //       { key: 'Bicycle', value: bicycleImageUrl },
     *   //       { key: 'Car', value: carImageUrl },
     *   //       { key: 'Bus', value: busImageUrl },
     *   //       { key: 'CARTO_VL_OTHERS', value: circleImageUrl }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get legend for an image ramp of a categorical property. (String)</caption>
     * const viz = new carto.Viz(`
     *   symbol: ramp('$vehicles'), [BICYCLE, CAR, BUS])
     * `);
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.symbol.getLegendData();
     *   // legend = {
     *   //    type: 'category',
     *   //    name: '$vehicles',
     *   //    data: [
     *   //       { key: 'Bicycle', value: bicycleImageUrl },
     *   //       { key: 'Car', value: carImageUrl },
     *   //       { key: 'Bus', value: busImageUrl },
     *   //       { key: 'CARTO_VL_OTHERS', value: circleImageUrl }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get legend of a ramp top expression and set "others" label.</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz({
     *   color: s.ramp(s.top(s.prop('vehicles')), s.palettes.PRISM)
     * });
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegendData({
     *      othersLabel: 'Other Vehicles'
     *   });
     *
     *   // legend = {
     *   //    type: 'category',
     *   //    name: 'top($vehicles)',
     *   //    data: [
     *   //       { key: 'Bicycle', value: { r: 95, g: 70, b: 144, a: 1 } },
     *   //       { key: 'Car', value: { r: 29, g: 105, b: 150, a: 1 } },
     *   //       { key: 'Bus', value: { r: 56, g: 166, b: 165, a: 1 } },
     *   //       { key: 'Other Vehicles', value: { r: 15, g: 133, b: 84, a: 1 } }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get legend of a ramp top expression and set "others" label. (String)</caption>
     * const viz = new carto.Viz(`
     *   color: ramp(top($vehicles, 5), PRISM)
     * `);
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegendData({
     *      othersLabel: 'Other Vehicles'
     *   });
     *
     *   // legend = {
     *   //    type: 'category',
     *   //    name: 'top($vehicles)',
     *   //    data: [
     *   //       { key: 'Bicycle', value: { r: 95, g: 70, b: 144, a: 1 } },
     *   //       { key: 'Car', value: { r: 29, g: 105, b: 150, a: 1 } },
     *   //       { key: 'Bus', value: { r: 56, g: 166, b: 165, a: 1 } },
     *   //       { key: 'Other Vehicles', value: { r: 15, g: 133, b: 84, a: 1 } }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get category legend in descending order</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz({
     *   color: s.ramp(s.top(s.prop('vehicles')), s.palettes.PRISM)
     * });
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegendData({
     *      othersLabel: 'Other Vehicles',
     *      order: 'DESC'
     *   });
     *
     *   // legend = {
     *   //    type: 'category',
     *   //    name: 'top($vehicles)',
     *   //    data: [
     *   //       { key: 'Car', value: { r: 29, g: 105, b: 150, a: 1 } },
     *   //       { key: 'Bicycle', value: { r: 95, g: 70, b: 144, a: 1 } },
     *   //       { key: 'Bus', value: { r: 56, g: 166, b: 165, a: 1 } },
     *   //       { key: 'Other Vehicles', value: { r: 15, g: 133, b: 84, a: 1 } }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get category legend in descending order (String)</caption>
     * const viz = new carto.Viz(`
     *   color: ramp(top($vehicles, 5), PRISM)
     * `);
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegendData({
     *      othersLabel: 'Other Vehicles'
     *      order: 'DESC'
     *   });
     *
     *   // legend = {
     *   //    type: 'category',
     *   //    name: 'top($vehicles)',
     *   //    data: [
     *   //       { key: 'Car', value: { r: 29, g: 105, b: 150, a: 1 } },
     *   //       { key: 'Bicycle', value: { r: 95, g: 70, b: 144, a: 1 } },
     *   //       { key: 'Bus', value: { r: 56, g: 166, b: 165, a: 1 } },
     *   //       { key: 'Other Vehicles', value: { r: 15, g: 133, b: 84, a: 1 } }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get legend for a linear ramp expression and set number of samples.</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz({
     *   color: s.ramp(s.linear(s.prop('numvehicles'), 1, 100), s.palettes.PRISM)
     * });
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegendData({
     *       samples: 4
     *   });
     *
     *   // legend = {
     *   //    type: 'number',
     *   //    name: 'linear($numvehicles, 1, 100)',
     *   //    data: [
     *   //       { key: 25, value: { r: 95, g: 70, b: 144, a: 1 } },
     *   //       { key: 50, value: { r: 29, g: 105, b: 150, a: 1 } },
     *   //       { key: 75, value: { r: 56, g: 166, b: 165, a: 1 } },
     *   //       { key: 100, value: { r: 15, g: 133, b: 84, a: 1 } }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get legend for a linear ramp expression and set number of samples. (String)</caption>
     * const viz = new carto.Viz(`
     *   color: ramp(linear($numvehicles, 1, 100), PRISM)
     * `);
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegendData({
     *       samples: 4
     *   });
     *
     *   // legend = {
     *   //    type: 'number',
     *   //    name: 'linear($numvehicles, 1, 100)',
     *   //    data: [
     *   //       { key: 25, value: { r: 95, g: 70, b: 144, a: 1 } },
     *   //       { key: 50, value: { r: 29, g: 105, b: 150, a: 1 } },
     *   //       { key: 75, value: { r: 56, g: 166, b: 165, a: 1 } },
     *   //       { key: 100, value: { r: 15, g: 133, b: 84, a: 1 } }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get numeric legend in descending order.</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz({
     *   color: s.ramp(s.linear(s.prop('numvehicles'), 1, 100), s.palettes.PRISM)
     * });
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegendData({
     *       samples: 4,
     *       order: 'DESC'
     *   });
     *
     *   // legend = {
     *   //    type: 'number',
     *   //    name: 'linear($numvehicles, 1, 100)',
     *   //    data: [
     *   //       { key: 100, value: { r: 15, g: 133, b: 84, a: 1 } }
     *   //       { key: 75, value: { r: 56, g: 166, b: 165, a: 1 } },
     *   //       { key: 50, value: { r: 29, g: 105, b: 150, a: 1 } },
     *   //       { key: 25, value: { r: 95, g: 70, b: 144, a: 1 } }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get numeric legend in descending order. (String)</caption>
     * const viz = new carto.Viz(`
     *   color: ramp(linear($numvehicles, 1, 100), PRISM)
     * `);
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegendData({
     *       samples: 4,
     *       order: 'DESC'
     *   });
     *
     *   // legend = {
     *   //    type: 'number',
     *   //    name: 'linear($numvehicles, 1, 100)',
     *   //    data: [
     *   //       { key: 100, value: { r: 15, g: 133, b: 84, a: 1 } }
     *   //       { key: 75, value: { r: 56, g: 166, b: 165, a: 1 } },
     *   //       { key: 50, value: { r: 29, g: 105, b: 150, a: 1 } },
     *   //       { key: 25, value: { r: 95, g: 70, b: 144, a: 1 } }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get legend for a buckets ramp expression.</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz({
     *   color: s.ramp(s.buckets((s.prop('numvehicles'), [1, 2, 3]), s.palettes.PRISM))
     * });
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegendData();
     *
     *   // legend = {
     *   //    type: 'number',
     *   //    name: 'buckets($numvehicles, [1, 2, 3])',
     *   //    data: [
     *   //       { key: [-Infinity, 1], value: { r: 95, g: 70, b: 144, a: 1 } },
     *   //       { key: [1, 2], value: { r: 29, g: 105, b: 150, a: 1 } },
     *   //       { key: [2, 3], value: { r: 56, g: 166, b: 165, a: 1 } },
     *   //       { key: [3, +Infinity], value: { r: 15, g: 133, b: 84, a: 1 } }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get legend for a buckets ramp expression. (String)</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz(`
     *   color: ramp(buckets($numvehicles', [1, 2, 3]), Prism))
     * `);
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegendData();
     *
     *   // legend = {
     *   //    type: 'number',
     *   //    name: 'buckets($numvehicles, [1, 2, 3])',
     *   //    data: [
     *   //       { key: [-Infinity, 1], value: { r: 95, g: 70, b: 144, a: 1 } },
     *   //       { key: [1, 2], value: { r: 29, g: 105, b: 150, a: 1 } },
     *   //       { key: [2, 3], value: { r: 56, g: 166, b: 165, a: 1 } },
     *   //       { key: [3, +Infinity], value: { r: 15, g: 133, b: 84, a: 1 } }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get legend for a classifier ramp expression.</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz({
     *   color: s.ramp(s.globalEqIntervals(s.prop('numvehicles'), 4), s.palettes.PRISM)
     * });
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegendData();
     *
     *   // legend = {
     *   //    type: 'number',
     *   //    name: 'globalEqIntervals($numvehicles, 4)',
     *   //    data: [
     *   //       { key: [-Infinity, 25], value: { r: 95, g: 70, b: 144, a: 1 } },
     *   //       { key: [25, 50], value: { r: 29, g: 105, b: 150, a: 1 } },
     *   //       { key: [50, 75], value: { r: 56, g: 166, b: 165, a: 1 } },
     *   //       { key: [100, +Infinity], value: { r: 15, g: 133, b: 84, a: 1 } }
     *   //     ]
     *   // }
     * });
     *
     * @example <caption>Get legend for a classifier ramp expression. (String)</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz(`
     *   color: ramp(globalEqIntervals($numvehicles, 4), Prism)
     * `);
     *
     * layer.on('loaded', () => {
     *   const legend = layer.viz.color.getLegendData();
     *
     *   // legend = {
     *   //    type: 'number',
     *   //    name: 'globalEqIntervals($numvehicles, 4)',
     *   //    data: [
     *   //       { key: [-Infinity, 25], value: { r: 95, g: 70, b: 144, a: 1 } },
     *   //       { key: [25, 50], value: { r: 29, g: 105, b: 150, a: 1 } },
     *   //       { key: [50, 75], value: { r: 56, g: 166, b: 165, a: 1 } },
     *   //       { key: [100, +Infinity], value: { r: 15, g: 133, b: 84, a: 1 } }
     *   //     ]
     *   // }
     * });
     *
     * @memberof expressions.Ramp
     * @name getLegendData
     * @instance
     * @api
     */
}


/***/ }),

/***/ "./src/renderer/viz/expressions/RampGeneric.js":
/*!*****************************************************!*\
  !*** ./src/renderer/viz/expressions/RampGeneric.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RampGeneric; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _basic_property__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basic/property */ "./src/renderer/viz/expressions/basic/property.js");
/* harmony import */ var _linear__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./linear */ "./src/renderer/viz/expressions/linear.js");
/* harmony import */ var _color_CIELab_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./color/CIELab.glsl */ "./src/renderer/viz/expressions/color/CIELab.glsl");
/* harmony import */ var _color_CIELab_glsl__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_color_CIELab_glsl__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _CategoryIndex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CategoryIndex */ "./src/renderer/viz/expressions/CategoryIndex.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants */ "./src/renderer/viz/expressions/constants.js");
/* harmony import */ var _color_palettes_Palette__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./color/palettes/Palette */ "./src/renderer/viz/expressions/color/palettes/Palette.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _basic_constant__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./basic/constant */ "./src/renderer/viz/expressions/basic/constant.js");
/* harmony import */ var _color_NamedColor__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./color/NamedColor */ "./src/renderer/viz/expressions/color/NamedColor.js");
/* harmony import */ var _aggregation_cluster_ClusterAggregation__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./aggregation/cluster/ClusterAggregation */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterAggregation.js");













class RampGeneric extends _base__WEBPACK_IMPORTED_MODULE_7__["default"] {
    _bindMetadata (metadata) {
        const DEFAULT_RAMP_OTHERS_NUMBER = new _basic_constant__WEBPACK_IMPORTED_MODULE_8__["default"](1);
        const DEFAULT_RAMP_OTHERS_COLOR = new _color_NamedColor__WEBPACK_IMPORTED_MODULE_9__["default"]('gray');

        super._bindMetadata(metadata);

        this.type = this.palette.childType;
        if (this.others === _constants__WEBPACK_IMPORTED_MODULE_5__["DEFAULT_RAMP_OTHERS"]) {
            this.others = this.palette.type === 'number-list'
                ? DEFAULT_RAMP_OTHERS_NUMBER
                : DEFAULT_RAMP_OTHERS_COLOR;
            this.others._bindMetadata(metadata);
        } else {
            this.others._bindMetadata(metadata);
            Object(_utils__WEBPACK_IMPORTED_MODULE_0__["checkType"])('ramp', 'others', 2, this.palette.childType, this.others);
        }

        if (this.input.isA(_basic_property__WEBPACK_IMPORTED_MODULE_1__["default"]) || this.input.isA(_aggregation_cluster_ClusterAggregation__WEBPACK_IMPORTED_MODULE_10__["default"])) {
            this.input = this.input.type === 'number'
                ? new _linear__WEBPACK_IMPORTED_MODULE_2__["default"](this.input)
                : new _CategoryIndex__WEBPACK_IMPORTED_MODULE_4__["default"](this.input);

            this.input._bindMetadata(metadata);
        }

        Object(_utils__WEBPACK_IMPORTED_MODULE_0__["checkType"])('ramp', 'input', 0, ['number', 'category'], this.input);

        this.childrenNames.push('others');
        this._metadata = metadata;
    }

    eval (feature) {
        const input = this.input.eval(feature);
        return this._calcEval(input, feature);
    }

    _calcEval (input, feature) {
        const { palette, others } = this._getPalette();
        const paletteValues = this.palette.isA(_color_palettes_Palette__WEBPACK_IMPORTED_MODULE_6__["default"])
            ? palette.map((color) => color.eval(feature))
            : this.palette.eval(feature);

        if (input === _constants__WEBPACK_IMPORTED_MODULE_5__["OTHERS_INDEX"]) {
            return others.eval(feature);
        }

        const maxValues = paletteValues.length - 1;
        const min = Math.floor(input * maxValues);
        const max = Math.ceil(input * maxValues);

        const clampMin = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["clamp"])(min, 0, maxValues);
        const clampMax = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["clamp"])(max, 0, maxValues);
        const m = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["fract"])(input * maxValues);

        return Object(_utils__WEBPACK_IMPORTED_MODULE_0__["mix"])(paletteValues[clampMin], paletteValues[clampMax], m);
    }

    get value () {
        return this.eval();
    }

    getLegendData (options) {
        const config = Object.assign({}, _constants__WEBPACK_IMPORTED_MODULE_5__["DEFAULT_OPTIONS"], options);
        const type = this.input.type;
        let legendData = this.input.getLegendData(config);
        let data = legendData.data
            .map(({ key, value }) => {
                value = this._calcEval(value, undefined);
                return { key, value };
            });

        if (config.order && config.order === _constants__WEBPACK_IMPORTED_MODULE_5__["SORT_DESC"]) {
            data = _checkBuckets(data)
                ? _sortNumericValues(data, config.order)
                : _sortCategoricalValues(data, config.order);
        }

        return { type, ...legendData, data };
    }

    _applyToShaderSource (getGLSLforProperty) {
        const input = this.input._applyToShaderSource(getGLSLforProperty);
        const { palette, others } = this._getPalette();
        const GLSLPalette = palette.map(color => color._applyToShaderSource(getGLSLforProperty));
        const GLSLOthers = others._applyToShaderSource(getGLSLforProperty);
        const GLSLBlend = this.palette.type === 'number-list'
            ? _getInlineGLSLBlend(GLSLPalette)
            : _getInlineColorGLSLBlend(GLSLPalette);

        const rampFnReturnType = this.palette.type === 'number-list' ? 'float' : 'vec4';
        const inline = `ramp_color${this._uid}(${input.inline})`;

        const preface = this._prefaceCode(`
            ${input.preface}
            ${_color_CIELab_glsl__WEBPACK_IMPORTED_MODULE_3___default.a}
            ${GLSLPalette.map(elem => elem.preface).join('\n')}
            ${GLSLOthers.preface}

            ${rampFnReturnType} ramp_color${this._uid}(float x){
                return x==${_constants__WEBPACK_IMPORTED_MODULE_5__["OTHERS_GLSL_VALUE"]}
                    ? ${GLSLOthers.inline}
                    : ${GLSLBlend};
            }`
        );

        return { preface, inline };
    }

    _getPalette () {
        return this.palette.isA(_color_palettes_Palette__WEBPACK_IMPORTED_MODULE_6__["default"])
            ? this._getColorPalette()
            : { palette: this.palette.elems, others: this.others };
    }

    _getColorPalette () {
        const subPalette = this.palette.getColors(this.input.numCategoriesWithoutOthers);

        return {
            palette: subPalette.colors,
            others: this._defaultOthers && subPalette.othersColor ? subPalette.othersColor : this.others
        };
    }
}

function _getInlineGLSLBlend (GLSLPalette) {
    return _generateGLSLBlend(GLSLPalette.map(elem => elem.inline));
}

function _getInlineColorGLSLBlend (GLSLPalette) {
    return `cielabToSRGBA(${_generateGLSLBlend(GLSLPalette.map(elem => `sRGBAToCieLAB(${elem.inline})`))})`;
}

function _generateGLSLBlend (list, index = 0) {
    const currentValue = list[index];

    if (index === list.length - 1) {
        return currentValue;
    }

    const nextBlend = _generateGLSLBlend(list, index + 1);

    return _mixClampGLSL(currentValue, nextBlend, index, list.length);
}

function _mixClampGLSL (currentValue, nextBlend, index, listLength) {
    const min = (index / (listLength - 1)).toFixed(20);
    const max = (1 / (listLength - 1)).toFixed(20);
    const clamp = `clamp((x - ${min})/${max}, 0., 1.)`;

    return `mix(${currentValue}, ${nextBlend}, ${clamp})`;
}

function _sortCategoricalValues (data, order) {
    return order === _constants__WEBPACK_IMPORTED_MODULE_5__["SORT_DESC"]
        ? data.sort((a, b) => b.key.localeCompare(a.key))
        : data.sort((a, b) => a.key.localeCompare(b.key));
}

function _sortNumericValues (data, order) {
    if (Array.isArray(data[0].key)) {
        return order === _constants__WEBPACK_IMPORTED_MODULE_5__["SORT_DESC"]
            ? data.sort((a, b) => b.key[0] - a.key[0])
            : data;
    }

    return order === _constants__WEBPACK_IMPORTED_MODULE_5__["SORT_DESC"]
        ? data.sort((a, b) => b.key - a.key)
        : data;
}

function _checkBuckets (data) {
    return data[0] && (Array.isArray(data[0].key) || (typeof data[0].key === 'number'));
}


/***/ }),

/***/ "./src/renderer/viz/expressions/RampImage.js":
/*!***************************************************!*\
  !*** ./src/renderer/viz/expressions/RampImage.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RampImage; });
/* harmony import */ var _defaultSVGs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../defaultSVGs */ "./src/renderer/viz/defaultSVGs.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _basic_property__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basic/property */ "./src/renderer/viz/expressions/basic/property.js");
/* harmony import */ var _CategoryIndex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CategoryIndex */ "./src/renderer/viz/expressions/CategoryIndex.js");
/* harmony import */ var _ListImage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ListImage */ "./src/renderer/viz/expressions/ListImage.js");
/* harmony import */ var _Image__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Image */ "./src/renderer/viz/expressions/Image.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./constants */ "./src/renderer/viz/expressions/constants.js");









const DEFAULT_RAMP_OTHERS_IMAGE = new _Image__WEBPACK_IMPORTED_MODULE_5__["default"](_defaultSVGs__WEBPACK_IMPORTED_MODULE_0__["default"].circle);
class RampImage extends _base__WEBPACK_IMPORTED_MODULE_6__["default"] {
    _bindMetadata (metadata) {
        _base__WEBPACK_IMPORTED_MODULE_6__["default"].prototype._bindMetadata.call(this, metadata);
        this.type = this.palette.childType;

        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('ramp', 'input', 0, 'category', this.input);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkInstance"])('ramp', 'palette', 1, _ListImage__WEBPACK_IMPORTED_MODULE_4__["default"], this.palette);

        if (this.others === _constants__WEBPACK_IMPORTED_MODULE_7__["DEFAULT_RAMP_OTHERS"]) {
            this.others = DEFAULT_RAMP_OTHERS_IMAGE;
        } else {
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('ramp', 'others', 2, 'image', this.others);
        }

        if (this.input.isA(_basic_property__WEBPACK_IMPORTED_MODULE_2__["default"])) {
            this.input = new _CategoryIndex__WEBPACK_IMPORTED_MODULE_3__["default"](this.input);
            this.input._bindMetadata(metadata);
        }

        this.others._bindMetadata(metadata);
        this.childrenNames.push('others');
    }

    get value () {
        return this.eval();
    }

    eval (feature) {
        const index = this.input.eval(feature);
        return this._calcEval(index);
    }

    _calcEval (input) {
        const index = Math.round(input * (this.input.numCategoriesWithoutOthers - 1));
        const paletteValues = this.palette.eval();
        return paletteValues[index] || this.others.eval();
    }

    getLegendData (options) {
        const type = this.input.type;
        const legendData = this.input.getLegendData(options);
        let data = legendData.data.map(({ key, value }) => {
            value = this._calcEval(value);
            return { key, value };
        });

        if (options && options.order && options.order === _constants__WEBPACK_IMPORTED_MODULE_7__["SORT_DESC"]) {
            data = data.sort((a, b) => b.key - a.key);
        }

        return { type, ...legendData, data };
    }

    _applyToShaderSource (getGLSLforProperty) {
        const input = this.input._applyToShaderSource(getGLSLforProperty);
        const images = this.palette._applyToShaderSource(getGLSLforProperty);
        const others = this.others._applyToShaderSource(getGLSLforProperty);
        return {
            preface: this._prefaceCode(`
                uniform float rampImageMultiplier${this._uid};

                ${input.preface}
                ${images.preface}
                ${others.preface}

                vec4 rampImage${this._uid}(vec2 imageUV, float index){
                    if (index == ${_constants__WEBPACK_IMPORTED_MODULE_7__["OTHERS_GLSL_VALUE"]}){
                        return ${others.inline};
                    }
                    return ${images.inline}(imageUV, rampImageMultiplier${this._uid}*index);
                }
            `),
            inline: `rampImage${this._uid}(imageUV, ${input.inline})`
        };
    }

    _postShaderCompile (program, gl) {
        super._postShaderCompile(program, gl);
        this._getBinding(program)._multiplierLoc = gl.getUniformLocation(program, `rampImageMultiplier${this._uid}`);
    }

    _preDraw (program, drawMetadata, gl) {
        super._preDraw(program, drawMetadata, gl);
        gl.uniform1f(this._getBinding(program)._multiplierLoc, this.input.numCategoriesWithoutOthers - 1);
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/SVG.js":
/*!*********************************************!*\
  !*** ./src/renderer/viz/expressions/SVG.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SVG; });
/* harmony import */ var _Image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Image */ "./src/renderer/viz/expressions/Image.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");



class SVG extends _Image__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (svg) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'svg');
        // This doesn't work in Firefox for local SVG images
        super(`data:image/svg+xml,${encodeURIComponent(svg)}`);
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/Scaled.js":
/*!************************************************!*\
  !*** ./src/renderer/viz/expressions/Scaled.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Scaled; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");




/**
 * Scale a width value to keep feature width constant in real space (meters).
 * This will change the width in pixels at different zoom levels to enforce the previous condition.
 *
 * @param {Number} width - pixel width at zoom level `zoomlevel`
 * @param {Number} [zoomlevel=0] - zoomlevel at which `width` is relative to
 * @return {Number}
 *
 * @example <caption>Keep feature width in meters constant with 25 pixels at zoom level 7.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.scaled(25, 7)
 * });
 *
 * @example <caption>Keep feature width in meters constant with 25 pixels at zoom level 7. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: s.scaled(25, 7)
 * `);
 *
 * @memberof carto.expressions
 * @name scaled
 * @function
 * @api
 */
class Scaled extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (width, zoomlevel = 0) {
        width = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["implicitCast"])(width);
        zoomlevel = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["implicitCast"])(zoomlevel);

        super({
            scale: Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["div"])(Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["mul"])(width, 0), Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["pow"])(2, zoomlevel))
        });

        this.type = 'number';
        this.inlineMaker = inline => inline.scale;
    }

    get value () {
        return this.scale.value;
    }

    eval (feature) {
        return this.scale.eval(feature);
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkType"])('scaled', 'width', 0, 'number', this.scale.a.a);
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkType"])('scaled', 'zoomlevel', 1, 'number', this.scale.b);
    }

    _preDraw (program, drawMetadata, gl) {
        this.scale.a.b.value = Math.pow(2, drawMetadata.zoomLevel);
        super._preDraw(program, drawMetadata, gl);
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/Zoomrange.js":
/*!***************************************************!*\
  !*** ./src/renderer/viz/expressions/Zoomrange.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Zoomrange; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");





/**
 * Define a list of interpolated zoom ranges based on an input breakpoint list. Useful in combination with ramp (see examples).
 *
 * @param {Number[]} _zoomBreakpointList - list of zoom breakpoints with at least two elements
 * @return {Number}
 *
 * @example <caption>Set the width to 1 at zoom levels < 7, set the width at 20 at zoom levels > 10, interpolate between 1 and 20 at zoom levels in the [7,10] range.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.ramp(s.zoomrange([7, 10]), [1, 20])
 * });
 *
 * @example <caption>Set the width to 1 at zoom levels < 7, set the width at 20 at zoom levels > 10, interpolate between 1 and 20 at zoom levels in the [7,10] range. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: width: ramp(zoomrange([7, 10]), [1, 20])
 * `);
 *
 * @memberof carto.expressions
 * @name zoomrange
 * @function
 * @api
 */
class Zoomrange extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (zoomBreakpointList) {
        zoomBreakpointList = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["implicitCast"])(zoomBreakpointList);

        super({});
        Object(_utils__WEBPACK_IMPORTED_MODULE_3__["checkExpression"])('zoomrange', 'zoomBreakpointList', 0, zoomBreakpointList);
        this.type = 'number';
        this._zoomBreakpointList = zoomBreakpointList;
        this.inlineMaker = inline => inline._impostor;
    }

    _bindMetadata (metadata) {
        this._zoomBreakpointList._bindMetadata(metadata);

        Object(_utils__WEBPACK_IMPORTED_MODULE_3__["checkType"])('zoomrange', 'zoomBreakpointList', 0, 'number-list', this._zoomBreakpointList);
        if (this._zoomBreakpointList.elems.length < 2) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"]('zoomrange() function must receive a list with at least two elements.', _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_VALUE);
        }

        const breakpointListCopy = [...this._zoomBreakpointList.elems];

        this._impostor = _genImpostor(breakpointListCopy, 0, breakpointListCopy.length - 1);
        this.childrenNames.push('_impostor');
        super._bindMetadata(metadata);
    }

    eval (feature) {
        return this._impostor.eval(feature);
    }

    /**
     * Get the zoomrange value
     *
     * @api
     * @memberof expressions.Zoomrange
     * @name value
     * @return {Array} - Zoom range breakpoint list
     */
    get value () {
        return this._zoomBreakpointList.elems.map(elem => elem.value);
    }
}

function _genImpostor (list, numerator, denominator) {
    if (list.length === 1) {
        return 1;
    }

    const a = list[0];
    const b = list[1];
    list.shift();

    return Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["blend"])(numerator / denominator,
        _genImpostor(list, numerator + 1, denominator),
        Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["linear"])(Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["pow"])(2, Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["zoom"])()), Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["pow"])(2, a), Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["pow"])(2, b))
    );
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/cluster/ClusterAggregation.js":
/*!********************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/cluster/ClusterAggregation.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ClusterAggregation; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _basic_property__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../basic/property */ "./src/renderer/viz/expressions/basic/property.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../schema */ "./src/renderer/schema.js");
/* harmony import */ var _constants_metadata__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../../constants/metadata */ "./src/constants/metadata.js");





class ClusterAggregation extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor ({ property, expressionName, aggName, aggType }) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkExpression"])(expressionName, 'property', 0, property);

        super({ property });
        this._aggName = aggName;
        this._expressionName = expressionName;
        this.type = aggType;
    }

    get name () {
        return this.property.name;
    }

    get propertyName () {
        return _schema__WEBPACK_IMPORTED_MODULE_3__["column"].aggColumn(this.property.name, this._aggName);
    }

    get aggName () {
        return this._aggName;
    }

    get numCategories () {
        return this.property.numCategories;
    }

    get categories () {
        return this.property.categories;
    }

    get value () {
        return this.propertyName;
    }

    eval (feature) {
        return feature[this.propertyName];
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);
        this._metadata = metadata;
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkInstance"])(this._expressionName, 'property', 0, _basic_property__WEBPACK_IMPORTED_MODULE_1__["default"], this.property);
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkType"])(this._expressionName, 'property', 0, this.type, this.property);
    }

    _applyToShaderSource (getGLSLforProperty) {
        return {
            preface: '',
            inline: `${getGLSLforProperty(this.propertyName)}`
        };
    }

    _postShaderCompile () {}

    _getMinimumNeededSchema () {
        return {
            [this.property.name]: [{
                type: _constants_metadata__WEBPACK_IMPORTED_MODULE_4__["aggregationTypes"].AGGREGATED,
                op: this._aggName
            }]
        };
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/cluster/ClusterAvg.js":
/*!************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/cluster/ClusterAvg.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ClusterAvg; });
/* harmony import */ var _ClusterAggregation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ClusterAggregation */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterAggregation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");


/**
 * Aggregate using the average. This operation disables the access to the property
 * except within other cluster aggregate functions.
 *
 * Note: `clusterAvg` can only be created by {@link carto.expressions.prop|carto.expressions.prop}, not other expressions.
 *
 * @param {Number} property - Column of the table to be aggregated
 * @return {Number} Aggregated column
 *
 * @example <caption>Use cluster average of the population as width.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.clusterAvg(s.prop('population'))
 * });
 *
 * @example <caption>Use cluster average of the population as width. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: clusterAvg($population)
 * `);
 *
 * @memberof carto.expressions
 * @name clusterAvg
 * @function
 * @api
 */
class ClusterAvg extends _ClusterAggregation__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (property) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'clusterAvg');
        super({ property, expressionName: 'clusterAvg', aggName: 'avg', aggType: 'number' });
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/cluster/ClusterCount.js":
/*!**************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/cluster/ClusterCount.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ClusterCount; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _constants_metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../constants/metadata */ "./src/constants/metadata.js");




/**
 * Count of features per cluster.
 *
 * The `clusterCount` expression has no input parameters and if data is not aggregated, it always returns 1.
 * It is not possible to use it as an input in global aggregations such as `globalMin` or `globalQuantiles`.
 *
 * @return {Number} Cluster feature count
 *
 * @example <caption>Use cluster count for width.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.clusterCount() / 50
 * });
 *
 * @example <caption>Use cluster count for width. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: clusterCount() / 50
 * `);
 *
 * @example <caption>Use cluster count with viewportQuantiles in a ramp for width and color.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.ramp(s.viewportQuantiles(s.clusterCount(), 5), [1, 20])
 *   width: s.ramp(s.viewportQuantiles(s.clusterCount(), 5), s.palettes.PINKYL))
 * });
 * // Note: this is not possible with globalQuantiles
 *
 * @example <caption>Use cluster count with viewportQuantiles in a ramp for width and color. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: ramp(viewportQuantiles(clusterCount(), 5), [1, 20])
 *   color: ramp(viewportQuantiles(clusterCount(), 5), Pinkyl)
 * `);
 * // Note: this is not possible with globalQuantiles
 *
 * @memberof carto.expressions
 * @name clusterCount
 * @function
 * @api
 */
class ClusterCount extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor () {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 0, 'clusterCount');
        super({});
        this.type = 'number';
        this._hasClusterFeatureCount = false;
    }

    get propertyName () {
        return _constants_metadata__WEBPACK_IMPORTED_MODULE_2__["CLUSTER_FEATURE_COUNT"];
    }

    isFeatureDependent () {
        return true;
    }

    eval (feature) {
        return Number(feature[_constants_metadata__WEBPACK_IMPORTED_MODULE_2__["CLUSTER_FEATURE_COUNT"]]) || 1;
    }

    getLegendData () {
        return {
            data: this._hasClusterFeatureCount
                ? this._metadata.properties[_constants_metadata__WEBPACK_IMPORTED_MODULE_2__["CLUSTER_FEATURE_COUNT"]]
                : []
        };
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);
        this._metadata = metadata;
        this._hasClusterFeatureCount = metadata.properties[_constants_metadata__WEBPACK_IMPORTED_MODULE_2__["CLUSTER_FEATURE_COUNT"]] !== undefined;
    }

    _applyToShaderSource (getGLSLforProperty) {
        return {
            preface: '',
            inline: this._hasClusterFeatureCount ? getGLSLforProperty(_constants_metadata__WEBPACK_IMPORTED_MODULE_2__["CLUSTER_FEATURE_COUNT"]) : '1.'
        };
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/cluster/ClusterMax.js":
/*!************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/cluster/ClusterMax.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ClusterMax; });
/* harmony import */ var _ClusterAggregation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ClusterAggregation */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterAggregation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");



/**
 * Aggregate using the maximum. This operation disables the access to the property
 * except within other cluster aggregate functions.
 *
 * Note: `clusterMax` can only be created by {@link carto.expressions.prop|carto.expressions.prop}, not other expressions.
 *
 * @param {Number} property - Column of the table to be aggregated
 * @return {Number} Aggregated column
 *
 * @example <caption>Use cluster maximum of the population as width.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.clusterMax(s.prop('population'))
 * });
 *
 * @example <caption>Use cluster maximum of the population as width. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: clusterMax($population)
 * `);
 *
 * @memberof carto.expressions
 * @name clusterMax
 * @function
 * @api
 */
class ClusterMax extends _ClusterAggregation__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (property) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'clusterMax');
        super({ property, expressionName: 'clusterMax', aggName: 'max', aggType: 'number' });
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/cluster/ClusterMin.js":
/*!************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/cluster/ClusterMin.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ClusterMin; });
/* harmony import */ var _ClusterAggregation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ClusterAggregation */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterAggregation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");


/**
 * Aggregate using the minimum. This operation disables the access to the property
 * except within other cluster aggregate functions.
 *
 * Note: `clusterMin` can only be created by {@link carto.expressions.prop|carto.expressions.prop}, not other expressions.
 *
 * @param {Number} property - Column of the table to be aggregated
 * @return {Number} Aggregated column
 *
 * @example <caption>Use cluster minimum of the population as width.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.clusterMin(s.prop('population'))
 * });
 *
 * @example <caption>Use cluster minimum of the population as width. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: clusterMin($population)
 * `);
 *
 * @memberof carto.expressions
 * @name clusterMin
 * @function
 * @api
 */
class ClusterMin extends _ClusterAggregation__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (property) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'clusterMin');
        super({ property, expressionName: 'clusterMin', aggName: 'min', aggType: 'number' });
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/cluster/ClusterMode.js":
/*!*************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/cluster/ClusterMode.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ClusterMode; });
/* harmony import */ var _ClusterAggregation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ClusterAggregation */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterAggregation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");


/**
 * Aggregate using the mode. This operation disables the access to the property
 * except within other cluster aggregate functions.
 *
 * Note: `clusterMode` can only be created by {@link carto.expressions.prop|carto.expressions.prop}, not other expressions.
 *
 * @param {Category} property - Column of the table to be aggregated
 * @return {Category} Aggregated column
 *
 * @example <caption>Use cluster mode of the population in a color ramp.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.ramp(s.clusterMode(s.prop('category')), s.palettes.PRISM)
 * });
 *
 * @example <caption>Use cluster mode of the population in a color ramp. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: ramp(clusterMode($category), PRISM)
 * `);
 *
 * @memberof carto.expressions
 * @name clusterMode
 * @function
 * @api
 */
class ClusterMode extends _ClusterAggregation__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (property) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'clusterMode');
        super({ property, expressionName: 'clusterMode', aggName: 'mode', aggType: 'category' });
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/cluster/ClusterSum.js":
/*!************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/cluster/ClusterSum.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ClusterSum; });
/* harmony import */ var _ClusterAggregation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ClusterAggregation */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterAggregation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");


/**
 * Aggregate using the sum. This operation disables the access to the property
 * except within other cluster aggregate functions.
 *
 * Note: `clusterSum` can only be created by {@link carto.expressions.prop|carto.expressions.prop}, not other expressions.
 *
 * @param {Number} property - Column of the table to be aggregated
 * @return {Number} Aggregated column
 *
 * @example <caption>Use cluster sum of the population as width.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.clusterSum(s.prop('population'))
 * });
 *
 * @example <caption>Use cluster sum of the population as width. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: clusterSum($population)
 * `);
 *
 * @memberof carto.expressions
 * @name clusterSum
 * @function
 * @api
 */
class ClusterSum extends _ClusterAggregation__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (property) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'clusterSum');
        super({ property, expressionName: 'clusterSum', aggName: 'sum', aggType: 'number' });
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/cluster/ClusterTime.js":
/*!*************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/cluster/ClusterTime.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ClusterTime; });
/* harmony import */ var _ClusterTimeDimension__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ClusterTimeDimension */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterTimeDimension.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");



/**
 * Use discretised property as aggregate dimension. This operation disables the access to the property
 * except within `clusterTime` expressions with the same parameters.
 *
 * Note: `clusterTime` can only be created with a {@link carto.expressions.prop|carto.expressions.prop},
 * as the first parameter, not other expressions.
 *
 * When the units of resolution are cyclic periods such as 'dayOfWeek' (day of the week) or 'monthOfYear' (month of the year),
 * the resulting expression takes a numeric value to represent the period, e.g. 1 for Monday or January.
 *
 * When the units are not cyclic (e.g. 'week' or 'month'), the resulting expression is a `TimeRange` that
 * encompass each individual calendar period, for example week 2018-W03 (third week of 2018 from 2018-01-15 to 2018-01-21)
 * or 2018-03 (March 2018, from 2018-03-01 to 2018-04-01).
 *
 * Accepted values for cyclic resolution periods are:
 * - `semesterOfYear` (6-month term) takes values from 1 to 2
 * - `trimesterOfYear` (4-month term) takes values from 1 to 3
 * - `quarterOfYear` (3-month term) takes values from 1 to 4
 * - `monthOfYear` takes values from 1 (January) to 12 (December)
 * - `weekOfYear` follows [ISO 8601 numbering](https://en.wikipedia.org/wiki/ISO_week_date) taking values from 1 up to 53
 * - `dayOfWeek` (as per ISO 8601, 1 = Monday, to 7 = Sunday
 * - `dayOfMonth` takes values from 1 to 31
 * - `dayOfYear` takes values from 1 to 366
 * - `hourOfDay` takes values from 0 to 23
 * - `minuteOfHour` takes values from 0 to 59
 *
 * Accepted values for serial resolution units are:
 *
 * - `year`, e.g. '2017'
 * - `month`, e.g. '2017-03'
 * - `day`, e.g. '2017-03-01'
 * - `hour`, e.g. '2017-03-01T13'
 * - `minute`, e.g. '2017-03-01T13:22'
 * - `second`, e.g. '2017-03-01T13:22:31'
 * - `week` represented as '2018-W03' (third week of 2018:, 2018-01-15 to 2018-01-21)
 * - `quarter` as '2018-Q2' (second quarter of 2018, i.e. 2018-04 to 2018-06)
 * - `semester` as '2018S2' (second semester of 2018, i.e. 2018-07 to 2018-12)
 * - `trimester` as '2018t2' (second trimester of 2018, i.e. 2018-05 to 2018-08)
 * - `decade` as 'D201' (decade 201, i.e. 2010 to 2019)
 * - `century` as 'C21' (21st century, ie. 2001 to 2100)
 * - `millennium` as 'M3' (3rd millennium: 2001 to 3000)
 *
 * The time zone is optional. By default UTC time will be used.
 * It admits a fixed offset from UTC as a signed number of seconds,
 * or [IANA](https://www.iana.org/time-zones) timezone [names](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones)
 * such as `America/New_York` or `Europe/Madrid`, which not only define a time offset,
 * but also rules for DST (daylight savings time).
 *
 * @param {Date} property - Column of the table to be discretised as dimension
 * @param {String} units - Units of resolution for the discretization
 * @param {String} timezone - Time zone in which the dates are discretised. UTC by default.
 * @return {TimeRange|Number} Dimension column; takes time range values (intervals) for serial units of resolutions and numbers for recurrent units.
 *
 * @example <caption>Use months as a dimension of the cluster aggregations as `month`.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   month: s.clusterTime(s.prop('date', 'month', 'America/New_York'))
 * });
 *
 * @example <caption>Use months as a dimension of the cluster aggregations as `month`. (String)</caption>
 * const viz = new carto.Viz(`
 *   month: clusterTime($date, 'month', 'America/New_York')
 * `);
 *
 * @memberof carto.expressions
 * @name clusterTime
 * @function
 * @api
 */
class ClusterTime extends _ClusterTimeDimension__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (property, units, timezone) {
        const expressionName = 'clusterTime';
        const isCyclic = _ClusterTimeDimension__WEBPACK_IMPORTED_MODULE_0__["default"].cyclicUnits.includes(units);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 3, expressionName);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])(expressionName, 'property', 0, property);
        const validUnits = isCyclic ? _ClusterTimeDimension__WEBPACK_IMPORTED_MODULE_0__["default"].cyclicUnits : _ClusterTimeDimension__WEBPACK_IMPORTED_MODULE_0__["default"].serialUnits;
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkStringValue"])(expressionName, 'units', 1, units, validUnits);
        super({
            property,
            expressionName,
            dimension: {
                group: {
                    units: units,
                    timezone
                },
                format: isCyclic ? 'number' : 'iso'
            },
            type: isCyclic ? 'number' : 'timerange',
            range: isCyclic ? undefined : []
        });
    }
    converse (v) {
        return v;
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/cluster/ClusterTimeDimension.js":
/*!**********************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/cluster/ClusterTimeDimension.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return clusterTimeDimension; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _basic_property__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../basic/property */ "./src/renderer/viz/expressions/basic/property.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../schema */ "./src/renderer/schema.js");





const SERIAL_UNITS = [
    'second', 'minute', 'hour',
    'day', 'month', 'year',
    'week', 'quarter', 'trimester', 'semester',
    'decade', 'century', 'millennium'
];

const CYCLIC_UNITS = [
    'dayOfYear', 'weekOfYear', 'monthOfYear', 'quarterOfYear',
    'dayOfMonth', 'dayOfWeek',
    'hourOfDay', 'minuteOfHour'
];

// TODO: generalize with base clusterDimension
class clusterTimeDimension extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor ({ property, expressionName, dimension, type, range }) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkExpression"])(expressionName, 'property', 0, property);
        super({ property });
        this._dimension = dimension;
        this._dimension.propertyName = _schema__WEBPACK_IMPORTED_MODULE_3__["column"].dimColumn(this.property.propertyName, this._dimension.group.units);
        this._expressionName = expressionName;
        this.type = type;
        this._range = range;
    }

    static get serialUnits () {
        return SERIAL_UNITS;
    }

    static get cyclicUnits () {
        return CYCLIC_UNITS;
    }

    get name () {
        return this.property.propertyName;
    }

    get propertyName () {
        return this._dimension.propertyName;
    }

    get value () {
        return {
            name: this.propertyName,
            range: this._range,
            dimension: this._dimension
        };
    }

    eval (feature) {
        return feature[this.propertyName];
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkInstance"])(this._expressionName, 'property', 0, _basic_property__WEBPACK_IMPORTED_MODULE_1__["default"], this.property);
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkType"])(this._expressionName, 'property', 0, 'date', this.property);
        this._range = metadata.properties[metadata.baseName(this.propertyName)].dimension.range;
    }

    _resolveAliases () {}

    _applyToShaderSource (getGLSLforProperty) {
        const inline = this._range
            ? this._range.map(propertyName => [
                `${getGLSLforProperty(propertyName)}`
            ])
            : `${getGLSLforProperty(this.propertyName)}`;

        return {
            preface: '',
            inline
        };
    }

    _postShaderCompile () {}

    _getMinimumNeededSchema () {
        return {
            [this.name]: [{
                type: 'dimension',
                dimension: this._dimension,
                range: !!this._range
            }]
        };
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/global/GlobalAggregation.js":
/*!******************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/global/GlobalAggregation.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GlobalAggregation; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _constants_metadata__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../../constants/metadata */ "./src/constants/metadata.js");






/**
 * Global aggregation expressions compute summary stats of properties for the whole dataset.
 * As such, they rely on data provided by the backend, and not on the possibly incomplete
 * set of features transferred to the client.
 *
 * In addition, the properties used in the visualization may have been aggregated into
 * clusters, if *cluster* aggregation expressions have been used.
 *
 * Since cluster aggregation is zoom-level-dependant (because the cluster size varies with
 * the zoom level), global aggregates cannot be assigned definite values for
 * cluster-aggregated properties in general.
 *
 * In some specific cases it possible to assign a defined value to the combination of a
 * global aggregation and a cluster aggregation. Such is the case with
 * `globalMin(clusterMin($p))`, `globalMax(clusterMax($p))`,
 * `globalSum(clusterCount($column))` and `globalSum(clusterSum($column))`.
 *
 * In the interest of allowing the use of `linear` without explicit limits in as many cases
 * as possible, we should make `globalMin()` and `globalMax()`, which are used
 * to compute the automatic linear limits, work with as many cluster expressions as possible,
 * to allow the convenient use of cluster aggregations in simple linear expressions.
 *
 * For that reason we'll allow global aggregations to work not only with those cluster
 * aggregations that yield definite values, but also for other cases in which we can
 * efficiently compute (with the available backend stats) the limit value for high zoom
 * level; and only in cases with fast monotonic convergence (which is not the case for example
 * for `globalSum(clusterMin($p)))` or `globalMin(clusterSum($p))`).
 *
 * Here's a table of global-cluster aggregation combinations showing which cases
 * have been implemented (the rest produce invalid input errors). Columns are cluster
 * aggregations and rows are global aggregations. Each cell shows the metadata stat
 * used to compute the combinations. For the cases varying per zoom level a tilde prefixes
 * the stat, two tildes for the more questionable cases.
 *
 * |         | c-Avg   | c-Count | c-Max   | c-Min   | c-Mode | c-Sum |
 * |---------|---------|---------|---------|---------|--------|-------|
 * | g-Avg   |   ~avg  |   ERR   |   ERR   |   ERR   |   ERR  |   ERR |
 * | g-Max   |   ~max  |   ERR   |   max   |  ~~max  |   ERR  |   ERR |
 * | g-Min   |   ~min  |   ERR   |  ~~min  |   min   |   ERR  |   ERR |
 * | g-Sum   |   ERR   |   count |   ERR   |   ERR   |   ERR  |   sum |
 *
 */

class GlobalAggregation extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @param {*} property
     * @param {*} name
     */
    constructor ({ property, name, type, baseStats = false }) {
        super({ _value: Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["number"])(0) });
        this.property = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["implicitCast"])(property);
        this._name = name;
        this.type = type;
        this.baseStats = baseStats;
        super.inlineMaker = inline => inline._value;
    }

    toString () {
        return `${this.expressionName}(${this.property.toString()})`;
    }

    isFeatureDependent () {
        return false;
    }

    get value () {
        return this._value.value;
    }

    eval () {
        return this.value;
    }

    _resolveAliases (aliases) {
        if (this.property) {
            this.property._resolveAliases(aliases);
        }
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);
        this.property._bindMetadata(metadata);
        const propertyName = this.property.name || this.property.propertyName;
        const value = this._getValueFromStats(metadata, propertyName);
        this._value.value = metadata.codec(propertyName).sourceToExternal(metadata, value);
    }

    _getValueFromStats (metadata, propertyName) {
        let value;

        if (this.baseStats) {
            if (this.baseStats === '_count') {
                value = metadata.featureCount;
            } else {
                const stats = metadata.stats(this.property.name);
                value = stats && stats[this.baseStats];
            }
        } else {
            if (propertyName === _constants_metadata__WEBPACK_IMPORTED_MODULE_4__["CLUSTER_FEATURE_COUNT"]) {
                throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["default"](_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["CartoValidationErrorTypes"].INCORRECT_TYPE, `'clusterCount' can not be used in ${this.expressionName}.`);
            }
            const stats = metadata.stats(propertyName);
            value = stats && stats[this._name];
        }

        if (value === undefined) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["default"](
                `Metadata ${this._name} for property ${propertyName} is not defined`,
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["CartoValidationErrorTypes"].MISSING_REQUIRED
            );
        }

        return value;
    }

    _getMinimumNeededSchema () {
        return this.property._getMinimumNeededSchema();
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/global/GlobalAvg.js":
/*!**********************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/global/GlobalAvg.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GlobalAvg; });
/* harmony import */ var _GlobalAggregation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GlobalAggregation */ "./src/renderer/viz/expressions/aggregation/global/GlobalAggregation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _cluster_ClusterAggregation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cluster/ClusterAggregation */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterAggregation.js");
/* harmony import */ var _cluster_ClusterAvg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cluster/ClusterAvg */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterAvg.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");








/**
 * Return the average of the feature property for the entire source data.
 *
 * Note: `globalAvg` can only be created by {@link carto.expressions.prop|carto.expressions.prop}, not other expressions.
 *
 * @param {Number} property - property expression of number type
 * @return {Number} Result of the aggregation
 *
 * @example <caption>Assign the global average of the `amount` property to a variable.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   variables: {
 *      g_avg: s.globalAvg(s.prop('amount'))
 *   }
 * });
 *
 * @example <caption>Assign the global average of the `amount` property to a variable. (String)</caption>
 * const viz = new carto.Viz(`
 *   \@g_avg: globalAvg($amount)
 * `);
 *
 * @memberof carto.expressions
 * @name globalAvg
 * @function
 * @api
 */
class GlobalAvg extends _GlobalAggregation__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (property) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'globalAvg');
        let baseStats = false;
        if (property && property.isA(_cluster_ClusterAggregation__WEBPACK_IMPORTED_MODULE_2__["default"])) {
            if (property.isA(_cluster_ClusterAvg__WEBPACK_IMPORTED_MODULE_3__["default"])) {
                // This is not strictly correct (the average of cluster averages is not the average of data)
                // but we'll allow it
                baseStats = 'avg';
            } else {
                throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_4__["default"](
                    'Invalid globlalAvg input',
                    _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_4__["CartoValidationErrorTypes"].INCORRECT_TYPE
                );
            }
        }

        super({ property, name: 'avg', type: 'number', baseStats });
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])(this.expressionName, 'property', 0, 'number', this.property);
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/global/GlobalCount.js":
/*!************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/global/GlobalCount.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GlobalCount; });
/* harmony import */ var _GlobalAggregation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GlobalAggregation */ "./src/renderer/viz/expressions/aggregation/global/GlobalAggregation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");



/**
 * Return the feature count for the entire source data.
 *
 * @return {Number} feature count
 *
 * @example <caption>Assign the global count of features to a variable.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   variables: {
 *      g_count: s.globalCount()
 *   }
 * });
 *
 * @example <caption>Assign the global count of features. (String)</caption>
 * const viz = new carto.Viz(`
 *   \@g_count: globalCount()
 * `);
 *
 * @memberof carto.expressions
 * @name globalCount
 * @function
 * @api
 */
class GlobalCount extends _GlobalAggregation__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor () {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 0, 'globalCount');
        super({ name: 'count', type: 'number' });
    }

    toString () {
        return `${this.expressionName}()`;
    }

    _bindMetadata (metadata) {
        this._value.value = metadata.featureCount;
    }

    _getMinimumNeededSchema () {
        return {};
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/global/GlobalMax.js":
/*!**********************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/global/GlobalMax.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GlobalMax; });
/* harmony import */ var _GlobalAggregation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GlobalAggregation */ "./src/renderer/viz/expressions/aggregation/global/GlobalAggregation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _cluster_ClusterAggregation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cluster/ClusterAggregation */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterAggregation.js");
/* harmony import */ var _cluster_ClusterAvg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cluster/ClusterAvg */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterAvg.js");
/* harmony import */ var _cluster_ClusterMax__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cluster/ClusterMax */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterMax.js");
/* harmony import */ var _cluster_ClusterMin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../cluster/ClusterMin */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterMin.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");










/**
 * Return the maximum of the feature property for the entire source data.
 *
 * Note: `globalMax` can only be created by {@link carto.expressions.prop|carto.expressions.prop}, not other expressions.
 *
 * @param {Number|Date} property - property expression of date or number type
 * @return {Number|Date} Result of the aggregation
 *
 * @example <caption>Assign the global maximum of the `amount` property to a variable.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   variables: {
 *      g_max: s.globalMax(s.prop('amount'))
 *   }
 * });
 *
 * @example <caption>Assign the global maximum of the `amount` property to a variable. (String)</caption>
 * const viz = new carto.Viz(`
 *   \@g_max: globalMax($amount)
 * `);
 *
 * @memberof carto.expressions
 * @name globalMax
 * @function
 * @api
 */
class GlobalMax extends _GlobalAggregation__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (property) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'globalMax');

        let baseStats = false;
        if (property && property.isA(_cluster_ClusterAggregation__WEBPACK_IMPORTED_MODULE_2__["default"])) {
            if (property.isA(_cluster_ClusterAvg__WEBPACK_IMPORTED_MODULE_3__["default"]) || property.isA(_cluster_ClusterMin__WEBPACK_IMPORTED_MODULE_5__["default"]) || property.isA(_cluster_ClusterMax__WEBPACK_IMPORTED_MODULE_4__["default"])) {
                // This is not correct for ClusterAvg, and specially not for clusterMin...
                // but we allow for it
                baseStats = 'max';
            } else {
                throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["default"](
                    'Invalid globlalAvg input',
                    _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["CartoValidationErrorTypes"].INCORRECT_TYPE
                );
            }
        }

        super({ property, name: 'max', type: 'number', baseStats });
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/global/GlobalMin.js":
/*!**********************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/global/GlobalMin.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GlobalMin; });
/* harmony import */ var _GlobalAggregation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GlobalAggregation */ "./src/renderer/viz/expressions/aggregation/global/GlobalAggregation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _cluster_ClusterAggregation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cluster/ClusterAggregation */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterAggregation.js");
/* harmony import */ var _cluster_ClusterAvg__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cluster/ClusterAvg */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterAvg.js");
/* harmony import */ var _cluster_ClusterMax__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cluster/ClusterMax */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterMax.js");
/* harmony import */ var _cluster_ClusterMin__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../cluster/ClusterMin */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterMin.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");










/**
 * Return the minimum of the feature property for the entire source data.
 *
 * Note: `globalMin` can only be created by {@link carto.expressions.prop|carto.expressions.prop}, not other expressions.
 *
 * @param {Number|Date} property - property expression of date or number type
 * @return {Number|Date} Result of the aggregation
 *
 * @example <caption>Assign the global minimum of the `amount` property to a variable.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   variables: {
 *      g_min: s.globalMin(s.prop('amount'))
 *   }
 * });
 *
 * @example <caption>Assign the global minimum of the `amount` property to a variable. (String)</caption>
 * const viz = new carto.Viz(`
 *   \@g_min: globalMin($amount)
 * `);
 *
 * @memberof carto.expressions
 * @name globalMin
 * @function
 * @api
 */
class GlobalMin extends _GlobalAggregation__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (property) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'globalMin');

        // FIXME: type should actually be the property type (number/date)
        // but if a variable it's too soon to know here

        let baseStats = false;
        if (property && property.isA(_cluster_ClusterAggregation__WEBPACK_IMPORTED_MODULE_2__["default"])) {
            if (property.isA(_cluster_ClusterAvg__WEBPACK_IMPORTED_MODULE_3__["default"]) || property.isA(_cluster_ClusterMin__WEBPACK_IMPORTED_MODULE_5__["default"]) || property.isA(_cluster_ClusterMax__WEBPACK_IMPORTED_MODULE_4__["default"])) {
                // This is not correct for ClusterAvg, and specially not for clusterMax...
                // but we allow for it
                baseStats = 'min';
            } else {
                throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["default"](
                    'Invalid globlalAvg input',
                    _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["CartoValidationErrorTypes"].INCORRECT_TYPE
                );
            }
        }

        super({ property, name: 'min', type: 'number', baseStats });
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/global/GlobalPercentile.js":
/*!*****************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/global/GlobalPercentile.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GlobalPercentile; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _basic_property__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../basic/property */ "./src/renderer/viz/expressions/basic/property.js");




/**
 * Return the Nth percentile of an numeric property for the entire source data.
 *
 * @param {Number} property - numeric property
 * @param {Number} percentile - Numeric expression in the [0, 100] range, must be feature independent
 * @return {Number} Result of the aggregation
 *
 * @example <caption>Assign the 90th percentile of the `amount` property for the entire dataset to a variable.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   variables: {
 *      v_percentile: s.globalPercentile(s.prop('amount'), 90)
 *   }
 * });
 *
 * @example <caption>Assign the 90th percentile of the `amount` property for the entire dataset to a variable. (String)</caption>
 * const viz = new carto.Viz(`
 *   \@v_percentile: globalPercentile($amount, 90)
 * `);
 *
 * @memberof carto.expressions
 * @name globalPercentile
 * @function
 * @api
 */
class GlobalPercentile extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (property, percentile) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkMaxArguments"])(arguments, 2, 'globalPercentile');
        property = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["implicitCast"])(property);
        percentile = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["implicitCast"])(percentile);
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkExpression"])('globalPercentile', 'property', 0, property);
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkExpression"])('globalPercentile', 'percentile', 1, percentile);

        super({ _value: Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["number"])(0), property, percentile });
        this.type = 'number';
        super.inlineMaker = inline => inline._value;
    }

    isFeatureDependent () {
        return false;
    }

    get value () {
        const p = this.percentile.value / 100;
        return this._copySample[Math.floor(p * this._copySample.length)];
    }

    eval () {
        return this.value;
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkType"])('globalPercentile', 'property', 0, 'number', this.property);
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkType"])('globalPercentile', 'percentile', 0, 'number', this.percentile);
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkInstance"])('globalPercentile', 'property', 0, _basic_property__WEBPACK_IMPORTED_MODULE_3__["default"], this.property);
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkFeatureIndependent"])('globalPercentile', 'percentile', 1, this.percentile);

        this._copySample = metadata.sample.map(s => s[this.property.propertyName]);
        this._copySample.sort((x, y) => x - y);
    }

    _preDraw (...args) {
        this._value.value = this.value;
        super._preDraw(...args);
    }

    _getMinimumNeededSchema () {
        return this.property._getMinimumNeededSchema();
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/global/GlobalSum.js":
/*!**********************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/global/GlobalSum.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GlobalSum; });
/* harmony import */ var _GlobalAggregation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GlobalAggregation */ "./src/renderer/viz/expressions/aggregation/global/GlobalAggregation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _cluster_ClusterAggregation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../cluster/ClusterAggregation */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterAggregation.js");
/* harmony import */ var _cluster_ClusterCount__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../cluster/ClusterCount */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterCount.js");
/* harmony import */ var _cluster_ClusterSum__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../cluster/ClusterSum */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterSum.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");









/**
 * Return the sum of the feature property for the entire source data.
 *
 * Note: `globalSum` can only be created by {@link carto.expressions.prop|carto.expressions.prop}, not other expressions.
 *
 * @param {Number} property - property expression of number type
 * @return {Number} Result of the aggregation
 *
 * @example <caption>Assign the global sum of the `amount` property to a variable.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   variables: {
 *      g_sum: s.globalSum(s.prop('amount'))
 *   }
 * });
 *
 * @example <caption>Assign the global sum of the `amount` property to a variable. (String)</caption>
 * const viz = new carto.Viz(`
 *   \@g_sum: globalSum($amount)
 * `);
 *
 * @memberof carto.expressions
 * @name globalSum
 * @function
 * @api
 */
class GlobalSum extends _GlobalAggregation__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (property) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'globalSum');
        const type = property.type;
        let baseStats = false;
        if (property && (property.isA(_cluster_ClusterAggregation__WEBPACK_IMPORTED_MODULE_2__["default"]) || property.isA(_cluster_ClusterCount__WEBPACK_IMPORTED_MODULE_3__["default"]))) {
            if (property.isA(_cluster_ClusterSum__WEBPACK_IMPORTED_MODULE_4__["default"])) {
                baseStats = 'sum';
            } else if (property.isA(_cluster_ClusterCount__WEBPACK_IMPORTED_MODULE_3__["default"])) {
                baseStats = '_count';
            } else {
                throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_5__["default"](
                    'Invalid globlalAvg input',
                    _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_5__["CartoValidationErrorTypes"].INCORRECT_TYPE
                );
            }
        }

        super({ property, name: 'sum', baseStats, type });
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/viewport/ViewportAggCalculator.js":
/*!************************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/viewport/ViewportAggCalculator.js ***!
  \************************************************************************************/
/*! exports provided: runViewportAggregations */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "runViewportAggregations", function() { return runViewportAggregations; });
/* harmony import */ var _Renderer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../Renderer */ "./src/renderer/Renderer.js");
/* harmony import */ var _viewportFeatures__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../viewportFeatures */ "./src/renderer/viz/expressions/viewportFeatures.js");
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../utils/geometry */ "./src/utils/geometry.js");





/**
 * Run all viewport aggregation functions over the visible features in the renderLayer
 */
function runViewportAggregations (renderLayer) {
    const viewportExpressions = _getViewportExpressions(renderLayer.viz._getRootExpressions());
    if (!viewportExpressions.length) {
        return;
    }

    _reset(viewportExpressions, renderLayer);
    _runInActiveDataframes(viewportExpressions, renderLayer);
}

/**
 * Perform a DFS (Depth First Search) through the expression tree collecting all viewport expressions.
 * This is a performance optimization to avoid doing DFS at each feature iteration
 */
function _getViewportExpressions (rootExpressions) {
    const viewportExpressions = [];

    function dfs (expr) {
        if (expr._isViewport) {
            viewportExpressions.push(expr);
        } else {
            expr._getChildren().map(dfs);
        }
    }

    rootExpressions.map(dfs);

    return viewportExpressions;
}

/**
 * Reset previous viewport aggregation function values.
 * It assumes that all dataframes of the renderLayer share the same metadata
 */
function _reset (viewportExpressions, renderLayer) {
    const metadata = renderLayer.viz.metadata;
    viewportExpressions.forEach(expr => expr._resetViewportAgg(metadata, renderLayer));
}

/**
 * Run all viewport aggregations in the active dataframes
 */
function _runInActiveDataframes (viewportExpressions, renderLayer) {
    const dataframes = renderLayer.getActiveDataframes();
    const inViewportFeaturesIDs = _runInDataframes(viewportExpressions, renderLayer, dataframes);

    _runImprovedForPartialFeatures(viewportExpressions, renderLayer, inViewportFeaturesIDs);
}

/**
 * Run all viewport aggregations in the dataframes, and returns a list of featureIDs inside the
 * viewport & not filtered out. That's a list of the features effectively included in the viewportExpressions run
 */
function _runInDataframes (viewportExpressions, renderLayer, dataframes) {
    const processedFeaturesIDs = new Set(); // same feature can belong to multiple dataframes
    const viz = renderLayer.viz;

    const inViewportFeaturesIDs = new Set();
    dataframes.forEach(dataframe => {
        _runInDataframe(viz, viewportExpressions, dataframe, processedFeaturesIDs, inViewportFeaturesIDs);
    });
    return inViewportFeaturesIDs;
}

/**
 * Run an improved viewportFeatures just for lines or polygons (considering the existence of partial Features)
 */
function _runImprovedForPartialFeatures (viewportExpressions, renderLayer, inViewportFeaturesIDs) {
    const noFeatures = (inViewportFeaturesIDs.size === 0);
    if (noFeatures) {
        return;
    }

    const noPossiblePartialFeatures = (renderLayer.viz.geometryType === _utils_geometry__WEBPACK_IMPORTED_MODULE_2__["GEOMETRY_TYPE"].POINT);
    if (noPossiblePartialFeatures) {
        return;
    }

    const viewportFeaturesExpressions = viewportExpressions.filter(exp => exp.isA(_viewportFeatures__WEBPACK_IMPORTED_MODULE_1__["default"]));
    if (viewportFeaturesExpressions.length > 0) {
        _runForPartialViewportFeatures(viewportFeaturesExpressions, renderLayer, inViewportFeaturesIDs);
    }
}

/**
 * Run viewport aggregations in the dataframe. It excludes features:
 *    - already accumulated in other dataframes
 *    - outside the viewport
 *    - filtered out
 */
function _runInDataframe (viz, viewportExpressions, dataframe, processedFeaturesIDs, inViewportFeaturesIDs) {
    for (let i = 0; i < dataframe.numFeatures; i++) {
        const idProperty = viz.metadata.idProperty;
        const featureId = dataframe.properties[idProperty][i];

        const featureAlreadyAccumulated = processedFeaturesIDs.has(featureId);
        if (featureAlreadyAccumulated) {
            continue; // This is correct for viewportExpressions related to 'alphanumeric' properties (not geometry-related)
        }

        const featureOutsideViewport = !dataframe.inViewport(i);
        if (featureOutsideViewport) {
            continue;
        }

        // a new feature, inside the viewport
        processedFeaturesIDs.add(featureId);
        const feature = dataframe.getFeature(i);

        const featureIsFilteredOut = viz.filter.eval(feature) < _Renderer__WEBPACK_IMPORTED_MODULE_0__["FILTERING_THRESHOLD"];
        if (featureIsFilteredOut) {
            continue;
        }

        inViewportFeaturesIDs.add(feature[idProperty]); // inViewport & in filter

        // not a filtered feature, so pass the rawFeature to viewport expressions
        viewportExpressions.forEach(expr => expr.accumViewportAgg(feature));
    }
}

/**
 * Rerun viewportFeatures to improve its results, including all feature pieces in dataframes
 */
function _runForPartialViewportFeatures (viewportFeaturesExpressions, renderLayer, featuresIDs) {
    // Reset previous expressions with (possibly 1 partial) features
    viewportFeaturesExpressions.forEach(expr => expr._resetViewportAgg(null, renderLayer));

    // Gather all pieces per feature
    const piecesPerFeature = renderLayer.getAllPiecesPerFeature(featuresIDs);

    // Run viewportFeatures with the whole set of feature pieces
    viewportFeaturesExpressions.forEach(expr => {
        for (const featureId in piecesPerFeature) {
            expr.accumViewportAgg(piecesPerFeature[featureId]);
        }
    });
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/viewport/ViewportAggregation.js":
/*!**********************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/viewport/ViewportAggregation.js ***!
  \**********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewportAggregation; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../expressions */ "./src/renderer/viz/expressions.js");




class ViewportAggregation extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @param {*} property
     */
    constructor ({ property }) {
        property = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(property);
        super({ property, _impostor: Object(_expressions__WEBPACK_IMPORTED_MODULE_2__["number"])(0) });
        this._isViewport = true;
        this.type = 'number';
        this.inlineMaker = inline => inline._impostor;
    }

    _bindMetadata (metadata) {
        // TODO improve type check
        super._bindMetadata(metadata);
    }

    _getMinimumNeededSchema () {
        return this.property._getMinimumNeededSchema();
    }

    _preDraw (...args) {
        this._impostor.value = this.value;
        super._preDraw(...args);
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/viewport/ViewportAvg.js":
/*!**************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/viewport/ViewportAvg.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewportAvg; });
/* harmony import */ var _ViewportAggregation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewportAggregation */ "./src/renderer/viz/expressions/aggregation/viewport/ViewportAggregation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _constants_metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../constants/metadata */ "./src/constants/metadata.js");




/**
 * Return the average value of an expression for the features showed in the viewport (features outside the viewport and features that don't pass the filter will be excluded).
 *
 * @param {Number} input - numeric expression
 * @return {Number} Result of the aggregation
 *
 * @example <caption>Assign the average of the `amount` property in the viewport to a variable.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   variables: {
 *      v_avg: s.viewportAvg(s.prop('amount'))
 *   }
 * });
 *
 * @example <caption>Assign the average of the `amount` property in the viewport to a variable. (String)</caption>
 * const viz = new carto.Viz(`
 *   \@v_avg: viewportAvg($amount)
 * `);
 *
 * @memberof carto.expressions
 * @name viewportAvg
 * @function
 * @api
 */
class ViewportAvg extends _ViewportAggregation__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (property) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'viewportAvg');

        super({ property });
        this._sum = 0;
        this._count = 0;
    }

    get value () {
        return this._sum / this._count;
    }

    eval () {
        return this.value;
    }

    accumViewportAgg (feature) {
        const propertyValue = this.property.eval(feature);

        if (propertyValue !== null) {
            const clusterCount = feature[_constants_metadata__WEBPACK_IMPORTED_MODULE_2__["CLUSTER_FEATURE_COUNT"]] || 1;
            this._count += clusterCount;
            this._sum += clusterCount * propertyValue;
        }
    }

    _resetViewportAgg () {
        this._sum = 0;
        this._count = 0;
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/viewport/ViewportCount.js":
/*!****************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/viewport/ViewportCount.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewportCount; });
/* harmony import */ var _ViewportAggregation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewportAggregation */ "./src/renderer/viz/expressions/aggregation/viewport/ViewportAggregation.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _constants_metadata__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../../constants/metadata */ "./src/constants/metadata.js");





/**
 * Return the feature count of the features showed in the viewport (features outside the viewport and features that don't pass the filter will be excluded).
 *
 * @return {Number} feature count in the viewport
 *
 * @example <caption>Assign the feature count in the viewport to a variable.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   variables: {
 *      v_count: s.viewportCount()
 *   }
 * });
 *
 * @example <caption>Assign the feature count in the viewport to a variable. (String)</caption>
 * const viz = new carto.Viz(`
 *   \@v_count: viewportCount()
 * `);
 *
 * @memberof carto.expressions
 * @name viewportCount
 * @function
 * @api
 */
class ViewportCount extends _ViewportAggregation__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor () {
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkMaxArguments"])(arguments, 0, 'viewportCount');
        super({ property: Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["number"])(0) });
        this._value = 0;
    }

    toString () {
        return `${this.expressionName}()`;
    }

    get value () {
        return this._value;
    }

    eval () {
        return this.value;
    }

    accumViewportAgg (feature) {
        const clusterCount = feature[_constants_metadata__WEBPACK_IMPORTED_MODULE_3__["CLUSTER_FEATURE_COUNT"]] || 1;
        this._value += clusterCount;
    }

    _resetViewportAgg () {
        this._value = 0;
    }

    _getMinimumNeededSchema () {
        return {};
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/viewport/ViewportMax.js":
/*!**************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/viewport/ViewportMax.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewportMax; });
/* harmony import */ var _ViewportAggregation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewportAggregation */ "./src/renderer/viz/expressions/aggregation/viewport/ViewportAggregation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");


/**
 * Return the maximum value of an expression for the features showed in the viewport (features outside the viewport and features that don't pass the filter will be excluded).
 *
 * @param {Number} input - numeric expression
 * @return {Number} Result of the aggregation
 *
 * @example <caption>Assign the maximum of the `amount` property in the viewport to a variable.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   variables: {
 *      v_max: s.viewportMax(s.prop('amount'))
 *   }
 * });
 *
 * @example <caption>Assign the maximum of the `amount` property in the viewport to a variable. (String)</caption>
 * const viz = new carto.Viz(`
 *   \@v_max: viewportMax($amount)
 * `);
 *
 * @memberof carto.expressions
 * @name viewportMax
 * @function
 * @api
 */
class ViewportMax extends _ViewportAggregation__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (property) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'viewportMax');
        super({ property });
        this._value = Number.NEGATIVE_INFINITY;
    }

    get value () {
        return this._value;
    }

    eval () {
        return this.value;
    }

    accumViewportAgg (feature) {
        const propertyValue = this.property.eval(feature);

        if (propertyValue !== null) {
            this._value = Math.max(this._value, propertyValue);
        }
    }

    _resetViewportAgg () {
        this._value = Number.NEGATIVE_INFINITY;
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/viewport/ViewportMin.js":
/*!**************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/viewport/ViewportMin.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewportMin; });
/* harmony import */ var _ViewportAggregation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewportAggregation */ "./src/renderer/viz/expressions/aggregation/viewport/ViewportAggregation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");



/**
 * Return the minimum value of an expression for the features showed in the viewport (features outside the viewport and features that don't pass the filter will be excluded).
 *
 * @param {Number} input - numeric expression
 * @return {Number} Result of the aggregation
 *
 * @example <caption>Assign the minimum of the `amount` property in the viewport to a variable.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   variables: {
 *      v_min: s.viewportMin(s.prop('amount'))
 *   }
 * });
 *
 * @example <caption>Assign the minimum of the `amount` property in the viewport to a variable. (String)</caption>
 * const viz = new carto.Viz(`
 *   \@v_min: viewportMin($amount)
 * `);
 *
 * @memberof carto.expressions
 * @name viewportMin
 * @function
 * @api
 */
class ViewportMin extends _ViewportAggregation__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (property) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'viewportMin');

        super({ property });
        this._value = Number.POSITIVE_INFINITY;
    }

    get value () {
        return this._value;
    }

    eval () {
        return this.value;
    }

    accumViewportAgg (feature) {
        const propertyValue = this.property.eval(feature);

        if (propertyValue !== null) {
            this._value = Math.min(this._value, propertyValue);
        }
    }

    _resetViewportAgg () {
        this._value = Number.POSITIVE_INFINITY;
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/viewport/ViewportPercentile.js":
/*!*********************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/viewport/ViewportPercentile.js ***!
  \*********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewportPercentile; });
/* harmony import */ var _ViewportAggregation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewportAggregation */ "./src/renderer/viz/expressions/aggregation/viewport/ViewportAggregation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _constants_metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../constants/metadata */ "./src/constants/metadata.js");



/**
 * Return the Nth percentile of an expression for the features showed in the viewport (features outside the viewport and features that don't pass the filter will be excluded).
 *
 * @param {Number} input - Numeric expression
 * @param {Number} percentile - Numeric expression [0, 100]
 * @return {Number} Result of the aggregation
 *
 * @example <caption>Assign the percentile of the `amount` property in the viewport to a variable.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   variables: {
 *      v_percentile: s.viewportPercentile(s.prop('amount'), 90)
 *   }
 * });
 *
 * @example <caption>Assign the percentile of the `amount` property in the viewport to a variable. (String)</caption>
 * const viz = new carto.Viz(`
 *   \@v_percentile: viewportPercentile($amount, 90)
 * `);
 *
 * @memberof carto.expressions
 * @name viewportPercentile
 * @function
 * @api
 */
class ViewportPercentile extends _ViewportAggregation__WEBPACK_IMPORTED_MODULE_0__["default"] {
    /**
     * @param {*} property
     * @param {*} percentile
     */
    constructor (property, percentile) {
        property = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(property);
        percentile = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(percentile);

        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('viewportPercentile', 'property', 0, property);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('viewportPercentile', 'percentile', 0, percentile);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 2, 'viewportPercentile');

        super({ property });
        this.percentile = percentile;
        this.childrenNames.push('percentile');
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('viewportPercentile', 'property', 0, 'number', this.property);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('viewportPercentile', 'percentile', 1, 'number', this.percentile);
    }

    get value () {
        return _nearestRankMethod(this.percentile.value, this._total, this._values);
    }

    eval (feature) {
        if (this._value === null) {
            this._value = _nearestRankMethod(this.percentile.eval(feature), this._total, this._values);
        }

        return this._value;
    }

    get _values () {
        return [...this._map.entries()];
    }

    _resetViewportAgg () {
        this._value = null;
        this._map = new Map();
        this._total = 0;
    }

    accumViewportAgg (feature) {
        const v = this.property.eval(feature);
        const clusterCount = feature[_constants_metadata__WEBPACK_IMPORTED_MODULE_2__["CLUSTER_FEATURE_COUNT"]] || 1;
        this._map.set(v, (this._map.get(v) || 0) + clusterCount);
        this._total += clusterCount;
    }
}

function _nearestRankMethod (value, total, values) {
    const unclampedIndex = Math.ceil(value / 100 * total) - 1;
    const index = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["clamp"])(unclampedIndex, 0, total - 1);

    values.sort((a, b) => a[0] - b[0]);

    let accum = 0;
    for (let i = 0; i < values.length; i++) {
        accum += values[i][1];
        values[i][1] = accum;
    }

    return binarySearch(values, index, 0, values.length - 1);
}

function binarySearch (array, index, begin, end) {
    const m = Math.round((begin + end) / 2);
    const upper = array[m][1];
    const lower = (array[m - 1] || [array[m][0] - 1, 0])[1];
    if (index >= lower && index < upper) {
        return array[m][0];
    } else if (index < lower) {
        return binarySearch(array, index, begin, m - 1);
    } else {
        return binarySearch(array, index, m + 1, end);
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/aggregation/viewport/ViewportSum.js":
/*!**************************************************************************!*\
  !*** ./src/renderer/viz/expressions/aggregation/viewport/ViewportSum.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewportSum; });
/* harmony import */ var _ViewportAggregation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ViewportAggregation */ "./src/renderer/viz/expressions/aggregation/viewport/ViewportAggregation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _constants_metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../../constants/metadata */ "./src/constants/metadata.js");




/**
 * Return the sum of an expression for the features showed in the viewport (features outside the viewport and features that don't pass the filter will be excluded).
 *
 * @param {Number} input - numeric expression
 * @return {Number} Result of the aggregation
 *
 * @example <caption>Assign the sum of the `amount` property in the viewport to a variable.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   variables: {
 *      v_sum: s.viewportSum(s.prop('amount'))
 *   }
 * });
 *
 * @example <caption>Assign the sum of the `amount` property in the viewport to a variable. (String)</caption>
 * const viz = new carto.Viz(`
 *   \@v_sum: viewportSum($amount)
 * `);
 *
 * @memberof carto.expressions
 * @name viewportSum
 * @function
 * @api
 */
class ViewportSum extends _ViewportAggregation__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (property) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'viewportSum');

        super({ property });
        this._value = 0;
    }

    get value () {
        return this._value;
    }

    eval () {
        return this.value;
    }

    accumViewportAgg (feature) {
        const propertyValue = this.property.eval(feature);

        if (propertyValue !== null) {
            const clusterCount = feature[_constants_metadata__WEBPACK_IMPORTED_MODULE_2__["CLUSTER_FEATURE_COUNT"]] || 1;
            this._value = this._value + clusterCount * propertyValue;
        }
    }

    _resetViewportAgg () {
        this._value = 0;
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/base.js":
/*!**********************************************!*\
  !*** ./src/renderer/viz/expressions/base.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Base; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../schema */ "./src/renderer/schema.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../errors/carto-runtime-error */ "./src/errors/carto-runtime-error.js");






/**
 * CARTO VL Expression
 *
 * An expression is a function that is used to modify the visualization. All expressions are listed in  {@link carto.expressions}.
 *
 * Any expression can be used where an expression is required as long as the types match. This means that you can't use a numeric expression where a color expression is expected.
 *
 * @name Expression
 * @abstract
 * @hideconstructor
 * @class
 * @api
 */
class Base {
    /**
     * @hideconstructor
     * @param {*} children
     * @param {*} inlineMaker
     * @param {*} preface
     */
    constructor (children) {
        this._initializeChildren(children);
        this.preface = '';
        this._shaderBindings = new Map();
        this.expressionName = _toCamelCase(this.constructor.name);
        this._variableName = null;
    }

    /**
     * Evaluate the expression providing a feature.
     * This is particularly useful for making legends.
     *
     * @memberof Expression
     * @param {Object} feature
     * @returns {} result - result of evaluating the expression for the input feature
     * @name eval
     * @api
     * @example
     * const viz = new carto.Viz(`
     *      color: red
     *      width: sqrt($amount)
     * `);
     *
     * const r = viz.width.eval({
     *      amount: 16
     * });
     *
     * // `r` value is `4`
     *
     * @example
     * const viz = new carto.Viz(`
     *      color: ramp(linear($amount), Emrld)
     * `);
     *
     * const color = viz.color.eval({
     *      amount: 123
     * });
     *
     * // `color` will have the same color as the features with an amount of 123
     *
     */
    eval () {
        return this.value;
    }

    /**
     * Get the expression value. It gets the data from the `getLegendData` method.
     *
     * @api
     * @memberof Expression
     * @name value
    */
    get value () {
        throw new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_4__["default"]('Must evaluate a feature using .eval(feature)');
    }

    /**
     * Get the expression values
     *
     * @api
     * @memberof Expression
     * @name values
     */
    get values () {
        return this.getLegendData().data;
    }

    /**
     * Get the expression stringified
     *
     * @api
     * @returns {String} Stringified expression
     * @memberof Expression
     * @instance
     * @name toString
     *
     * @example <caption>Get the stringified expression of the viz color property.</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz({
     *   color: s.ramp(s.linear('amount'), s.palettes.PRISM)
     * });
     * console.log(viz.color.toString());
     * // logs: "ramp(linear($amount), Prism)"
     *
     * @example <caption>Get the stringified expression of the viz color property. (String)</caption>
     * const viz = new carto.Viz(`
     *   color: ramp(linear($amount), Prism)
     * `);
     *
     * console.log(viz.color.toString());
     * // logs: "ramp(linear($amount), Prism)"
     *
     */
    toString () {
        return `${this.expressionName}(${this._getChildren().map(child => child.toString()).join(', ')})`;
    }

    /**
     *
     * @api
     * @returns `true` if the evaluation of the expression may change without external action, `false` otherwise.
     * @memberof Expression
     * @instance
     * @name isAnimated
     */
    isAnimated () {
        return this._getChildren().some(child => child.isAnimated());
    }

    /**
     *
     * @api
     * @returns `true` if the expression it is currently changing
     * @memberof Expression
     * @instance
     * @name isPlaying
     */
    isPlaying () {
        return this._getChildren().some(child => child.isPlaying());
    }

    /**
     * Linear interpolate between `this` and `final` with the specified duration
     *
     * @api
     * @param {Expression|string} final - Viz Expression or string to parse for a Viz expression
     * @param {Expression} duration - duration of the transition in milliseconds
     * @param {Expression} blendFunc
     * @memberof Expression
     * @instance
     * @async
     * @name blendTo
     */
    async blendTo (final, duration = 500) {
        // The previous parsing of 'final' (if it is a string) is monkey-patched at parser.js to avoid a circular dependency
        final = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["implicitCast"])(final);
        this.keepDefaultsOnBlend && this.keepDefaultsOnBlend();
        const parent = this.parent;
        const blender = Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["blend"])(this, final, Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["transition"])(duration));
        parent.replaceChild(this, blender);
        blender.notify();
    }

    isA (expressionClass) {
        return this instanceof expressionClass;
    }

    notify () {
        return this.parent.notify();
    }

    accumViewportAgg (feature) {
        this._getChildren().forEach(child => child.accumViewportAgg(feature));
    }

    loadImages () {
        return Promise.all(this._getChildren().map(child => child.loadImages()));
    }

    get propertyName () {
        return this._getChildren().map(child => child.propertyName).find(name => !!name);
    }

    /**
     * Get information data from the expression.
     *
     * @api
     * @memberof Expression
     * @name getLegendData
     * @typedef {String} PropertyName
     * @typedef {Array} LegendData
     * @returns {Object} - { PropertyName, LegendData }
     * @instance
    */
    getLegendData () {
        return {
            name: this.propertyName,
            data: []
        };
    }

    _bindMetadata (metadata) {
        this._getChildren().forEach(child => child._bindMetadata(metadata));
    }

    _initializeChildren (children) {
        if (Array.isArray(children)) {
            this._initializeChildrenArray(children);
        } else {
            this._initializeChildrenObject(children);
        }
        this._addParentToChildren();
    }

    _initializeChildrenArray (children) {
        if (this.maxParameters && this.maxParameters < children.length) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["default"](
                `Extra parameters, got ${children.length} but maximum is ${this.maxParameters}`,
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["CartoValidationErrorTypes"].TOO_MANY_ARGS
            );
        }

        this.childrenNames = [];

        children.map((child, index) => {
            const childName = `${child.type}-${index}`;
            this.childrenNames.push(childName);
            this[childName] = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["implicitCast"])(child);
        });
    }

    _initializeChildrenObject (children) {
        if (this.childrenNames === undefined) {
            this.childrenNames = [];
        }
        this.childrenNames.push(...Object.keys(children));

        if (this.maxParameters && this.maxParameters < this.childrenNames.length) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["default"](
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["CartoValidationErrorTypes"].TOO_MANY_ARGS, `Extra parameters, got ${this.childrenNames.length} but maximum is ${this.maxParameters}`
            );
        }

        Object.keys(children).map(name => {
            this[name] = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["implicitCast"])(children[name]);
        });
    }

    _addParentToChildren () {
        this._getChildren().map(child => {
            child.parent = this;
        });
    }

    _setUID (idGenerator) {
        this._uid = idGenerator.getID(this);
        this._getChildren().map(child => child._setUID(idGenerator));
    }

    _dataReady () {
        this._getChildren().map(child => child._dataReady());
    }

    isFeatureDependent () {
        return this._getChildren().some(child => child.isFeatureDependent());
    }

    _prefaceCode (glslCode) {
        return glslCode
            ? `\n${this._buildGLSLCode(glslCode)}\n`
            : '';
    }

    _buildGLSLCode (glslCode) {
        return `
            #ifndef DEF_${this._uid}
            #define DEF_${this._uid}
            ${glslCode}
            #endif`;
    }

    _getDependencies () {
        return this._getChildren().map(child => child._getDependencies()).reduce((x, y) => x.concat(y), []);
    }

    _resolveAliases (aliases) {
        this._getChildren().map(child => child._resolveAliases(aliases));
    }

    _setGenericGLSL (inlineMaker, preface) {
        this.inlineMaker = inlineMaker;
        this.preface = (preface || '');
    }

    // Generate GLSL code
    // @param {*} getGLSLforProperty  fn to get property IDs and inform of used properties
    _applyToShaderSource (getGLSLforProperty) {
        const childSources = this.childrenNames.map(name => this[name]._applyToShaderSource(getGLSLforProperty));
        let childInlines = {};
        childSources.map((source, index) => {
            childInlines[this.childrenNames[index]] = source.inline;
        });
        return {
            preface: this._prefaceCode(childSources.map(s => s.preface).reduce((a, b) => a + b, '') + this.preface),
            inline: this.inlineMaker(childInlines, getGLSLforProperty)
        };
    }

    // Inform about a successful shader compilation. One-time post-compilation WebGL calls should be done here.
    _postShaderCompile (program, gl) {
        this.childrenNames.forEach(name => this[name]._postShaderCompile(program, gl));
    }

    _getBinding (shader) {
        if (!this._shaderBindings.has(shader)) {
            this._shaderBindings.set(shader, {});
        }
        return this._shaderBindings.get(shader);
    }

    _resetViewportAgg (metadata) {
        this._getChildren().forEach(child => child._resetViewportAgg(metadata));
    }

    // Pre-rendering routine. Should establish the current timestamp in seconds since an arbitrary point in time as needed.
    // @param {number} timestamp
    _setTimestamp (timestamp) {
        this.childrenNames.forEach(name => this[name]._setTimestamp(timestamp));
    }

    // Pre-rendering routine. Should establish related WebGL state as needed.
    _preDraw (...args) {
        this.childrenNames.forEach(name => this[name]._preDraw(...args));
    }

    // Replace child *toReplace* by *replacer*
    replaceChild (toReplace, replacer) {
        const name = this.childrenNames.find(name => this[name] === toReplace);
        this[name] = replacer;
        replacer.parent = this;
        replacer.notify = toReplace.notify;
        replacer.notify().catch(() => { }); // ignore change rejections when using blend
    }

    _blendFrom (final, duration = 500, interpolator = null) {
        if (this.default && final.default) {
            return;
        }
        final = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["implicitCast"])(final);
        const parent = this.parent;
        const blender = Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["blend"])(final, this, Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["transition"])(duration), interpolator);
        parent.replaceChild(this, blender);
        blender.notify();
    }

    _getChildren () {
        return this.childrenNames.map(name => this[name]);
    }

    _getMinimumNeededSchema () {
        // Depth First Search => reduce using union
        return this._getChildren().map(child => child._getMinimumNeededSchema()).reduce(_schema__WEBPACK_IMPORTED_MODULE_2__["union"], _schema__WEBPACK_IMPORTED_MODULE_2__["IDENTITY"]);
    }
}

function _toCamelCase (str) {
    if (str.toUpperCase() === str) {
        return str.toLowerCase();
    }
    return str.charAt(0).toLowerCase() + str.slice(1);
}


/***/ }),

/***/ "./src/renderer/viz/expressions/basic/List.js":
/*!****************************************************!*\
  !*** ./src/renderer/viz/expressions/basic/List.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return List; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _ListImage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../ListImage */ "./src/renderer/viz/expressions/ListImage.js");
/* harmony import */ var _ListGeneric__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ListGeneric */ "./src/renderer/viz/expressions/basic/ListGeneric.js");
/* harmony import */ var _ListTransform__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../ListTransform */ "./src/renderer/viz/expressions/ListTransform.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");







const SUPPORTED_CHILD_TYPES = ['number', 'category', 'color', 'date', 'image', 'transformation'];

/**
 * Wrapper around arrays. Explicit usage is unnecessary since CARTO VL will wrap implicitly all arrays using this function.
 *
 * When used with Transformation expressions, the returned value will be a Transformation that will chain each single transformation one after another.
 *
 * @example <caption>Rotate then translate.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   symbol: s.CROSS
 *   transform: [s.rotate(90), s.translate(10, 20)]
 * });
 *
 * @example <caption>Rotate then translate. (String)</caption>
 * const viz = new carto.Viz(`
 *   symbol: cross
 *   transform: [rotate(90), translate(10, 20)]
 * `);
 *
 * @param {Number[]|Category[]|Color[]|Date[]|Image[]|Transform[]} elements
 * @returns {List|Transform}
 *
 * @memberof carto.expressions
 * @name list
 * @function
 * @api
 */
class List extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (elems) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'list');

        if (!elems) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_5__["default"](
                'list(): invalid parameters: must receive at least one argument.',
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_5__["CartoValidationErrorTypes"].MISSING_REQUIRED
            );
        }

        if (!Array.isArray(elems)) {
            elems = [elems];
        }

        elems = elems.map(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"]);

        if (!elems.length) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_5__["default"](
                'list(): invalid parameters: must receive at least one argument.',
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_5__["CartoValidationErrorTypes"].MISSING_REQUIRED
            );
        }

        elems.map((item, index) => {
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('list', `item[${index}]`, index, item);
        });

        super(elems);
        this.elems = elems;
        this.type = elems[0].type;
    }

    get value () {
        return this.elems.map(elem => elem.value);
    }

    eval (feature) {
        return this.elems.map(elem => elem.eval(feature));
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);
        this._setTypes();

        if (SUPPORTED_CHILD_TYPES.indexOf(this.childType) === -1) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_5__["default"](
                `list(): invalid parameters type: ${this.childType}.`,
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_5__["CartoValidationErrorTypes"].INCORRECT_TYPE
            );
        }

        this.elems.map((item, index) => {
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('list', `item[${index}]`, index, item);

            if (item.type !== this.childType) {
                throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_5__["default"](
                    `list(): invalid ${Object(_utils__WEBPACK_IMPORTED_MODULE_1__["getOrdinalFromIndex"])(index + 1)} parameter type, invalid argument type combination.`,
                    _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_5__["CartoValidationErrorTypes"].INCORRECT_TYPE
                );
            }
        });

        switch (this.elems[0].type) {
            case 'image':
                Object.setPrototypeOf(this, _ListImage__WEBPACK_IMPORTED_MODULE_2__["default"].prototype);
                break;
            case 'transformation':
                Object.setPrototypeOf(this, _ListTransform__WEBPACK_IMPORTED_MODULE_4__["default"].prototype);
                break;
            default:
                Object.setPrototypeOf(this, _ListGeneric__WEBPACK_IMPORTED_MODULE_3__["default"].prototype);
                break;
        }

        return this._bindMetadata(metadata);
    }

    _setTypes () {
        this.childType = this.elems[0].type;
        this.type = `${this.childType}-list`;
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/basic/ListGeneric.js":
/*!***********************************************************!*\
  !*** ./src/renderer/viz/expressions/basic/ListGeneric.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ListGeneric; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");


class ListGeneric extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    get value () {
        return this.elems.map(c => c.value);
    }

    eval (feature) {
        return this.elems.map(c => c.eval(feature));
    }

    _applyToShaderSource (getGLSLforProperty) {
        const childGLSL = this.elems.map(elem => elem._applyToShaderSource(getGLSLforProperty));
        return {
            preface: childGLSL.map(c => c.preface).join('\n'),
            inline: childGLSL.map(c => c.inline)
        };
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/basic/category.js":
/*!********************************************************!*\
  !*** ./src/renderer/viz/expressions/basic/category.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BaseCategory; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");



/**
 * Wrapper around category names. Explicit usage is unnecessary since CARTO VL will wrap implicitly all strings using this function.
 *
 * @param {String} categoryName
 * @returns {Category} category expression with the name provided
 *
 * @memberof carto.expressions
 * @name category
 * @function
 * @IGNOREapi
 */
class BaseCategory extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (categoryName) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'category');
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkString"])('category', 'categoryName', 0, categoryName);

        super({});
        this._value = categoryName;
        this.type = 'category';
    }

    get value () {
        return this._value;
    }

    set value (value) {
        this.value = value;
    }

    eval () {
        return this.value;
    }

    isAnimated () {
        return false;
    }

    isPlaying () {
        return false;
    }

    _bindMetadata (metadata) {
        this._metadata = metadata;
    }

    _applyToShaderSource () {
        return {
            preface: this._prefaceCode(`uniform float cat${this._uid};\n`),
            inline: `cat${this._uid}`
        };
    }

    _postShaderCompile (program, gl) {
        this._getBinding(program).uniformLocation = gl.getUniformLocation(program, `cat${this._uid}`);
    }

    _preDraw (program, drawMetadata, gl) {
        if (this._metadata) {
            const id = this._metadata.categoryToID.get(this.value);
            gl.uniform1f(this._getBinding(program).uniformLocation, id);
        }
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/basic/constant.js":
/*!********************************************************!*\
  !*** ./src/renderer/viz/expressions/basic/constant.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Constant; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");



/**
 * Wraps a constant number. Implies a GPU optimization vs {@link carto.expressions.number|number expression}.
 *
 * @param {number} x - A number to be warped in a constant numeric expression
 * @return {Number} Numeric expression
 *
 * @example <caption>Creating a constant number expression.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.constant(15)
 * });
 *
 * @example <caption>Creating a constant number expression. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: constant(15)
 * `);
 *
 * @memberof carto.expressions
 * @name constant
 * @function
 * @api
 */
class Constant extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (x) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'constant');
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkNumber"])('constant', 'x', 0, x);

        super({});
        this._value = x;
        this.type = 'number';
        this.inlineMaker = () => `(${x.toFixed(20)})`;
    }

    get value () {
        return this._value;
    }

    set value (value) {
        this._value = value;
    }

    eval () {
        return this.value;
    }

    toString () {
        return `${this.value}`;
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/basic/number.js":
/*!******************************************************!*\
  !*** ./src/renderer/viz/expressions/basic/number.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BaseNumber; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");



/**
 * Wraps a number. Explicit usage is unnecessary since CARTO VL will wrap implicitly all numbers using this function.
 *
 * @param {number} x - A number to be warped in a numeric expression
 * @return {Number} Numeric expression
 *
 * @example <caption>Creating a number expression.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.number(15)  // Equivalent to `width: 15`
 * });
 *
 * @example <caption>Creating a number expression. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: 15  // Equivalent to number(15)
 * `);
 *
 * @memberof carto.expressions
 * @name number
 * @function
 * @IGNOREapi
 */
class BaseNumber extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (x) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'number');
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkNumber"])('number', 'x', 0, x);

        super({});
        this._value = x;
        this.type = 'number';
    }

    get value () {
        return this._value;
    }

    set value (value) {
        this._value = value;
    }

    eval () {
        return this.value;
    }

    toString () {
        return `${this.value}`;
    }

    isAnimated () {
        return false;
    }

    isPlaying () {
        return false;
    }

    _applyToShaderSource () {
        return {
            preface: this._prefaceCode(`uniform float number${this._uid};`),
            inline: `number${this._uid}`
        };
    }

    _postShaderCompile (program, gl) {
        this._getBinding(program).uniformLocation = gl.getUniformLocation(program, `number${this._uid}`);
    }

    _preDraw (program, drawMetadata, gl) {
        gl.uniform1f(this._getBinding(program).uniformLocation, this.value);
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/basic/property.js":
/*!********************************************************!*\
  !*** ./src/renderer/viz/expressions/basic/property.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Property; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants */ "./src/renderer/viz/expressions/constants.js");
/* harmony import */ var _constants_metadata__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../constants/metadata */ "./src/constants/metadata.js");





/**
 * Evaluates the value of a column for every row in the dataset.
 *
 * For example think about a dataset containing 3 cities: Barcelona, Paris and London.
 * The `prop('name')` will return the name of the current city for every point in the dataset.
 *
 * @param {String} name - The property in the dataset that is going to be evaluated
 * @return {Number|Category|Date}
 *
 * @example <caption>Display only cities with name different from "London".</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *  filter: s.neq(s.prop('name'), 'london')
 * });
 *
 * @example <caption>Display only cities with name different from "London". (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: neq(prop('name'), 'london')
 * `);
 *
 * const viz = new carto.Viz(`
 *   filter: $name != 'london'
 * `);
 *
 * @memberof carto.expressions
 * @name prop
 * @function
 * @api
 */
class Property extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (name) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'property');
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkString"])('property', 'name', 0, name);

        if (name === '') {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
                'property(): invalid parameter, zero-length string',
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_VALUE
            );
        }
        super({});
        this.name = name;
        this.expressionName = name;
        super._setGenericGLSL((childInlines, getGLSLforProperty) => getGLSLforProperty(this.name));
    }

    isFeatureDependent () {
        return true;
    }

    get value () {
        return this.propertyName;
    }

    get propertyName () {
        return this.name;
    }

    eval (feature) {
        if (!feature) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
                'A property needs to be evaluated in a \'feature\'.',
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].MISSING_REQUIRED
            );
        }

        return feature[this.name] && feature[this.name] === _constants__WEBPACK_IMPORTED_MODULE_3__["FP32_DESIGNATED_NULL_VALUE"]
            ? null
            : feature[this.name];
    }

    toString () {
        return `$${this.name}`;
    }

    get categories () {
        return this.type === 'category'
            ? this._metadata.properties[this.name].categories
            : undefined;
    }

    _bindMetadata (metadata) {
        const metaColumn = metadata.properties[this.name];

        if (!metaColumn) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
                `Property '${this.name}' does not exist`,
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].MISSING_REQUIRED
            );
        }

        this._metadata = metadata;
        this.type = metaColumn.type;

        if (this.type === 'category' && this.numCategories === undefined) {
            Object.defineProperty(this, 'numCategories', {
                get: function () {
                    return metaColumn.categories.length;
                }
            });
        }
    }

    _applyToShaderSource (getGLSLforProperty) {
        return {
            preface: '',
            inline: getGLSLforProperty(this.name)
        };
    }

    _getMinimumNeededSchema () {
        const type = this._variableName
            ? _constants_metadata__WEBPACK_IMPORTED_MODULE_4__["aggregationTypes"].UNKNOWN
            : _constants_metadata__WEBPACK_IMPORTED_MODULE_4__["aggregationTypes"].UNAGGREGATED;

        return {
            [this.name]: [{ type }]
        };
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/basic/variable.js":
/*!********************************************************!*\
  !*** ./src/renderer/viz/expressions/basic/variable.js ***!
  \********************************************************/
/*! exports provided: Variable, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Variable", function() { return Variable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return variable; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");




/**
 * Alias to a named variable defined in the Viz.
 *
 * @param {String} name - The variable name that is going to be evaluated
 * @return {Number|Category|Color|Date}
 *
 * @example <caption></caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   variables: {
 *     sum_price: s.clusterSum(s.prop('price'))
 *   }
 *  filter: s.neq(s.var('sum_price'), 'london')
 * });
 *
 * @example <caption>(String)</caption>
 * const viz = new carto.Viz(`
 *   \@sum_price: clusterSum($price)
 *   filter: $price == 30  // Equivalent to eq($price, 30)
 * `);
 *
 * @memberof carto.expressions
 * @name var
 * @function
 * @api
 */
class Variable extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor () {
        super({});
    }
}

function variable (name) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'variable');
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkString"])('variable', 'name', 0, name);

    if (name === '') {
        throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
            'variable(): invalid parameter, zero-length string',
            _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_VALUE
        );
    }

    let alias;

    const resolve = aliases => {
        if (aliases[name]) {
            alias = aliases[name];
        } else {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
                `variable() with name '${name}' doesn't exist`,
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].MISSING_REQUIRED
            );
        }
    };

    const _getDependencies = () => {
        return [alias];
    };

    let aliaser = {
        set: (obj, prop, value) => {
            if (prop === 'parent') {
                obj[prop] = value;
            } else if (prop === 'notify') {
                obj[prop] = value;
            } else if (alias && alias[prop]) {
                alias[prop] = value;
            } else {
                return false;
            }

            return true;
        },

        get: (obj, prop) => {
            switch (prop) {
                case 'propertyName':
                    return alias.propertyName;
                case 'name':
                    return alias._dimension ? alias.propertyName : alias.name;
                case 'parent':
                case 'notify':
                case 'blendTo':
                    return obj[prop];
                case '_resolveAliases':
                    return resolve;
                case '_getDependencies':
                    return _getDependencies;
                default:
                    if (alias !== undefined) {
                        const p = alias[prop];
                        if (p !== undefined) {
                            if (p.bind) {
                                return p.bind(alias);
                            }
                            return p;
                        }
                    }
                    return obj[prop];
            }
        }
    };

    return new Proxy(new Variable(), aliaser);
}


/***/ }),

/***/ "./src/renderer/viz/expressions/belongs.js":
/*!*************************************************!*\
  !*** ./src/renderer/viz/expressions/belongs.js ***!
  \*************************************************/
/*! exports provided: In, Nin */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "In", function() { return In; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Nin", function() { return Nin; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");



/**
 * Check if a categorical value belongs to a list of categories.
 *
 * @param {Category|Number} input - Categorical or numeric expression to be tested against the whitelist
 * @param {Category[]|Number[]} list - Multiple expression parameters that will form the whitelist
 * @return {Number} Numeric expression with the result of the check
 *
 * @example <caption>Display only cities where $type is 'metropolis' or 'capital'.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   filter: s.in(s.prop('type'), ['metropolis', 'capital'])
 * });
 *
 * @example <caption>Display only cities where $type is 'metropolis' or 'capital'. (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: $type in ['metropolis', 'capital']
 * `);
 *
 * @example <caption>Display only products where $amount is 10, 15 or 20.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   filter: s.in(s.prop('amount'), [10, 15, 20])
 * });
 *
 * @example <caption>Display only products where $amount is 10, 15 or 20. (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: $amount in [10, 15, 20]
 * `);
 *
 * @memberof carto.expressions
 * @name in
 * @function
 * @api
 */
const In = generateBelongsExpression('in', (input, list) => list.some(item => item === input) ? 1 : 0);

const belongsReturn = {
    nin: {
        check: '1.',
        result: '0.'
    },
    in: {
        check: '0.',
        result: '1.'
    }
};

/**
 * Check if value does not belong to the list of elements.
 *
 * @param {Category|Number} input - Categorical or numeric expression to be tested against the blacklist
 * @param {Category[]|Number[]} list - Multiple expression parameters that will form the blacklist
 * @return {Number} Numeric expression with the result of the check
 *
 * @example <caption>Display only cities where $type is not 'metropolis' or 'capital'.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   filter: s.nin(s.prop('type'), ['metropolis', 'capital'])
 * });
 *
 * @example <caption>Display only cities where $type is not 'metropolis' or 'capital'. (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: $type nin ['metropolis', 'capital']
 * `);
 *
 * @example <caption>Display only products where $amount is not 10, 15 or 20.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   filter: s.nin(s.prop('amount'), [10, 15, 20])
 * });
 *
 * @example <caption>Display only products where $amount is not 10, 15 or 20. (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: $amount nin [10, 15, 20]
 * `);
 *
 * @memberof carto.expressions
 * @name nin
 * @function
 * @api
 */
const Nin = generateBelongsExpression('nin', (input, list) => list.some(item => item === input) ? 0 : 1);

function generateBelongsExpression (name, jsEval) {
    return class BelongExpression extends _base__WEBPACK_IMPORTED_MODULE_1__["default"] {
        constructor (input, list) {
            Object(_utils__WEBPACK_IMPORTED_MODULE_0__["checkMaxArguments"])(arguments, 2, name);

            input = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["implicitCast"])(input);
            list = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["implicitCast"])(list);

            Object(_utils__WEBPACK_IMPORTED_MODULE_0__["checkExpression"])(name, 'input', 0, input);
            Object(_utils__WEBPACK_IMPORTED_MODULE_0__["checkExpression"])(name, ['list', 'variable'], 1, list);

            super({ input, list });

            this.type = 'number';
            this.name = name;
        }

        get value () {
            return jsEval(this.input.value, this.list.value);
        }

        eval (feature) {
            return jsEval(this.input.eval(feature), this.list.eval(feature));
        }

        _applyToShaderSource (getGLSLforProperty) {
            const childSourcesArray = this.childrenNames.map(name => this[name]._applyToShaderSource(getGLSLforProperty));

            let childSources = {};
            childSourcesArray.map((source, index) => {
                childSources[this.childrenNames[index]] = source;
            });

            const funcName = `belongs${this._uid}`;
            const funcList = this._getFuncList();
            const funcBody = this.list.elems.map(funcList).join('');
            const checkValue = belongsReturn[this.name].check;

            const preface = `float ${funcName}(float x){
                ${funcBody}

                return ${checkValue};
            }`;

            return {
                preface: this._prefaceCode(childSources.input.preface + childSources.list.preface + preface),
                inline: `${funcName}(${childSources.input.inline})`
            };
        }

        _getFuncList () {
            const returnValue = belongsReturn[this.name].result;

            return (elem) => {
                const x = this.input.type === 'number' ? `${elem}.0` : `cat${elem._uid}`;
                return `if (x==${x}) { return ${returnValue}; }`;
            };
        }

        _bindMetadata (meta) {
            super._bindMetadata(meta);
            const validTypes = ['number', 'category'];

            validTypes.forEach((type) => {
                if (this.input.type === type) {
                    Object(_utils__WEBPACK_IMPORTED_MODULE_0__["checkType"])(name, 'input', 0, type, this.input);
                    Object(_utils__WEBPACK_IMPORTED_MODULE_0__["checkType"])(name, 'list', 1, `${type}-list`, this.list);
                }
            });
        }
    };
}


/***/ }),

/***/ "./src/renderer/viz/expressions/between.js":
/*!*************************************************!*\
  !*** ./src/renderer/viz/expressions/between.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Between; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");



/**
 * Check if a given value is contained within an inclusive range (including the limits).
 *
 * This returns a numeric expression where 0 means `false` and 1 means `true`.
 *
 * @param {Number} input - Numeric expression that is going to be tested against the [lowerLimit, upperLimit] range
 * @param {Number} lowerLimit - Numeric expression with the lower limit of the range
 * @param {Number} upperLimit -  Numeric expression with the upper limit of the range
 * @return {Number} Numeric expression with the result of the check
 *
 * @example <caption>Display only cities where the population density is within the [50,100] range.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   filter: s.between(s.prop('dn'), 50, 100);
 * });
 *
 * @example <caption>Display only cities where the population density is within the [50,100] range. (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: between($dn, 50, 100)
 * `);
 *
 * @memberof carto.expressions
 * @name between
 * @function
 * @api
 */
class Between extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (input, lowerLimit, upperLimit) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 3, 'between');

        input = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(input);
        lowerLimit = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(lowerLimit);
        upperLimit = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(upperLimit);

        super({ input, lowerLimit, upperLimit });
        this.type = 'number';
        this.inlineMaker = inline => `((${inline.input} >= ${inline.lowerLimit} &&  ${inline.input} <= ${inline.upperLimit}) ? 1. : 0.)`;
    }

    eval (feature) {
        const input = this.input.eval(feature);
        const lower = this.lowerLimit.eval(feature);
        const upper = this.upperLimit.eval(feature);
        return (input >= lower && input <= upper) ? 1 : 0;
    }

    _bindMetadata (meta) {
        super._bindMetadata(meta);

        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('between', 'input', 0, ['number', 'date'], this.input);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('between', 'lowerLimit', 1, ['number', 'date'], this.lowerLimit);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('between', 'upperLimit', 2, ['number', 'date'], this.upperLimit);
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/binary/Add.js":
/*!****************************************************!*\
  !*** ./src/renderer/viz/expressions/binary/Add.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Add; });
/* harmony import */ var _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BinaryOperation */ "./src/renderer/viz/expressions/binary/BinaryOperation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");




/**
 * Add two numeric expressions.
 *
 * @param {Number|Color} x - First value to add
 * @param {Number|Color} y - Second value to add
 * @return {Number|Color} Result of the addition
 *
 * @example <caption>Number addition.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.add(10, 2)  // 12
 * });
 *
 * @example <caption>Number addition. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: 10 + 2  // Equivalent to add(10, 2)
 * `);
 *
 * @memberof carto.expressions
 * @name add
 * @function
 * @api
 */
class Add extends _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["BinaryOperation"] {
    constructor (a, b) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 2);

        const signatureMethods = {
            1: (x, y) => x + y, // NUMBERS_TO_NUMBER
            4: _addColors // COLORS_TO_COLOR
        };

        const glsl = (x, y) => `(${x} + ${y})`;

        super(a, b, signatureMethods, glsl);
        this.allowedSignature = _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["NUMBERS_TO_NUMBER"] | _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["COLORS_TO_COLOR"] | _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["IMAGES_TO_IMAGE"];
    }
}

function _addColors (colorA, colorB) {
    const r = colorA.r + colorB.r < 255 ? colorA.r + colorB.r : 255;
    const g = colorA.g + colorB.g < 255 ? colorA.g + colorB.g : 255;
    const b = colorA.b + colorB.b < 255 ? colorA.b + colorB.b : 255;
    const a = colorA.a;

    return { r, g, b, a };
}


/***/ }),

/***/ "./src/renderer/viz/expressions/binary/And.js":
/*!****************************************************!*\
  !*** ./src/renderer/viz/expressions/binary/And.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return And; });
/* harmony import */ var _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BinaryOperation */ "./src/renderer/viz/expressions/binary/BinaryOperation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");




/**
 * Perform a binary AND between two numeric expressions.
 * If the numbers are different from 0 or 1 this performs a [fuzzy and operation](https://en.wikipedia.org/wiki/Fuzzy_logic#Fuzzification).
 * This fuzzy behavior will allow transitions to work in a continuos, non-discrete, fashion.
 *
 * This returns a number expression where 0 means `false` and 1 means `true`.
 *
 * @param {Number} x - First value of the expression
 * @param {Number} y - Second value of the expression
 * @return {Number} Result of the expression
 *
 * @example <caption>Show only elements with price < 30 AND category === 'fruit'.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   filter: s.and(
 *     s.lt(s.prop('price'), 30),
 *     s.eq(s.prop('category'), 'fruit')
 *   )
 * });
 *
 * @example <caption>Show only elements with price < 30 AND category === 'fruit'. (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: $price < 30 and $category === 'fruit'  // Equivalent to and(lt($price, 30), eq($category, 'fruit'))
 * `);
 *
 * @memberof carto.expressions
 * @name and
 * @function
 * @api
 */
class And extends _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["BinaryOperation"] {
    constructor (a, b) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 2);

        const signatureMethods = {
            1: (x, y) => Math.min(x * y, 1) // NUMBERS_TO_NUMBER
        };

        const glsl = (x, y) => `min(${x} * ${y}, 1.)`;

        a = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(a);
        b = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(b);

        super(a, b, signatureMethods, glsl);
        this.allowedSignature = _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["NUMBERS_TO_NUMBER"];
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/binary/BinaryOperation.js":
/*!****************************************************************!*\
  !*** ./src/renderer/viz/expressions/binary/BinaryOperation.js ***!
  \****************************************************************/
/*! exports provided: UNSUPPORTED_SIGNATURE, NUMBERS_TO_NUMBER, NUMBER_AND_COLOR_TO_COLOR, COLORS_TO_COLOR, CATEGORIES_TO_NUMBER, IMAGES_TO_IMAGE, DATES_TO_DATES, BinaryOperation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UNSUPPORTED_SIGNATURE", function() { return UNSUPPORTED_SIGNATURE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NUMBERS_TO_NUMBER", function() { return NUMBERS_TO_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NUMBER_AND_COLOR_TO_COLOR", function() { return NUMBER_AND_COLOR_TO_COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLORS_TO_COLOR", function() { return COLORS_TO_COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CATEGORIES_TO_NUMBER", function() { return CATEGORIES_TO_NUMBER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IMAGES_TO_IMAGE", function() { return IMAGES_TO_IMAGE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DATES_TO_DATES", function() { return DATES_TO_DATES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BinaryOperation", function() { return BinaryOperation; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../expressions */ "./src/renderer/viz/expressions.js");





const UNSUPPORTED_SIGNATURE = 0;
const NUMBERS_TO_NUMBER = 1;
const NUMBER_AND_COLOR_TO_COLOR = 2;
const COLORS_TO_COLOR = 4;
const CATEGORIES_TO_NUMBER = 8;
const IMAGES_TO_IMAGE = 16;
const DATES_TO_DATES = 32;

const signature = {
    0: null,
    1: 'number',
    2: 'color',
    4: 'color',
    8: 'number',
    16: 'image',
    32: 'date'
};

class BinaryOperation extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (a, b, signatureMethods, glsl) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 4);

        if (Number.isFinite(a) && Number.isFinite(b)) {
            return Object(_expressions__WEBPACK_IMPORTED_MODULE_3__["number"])(signatureMethods[NUMBERS_TO_NUMBER](a, b));
        }

        a = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(a);
        b = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(b);

        super({ a, b });

        this.signatureMethods = signatureMethods;
        this._signature = getSignature(a, b);
        this.glsl = glsl;
        this.allowedSignature = UNSUPPORTED_SIGNATURE;
        this.type = signature[this._signature];
        this.inlineMaker = inline => glsl(inline.a, inline.b);
    }

    get value () {
        return this.operation(this.a.value, this.b.value);
    }

    get operation () {
        return this.signatureMethods[this._signature] || this.signatureMethods[NUMBERS_TO_NUMBER];
    }

    eval (...features) {
        if (Number.isFinite(this.a) && Number.isFinite(this.b)) {
            return this.operation(this.a.value, this.b.value);
        }

        if (Number.isFinite(this.a)) {
            return this.operation(this.a.value, this.b.eval(features[0]));
        }

        if (Number.isFinite(this.b)) {
            return this.operation(this.a.eval(features[0]), this.b.value);
        }

        const { featureA, featureB } = this._getDependentFeatures(features);
        const valueA = this.a.eval(featureA);
        const valueB = this.b.eval(featureB);

        return this.operation(valueA, valueB);
    }

    getLegendData (options) {
        const legendDataA = this.a.getLegendData(options);
        const legendDataB = this.b.getLegendData(options);
        const SIZE_A = legendDataA.data.length;
        const SIZE_B = legendDataB.data.length;
        const data = [];

        for (let i = 0; i < SIZE_A; i++) {
            for (let j = 0; j < SIZE_B; j++) {
                const value = this.operation(legendDataA.data[i].value, legendDataB.data[j].value);
                data.push({ value });
            }
        }

        return { n: SIZE_A, m: SIZE_B, data };
    }

    _getDependentFeatures (features) {
        const { featureA, featureB } = features.length > 1
            ? { featureA: features[0], featureB: features[1] }
            : { featureA: features[0], featureB: features[0] };

        return { featureA, featureB };
    }

    _bindMetadata (meta) {
        super._bindMetadata(meta);
        const [a, b] = [this.a, this.b];

        this._signature = getSignature(a, b);
        if (this._signature === UNSUPPORTED_SIGNATURE || !(this._signature & this.allowedSignature)) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
                `${this.expressionName}(): invalid parameter types\n'x' type was ${a.type}, 'y' type was ${b.type}`,
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_TYPE
            );
        }
        this.type = getReturnTypeFromSignature(this._signature);
    }
}

function getSignature (a, b) {
    if (!a.type || !b.type) {
        return undefined;
    } else if (a.type === 'date' && b.type === 'date') {
        return DATES_TO_DATES;
    } else if (a.type === 'number' && b.type === 'number') {
        return NUMBERS_TO_NUMBER;
    } else if (a.type === 'number' && b.type === 'color') {
        return NUMBER_AND_COLOR_TO_COLOR;
    } else if (a.type === 'color' && b.type === 'number') {
        return NUMBER_AND_COLOR_TO_COLOR;
    } else if (a.type === 'color' && b.type === 'color') {
        return COLORS_TO_COLOR;
    } else if (a.type === 'category' && b.type === 'category') {
        return CATEGORIES_TO_NUMBER;
    } else if ((a.type === 'image' && b.type === 'color') ||
        (a.type === 'image' && b.type === 'color') ||
        (a.type === 'image' && b.type === 'image') ||
        (a.type === 'color' && b.type === 'image')) {
        return IMAGES_TO_IMAGE;
    } else {
        return UNSUPPORTED_SIGNATURE;
    }
}

function getReturnTypeFromSignature (signature) {
    switch (signature) {
        case NUMBERS_TO_NUMBER:
            return 'number';
        case NUMBER_AND_COLOR_TO_COLOR:
            return 'color';
        case COLORS_TO_COLOR:
            return 'color';
        case CATEGORIES_TO_NUMBER:
            return 'number';
        case IMAGES_TO_IMAGE:
            return 'image';
        default:
            return undefined;
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/binary/Div.js":
/*!****************************************************!*\
  !*** ./src/renderer/viz/expressions/binary/Div.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Div; });
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _BinaryOperation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BinaryOperation */ "./src/renderer/viz/expressions/binary/BinaryOperation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");





/**
 * Divide two numeric expressions.
 *
 * @param {Number|Color} numerator - Numerator of the division
 * @param {Number|Color} denominator - Denominator of the division
 * @return {Number|Color} Result of the division
 *
 * @example <caption>Number division.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.div(10, 2)  // 5
 * });
 *
 * @example <caption>Number division. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: 10 / 2  // Equivalent to div(10, 2)
 * `);
 *
 * @memberof carto.expressions
 * @name div
 * @function
 * @api
 */
class Div extends _BinaryOperation__WEBPACK_IMPORTED_MODULE_1__["BinaryOperation"] {
    constructor (a, b) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkMaxArguments"])(arguments, 2);

        if (Number.isFinite(a) && Number.isFinite(b)) {
            return Object(_expressions__WEBPACK_IMPORTED_MODULE_0__["number"])(a / b);
        }

        const signatureMethods = {
            1: (x, y) => x / y, // NUMBERS_TO_NUMBER
            2: _divNumberColor, // NUMBER_AND_COLOR_TO_COLOR
            4: _divColors // COLORS_TO_COLOR
        };

        const glsl = (x, y) => `(${x} / ${y})`;

        a = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["implicitCast"])(a);
        b = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["implicitCast"])(b);

        super(a, b, signatureMethods, glsl);
        this.allowedSignature = _BinaryOperation__WEBPACK_IMPORTED_MODULE_1__["NUMBERS_TO_NUMBER"] | _BinaryOperation__WEBPACK_IMPORTED_MODULE_1__["NUMBER_AND_COLOR_TO_COLOR"] | _BinaryOperation__WEBPACK_IMPORTED_MODULE_1__["COLORS_TO_COLOR"] | _BinaryOperation__WEBPACK_IMPORTED_MODULE_1__["IMAGES_TO_IMAGE"];
    }
}

function _divColors (colorA, colorB) {
    return {
        r: Math.round(colorA.r / colorB.r),
        g: Math.round(colorA.g / colorB.g),
        b: Math.round(colorA.b / colorB.b),
        a: colorA.a
    };
}

function _divNumberColor (valueA, valueB) {
    const { n, color } = typeof valueA === 'number'
        ? { n: valueA, color: valueB }
        : { n: valueB, color: valueA };

    return {
        r: Math.round(color.r / n),
        g: Math.round(color.g / n),
        b: Math.round(color.b / n),
        a: color.a
    };
}


/***/ }),

/***/ "./src/renderer/viz/expressions/binary/Equals.js":
/*!*******************************************************!*\
  !*** ./src/renderer/viz/expressions/binary/Equals.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Equals; });
/* harmony import */ var _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BinaryOperation */ "./src/renderer/viz/expressions/binary/BinaryOperation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");




/**
 * Compare if x is equal to a y.
 *
 * This returns a numeric expression where 0 means `false` and 1 means `true`.
 *
 * @param {Number|Category} x - Firt value of the comparison
 * @param {Number|Category} y - Second value of the comparison
 * @return {Number} Result of the comparison: 0 or 1
 *
 * @example <caption>Compare two numbers to show only elements with price equal to 30.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   filter: s.eq(s.prop('price'), 30)
 * });
 *
 * @example <caption>Compare two numbers to show only elements with price equal to 30. (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: $price == 30  // Equivalent to eq($price, 30)
 * `);
 *
 * @memberof carto.expressions
 * @name eq
 * @function
 * @api
 */
class Equals extends _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["BinaryOperation"] {
    constructor (a, b) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 2);

        const signatureMethods = {
            1: (x, y) => x === y ? 1 : 0, // NUMBERS_TO_NUMBER,
            8: (x, y) => x === y ? 1 : 0 // CATEGORIES_TO_NUMBER
        };

        const glsl = (x, y) => `(${x}==${y}? 1.:0.)`;

        super(a, b, signatureMethods, glsl);
        this.allowedSignature = _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["NUMBERS_TO_NUMBER"] | _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["CATEGORIES_TO_NUMBER"];
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/binary/GreaterThan.js":
/*!************************************************************!*\
  !*** ./src/renderer/viz/expressions/binary/GreaterThan.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GreaterThan; });
/* harmony import */ var _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BinaryOperation */ "./src/renderer/viz/expressions/binary/BinaryOperation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");




/**
 * Compare if x is greater than y.
 *
 * This returns a numeric expression where 0 means `false` and 1 means `true`.
 *
 * @param {Number} x - Firt value of the comparison
 * @param {Number} y - Firt value of the comparison
 * @return {Number} Result of the comparison: 0 or 1
 *
 * @example <caption>Compare two numbers to show only elements with price greater than 30.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   filter: s.gt(s.prop('price'), 30)
 * });
 *
 * @example <caption>Compare two numbers to show only elements with price greater than 30. (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: $price > 30  // Equivalent to gt($price, 30)
 * `);
 *
 * @memberof carto.expressions
 * @name gt
 * @function
 * @api
 */
class GreaterThan extends _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["BinaryOperation"] {
    constructor (a, b) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 2);

        const signatureMethods = {
            1: (x, y) => x > y ? 1 : 0 // NUMBERS_TO_NUMBER
        };

        const glsl = (x, y) => `(${x}>${y}? 1.:0.)`;

        super(a, b, signatureMethods, glsl);
        this.allowedSignature = _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["NUMBERS_TO_NUMBER"] | _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["DATES_TO_DATES"];
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/binary/GreaterThanOrEqualTo.js":
/*!*********************************************************************!*\
  !*** ./src/renderer/viz/expressions/binary/GreaterThanOrEqualTo.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GreaterThanOrEqualTo; });
/* harmony import */ var _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BinaryOperation */ "./src/renderer/viz/expressions/binary/BinaryOperation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");




/**
 * Compare if x is greater than or equal to y.
 *
 * This returns a numeric expression where 0 means `false` and 1 means `true`.
 *
 * @param {Number} x - Firt value of the comparison
 * @param {Number} y - Second value of the comparison
 * @return {Number} Result of the comparison: 0 or 1
 *
 * @example <caption>Compare two numbers to show only elements with price greater than or equal to 30.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   filter: s.gte(s.prop('price'), 30)
 * });
 *
 * @example <caption>Compare two numbers to show only elements with price greater than or equal to 30. (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: $price >= 30  // Equivalent to gte($price, 30)
 * `);
 *
 * @memberof carto.expressions
 * @name gte
 * @function
 * @api
 */
class GreaterThanOrEqualTo extends _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["BinaryOperation"] {
    constructor (a, b) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 2);

        const signatureMethods = {
            1: (x, y) => x >= y ? 1 : 0 // NUMBERS_TO_NUMBER
        };

        const glsl = (x, y) => `(${x}>=${y}? 1.:0.)`;

        super(a, b, signatureMethods, glsl);
        this.allowedSignature = _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["NUMBERS_TO_NUMBER"] | _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["DATES_TO_DATES"];
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/binary/LessThan.js":
/*!*********************************************************!*\
  !*** ./src/renderer/viz/expressions/binary/LessThan.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LessThan; });
/* harmony import */ var _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BinaryOperation */ "./src/renderer/viz/expressions/binary/BinaryOperation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");




/**
 * Compare if x is lower than y.
 *
 * This returns a numeric expression where 0 means `false` and 1 means `true`.
 *
 * @param {Number} x - Firt value of the comparison
 * @param {Number} y - Second value of the comparison
 * @return {Number} Result of the comparison: 0 or 1
 *
 * @example <caption>Compare two numbers to show only elements with price less than 30.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   filter: s.lt(s.prop('price'), 30)
 * });
 *
 * @example <caption>Compare two numbers to show only elements with price less than 30. (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: $price < 30  // Equivalent to lt($price, 30)
 * `);
 *
 * @memberof carto.expressions
 * @name lt
 * @function
 * @api
 */
class LessThan extends _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["BinaryOperation"] {
    constructor (a, b) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 2);

        const signatureMethods = {
            1: (x, y) => x < y ? 1 : 0 // NUMBERS_TO_NUMBER
        };

        const glsl = (x, y) => `(${x}<${y}? 1.:0.)`;

        super(a, b, signatureMethods, glsl);
        this.allowedSignature = _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["NUMBERS_TO_NUMBER"] | _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["DATES_TO_DATES"];
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/binary/LessThanOrEqualTo.js":
/*!******************************************************************!*\
  !*** ./src/renderer/viz/expressions/binary/LessThanOrEqualTo.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LessThanOrEqualTo; });
/* harmony import */ var _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BinaryOperation */ "./src/renderer/viz/expressions/binary/BinaryOperation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");




/**
 * Compare if x is lower than or equal to y.
 *
 * This returns a numeric expression where 0 means `false` and 1 means `true`.
 *
 * @param {Number} x - Firt value of the comparison
 * @param {Number} y - Second value of the comparison
 * @return {Number} Result of the comparison: 0 or 1
 *
 * @example <caption>Compare two numbers to show only elements with price less than or equal to 30.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   filter: s.lte(s.prop('price'), 30)
 * });
 *
 * @example <caption>Compare two numbers to show only elements with price less than or equal to 30. (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: $price <= 30  // Equivalent to lte($price, 30)
 * `);
 *
 * @memberof carto.expressions
 * @name lte
 * @function
 * @api
 */
class LessThanOrEqualTo extends _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["BinaryOperation"] {
    constructor (a, b) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 2);

        const signatureMethods = {
            1: (x, y) => x <= y ? 1 : 0 // NUMBERS_TO_NUMBER
        };

        const glsl = (x, y) => `(${x}<=${y}? 1.:0.)`;

        super(a, b, signatureMethods, glsl);
        this.allowedSignature = _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["NUMBERS_TO_NUMBER"] | _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["DATES_TO_DATES"];
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/binary/Mod.js":
/*!****************************************************!*\
  !*** ./src/renderer/viz/expressions/binary/Mod.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Mod; });
/* harmony import */ var _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BinaryOperation */ "./src/renderer/viz/expressions/binary/BinaryOperation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");




/**
 * Modulus of two numeric expressions, mod returns a numeric expression with the value of x module y. This is computed as x - y * floor(x/y).
 *
 * @param {Number} x - First value of the modulus
 * @param {Number} y - Second value of the modulus
 * @return {Number} Result of the modulus
 *
 * @example <caption>Number modulus.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.mod(10, 6)  // 4
 * });
 *
 * @example <caption>Number modulus. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: 10 % 6  // Equivalent to mod(10, 6)
 * `);
 *
 * @memberof carto.expressions
 * @name mod
 * @function
 * @api
 */
class Mod extends _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["BinaryOperation"] {
    constructor (a, b) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 2);

        const signatureMethods = {
            1: (x, y) => x % y // NUMBERS_TO_NUMBER
        };

        const glsl = (x, y) => `mod(${x}, ${y})`;

        a = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(a);
        b = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(b);

        super(a, b, signatureMethods, glsl);
        this.allowedSignature = _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["NUMBERS_TO_NUMBER"] | _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["DATES_TO_DATES"];
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/binary/Mul.js":
/*!****************************************************!*\
  !*** ./src/renderer/viz/expressions/binary/Mul.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Mul; });
/* harmony import */ var _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BinaryOperation */ "./src/renderer/viz/expressions/binary/BinaryOperation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");




/**
 * Multiply two numeric expressions.
 *
 * @param {Number|Color} x - First value to multiply
 * @param {Number|Color} y - Second value to multiply
 * @return {Number|Color} Result of the multiplication
 *
 * @example <caption>Number multiplication.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.mul(5, 5)  // 25
 * });
 *
 * @example <caption>Number multiplication. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: 5 * 5  // Equivalent to mul(5, 5)
 * `);
 *
 * @memberof carto.expressions
 * @name mul
 * @function
 * @api
 */
class Mul extends _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["BinaryOperation"] {
    constructor (a, b) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 2);

        const signatureMethods = {
            1: (x, y) => x * y, // NUMBERS_TO_NUMBER
            2: _mulNumberColor, // NUMBER_AND_COLOR_TO_COLOR
            4: _mulColors // COLORS_TO_COLOR
        };

        const glsl = (x, y) => `(${x} * ${y})`;

        super(a, b, signatureMethods, glsl);
        this.allowedSignature = _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["NUMBERS_TO_NUMBER"] | _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["NUMBER_AND_COLOR_TO_COLOR"] | _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["COLORS_TO_COLOR"] | _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["IMAGES_TO_IMAGE"];
    }
}

function _mulColors (colorA, colorB) {
    return {
        r: Math.round(colorA.r * colorB.r / 255),
        g: Math.round(colorA.g * colorB.g / 255),
        b: Math.round(colorA.b * colorB.b / 255),
        a: colorA.a
    };
}

function _mulNumberColor (valueA, valueB) {
    const { n, color } = typeof valueA === 'number'
        ? { n: valueA, color: valueB }
        : { n: valueB, color: valueA };

    return {
        r: Math.round(n * color.r / 255),
        g: Math.round(n * color.g / 255),
        b: Math.round(n * color.b / 255),
        a: color.a
    };
}


/***/ }),

/***/ "./src/renderer/viz/expressions/binary/NotEquals.js":
/*!**********************************************************!*\
  !*** ./src/renderer/viz/expressions/binary/NotEquals.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NotEquals; });
/* harmony import */ var _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BinaryOperation */ "./src/renderer/viz/expressions/binary/BinaryOperation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");




/**
 * Compare if x is different than y.
 *
 * This returns a number expression where 0 means `false` and 1 means `true`.
 *
 * @param {Number|Category} x - Firt value of the comparison
 * @param {Number|Category} y - Second value of the comparison
 * @return {Number} Result of the comparison: 0 or 1
 *
 * @example <caption>Compare two numbers to show only elements with price not equal to 30.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   filter: s.neq(s.prop('price'), 30);
 * });
 *
 * @example <caption>Compare two numbers to show only elements with price not equal to 30. (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: $price != 30  // Equivalent to neq($price, 30)
 * `);
 *
 * @memberof carto.expressions
 * @name neq
 * @function
 * @api
 */
class NotEquals extends _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["BinaryOperation"] {
    constructor (a, b) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 2);

        const signatureMethods = {
            1: (x, y) => x !== y ? 1 : 0, // NUMBERS_TO_NUMBER
            8: (x, y) => x !== y ? 1 : 0
        };

        const glsl = (x, y) => `(${x}!=${y}? 1.:0.)`;

        super(a, b, signatureMethods, glsl);
        this.allowedSignature = _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["NUMBERS_TO_NUMBER"] | _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["CATEGORIES_TO_NUMBER"] | _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["DATES_TO_DATES"];
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/binary/Or.js":
/*!***************************************************!*\
  !*** ./src/renderer/viz/expressions/binary/Or.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Or; });
/* harmony import */ var _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BinaryOperation */ "./src/renderer/viz/expressions/binary/BinaryOperation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");




/**
 * Perform a binary OR between two numeric expressions.
 * If the numbers are different from 0 or 1 this performs a [fuzzy or operation](https://en.wikipedia.org/wiki/Fuzzy_logic#Fuzzification).
 * This fuzzy behavior will allow transitions to work in a continuos, non-discrete, fashion.
 *
 * This returns a number expression where 0 means `false` and 1 means `true`.
 *
 * @param {Number} x - First value of the expression
 * @param {Number} y - Second value of the expression
 * @return {Number} Result of the expression
 *
 * @example <caption>Show only elements with price < 30 OR price > 1000.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   filter: s.or(
 *     s.lt(s.prop('price'), 30),
 *     s.gt(s.prop('price'), 1000)
 *   )
 * });
 *
 * @example <caption>Show only elements with price < 30 OR price > 1000. (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: $price < 30 or $price > 1000  // Equivalent to or(lt($price, 30), gt($price, 1000))
 * `);
 *
 * @memberof carto.expressions
 * @name or
 * @function
 * @api
 */
class Or extends _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["BinaryOperation"] {
    constructor (a, b) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 2);

        const signatureMethods = {
            1: (x, y) => Math.min(x + y, 1) // NUMBERS_TO_NUMBER
        };

        const glsl = (x, y) => `min(${x} + ${y}, 1.)`;

        a = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(a);
        b = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(b);

        super(a, b, signatureMethods, glsl);
        this.allowedSignature = _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["NUMBERS_TO_NUMBER"];
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/binary/Pow.js":
/*!****************************************************!*\
  !*** ./src/renderer/viz/expressions/binary/Pow.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Pow; });
/* harmony import */ var _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BinaryOperation */ "./src/renderer/viz/expressions/binary/BinaryOperation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");



/**
 * Compute the base to the exponent power, return a numeric expression with the value of the first parameter raised to the power of the second.
 * The result is undefined if x<0 or if x=0 and y0.
 *
 * @param {Number} base - Base of the power
 * @param {Number} exponent - Exponent of the power
 * @return {Number} Result of the power
 *
 * @example <caption>Number power.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.pow(2, 3)  // 8
 * });
 *
 * @example <caption>Number power. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: 2 ^ 3  // Equivalent to pow(2, 3)
 * `);
 *
 * @memberof carto.expressions
 * @name pow
 * @function
 * @api
 */
class Pow extends _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["BinaryOperation"] {
    constructor (a, b) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 2);

        const signatureMethods = {
            1: (x, y) => Math.pow(x, y) // NUMBERS_TO_NUMBER
        };

        const glsl = (x, y) => `pow(${x}, ${y})`;

        super(a, b, signatureMethods, glsl);
        this.allowedSignature = _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["NUMBERS_TO_NUMBER"];
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/binary/Sub.js":
/*!****************************************************!*\
  !*** ./src/renderer/viz/expressions/binary/Sub.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Sub; });
/* harmony import */ var _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BinaryOperation */ "./src/renderer/viz/expressions/binary/BinaryOperation.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");




/**
 * Substract two numeric expressions.
 *
 * @param {Number|Color} minuend - The minuend of the subtraction
 * @param {Number|Color} subtrahend - The subtrahend of the subtraction
 * @return {Number|Color} Result of the substraction
 *
 * @example <caption>Number subtraction.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.sub(10, 2)  // 8
 * });
 *
 * @example <caption>Number subtraction. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: 10 - 2  // Equivalent to sub(10, 2)
 * `);
 *
 * @memberof carto.expressions
 * @name sub
 * @function
 * @api
 */
class Sub extends _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["BinaryOperation"] {
    constructor (a, b) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 2);

        const signatureMethods = {
            1: (x, y) => x - y, // NUMBERS_TO_NUMBER
            4: _subColors // COLORS_TO_COLOR
        };

        const glsl = (x, y) => `(${x} - ${y})`;

        super(a, b, signatureMethods, glsl);
        this.allowedSignature = _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["NUMBERS_TO_NUMBER"] | _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["COLORS_TO_COLOR"] | _BinaryOperation__WEBPACK_IMPORTED_MODULE_0__["IMAGES_TO_IMAGE"];
    }
}

function _subColors (colorA, colorB) {
    const r = colorA.r - colorB.r > 0 ? colorA.r - colorB.r : 0;
    const g = colorA.g - colorB.g > 0 ? colorA.g - colorB.g : 0;
    const b = colorA.b - colorB.b > 0 ? colorA.b - colorB.b : 0;
    const a = colorA.a;

    return { r, g, b, a };
}


/***/ }),

/***/ "./src/renderer/viz/expressions/blend.js":
/*!***********************************************!*\
  !*** ./src/renderer/viz/expressions/blend.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Blend; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _transition__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transition */ "./src/renderer/viz/expressions/transition.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");





/**
 * Linearly interpolate from `a` to `b` based on `mix`.
 *
 * @param {Number|Color} a - Numeric or color expression, `a` type must match `b` type
 * @param {Number|Color} b - Numeric or color expression, `b` type must match `a` type
 * @param {Number} mix - Numeric expression with the interpolation parameter in the [0,1] range
 * @returns {Number|Color} Numeric or color expression with the same type as `a` and `b`
 *
 * @example <caption>Blend based on the zoom level to display a bubble map at high zoom levels and display fixed-sized points at low zoom levels.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.blend(3,
 *                  s.prop('dn'),
 *                  s.linear(s.zoom(), 10, 14))
 *           );
 * });
 *
 * @example <caption>Blend based on the zoom level to display a bubble map at high zoom levels and display fixed-sized points at low zoom levels. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: blend(3,
 *                $dn,
 *                linear(zoom(), 10, 14)
 *          )
 * `);
 *
 * @memberof carto.expressions
 * @name blend
 * @function
 * @api
 */
class Blend extends _base__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor (a, b, mix, interpolator) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_0__["checkMaxArguments"])(arguments, 4, 'blend');
        a = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["implicitCast"])(a);
        b = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["implicitCast"])(b);
        mix = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["implicitCast"])(mix);

        Object(_utils__WEBPACK_IMPORTED_MODULE_0__["checkExpression"])('blend', 'a', 0, a);
        Object(_utils__WEBPACK_IMPORTED_MODULE_0__["checkExpression"])('blend', 'b', 1, b);
        Object(_utils__WEBPACK_IMPORTED_MODULE_0__["checkExpression"])('blend', 'mix', 2, mix);

        // TODO check interpolator type
        const originalMix = mix;
        if (interpolator) {
            mix = interpolator(mix);
        }
        super({ a, b, mix });
        this.originalMix = originalMix;

        if (a.type && b.type) {
            this.type = a.type;
        }
        this.inlineMaker = inline => `mix(${inline.a}, ${inline.b}, clamp(${inline.mix}, 0., 1.))`;
    }

    get value () {
        const a = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["clamp"])(this.mix.value, 0, 1);
        const x = this.a.value;
        const y = this.b.value;

        return Object(_utils__WEBPACK_IMPORTED_MODULE_0__["mix"])(x, y, a);
    }

    eval (feature) {
        const a = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["clamp"])(this.mix.eval(feature), 0, 1);
        const x = this.a.eval(feature);
        const y = this.b.eval(feature);

        return Object(_utils__WEBPACK_IMPORTED_MODULE_0__["mix"])(x, y, a);
    }

    replaceChild (toReplace, replacer) {
        if (toReplace === this.mix) {
            this.originalMix = replacer;
        }
        super.replaceChild(toReplace, replacer);
    }
    _bindMetadata (meta) {
        super._bindMetadata(meta);

        abTypeCheck(this.a, this.b);
        Object(_utils__WEBPACK_IMPORTED_MODULE_0__["checkType"])('blend', 'mix', 2, 'number', this.mix);

        this.type = this.a.type;
    }

    _preDraw (...args) {
        super._preDraw(...args);
        if (this.originalMix.isA(_transition__WEBPACK_IMPORTED_MODULE_1__["default"]) && !this.originalMix.isAnimated()) {
            this.parent.replaceChild(this, this.b);
        }
    }
}

function abTypeCheck (a, b) {
    const validTypes = ['number', 'color', 'image', 'placement', 'date'];

    if (a.type !== b.type || !(validTypes.includes(a.type))) {
        throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["default"](
            `blend(): invalid parameter types\n\t'a' type was '${a.type}'\n\t'b' type was '${b.type}'`,
            _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["CartoValidationErrorTypes"].INCORRECT_TYPE
        );
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/buckets.js":
/*!*************************************************!*\
  !*** ./src/renderer/viz/expressions/buckets.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Buckets; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ "./src/renderer/viz/expressions/constants.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _BucketsGLSLHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BucketsGLSLHelper */ "./src/renderer/viz/expressions/BucketsGLSLHelper.js");






/**
 * Given a property create "sub-groups" based on the given breakpoints.
 *
 * This returns a number or category expression depending on the input values. The "others" label is by default CARTO_VL_OTHERS.
 * This can be overwriten by setting the "others" label as the third parameter.
 *
 * @param {Number|Category} property - The property to be evaluated and interpolated
 * @param {Number[]|Category[]} breakpoints - Expression containing the different breakpoints.
 * @param {string} othersLabel - Custom label for "others"
 * @return {Number|Category}
 *
 * @example <caption>Display a traffic dataset in 4 colors depending on the numeric speed.</caption>
 * // Using the buckets `expression` we divide the dataset into 4 buckets according to the speed
 * // - From -inf to 29
 * // - From 30 to 79
 * // - From 80 to 119
 * // - From 120 to +inf
 * // Values lower than 0 will be in the first bucket and values higher than 120 will be in the last one.
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *    color: s.ramp(
 *      s.buckets(s.prop('speed'), [30, 80, 120]),
 *      s.palettes.PRISM
 *    )
 * });
 *
 * @example <caption>Display a traffic dataset in 4 colors depending on the numeric speed. (String)</caption>
 * // Using the buckets `expression` we divide the dataset into 4 buckets according to the speed
 * // - From -inf to 29
 * // - From 30 to 79
 * // - From 80 to 119
 * // - From 120 to +inf
 * // Values lower than 0 will be in the first bucket and values higher than 120 will be in the last one.
 * const viz = new carto.Viz(`
 *    color: ramp(buckets($speed, [30, 80, 120]), PRISM)
 * `);
 *
 * @example <caption>Display a traffic dataset is 3 colors depending on the category procesedSpeed.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.ramp(
 *     s.buckets(s.prop('procesedSpeed'), ['slow', 'medium', 'high']),
 *     s.palettes.PRISM)
 *   )
 * });
 *
 * @example <caption>Display a traffic dataset is 3 colors depending on the category procesedSpeed. (String)</caption>
 * const viz = new carto.Viz(`
 *    color: ramp(buckets($procesedSpeed, ['slow', 'medium', 'high']), PRISM)
 * `);
 *
 * @example <caption>Set custom "others" label.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.ramp(
 *     s.buckets(s.prop('procesedSpeed'), ['slow', 'medium', 'high'], 'Others'),
 *     s.palettes.PRISM)
 *   )
 * });
 *
 * @example <caption>Set custom "others" label. (String)</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz(`
 *    color: ramp(buckets($procesedSpeed, ['slow', 'medium', 'high'], 'Others'), PRISM)
 * `);
 *
 * @memberof carto.expressions
 * @name buckets
 * @function
 * @api
 */
class Buckets extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (input, list, othersLabel = _constants__WEBPACK_IMPORTED_MODULE_2__["OTHERS_LABEL"]) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 3, 'buckets');

        input = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(input);
        list = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(list);
        othersLabel = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(othersLabel);

        let children = {
            input,
            list,
            othersLabel
        };

        super(children);
        this.numCategories = null;
        this.numCategoriesWithoutOthers = null;
        this.type = 'category';

        this._GLSLhelper = new _BucketsGLSLHelper__WEBPACK_IMPORTED_MODULE_4__["default"](this);
    }

    get value () {
        return this.eval();
    }

    eval (feature) {
        const v = this.input.eval(feature);
        const divisor = this.numCategoriesWithoutOthers - 1 || 1;

        if (this.input.type === 'category') {
            for (let i = 0; i < this.list.elems.length; i++) {
                if (v === this.list.elems[i].eval(feature)) {
                    return i / divisor;
                }
            }

            return _constants__WEBPACK_IMPORTED_MODULE_2__["OTHERS_INDEX"];
        }

        for (let i = 0; i < this.list.elems.length; i++) {
            if (v < this.list.elems[i].eval(feature)) {
                return i / divisor;
            }
        }

        return 1;
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);

        if (this.input.type !== 'number' && this.input.type !== 'category') {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["default"](
                `buckets(): invalid first parameter type\n\t'input' type was ${this.input.type}`,
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["CartoValidationErrorTypes"].INCORRECT_TYPE
            );
        }

        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('buckets', 'list', 1, ['number-list', 'category-list'], this.list);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('buckets', 'othersLabel', 2, 'category', this.othersLabel);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkFeatureIndependent"])('buckets', 'othersLabel', 2, this.othersLabel);

        this.list.elems.map((item, index) => {
            if (this.input.type !== item.type) {
                throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["default"](
                    `buckets(): invalid ${Object(_utils__WEBPACK_IMPORTED_MODULE_1__["getOrdinalFromIndex"])(index + 1)} parameter type` +
                    `\n\texpected type was ${this.input.type}\n\tactual type was ${item.type}`,
                    _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["CartoValidationErrorTypes"].INCORRECT_TYPE
                );
            } else if (item.type !== 'number' && item.type !== 'category') {
                throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["default"](
                    `buckets(): invalid ${Object(_utils__WEBPACK_IMPORTED_MODULE_1__["getOrdinalFromIndex"])(index + 1)} parameter type\n\ttype was ${item.type}`,
                    _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["CartoValidationErrorTypes"].INCORRECT_TYPE
                );
            }
        });

        if (this.input.type === 'category') {
            const property = metadata.properties[this.input.propertyName];
            this._numDatasetCategories = property
                ? property.categories.length
                : this.list.elems.length - 1;
        }

        this.numCategories = this.list.elems.length + 1;
        this.numCategoriesWithoutOthers = this.input.type === 'category' ? this.numCategories - 1 : this.numCategories;
    }

    _applyToShaderSource (getGLSLforProperty) {
        return this._GLSLhelper.applyToShaderSource(getGLSLforProperty);
    }

    getLegendData (options) {
        const name = this.toString();
        const list = this.list.elems.map(elem => elem.value);
        const config = {
            othersLabel: options && options.othersLabel ? options.othersLabel : this.othersLabel.value,
            order: options ? options.order : _constants__WEBPACK_IMPORTED_MODULE_2__["SORT_DESC"].ASCENDING
        };

        let data = this.input.type === 'number'
            ? _getLegendDataNumeric(list, config.sort)
            : _getLegendDataCategory(list, this._numDatasetCategories, config);

        return { data, name };
    }
}

function _getLegendDataNumeric (list, order) {
    let data = [];

    for (let i = 0; i <= list.length; i++) {
        const min = i - 1 >= 0 ? list[i - 1] : Number.NEGATIVE_INFINITY;
        const max = i < list.length ? list[i] : Number.POSITIVE_INFINITY;
        const key = [min, max];
        const value = i / list.length;
        data.push({ key, value });
    }

    if (order && order === _constants__WEBPACK_IMPORTED_MODULE_2__["SORT_DESC"]) {
        data = data.sort((a, b) => b.key[0] - a.key[0]);
    }

    return data;
}

function _getLegendDataCategory (list, numDatasetCategories, config) {
    const divisor = list.length - 1 || 1;
    let data = list.map((category, index) => {
        const key = category;
        const value = index / divisor;

        return { key, value };
    });

    if (numDatasetCategories > list.length) {
        data.push({
            key: config.othersLabel,
            value: _constants__WEBPACK_IMPORTED_MODULE_2__["OTHERS_INDEX"]
        });
    }

    if (config.order && config.order === _constants__WEBPACK_IMPORTED_MODULE_2__["SORT_DESC"]) {
        data = data.sort((a, b) => b.key - a.key);
    }

    return data;
}


/***/ }),

/***/ "./src/renderer/viz/expressions/classification/Classifier.js":
/*!*******************************************************************!*\
  !*** ./src/renderer/viz/expressions/classification/Classifier.js ***!
  \*******************************************************************/
/*! exports provided: DEFAULT_HISTOGRAM_SIZE, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_HISTOGRAM_SIZE", function() { return DEFAULT_HISTOGRAM_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Classifier; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _ClassifierGLSLHelper__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ClassifierGLSLHelper */ "./src/renderer/viz/expressions/classification/ClassifierGLSLHelper.js");







const DEFAULT_HISTOGRAM_SIZE = 1000;

let classifierUID = 0;
class Classifier extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (children) {
        super(children);
        this.classifierUID = classifierUID++;
        this.type = 'category';

        this._GLSLhelper = new _ClassifierGLSLHelper__WEBPACK_IMPORTED_MODULE_4__["default"](this);
    }

    get value () {
        return this.eval();
    }

    eval (feature) {
        const inputValue = this.input.eval(feature);
        const breakpoint = this.breakpoints.findIndex((breakpoint) => {
            return inputValue <= breakpoint.value;
        });

        const divisor = this.numCategories - 1 || 1;
        const index = breakpoint === -1 ? 1 : breakpoint / divisor;

        return index;
    }

    toString () {
        return `${this.expressionName}(${this.input.toString()}, ${this.numCategories})`;
    }

    _resolveAliases (aliases) {
        super._resolveAliases(aliases);

        this._bucketsInitialization();
    }

    _bucketsInitialization () {
        this._validateBucketsIsProperNumber();

        const buckets = this.buckets.value;
        this.numCategories = buckets;
        this.numCategoriesWithoutOthers = buckets;

        this._initBreakpointsChildren(buckets);
    }

    _initBreakpointsChildren (buckets) {
        this.breakpoints = this._breakpointsWithZeros(buckets);

        const breakpointsChildren = this.breakpoints.reduce((children, current, index) => {
            children[`arg${index}`] = current;
            return children;
        }, {});
        this._initializeChildren(breakpointsChildren);
    }

    _breakpointsWithZeros (buckets) {
        const breakpoints = [];
        for (let i = 0; i < buckets - 1; i++) {
            breakpoints.push(Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["number"])(0));
        }
        return breakpoints;
    }

    _validateBucketsIsProperNumber () {
        const buckets = this.buckets.value;
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkNumber"])(this.expressionName, 'buckets', 1, buckets);
        if (buckets <= 1) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["default"](
                `The number of 'buckets' must be >=2, but ${buckets} was used`,
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["CartoValidationErrorTypes"].INCORRECT_VALUE
            );
        }
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);

        this._validateInputIsNumericProperty();
    }

    _validateInputIsNumericProperty () {
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkType"])(this.expressionName, 'input', 0, 'number', this.input);
    }

    _getBreakpointList () {
        this._genBreakpoints();
        return this.breakpoints.map(breakpoint => breakpoint.value);
    }

    _genBreakpoints () { }

    _applyToShaderSource (getGLSLforProperty) {
        return this._GLSLhelper ? this._GLSLhelper.applyToShaderSource(getGLSLforProperty) : null;
    }

    _preDraw (program, drawMetadata, gl) {
        this._genBreakpoints();
        super._preDraw(program, drawMetadata, gl);
    }

    getLegendData () {
        const breakpoints = this._getBreakpointList();
        const breakpointsLength = breakpoints.length;
        const legendMin = this.min.value;
        const legendMax = this.max.value;
        const data = [];

        for (let i = 0; i <= breakpointsLength; i++) {
            const min = breakpoints[i - 1] === 0 ? 0 : breakpoints[i - 1] || legendMin;
            const max = breakpoints[i] === 0 ? 0 : breakpoints[i] || legendMax;
            const key = [min, max];
            const value = i / breakpointsLength;
            data.push({ key, value });
        }

        return { name: this.toString(), data };
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/classification/ClassifierGLSLHelper.js":
/*!*****************************************************************************!*\
  !*** ./src/renderer/viz/expressions/classification/ClassifierGLSLHelper.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ClassifierGLSLHelper; });
class ClassifierGLSLHelper {
    constructor (classifier) {
        this.classifier = classifier;
    }

    applyToShaderSource (getGLSLforProperty) {
        const childSources = this.classifier.childrenNames.map(name => this.classifier[name]._applyToShaderSource(getGLSLforProperty));
        let childInlines = {};
        childSources.map((source, index) => {
            childInlines[this.classifier.childrenNames[index]] = source.inline;
        });

        // Create classifier function
        const funcName = `classifier${this.classifier.classifierUID}`;

        const divisor = this.classifier.numCategories - 1 || 1;
        const elif = (_, index) =>
            `${index > 0 ? 'else' : ''} if (x<(${childInlines[`arg${index}`]})){
                return ${(index / divisor).toFixed(20)};
            }`;
        const funcBody = this.classifier.breakpoints
            ? this.classifier.breakpoints.map(elif).join('')
            : '';

        const preface = `float ${funcName}(float x){
            ${funcBody}
            return 1.;
        }`;

        // GLSL preface & inline
        return {
            preface: this.classifier._prefaceCode(childSources.map(s => s.preface).reduce((a, b) => a + b, '') + preface),
            inline: `${funcName}(${childInlines.input})`
        };
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/classification/GlobalEqIntervals.js":
/*!**************************************************************************!*\
  !*** ./src/renderer/viz/expressions/classification/GlobalEqIntervals.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GlobalEqIntervals; });
/* harmony import */ var _Classifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Classifier */ "./src/renderer/viz/expressions/classification/Classifier.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _constants_metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../constants/metadata */ "./src/constants/metadata.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../expressions */ "./src/renderer/viz/expressions.js");






/**
 * Classify `input` by using the equal intervals method with `n` buckets.
 *
 * It will classify the input based on the entire dataset without filtering by viewport or by `filter`.
 *
 * @param {Number} input - The input expression to classify
 * @param {number} n - Number of buckets
 * @return {Category}
 *
 * @example <caption>Use global equal intervals to define a color ramp.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.ramp(s.globalEqIntervals(s.prop('density'), 5), s.palettes.PRISM)
 * });
 *
 * @example <caption>Use global equal intervals to define a color ramp. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: ramp(globalEqIntervals($density, 5), PRISM)
 * `);
 *
 * @memberof carto.expressions
 * @name globalEqIntervals
 * @function
 * @api
 */
class GlobalEqIntervals extends _Classifier__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (input, buckets) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExactNumberOfArguments"])(arguments, 2, 'globalEqIntervals');
        super({ input, buckets });
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);
        this._updateBreakpointsWith(metadata);
    }

    _updateBreakpointsWith (metadata) {
        if (this.input.propertyName === _constants_metadata__WEBPACK_IMPORTED_MODULE_2__["CLUSTER_FEATURE_COUNT"]) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["default"](
                '\'clusterCount\' can not be used in GlobalEqIntervals. Consider using ViewportEqIntervals instead',
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["CartoValidationErrorTypes"].INCORRECT_TYPE
            );
        }

        const name = this.input.name;
        const { min, max } = metadata.stats(name);
        this.min = Object(_expressions__WEBPACK_IMPORTED_MODULE_4__["number"])(min);
        this.max = Object(_expressions__WEBPACK_IMPORTED_MODULE_4__["number"])(max);

        this.breakpoints.map((breakpoint, index) => {
            const p = (index + 1) / this.numCategories;
            breakpoint.value = min + (max - min) * p;
        });
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/classification/GlobalQuantiles.js":
/*!************************************************************************!*\
  !*** ./src/renderer/viz/expressions/classification/GlobalQuantiles.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GlobalQuantiles; });
/* harmony import */ var _Classifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Classifier */ "./src/renderer/viz/expressions/classification/Classifier.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _constants_metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../constants/metadata */ "./src/constants/metadata.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../expressions */ "./src/renderer/viz/expressions.js");






/**
 * Classify `input` by using the quantiles method with `n` buckets.
 *
 * It will classify the input based on the entire dataset without filtering by viewport or by `filter`.
 *
 * @param {Number} input - The input expression used in the quantiles
 * @param {number} n - Number of buckets to be returned
 * @return {Category}
 *
 * @example <caption>Use global quantiles to define a color ramp.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.ramp(s.globalQuantiles(s.prop('density'), 5), s.palettes.CB_REDS)
 * });
 *
 * @example <caption>Use global quantiles to define a color ramp. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: ramp(globalQuantiles($density, 5), CB_REDS)
 * `);
 *
 * @memberof carto.expressions
 * @name globalQuantiles
 * @function
 * @api
 */
class GlobalQuantiles extends _Classifier__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (input, buckets) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExactNumberOfArguments"])(arguments, 2, 'globalQuantiles');

        super({ input, buckets });
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);

        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('globalQuantiles', 'input', 0, 'number', this.input);
        this._updateBreakpointsWith(metadata);
    }

    _validateInputIsNumericProperty () { /* noop */ }

    _updateBreakpointsWith (metadata) {
        if (this.input.propertyName === _constants_metadata__WEBPACK_IMPORTED_MODULE_2__["CLUSTER_FEATURE_COUNT"]) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["default"](
                '\'clusterCount\' can not be used in GlobalQuantiles. Consider using ViewportQuantiles instead',
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["CartoValidationErrorTypes"].INCORRECT_TYPE
            );
        }

        const name = this.input.name;
        const { min, max } = metadata.stats(name);
        const copy = metadata.sample.map(s => s[name]);

        this.min = Object(_expressions__WEBPACK_IMPORTED_MODULE_4__["number"])(min);
        this.max = Object(_expressions__WEBPACK_IMPORTED_MODULE_4__["number"])(max);

        copy.sort((x, y) => x - y);

        this.breakpoints = this.breakpoints.map((breakpoint, index) => {
            const p = (index + 1) / this.numCategories;
            breakpoint.value = copy[Math.floor(p * copy.length)];
            return breakpoint;
        });
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/classification/GlobalStandardDev.js":
/*!**************************************************************************!*\
  !*** ./src/renderer/viz/expressions/classification/GlobalStandardDev.js ***!
  \**************************************************************************/
/*! exports provided: default, calculateBreakpoints */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GlobalStandardDev; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateBreakpoints", function() { return calculateBreakpoints; });
/* harmony import */ var _Classifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Classifier */ "./src/renderer/viz/expressions/classification/Classifier.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../errors/carto-runtime-error */ "./src/errors/carto-runtime-error.js");
/* harmony import */ var _stats__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../stats */ "./src/renderer/viz/expressions/stats.js");
/* harmony import */ var _constants_metadata__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../../constants/metadata */ "./src/constants/metadata.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../expressions */ "./src/renderer/viz/expressions.js");









/**
 * Classify `input` by using the Mean-Standard Deviation method with `n` buckets.
 *
 * It will classify the input based on the entire dataset without filtering by viewport or by `filter`.
 *
 * It uses average and standard deviation (population formula) to classify the dataset.
 * When using an odd number of buckets, the central class has a double size (classSize * 2), to honour the number of required buckets
 *
 * This method is suitable if data are normally (or near normal) distributed, and it is specially
 * appropiated for diverging datasets, which can be well displayed using a diverging color scheme like TEALROSE
 *
 * @param {Number} input - The input expression to classify
 * @param {number} n - Number of buckets
 * @param {number?} classSize - Optional. The class size, defaults to 1.0 standard deviation (usual values are also 0.5 or 0.25)
 * @return {Category}
 *
 * @example <caption>Use global mean-standard deviation to define a color ramp.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.ramp(s.globalStandardDev(s.prop('density'), 5), s.palettes.TEALROSE)
 * });
 *
 * @example <caption>Use global mean-standard deviation to define a color ramp. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: ramp(globalStandardDev($density, 5), TEALROSE)
 * `);
 *
 * @example <caption>Use global custom mean-standard deviation to define a color ramp.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.ramp(s.globalStandardDev(s.prop('density'), 7, 0.5), s.palettes.TEALROSE)
 * });
 *
 * @example <caption>Use global custom mean-standard deviation to define a color ramp. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: ramp(globalStandardDev($density, 7, 0.5), TEALROSE)
 * `);
 *
 * @memberof carto.expressions
 * @name globalStandardDev
 * @function
 * @api
 */
class GlobalStandardDev extends _Classifier__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (input, buckets, classSize = 1.0) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMinArguments"])(arguments, 2, 'globalStandardDev');
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 3, 'globalStandardDev');

        super({ input, buckets, _classSize: classSize });
    }

    _resolveAliases (aliases) {
        super._resolveAliases(aliases);

        this._validateClassSizeIsProperNumber();
    }

    _validateClassSizeIsProperNumber () {
        const classSize = this._classSize.value;
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkNumber"])(this.expressionName, 'classSize', 2, classSize);
        if (classSize <= 0) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
                `The 'classSize' must be > 0.0, but ${classSize} was used.`,
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_VALUE
            );
        }
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);

        this._updateBreakpointsWith(metadata);
    }

    _updateBreakpointsWith (metadata) {
        if (this.input.propertyName === _constants_metadata__WEBPACK_IMPORTED_MODULE_5__["CLUSTER_FEATURE_COUNT"]) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
                '\'clusterCount\' can not be used in GlobalStandardDev. Consider using ViewportStandardDev instead',
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_TYPE
            );
        }
        const name = this.input.name;
        const sample = metadata.sample.map(s => s[name]);
        const avg = Object(_stats__WEBPACK_IMPORTED_MODULE_4__["average"])(sample);
        const standardDev = Object(_stats__WEBPACK_IMPORTED_MODULE_4__["standardDeviation"])(sample);
        const { min, max } = metadata.stats(name);
        this.min = Object(_expressions__WEBPACK_IMPORTED_MODULE_6__["number"])(min);
        this.max = Object(_expressions__WEBPACK_IMPORTED_MODULE_6__["number"])(max);

        const breaks = calculateBreakpoints(avg, standardDev, this.numCategories, this._classSize.value);
        this.breakpoints.forEach((breakpoint, index) => {
            breakpoint.value = breaks[index];
        });
    }
}

/**
 * Calculate breakpoints according to mean-standard deviation process
 *
 * @export
 * @param {Number} avg - average
 * @param {Number} stDev - standard deviation
 * @param {Number} buckets - number of buckets
 * @param {Number} classSize - in standard deviation units (usually 1.0, 0.5, 0.25...)
 * @returns {Number[]}
 */
function calculateBreakpoints (avg, stDev, buckets, classSize) {
    if (stDev === 0 || isNaN(stDev)) {
        throw new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_3__["default"](
            `There is no Standard Deviation, not possible to compute ${buckets} buckets (just one feature or maybe all share the same value...?)`,
            _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_3__["CartoRuntimeErrorTypes"].NOT_SUPPORTED
        );
    }

    let breaks;
    let over = [];
    let under = [];
    const isEven = buckets % 2 === 0;
    let factor = isEven ? 0.0 : 1.0; // if odd, central class is double sized
    do {
        const step = factor * (stDev * classSize);
        over.push(avg + step);
        under.push(avg - step);
        breaks = [...new Set(over.concat(under))];
        breaks.sort((a, b) => a - b);
        factor++;
    } while (breaks.length < buckets - 1);

    return breaks;
}


/***/ }),

/***/ "./src/renderer/viz/expressions/classification/ViewportEqIntervals.js":
/*!****************************************************************************!*\
  !*** ./src/renderer/viz/expressions/classification/ViewportEqIntervals.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewportEqIntervals; });
/* harmony import */ var _Classifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Classifier */ "./src/renderer/viz/expressions/classification/Classifier.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");




/**
 * Classify `input` by using the equal intervals method with `n` buckets.
 *
 * It will classify the input based on the filtered dataset, filtering by viewport and by `filter`.
 *
 * @param {Number} input - The input expression to classify
 * @param {number} n - Number of buckets
 * @return {Category}
 *
 * @example <caption>Use viewport equal intervals to define a color ramp.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.ramp(s.viewportEqIntervals(s.prop('density'), 5), s.palettes.PRISM)
 * });
 *
 * @example <caption>Use viewport equal intervals to define a color ramp. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: ramp(viewportEqIntervals($density, 5), PRISM)
 * `);
 *
 * @memberof carto.expressions
 * @name viewportEqIntervals
 * @function
 * @api
 */
class ViewportEqIntervals extends _Classifier__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (input, buckets) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkExactNumberOfArguments"])(arguments, 2, 'viewportEqIntervals');

        super({ input, buckets });
    }

    _resolveAliases (aliases) {
        super._resolveAliases(aliases);

        this._minMaxInitialization();
    }

    _minMaxInitialization () {
        const input = this.input;
        const children = { min: Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["viewportMin"])(input), max: Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["viewportMax"])(input) };

        this._initializeChildren(children);
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);

        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkType"])('viewportEqIntervals', 'input', 0, 'number', this.input);
    }

    _validateInputIsNumericProperty () { /* noop */ }

    _genBreakpoints () {
        const min = this.min.value;
        const max = this.max.value;

        this.breakpoints.map((breakpoint, index) => {
            const p = (index + 1) / this.numCategories;
            breakpoint.value = min + (max - min) * p;
        });
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/classification/ViewportQuantiles.js":
/*!**************************************************************************!*\
  !*** ./src/renderer/viz/expressions/classification/ViewportQuantiles.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewportQuantiles; });
/* harmony import */ var _Classifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Classifier */ "./src/renderer/viz/expressions/classification/Classifier.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../expressions */ "./src/renderer/viz/expressions.js");







/**
 * Classify `input` by using the quantiles method with `n` buckets.
 *
 * It will classify the input based on the filtered dataset, filtering by viewport and by `filter`.
 *
 * @param {Number} input - The input expression used in the quantiles
 * @param {Number} n - Number of buckets to be returned
 * @param {Number?} histogramSize - Optional (DEFAULT_HISTOGRAM_SIZE = 1000).  Histogram 'size' used for calculations (the bigger, the more precision)
 * @return {Category}
 *
 * @example <caption>Use viewportQuantiles to define a color ramp.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.ramp(s.viewportQuantiles(s.prop('density'), 5), s.palettes.PRISM)
 * });
 *
 * @example <caption>Use viewportQuantiles to define a color ramp. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: ramp(viewportQuantiles($density, 5), PRISM)
 * `);
 *
 * @memberof carto.expressions
 * @name viewportQuantiles
 * @function
 * @api
 */
class ViewportQuantiles extends _Classifier__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (input, buckets, histogramSize = _Classifier__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_HISTOGRAM_SIZE"]) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMinArguments"])(arguments, 2, 'viewportQuantiles');
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 3, 'viewportQuantiles');
        input = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(input);

        super({ input, buckets, _histogramSize: histogramSize });
    }

    _resolveAliases (aliases) {
        super._resolveAliases(aliases);

        this._histogramInitialization();
    }

    _histogramInitialization () {
        this._validateHistogramSizeIsProperNumber();

        const input = this.input;
        const histogramSize = this._histogramSize.value;
        const min = Object(_expressions__WEBPACK_IMPORTED_MODULE_3__["viewportMin"])(input);
        const max = Object(_expressions__WEBPACK_IMPORTED_MODULE_3__["viewportMax"])(input);
        const _histogram = Object(_expressions__WEBPACK_IMPORTED_MODULE_3__["viewportHistogram"])(input, histogramSize);

        const children = { min, max, _histogram };
        this._initializeChildren(children);
    }

    _validateHistogramSizeIsProperNumber () {
        const histogramSize = this._histogramSize.value;
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkNumber"])(this.expressionName, 'histogramSize', 2, histogramSize);
        if (histogramSize <= 0) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
                `The 'histogramSize' must be > 0, but ${histogramSize} was used`,
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_VALUE
            );
        }
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);

        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('viewportQuantiles', 'input', 0, 'number', this.input);
    }

    _validateInputIsNumericProperty () { /* noop */ }

    _genBreakpoints () {
        const histogram = this._histogram.value;

        if (!histogram) {
            return;
        }

        const accumHistogram = this._getAccumHistogramFrom(histogram);
        const [min, max] = this._getMinMaxFrom(histogram);

        this._updateBreakpointsWith({ accumHistogram, min, max });
    }

    _updateBreakpointsWith ({ accumHistogram, min, max }) {
        const histogramBuckets = accumHistogram.length;

        let i = 0;
        const total = accumHistogram[histogramBuckets - 1];
        // TODO OPT: this could be faster with binary search
        this.breakpoints.map((breakpoint, index) => {
            for (i; i < histogramBuckets; i++) {
                if (accumHistogram[i] > (index + 1) / this.numCategories * total) {
                    break;
                }
            }
            const percentileValue = i / histogramBuckets * (max - min) + min;
            breakpoint.value = percentileValue;
        });
    }

    _getAccumHistogramFrom (histogram) {
        let prev = 0;
        const accumHistogram = histogram.map(({ y }) => {
            prev += y;
            return prev;
        });
        return accumHistogram;
    }

    _getMinMaxFrom (histogram) {
        const min = histogram[0].x[0];
        const max = histogram[histogram.length - 1].x[1];

        return [min, max];
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/classification/ViewportStandardDev.js":
/*!****************************************************************************!*\
  !*** ./src/renderer/viz/expressions/classification/ViewportStandardDev.js ***!
  \****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewportStandardDev; });
/* harmony import */ var _Classifier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Classifier */ "./src/renderer/viz/expressions/classification/Classifier.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _GlobalStandardDev__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GlobalStandardDev */ "./src/renderer/viz/expressions/classification/GlobalStandardDev.js");








/**
 * Classify `input` by using the Mean-Standard Deviation method with `n` buckets.
 *
 * It will classify the input based on the filtered dataset, filtering by viewport and by `filter`.
 *
 * It uses average and standard deviation (population formula) to classify the dataset.
 * When using an odd number of buckets, the central class has a double size (classSize * 2), to honour the number of required buckets
 *
 * This method is suitable if data are normally (or near normal) distributed, and it is specially
 * appropiated for diverging datasets, which can be well displayed using a diverging color scheme like TEALROSE
 *
 *
 * @param {Number} input - The input expression to classify
 * @param {Number} n - Number of buckets
 * @param {Number?} classSize - Optional. The class size, defaults to 1.0 standard deviation (usual values are also 0.5 or 0.25)
 * @param {Number?} histogramSize - Optional (DEFAULT_HISTOGRAM_SIZE = 1000).  Histogram 'size' used for calculations (the bigger, the more precision)
 * @return {Category}
 *
 * @example <caption>Use viewport mean-standard deviation to define a color ramp.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.ramp(s.viewportStandardDev(s.prop('density'), 5), s.palettes.TEALROSE)
 * });
 *
 * @example <caption>Use viewport mean-standard deviation to define a color ramp. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: ramp(viewportStandardDev($density, 5), tealrose)
 * `);
 *
 * @example <caption>Use viewport custom mean-standard deviation to define a color ramp.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.ramp(s.viewportStandardDev(s.prop('density'), 7, 0.5), s.palettes.TEALROSE)
 * });
 *
 * @example <caption>Use viewport custom mean-standard deviation to define a color ramp. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: ramp(viewportStandardDev($density, 7, 0.5), tealrose)
 * `);
 *
 * @memberof carto.expressions
 * @name viewportStandardDev
 * @function
 * @api
 */

class ViewportStandardDev extends _Classifier__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (input, buckets, classSize = 1.0, histogramSize = _Classifier__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_HISTOGRAM_SIZE"]) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMinArguments"])(arguments, 2, 'viewportStandardDev');
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 4, 'viewportStandardDev');

        super({ input, buckets, _classSize: classSize, _histogramSize: histogramSize });
    }

    _resolveAliases (aliases) {
        super._resolveAliases(aliases);

        this._validateClassSizeIsProperNumber();
        this._histogramInitialization();
    }

    _histogramInitialization () {
        this._validateHistogramSizeIsProperNumber();

        const input = this.input;
        const histogramSize = this._histogramSize.value;
        const min = Object(_expressions__WEBPACK_IMPORTED_MODULE_3__["viewportMin"])(input);
        const max = Object(_expressions__WEBPACK_IMPORTED_MODULE_3__["viewportMax"])(input);
        const _histogram = Object(_expressions__WEBPACK_IMPORTED_MODULE_3__["viewportHistogram"])(input, histogramSize);

        const children = { min, max, _histogram };
        this._initializeChildren(children);
    }

    _validateClassSizeIsProperNumber () {
        const classSize = this._classSize.value;
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkNumber"])(this.expressionName, 'classSize', 2, classSize);
        if (classSize <= 0) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
                `The 'classSize' must be > 0.0, but ${classSize} was used.`,
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_VALUE
            );
        }
    }

    _validateHistogramSizeIsProperNumber () {
        const histogramSize = this._histogramSize.value;
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkNumber"])(this.expressionName, 'histogramSize', 3, histogramSize);
        if (histogramSize <= 0) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
                `The 'histogramSize' must be > 0, but ${histogramSize} was used`,
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_VALUE
            );
        }
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);

        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('viewportStandardDev', 'input', 0, 'number', this.input);
    }

    _validateInputIsNumericProperty () { /* noop */ }

    _genBreakpoints () {
        const histogram = this._histogram.value;
        if (histogram === undefined) { return; }

        const avg = this._getAverageFrom(histogram);
        const stdev = this._getStandardDevFrom(histogram, avg);

        this._updateBreakpointsWith({ avg, stdev });
    }

    _updateBreakpointsWith ({ avg, stdev }) {
        const breaks = Object(_GlobalStandardDev__WEBPACK_IMPORTED_MODULE_4__["calculateBreakpoints"])(avg, stdev, this.numCategories, this._classSize.value);

        this.breakpoints.forEach((breakpoint, index) => {
            breakpoint.value = breaks[index];
        });
    }

    _getAverageFrom (histogram) {
        let sumFrequencies = 0.0;
        let sumMidValueFrequencies = 0.0;
        histogram.forEach(({ x, y }) => {
            sumFrequencies += y;

            const midValue = (x[0] + x[1]) / 2.0;
            sumMidValueFrequencies += midValue * y;
        });

        const avg = sumMidValueFrequencies / sumFrequencies;
        return avg;
    }

    _getStandardDevFrom (histogram, average) {
        let sumFrequencies = 0.0;
        let sumPowDifferences = 0.0;
        histogram.forEach(({ x, y }) => {
            sumFrequencies += y;

            const midValue = (x[0] + x[1]) / 2.0;
            const diff = (midValue - average);
            sumPowDifferences += y * diff * diff;
        });

        const variance = sumPowDifferences / sumFrequencies;
        return Math.sqrt(variance);
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/color/CIELab.glsl":
/*!********************************************************!*\
  !*** ./src/renderer/viz/expressions/color/CIELab.glsl ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "#ifndef CIELAB_TO_SRGBA\n#define CIELAB_TO_SRGBA\n\nconst mat3 XYZ_2_RGB = (mat3(\n    3.2404542,-1.5371385,-0.4985314,\n    -0.9692660, 1.8760108, 0.0415560,\n    0.0556434,-0.2040259, 1.0572252\n));\nconst float SRGB_GAMMA = 1.0 / 2.2;\n\nvec3 rgb_to_srgb_approx(vec3 rgb) {\n    return pow(rgb, vec3(SRGB_GAMMA));\n}\n\nfloat f1(float t){\n    const float sigma = 6./29.;\n    if (t>sigma){\n        return t*t*t;\n    }else{\n        return 3.*sigma*sigma*(t-4./29.);\n    }\n}\n\nvec3 cielabtoxyz(vec3 c) {\n    const float xn = 95.047/100.;\n    const float yn = 100./100.;\n    const float zn = 108.883/100.;\n    return vec3(xn*f1((c.x+16.)/116.  + c.y/500. ),\n                yn*f1((c.x+16.)/116.),\n                zn*f1((c.x+16.)/116.  - c.z/200. )\n            );\n}\n\nvec3 xyztorgb(vec3 c){\n    return c * XYZ_2_RGB;\n}\n\nvec3 xyztosrgb(vec3 c) { // FIXME naming\n    return rgb_to_srgb_approx(xyztorgb(c));\n}\n\nvec4 cielabToSRGBA(vec4 cielab){\n    return vec4(xyztosrgb(cielabtoxyz(\n        vec3(\n            clamp(cielab.r, 0., 100.),\n            clamp(cielab.g, -128., 128.),\n            clamp(cielab.b, -128., 128.)\n        )\n    )), cielab.a);\n}\n#endif\n\n\n#ifndef SRGBA_TO_CIELAB\n#define SRGBA_TO_CIELAB\nvec4 sRGBToXYZ (vec4 srgba);\nvec4 sRGBToLinearRGB (vec4 srgba);\nfloat inverseGammaCorrection(float t);\nvec4 XYZToCieLab (vec4 xyza);\nfloat XYZToCieLabAux(float t);\n\nvec4 sRGBAToCieLAB(vec4 srgba){\n    return XYZToCieLab(sRGBToXYZ(srgba));\n}\n\n// Convert sRGB to CIE XYZ with the D65 white point\nvec4 sRGBToXYZ (vec4 srgba) {\n    // Poynton, \"Frequently Asked Questions About Color,\" page 10\n    // Wikipedia: http://en.wikipedia.org/wiki/SRGB\n    // Wikipedia: http://en.wikipedia.org/wiki/CIE_1931_color_space\n    vec4 rgba = sRGBToLinearRGB(srgba);\n    return vec4(\n        (0.4123955889674142161 * rgba.r + 0.3575834307637148171 * rgba.g + 0.1804926473817015735 * rgba.b),\n        (0.2125862307855955516 * rgba.r + 0.7151703037034108499 * rgba.g + 0.07220049864333622685 * rgba.b),\n        (0.01929721549174694484 * rgba.r + 0.1191838645808485318 * rgba.g + 0.9504971251315797660 * rgba.b),\n        rgba.a\n    );\n}\n\nvec4 sRGBToLinearRGB (vec4 srgba) {\n    // http://en.wikipedia.org/wiki/SRGB\n    return vec4(\n        inverseGammaCorrection(srgba.r),\n        inverseGammaCorrection(srgba.g),\n        inverseGammaCorrection(srgba.b),\n        srgba.a\n    );\n}\n\nfloat inverseGammaCorrection(float t) {\n    return t <= 0.0404482362771076 ? t / 12.92 : pow((t + 0.055) / 1.055, 2.4);\n}\n\n\nfloat WHITEPOINT_D65_X = 0.950456;\nfloat WHITEPOINT_D65_Y = 1.0;\nfloat WHITEPOINT_D65_Z = 1.088754;\n\n// Convert CIE XYZ to CIE L*a*b* (CIELAB) with the D65 white point\nvec4 XYZToCieLab (vec4 xyza) {\n    // Wikipedia: http://en.wikipedia.org/wiki/Lab_color_space\n\n    float xn = WHITEPOINT_D65_X;\n    float yn = WHITEPOINT_D65_Y;\n    float zn = WHITEPOINT_D65_Z;\n\n    return vec4(\n        116. * XYZToCieLabAux(xyza.y / yn) - 16.,\n        500. * (XYZToCieLabAux(xyza.x / xn) - XYZToCieLabAux(xyza.y / yn)),\n        200. * (XYZToCieLabAux(xyza.y / yn) - XYZToCieLabAux(xyza.z / zn)),\n        xyza.a\n    );\n}\n\nfloat XYZToCieLabAux(float t) {\n    return t >= 8.85645167903563082e-3\n            ? pow(t, 0.333333333333333) : (841.0 / 108.0) * t + 4.0 / 29.0;\n}\n\n#endif\n"

/***/ }),

/***/ "./src/renderer/viz/expressions/color/CIELab.js":
/*!******************************************************!*\
  !*** ./src/renderer/viz/expressions/color/CIELab.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CIELab; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _CIELab_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CIELab.glsl */ "./src/renderer/viz/expressions/color/CIELab.glsl");
/* harmony import */ var _CIELab_glsl__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_CIELab_glsl__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _colorspaces__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../colorspaces */ "./src/renderer/viz/colorspaces.js");





/**
 * Evaluates to a CIELab color.
 *
 * @param {Number} l - The lightness of the color
 * @param {Number} a - The greenred color component
 * @param {Number} b - The blueyellow color component
 * @return {Color}
 *
 * @example <caption>Display blue points.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.cielab(32.3, 79.2, -107.86)
 * });
 *
 * @example <caption>Display blue points. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: cielab(32.3, 79.2, -107.86)
 * `);
 *
 * @memberof carto.expressions
 * @name cielab
 * @function
 * @api
 */
class CIELab extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (l, a, b) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 3, 'cielab');
        l = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(l);
        a = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(a);
        b = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(b);

        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('cielab', 'l', 0, l);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('cielab', 'a', 1, a);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('cielab', 'b', 2, b);

        super({ l, a, b });
        this.type = 'color';

        this._setGenericGLSL(
            inline => `cielabToSRGBA(vec4(${inline.l}, ${inline.a}, ${inline.b}, 1.))`,
            _CIELab_glsl__WEBPACK_IMPORTED_MODULE_2___default.a
        );
    }

    get value () {
        return this.eval(null);
    }

    eval (feature) {
        return Object(_colorspaces__WEBPACK_IMPORTED_MODULE_3__["cielabToSRGB"])({
            l: this.l.eval(feature),
            a: this.a.eval(feature),
            b: this.b.eval(feature)
        });
    }

    getLegendData () {
        const name = 'color';
        const value = this.value;
        const key = '';
        const data = [{ key, value }];

        return { name, data };
    }

    _bindMetadata (meta) {
        super._bindMetadata(meta);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('cielab', 'l', 0, 'number', this.l);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('cielab', 'a', 1, 'number', this.a);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('cielab', 'b', 2, 'number', this.b);
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/color/NamedColor.js":
/*!**********************************************************!*\
  !*** ./src/renderer/viz/expressions/color/NamedColor.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NamedColor; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _cssColorNames__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cssColorNames */ "./src/renderer/viz/expressions/color/cssColorNames.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");





/**
 * Create a color from its name.
 *
 * @param {String} name - The name of the color
 * @return {Color}
 *
 * @example <caption>Display blue points.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.namedColor('blue')  // Equivalent to `color: 'blue'`
 * });
 *
 * @example <caption>Display blue points. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: blue  // Equivalent to namedColor('blue')
 * `);
 *
 * @memberof carto.expressions
 * @name namedColor
 * @function
 * @api
 */
class NamedColor extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (colorName) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'namedColor');
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkString"])('namedColor', 'colorName', 0, colorName);

        if (!_cssColorNames__WEBPACK_IMPORTED_MODULE_2__["CSS_COLOR_NAMES"].includes(colorName.toLowerCase())) {
            const preface = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["getStringErrorPreface"])('namedColor', 'colorName', 0);
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["default"](
                `${preface}\nInvalid color name:  '${colorName}'`,
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["CartoValidationErrorTypes"].INCORRECT_VALUE
            );
        }
        super({});
        this.type = 'color';
        this.name = colorName;
        this.expressionName = colorName;
        this.color = _nameToRGBA(this.name);
        this.inlineMaker = () => `vec4(${(this.color.r / 255).toFixed(4)}, ${(this.color.g / 255).toFixed(4)}, ${(this.color.b / 255).toFixed(4)}, ${(this.color.a).toFixed(4)})`;
    }

    get value () {
        return this.color;
    }

    toString () {
        return this.expressionName;
    }

    getLegendData () {
        const name = 'color';
        const value = this.color;
        const key = '';
        const data = [{ key, value }];

        return { name, data };
    }
}

const nameToRGBACache = {};

function _nameToRGBA (name) {
    if (nameToRGBACache[name]) {
        return nameToRGBACache[name];
    }
    const colorRegex = /^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+(?:\.\d+)?))?\)$/;
    const fakeDiv = document.createElement('div');
    fakeDiv.style.backgroundColor = name;
    document.body.appendChild(fakeDiv);
    const rgbSring = getComputedStyle(fakeDiv).backgroundColor;
    document.body.removeChild(fakeDiv);

    const match = colorRegex.exec(rgbSring);
    const color = {
        r: Number(match[1]),
        g: Number(match[2]),
        b: Number(match[3]),
        a: Number(match[4] || 1)
    };

    nameToRGBACache[name] = color;
    return color;
}


/***/ }),

/***/ "./src/renderer/viz/expressions/color/Opacity.js":
/*!*******************************************************!*\
  !*** ./src/renderer/viz/expressions/color/Opacity.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Opacity; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");



/**
 * Override the input opacity.
 *
 * @param {Color | Image} color - Color or image expression to apply the opacity
 * @param {Number} alpha - Number expression with the alpha (transparency) value
 * @return {Color | Image}
 *
 * @example <caption>Display blue points with 50% opacity.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.opacity(s.rgb(0,0,255), 0.5)  // Equivalent to `s.rgba(0,0,255,0.5)`
 * });
 *
 * @example <caption>Display blue points with 50% opacity. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: opacity(rgb(0,0,255), 0.5) // Equivalent to `rgba(0,0,255,0.5)`
 * `);
 *
 * @memberof carto.expressions
 * @name opacity
 * @function
 * @api
 */
class Opacity extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (input, alpha) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 2, 'opacity');

        input = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(input);
        alpha = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(alpha);

        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('opacity', 'input', 0, input);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('opacity', 'alpha', 1, alpha);
        super({ input, alpha });
        this.inlineMaker = inline => `vec4((${inline.input}).rgb, ${inline.alpha})`;
    }

    get value () {
        const value = this.input.value;
        const alpha = this.alpha.value;
        value.a = alpha;

        return value;
    }

    eval (feature) {
        const input = this.input.eval(feature);
        const alpha = this.alpha.eval(feature);
        input.a = alpha;

        return input;
    }

    getLegendData (options) {
        const legend = this.input.getLegendData(options);
        const alpha = this.alpha.value;

        if (this.input.type === 'color') {
            const data = legend.data.map(({ key, value }) => {
                const { r, g, b } = value;
                const a = alpha;

                return {
                    key,
                    value: { r, g, b, a }
                };
            });

            return { ...legend, data };
        } else {
            const data = legend.data;

            return { ...legend, data, alpha };
        }
    }

    _bindMetadata (meta) {
        super._bindMetadata(meta);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('opacity', 'input', 0, ['color', 'image'], this.input);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('opacity', 'alpha', 1, 'number', this.alpha);
        this.type = this.input.type;
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/color/cssColorNames.js":
/*!*************************************************************!*\
  !*** ./src/renderer/viz/expressions/color/cssColorNames.js ***!
  \*************************************************************/
/*! exports provided: CSS_COLOR_NAMES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSS_COLOR_NAMES", function() { return CSS_COLOR_NAMES; });
const CSS_COLOR_NAMES = [
    'aliceblue',
    'antiquewhite',
    'aqua',
    'aquamarine',
    'azure',
    'beige',
    'bisque',
    'black',
    'blanchedalmond',
    'blue',
    'blueviolet',
    'brown',
    'burlywood',
    'cadetblue',
    'chartreuse',
    'chocolate',
    'coral',
    'cornflowerblue',
    'cornsilk',
    'crimson',
    'cyan',
    'darkblue',
    'darkcyan',
    'darkgoldenrod',
    'darkgray',
    'darkgreen',
    'darkgrey',
    'darkkhaki',
    'darkmagenta',
    'darkolivegreen',
    'darkorange',
    'darkorchid',
    'darkred',
    'darksalmon',
    'darkseagreen',
    'darkslateblue',
    'darkslategray',
    'darkslategrey',
    'darkturquoise',
    'darkviolet',
    'deeppink',
    'deepskyblue',
    'dimgray',
    'dimgrey',
    'dodgerblue',
    'firebrick',
    'floralwhite',
    'forestgreen',
    'fuchsia',
    'gainsboro',
    'ghostwhite',
    'gold',
    'goldenrod',
    'gray',
    'green',
    'greenyellow',
    'grey',
    'honeydew',
    'hotpink',
    'indianred',
    'indigo',
    'ivory',
    'khaki',
    'lavender',
    'lavenderblush',
    'lawngreen',
    'lemonchiffon',
    'lightblue',
    'lightcoral',
    'lightcyan',
    'lightgoldenrodyellow',
    'lightgray',
    'lightgreen',
    'lightgrey',
    'lightpink',
    'lightsalmon',
    'lightseagreen',
    'lightskyblue',
    'lightslategray',
    'lightslategrey',
    'lightsteelblue',
    'lightyellow',
    'lime',
    'limegreen',
    'linen',
    'magenta',
    'maroon',
    'mediumaquamarine',
    'mediumblue',
    'mediumorchid',
    'mediumpurple',
    'mediumseagreen',
    'mediumslateblue',
    'mediumspringgreen',
    'mediumturquoise',
    'mediumvioletred',
    'midnightblue',
    'mintcream',
    'mistyrose',
    'moccasin',
    'navajowhite',
    'navy',
    'oldlace',
    'olive',
    'olivedrab',
    'orange',
    'orangered',
    'orchid',
    'palegoldenrod',
    'palegreen',
    'paleturquoise',
    'palevioletred',
    'papayawhip',
    'peachpuff',
    'peru',
    'pink',
    'plum',
    'powderblue',
    'purple',
    'red',
    'rosybrown',
    'royalblue',
    'saddlebrown',
    'salmon',
    'sandybrown',
    'seagreen',
    'seashell',
    'sienna',
    'silver',
    'skyblue',
    'slateblue',
    'slategray',
    'slategrey',
    'snow',
    'springgreen',
    'steelblue',
    'tan',
    'teal',
    'thistle',
    'tomato',
    'transparent',
    'turquoise',
    'violet',
    'wheat',
    'white',
    'whitesmoke',
    'yellow',
    'yellowgreen'
];


/***/ }),

/***/ "./src/renderer/viz/expressions/color/hex.js":
/*!***************************************************!*\
  !*** ./src/renderer/viz/expressions/color/hex.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Hex; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");




/**
 * Create a color from its hexadecimal description.
 *
 * @param {String} hexadecimalColor - Color in the #RGB, #RGBA, #RRGGBB or #RRGGBBAA format
 * @return {Color}
 *
 * @example <caption>Display blue points.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.hex('#00F');  // Equivalent to `color: '#00F'`
 * });
 *
 * @example <caption>Display blue points. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: #00F  // Equivalent to hex('#00F')
 * `);
 *
 * @memberof carto.expressions
 * @name hex
 * @function
 * @api
 */
class Hex extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (hexadecimalColor) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'hex');
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkString"])('hex', 'hexadecimalColor', 0, hexadecimalColor);

        super({});
        this.type = 'color';
        try {
            this.color = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["hexToRgb"])(hexadecimalColor);
        } catch (error) {
            const preface = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["getStringErrorPreface"])('hex', 'hexadecimalColor', 0);
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
                `${preface} \nInvalid hexadecimal color string`,
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_VALUE
            );
        }
        this.hexadecimalColor = hexadecimalColor;
        this.inlineMaker = () => `vec4(${(this.color.r / 255).toFixed(4)}, ${(this.color.g / 255).toFixed(4)}, ${(this.color.b / 255).toFixed(4)}, ${(this.color.a).toFixed(4)})`;
    }

    toString () {
        return this.hexadecimalColor;
    }

    get value () {
        return this.color;
    }

    eval () {
        return this.value;
    }

    getLegendData () {
        const name = 'color';
        const value = this.value;
        const key = '';
        const data = [{ key, value }];

        return { name, data };
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/color/hsl.js":
/*!***************************************************!*\
  !*** ./src/renderer/viz/expressions/color/hsl.js ***!
  \***************************************************/
/*! exports provided: HSL, HSLA */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HSL", function() { return HSL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HSLA", function() { return HSLA; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");





/**
 * Evaluates to a hsl color.
 *
 * @param {Number} h - hue of the color in the [0, 1] range
 * @param {Number} s - saturation of the color in the [0, 1] range
 * @param {Number} l - lightness of the color in the [0, 1] range
 * @return {Color}
 *
 * @example <caption>Display blue points.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.hsl(0.67, 1.0, 0.5)
 * });
 *
 * @example <caption>Display blue points. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: hsl(0.67, 1.0, 0.5)
 * `);
 *
 * @memberof carto.expressions
 * @name hsl
 * @function
 * @api
 */
const HSL = genHSL('hsl', false);

/**
 * Evaluates to a hsla color.
 *
 * @param {Number} h - hue of the color in the [0, 1] range
 * @param {Number} s - saturation of the color in the [0, 1] range
 * @param {Number} l - lightness of the color in the [0, 1] range
 * @param {Number} a - alpha value of the color in the [0, 1] range
 * @return {Color}
 *
 * @example <caption>Display blue points.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.hsla(0.67, 1.0, 0.5, 1.0)
 * });
 *
 * @example <caption>Display blue points. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: hsla(0.67, 1.0, 0.5, 1.0)
 * `);
 *
 * @memberof carto.expressions
 * @function
 * @name hsla
 * @api
 */
const HSLA = genHSL('hsla', true);

function genHSL (name, alpha = null) {
    return class HSLA extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
        constructor (h, s, l, a) {
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 4, 'hsla');

            [h, s, l, a] = [h, s, l, a].map(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"]);

            const children = { h, s, l };

            if (alpha) {
                Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])(name, 'a', 3, a);
                children.a = a;
            }

            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])(name, 'h', 0, h);
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])(name, 's', 1, s);
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])(name, 'l', 2, l);

            super(children);
            this._alpha = alpha;
            this.type = 'color';
        }

        get value () {
            return this.eval(null);
        }

        eval (feature) {
            const h = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["clamp"])(normalize(this.h, feature, true), 0, 1);
            const s = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["clamp"])(normalize(this.s, feature), 0, 1);
            const l = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["clamp"])(normalize(this.l, feature), 0, 1);
            const a = this.a;
            const alpha = this._alpha;

            return hslToRgb(h, s, l, a, alpha, feature);
        }

        getLegendData () {
            const name = 'color';
            const value = this.value;
            const key = '';
            const data = [{ key, value }];

            return { name, data };
        }
        _bindMetadata (meta) {
            super._bindMetadata(meta);
            hslCheckType('h', 0, this.h);
            hslCheckType('s', 1, this.s);
            hslCheckType('l', 2, this.l);

            if (this._alpha) {
                Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('hsla', 'a', 3, 'number', this.a);
            }

            super._setGenericGLSL(
                inline => `vec4(HSLtoRGB(vec3(
                    ${inline.h}${normalizeGLSL(this.h, true)},
                    clamp(${inline.s}${normalizeGLSL(this.s)}, 0., 1.),
                    clamp(${inline.l}${normalizeGLSL(this.l)}, 0., 1.)
                )), ${this._alpha ? `clamp(${inline.a}, 0., 1.)` : '1.'})`,
                `
                    #ifndef HSL2RGB
                    #define HSL2RGB
                    vec3 HSLtoRGB(vec3 HSL) {
                        float R = abs(HSL.x * 6. - 3.) - 1.;
                        float G = 2. - abs(HSL.x * 6. - 2.);
                        float B = 2. - abs(HSL.x * 6. - 4.);
                        float C = (1. - abs(2. * HSL.z - 1.)) * HSL.y;
                        vec3 RGB = clamp(vec3(R,G,B), 0., 1.);
                        return (RGB - 0.5) * C + HSL.z;
                    }
                    #endif
                `
            );
        }
    };

    function hslCheckType (parameterName, parameterIndex, parameter) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])(name, parameterName, parameterIndex, parameter);
        if (parameter.type !== 'number' && parameter.type !== 'category' && parameter.type !== undefined) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
                `${name}(): invalid parameter\n\t${parameterName} type was: '${parameter.type}'`,
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_TYPE
            );
        }
    }

    function hslToRgb (h, s, l, a, alpha, feature) {
        const aValue = alpha ? (feature ? a.eval(feature) : a.value) : 1;

        const c = {
            r: Math.abs(h * 6 - 3) - 1,
            g: 2 - Math.abs(h * 6 - 2),
            b: 2 - Math.abs(h * 6 - 4),
            a: aValue
        };

        const C = (1 - Math.abs(2 * l - 1)) * s;

        c.r = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["clamp"])(c.r, 0, 1);
        c.g = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["clamp"])(c.g, 0, 1);
        c.b = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["clamp"])(c.b, 0, 1);

        c.r = ((c.r - 0.5) * C + l) * 255;
        c.g = ((c.g - 0.5) * C + l) * 255;
        c.b = ((c.b - 0.5) * C + l) * 255;

        return c;
    }

    function normalize (input, feature, hue = false) {
        const data = feature !== null
            ? input.eval(feature)
            : input.value;

        if (input.type === 'category') {
            return data / (hue ? input.numCategories + 1 : input.numCategories);
        }

        return data;
    }

    function normalizeGLSL (input, hue = false) {
        if (input.type === 'category') {
            return `/${hue ? input.numCategories + 1 : input.numCategories}.`;
        }

        return '';
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/color/hsv.js":
/*!***************************************************!*\
  !*** ./src/renderer/viz/expressions/color/hsv.js ***!
  \***************************************************/
/*! exports provided: HSV, HSVA */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HSV", function() { return HSV; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HSVA", function() { return HSVA; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");




/**
 * Evaluates to a hsv color.
 *
 * @param {Number} h - hue of the color in the [0, 1] range
 * @param {Number} s - saturation of the color in the [0, 1] range
 * @param {Number} v - value (brightness) of the color in the [0, 1] range
 * @return {Color}
 *
 * @example <caption>Display blue points.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.hsv(0.67, 1.0, 1.0)
 * });
 *
 * @example <caption>Display blue points. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: hsv(0.67, 1.0, 1.0)
 * `);
 *
 * @memberof carto.expressions
 * @name hsv
 * @function
 * @api
 */
const HSV = genHSV('hsv', false);

/**
 * Evaluates to a hsva color.
 *
 * @param {Number} h - hue of the color in the [0, 1] range
 * @param {Number} s - saturation of the color in the [0, 1] range
 * @param {Number} v - value (brightness) of the color in the [0, 1] range
 * @param {Number} a - alpha value of the color in the [0, 1] range
 * @return {Color}
 *
 * @example <caption>Display blue points.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.hsva(0.67, 1.0, 1.0, 1.0)
 * });
 *
 * @example <caption>Display blue points. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: hsva(0.67, 1.0, 1.0, 1.0)
 * `);
 *
 * @memberof carto.expressions
 * @function
 * @name hsva
 * @api
 */
const HSVA = genHSV('hsva', true);

function genHSV (name, alpha) {
    return class extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
        constructor (h, s, v, a) {
            if (alpha) {
                Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 4, name);
            } else {
                Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 3, name);
            }

            h = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(h);
            s = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(s);
            v = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(v);
            const children = { h, s, v };
            if (alpha) {
                a = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(a);
                Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])(name, 'a', 3, a);
                children.a = a;
            }

            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])(name, 'h', 0, h);
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])(name, 's', 1, s);
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])(name, 'v', 2, v);

            super(children);
            this.type = 'color';
        }

        get value () {
            return this.eval(null);
        }

        eval (feature) {
            const normalize = (value, hue = false) => {
                if (value.type === 'category') {
                    return value.eval(feature) / (hue ? value.numCategories + 1 : value.numCategories);
                }
                return value.eval(feature);
            };
            const h = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["clamp"])(normalize(this.h, true), 0, 1);
            const s = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["clamp"])(normalize(this.s), 0, 1);
            const v = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["clamp"])(normalize(this.v), 0, 1);

            const hsvToRgb = (h, s, v) => {
                const c = {
                    r: Math.abs(h * 6 - 3) - 1,
                    g: 2 - Math.abs(h * 6 - 2),
                    b: 2 - Math.abs(h * 6 - 4),
                    a: alpha ? Object(_utils__WEBPACK_IMPORTED_MODULE_1__["clamp"])(this.a.eval(feature), 0, 1) : 1
                };

                c.r = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["clamp"])(c.r, 0, 1);
                c.g = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["clamp"])(c.g, 0, 1);
                c.b = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["clamp"])(c.b, 0, 1);

                c.r = ((c.r - 1) * s + 1) * v * 255;
                c.g = ((c.g - 1) * s + 1) * v * 255;
                c.b = ((c.b - 1) * s + 1) * v * 255;

                return c;
            };

            return hsvToRgb(h, s, v);
        }

        getLegendData () {
            const name = 'color';
            const value = this.value;
            const key = '';
            const data = [{ key, value }];

            return { name, data };
        }

        _bindMetadata (metadata) {
            super._bindMetadata(metadata);
            hsvCheckType('h', 0, this.h);
            hsvCheckType('s', 1, this.s);
            hsvCheckType('v', 2, this.v);
            if (alpha) {
                Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('hsva', 'a', 3, 'number', this.a);
            }
            const normalize = (value, hue = false) => {
                if (value.type === 'category') {
                    return `/${hue ? value.numCategories + 1 : value.numCategories}.`;
                }
                return '';
            };
            super._setGenericGLSL(
                inline => `vec4(HSVtoRGB(vec3(
                    ${inline.h}${normalize(this.h, true)},
                    clamp(${inline.s}${normalize(this.s)}, 0.,1.),
                    clamp(${inline.v}${normalize(this.v)}, 0.,1.)
                )), ${alpha ? `clamp(${inline.a}, 0.,1.)` : '1.'})`,
                `
                    #ifndef HSV2RGB
                    #define HSV2RGB
                    vec3 HSVtoRGB(vec3 HSV) {
                        float R = abs(HSV.x * 6. - 3.) - 1.;
                        float G = 2. - abs(HSV.x * 6. - 2.);
                        float B = 2. - abs(HSV.x * 6. - 4.);
                        vec3 RGB = clamp(vec3(R,G,B), 0., 1.);
                        return ((RGB - 1.) * HSV.y + 1.) * HSV.z;
                    }
                    #endif
                `
            );
        }
    };

    function hsvCheckType (parameterName, parameterIndex, parameter) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])(name, parameterName, parameterIndex, parameter);
        if (parameter.type !== 'number' && parameter.type !== 'category' && parameter.type !== undefined) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
                `${name}(): invalid parameter\n\t${parameterName} type was: '${parameter.type}'`,
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_TYPE
            );
        }
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/color/palettes.js":
/*!********************************************************!*\
  !*** ./src/renderer/viz/expressions/color/palettes.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var cartocolor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cartocolor */ "./node_modules/cartocolor/index.js");
/* harmony import */ var cartocolor__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cartocolor__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _palettes_Palette__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./palettes/Palette */ "./src/renderer/viz/expressions/color/palettes/Palette.js");




const palettes = {};

Object.keys(cartocolor__WEBPACK_IMPORTED_MODULE_0__).map(name => {
    palettes[`${name.toUpperCase()}`] = new _palettes_Palette__WEBPACK_IMPORTED_MODULE_1__["default"](name, cartocolor__WEBPACK_IMPORTED_MODULE_0__[name]);
});

/* harmony default export */ __webpack_exports__["default"] = (palettes);


/***/ }),

/***/ "./src/renderer/viz/expressions/color/palettes/Palette.js":
/*!****************************************************************!*\
  !*** ./src/renderer/viz/expressions/color/palettes/Palette.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Palette; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _rgb__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../rgb */ "./src/renderer/viz/expressions/color/rgb.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../expressions */ "./src/renderer/viz/expressions.js");





/**
 * Color palettes.
 *
 * Palettes are constants that allow to use {@link https://carto.com/carto-colors/|CARTOColors} and {@link https://github.com/axismaps/colorbrewer/|ColorBrewer} palettes easily.
 * Use them with a {@link carto.expressions.ramp|ramp}.
 *
 * The following palettes are available in the namespace {@link carto.expressions|carto.expressions}.
 *
 *  ```
 *  BURG, BURGYL, REDOR, ORYEL, PEACH, PINKYL, MINT, BLUGRN, DARKMINT, EMRLD, AG_GRNYL, BLUYL, TEAL, TEALGRN,
 *  PURP, PURPOR, SUNSET, MAGENTA, SUNSETDARK, AG_SUNSET, BRWNYL, ARMYROSE, FALL, GEYSER, TEMPS, TEALROSE, TROPIC,
 *  EARTH, ANTIQUE, BOLD, PASTEL, PRISM, SAFE, VIVID, CB_YLGN, CB_YLGNBU, CB_GNBU, CB_BUGN, CB_PUBUGN, CB_PUBU,
 *  CB_BUPU, CB_RDPU, CB_PURD, CB_ORRD, CB_YLORRD, CB_YLORBR, CB_PURPLES, CB_BLUES, CB_GREENS, CB_ORANGES, CB_REDS,
 *  CB_GREYS, CB_PUOR, CB_BRBG, CB_PRGN, CB_PIYG, CB_RDBU, CB_RDGY, CB_RDYLBU, CB_SPECTRAL, CB_RDYLGN, CB_ACCENT,
 *  CB_DARK2, CB_PAIRED, CB_PASTEL1, CB_PASTEL2, CB_SET1, CB_SET2, CB_SET3
 *  ```
 *
 * @example <caption>Using a color scheme.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.ramp(s.prop('type'), s.palettes.PRISM);
 * });
 *
 * @example <caption>Using a color scheme. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: ramp($type, PRISM)
 * `);
 *
 * @name palettes
 * @memberof carto.expressions
 * @api
 */
class Palette extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (name, subPalettes) {
        super({});
        this.type = 'palette';
        this.childType = 'color';
        this.name = name;
        this.subPalettes = new Proxy(subPalettes, {
            get: (target, name) => {
                if (typeof name !== 'symbol' && Number.isSafeInteger(Number(name)) && Array.isArray(target[name])) {
                    return target[name].map(_utils__WEBPACK_IMPORTED_MODULE_1__["hexToRgb"]);
                }
            }
        });
        this.expressionName = name;
        this.tags = subPalettes.tags;
    }

    getColors (numCategories) {
        const colors = this._getBestSubPalette(numCategories);

        if (this.isQualitative()) {
            const othersColor = colors.pop();
            return { colors, othersColor };
        } else {
            return { colors, othersColor: null };
        }
    }

    toString () {
        return this.expressionName;
    }

    _getBestSubPalette (subPaletteIndex) {
        const longestSubPaletteIndex = this.getLongestSubPaletteIndex();
        const smallestSubPaletteIndex = this.getSmallestSubPaletteIndex();
        if (!Number.isInteger(subPaletteIndex) || subPaletteIndex > longestSubPaletteIndex) {
            subPaletteIndex = longestSubPaletteIndex;
        } else if (subPaletteIndex < smallestSubPaletteIndex) {
            subPaletteIndex = smallestSubPaletteIndex;
        }
        const subPalette = [...this.subPalettes[subPaletteIndex]];
        return subPalette.map(color =>
            new _rgb__WEBPACK_IMPORTED_MODULE_2__["RGBA"](Object(_expressions__WEBPACK_IMPORTED_MODULE_3__["constant"])(color.r), Object(_expressions__WEBPACK_IMPORTED_MODULE_3__["constant"])(color.g), Object(_expressions__WEBPACK_IMPORTED_MODULE_3__["constant"])(color.b), Object(_expressions__WEBPACK_IMPORTED_MODULE_3__["constant"])(color.a))
        );
    }

    getSmallestSubPaletteIndex () {
        const s = this.subPalettes;
        for (let i = 0; i <= 20; i++) {
            if (s[i]) {
                return i;
            }
        }
    }

    getLongestSubPaletteIndex () {
        const s = this.subPalettes;
        for (let i = 20; i >= 0; i--) {
            if (s[i]) {
                return i;
            }
        }
    }

    isQualitative () {
        return this.tags.includes('qualitative');
    }

    isQuantitative () {
        return this.tags.includes('quantitative');
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/color/rgb.js":
/*!***************************************************!*\
  !*** ./src/renderer/viz/expressions/color/rgb.js ***!
  \***************************************************/
/*! exports provided: RGB, RGBA */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB", function() { return RGB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA", function() { return RGBA; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");



/**
 * Evaluates to a rgb color.
 *
 * @param {Number} r - The amount of red in the color in the [0, 255] range. Numeric expression.
 * @param {Number} g - The amount of green in the color in the [0, 255] range. Numeric expression.
 * @param {Number} b - The amount of blue in the color in the [0, 255] range. Numeric expression.
 * @return {Color}
 *
 * @example <caption>Display blue points.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.rgb(0, 0, 255)
 * });
 *
 * @example <caption>Display blue points. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: rgb(0, 0, 255)
 * `);
 *
 * @memberof carto.expressions
 * @name rgb
 * @function
 * @api
 */
const RGB = genRGB('rgb', false);

/**
 * Evaluates to a rgba color.
 *
 * @param {Number} r - The amount of red in the color in the [0, 255] range. Numeric expression.
 * @param {Number} g - The amount of green in the color in the [0, 255] range. Numeric expression.
 * @param {Number} b - The amount of blue in the color in the [0, 255] range. Numeric expression.
 * @param {Number} a - The alpha value of the color in the [0, 1] range. Numeric expression.
 * @return {Color}
 *
 * @example <caption>Display blue points.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.rgba(0, 0, 255, 1)
 * });
 *
 * @example <caption>Display blue points. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: rgba(0, 0, 255, 1)
 * `);
 *
 * @memberof carto.expressions
 * @name rgba
 * @function
 * @api
 */
const RGBA = genRGB('rgba', true);

// TODO refactor to uniformcolor, write color (plain, literal)

function genRGB (name, alpha) {
    return class RGBA extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
        constructor (r, g, b, a) {
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 4, 'rgba');

            [r, g, b, a] = [r, g, b, a].map(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"]);
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])(name, 'r', 0, r);
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])(name, 'g', 1, g);
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])(name, 'b', 2, b);

            const children = { r, g, b };
            if (alpha) {
                Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])(name, 'a', 3, a);
                children.a = a;
            }
            super(children);
            this.type = 'color';
            this.inlineMaker = inline => `vec4(${inline.r}/255., ${inline.g}/255., ${inline.b}/255., ${alpha ? inline.a : '1.'})`;
        }

        get value () {
            return {
                r: this.r.value,
                g: this.g.value,
                b: this.b.value,
                a: alpha ? this.a.value : 1
            };
        }

        eval () {
            return this.value;
        }

        getLegendData () {
            const name = 'color';
            const value = this.value;
            const key = '';
            const data = [{ key, value }];

            return { name, data };
        }

        _bindMetadata (meta) {
            super._bindMetadata(meta);
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])(name, 'r', 0, 'number', this.r);
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])(name, 'g', 1, 'number', this.g);
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])(name, 'b', 2, 'number', this.b);
            if (alpha) {
                Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('rgba', 'a', 3, 'number', this.a);
            }
        }
    };
}


/***/ }),

/***/ "./src/renderer/viz/expressions/constants.js":
/*!***************************************************!*\
  !*** ./src/renderer/viz/expressions/constants.js ***!
  \***************************************************/
/*! exports provided: DEFAULT_RAMP_OTHERS, DEFAULT_SAMPLES, OTHERS_GLSL_VALUE, OTHERS_INDEX, OTHERS_LABEL, SORT_DESC, SORT_ASC, DEFAULT_OPTIONS, FP32_DESIGNATED_NULL_VALUE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_RAMP_OTHERS", function() { return DEFAULT_RAMP_OTHERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_SAMPLES", function() { return DEFAULT_SAMPLES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OTHERS_GLSL_VALUE", function() { return OTHERS_GLSL_VALUE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OTHERS_INDEX", function() { return OTHERS_INDEX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OTHERS_LABEL", function() { return OTHERS_LABEL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SORT_DESC", function() { return SORT_DESC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SORT_ASC", function() { return SORT_ASC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_OPTIONS", function() { return DEFAULT_OPTIONS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FP32_DESIGNATED_NULL_VALUE", function() { return FP32_DESIGNATED_NULL_VALUE; });
const DEFAULT_RAMP_OTHERS = 'DEFAULT_RAMP_OTHERS';
const DEFAULT_SAMPLES = 10;
const OTHERS_GLSL_VALUE = '(-1.)';
const OTHERS_INDEX = -1;
const OTHERS_LABEL = 'CARTO_VL_OTHERS';
const SORT_DESC = 'DESC';
const SORT_ASC = 'ASC';
const DEFAULT_OPTIONS = {
    othersLabel: OTHERS_LABEL,
    samples: DEFAULT_SAMPLES,
    order: SORT_ASC
};

const FP32_DESIGNATED_NULL_VALUE = -(1 << 24);


/***/ }),

/***/ "./src/renderer/viz/expressions/histogram/GlobalHistogram.js":
/*!*******************************************************************!*\
  !*** ./src/renderer/viz/expressions/histogram/GlobalHistogram.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GlobalHistogram; });
/* harmony import */ var _Histogram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Histogram */ "./src/renderer/viz/expressions/histogram/Histogram.js");
/* harmony import */ var _basic_property__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../basic/property */ "./src/renderer/viz/expressions/basic/property.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../constants */ "./src/renderer/viz/expressions/constants.js");





/**
 * Generates a histogram based on a representative sample of the data.
 *
 * The histogram can be based on a categorical expression, in which case each category will correspond to a histogram bar.
 *
 * The histogram can be based on a numeric expression, the buckets for the histogram is controllable through the `sizeOrBuckets` parameter.
 * For numeric values of sizeOrBuckets, the minimum and maximum will be computed automatically and bars will be generated at regular intervals between the minimum and maximum.
 * When providing sizeOrBuckets as a list of buckets, the values will get assigned to the first bucket matching the criteria [bucketMin <= value < bucketMax].
 *
 * The globalHistogram can also be combined with the `top()` expression.
 *
 * Histograms are useful to get insights and create widgets outside the scope of CARTO VL, see the following example for more info.
 *
 * @param {Number} input - expression to base the histogram
 * @param {Number|Array} sizeOrBuckets - Optional (defaults to 20). Number of bars to use if `x` is a numeric expression; or user-defined buckets for numeric expressions.
 * @return {GlobalHistogram} GlobalHistogram
 *
 * @example <caption>Create and use an histogram.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz(
 *     variables: {
 *       categoryHistogram: s.globalHistogram(s.prop('type')),
 *       numericHistogram: s.globalHistogram(s.prop('amount'), 3, 1),
 *       userDefinedHistogram: s.globalHistogram(s.prop('amount', [[0, 10], [10, 20], [20, 30]], 1),
 *       topCategoryHistogram: s.globalHistogram(s.top(s.prop('type'), 3))
 *     }
 * );
 * // ...
 * console.log(viz.variables.categoryHistogram.value);
 * // [{x: 'typeA', y: 10}, {x: 'typeB', y: 20}]
 * // There are 10 features of type A and 20 of type B
 *
 * console.log(viz.variables.numericHistogram.value);
 * // [{x: [0,10],  y: 20}, {x: [10,20],  y: 7}, {x: [20, 30], y: 3}]
 * // There are 20 features with an amount between 0 and 10, 7 features with an amount between 10 and 20, and 3 features with an amount between 20 and 30
 *
 *
 * @example <caption>Create and use an histogram. (String)</caption>
 * const viz = new carto.Viz(`
 *    \@categoryHistogram:    globalHistogram($type)
 *    \@numericHistogram:     globalHistogram($amount, 3, 1)
 *    \@userDefinedHistogram: globalHistogram($amount, [[0, 10], [10, 20], [20, 30]], 1)
 *    \@topCategoryHistogram: globalHistogram(top($type, 3))
 * `);
 * // ...
 * console.log(viz.variables.categoryHistogram.value);
 * // [{x: 'typeA', y: 10}, {x: 'typeB', y: 20}]
 * // There are 10 features of type A and 20 of type B
 *
 * console.log(viz.variables.numericHistogram.value);
 * // [{x: [0,10],  y: 20}, {x: [10,20],  y: 7}, {x: [20, 30], y: 3}]
 * // There are 20 features with an amount between 0 and 10, 7 features with an amount between 10 and 20, and 3 features with an amount between 20 and 30
 *
 * @memberof carto.expressions
 * @name globalHistogram
 * @function
 * @api
 */

/**
 * GlobalHistogram Class
 *
 * Generates a histogram based on the samples from the metadata.
 * This class is instanced automatically by using the `globalHistogram` function. It is documented for its methods.
 * Read more about histogram expression at {@link carto.expressions.globalHistogram}.
 *
 * @name expressions.GlobalHistogram
 * @abstract
 * @hideconstructor
 * @class
 * @api
 */
class GlobalHistogram extends _Histogram__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (input, sizeOrBuckets = 20) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkMaxArguments"])(arguments, 3, 'globalHistogram');
        super({ input: Object(_utils__WEBPACK_IMPORTED_MODULE_2__["implicitCast"])(input) });

        this._sizeOrBuckets = sizeOrBuckets;
        this._hasBuckets = Array.isArray(sizeOrBuckets);
        this._histogram = new Map();
    }

    /**
     * Get an array of joined data by key and sorted by frequency.
     *
     * Note: It can be combined with a `ramp.getLegendData()` method. Take a look at the examples to see how it works.
     *
     * @param {Array} values - Array of { key, value } pairs
     * @return {Array} - { frequency, key, value }
     * @memberof expressions.GlobalHistogram
     * @api
     * @example <caption>Get joined data for a categorical property sorted by frequency.</caption>
     * const numberOfWheels = [
     *  { key: 'car', value: 4 },
     *  { key: 'truck', value: 8 },
     *  { key: 'bike', value: 2 }
     * ];
     *
     * const s = carto.expressions;
     * const viz = new carto.Viz({
     *   @histogram: s.globalHistogram(s.prop('vehicles'))
     * });
     *
     * const data = viz.variables.histogram.getJoinedValues(numberOfWheels);
     * // returns an array with the following format:
     * // [
     * //   { frequency: 10, key: 'truck', value: 8 }
     * //   { frequency: 20, key: 'bike', value: 2 }
     * //   { frequency: 30, key: 'car', value: 4 }
     * // ]
     *
     * @example <caption>Get joined data for a categorical property sorted by frequency. (String)</caption>
     * const numberOfWheels = [
     *  { key: 'car', value: 4 },
     *  { key: 'truck', value: 8 },
     *  { key: 'bike', value: 2 }
     * ];
     *
     * const s = carto.expressions;
     * const viz = new carto.Viz(`
     *   @histogram: globalHistogram($vehicles)
     * `);
     *
     * const data = viz.variables.histogram.getJoinedValues(numberOfWheels);
     * // returns an array with the following format:
     * // [
     * //   { frequency: 10, key: 'truck', value: 8 }
     * //   { frequency: 20, key: 'bike', value: 2 }
     * //   { frequency: 30, key: 'car', value: 4 }
     * // ]
     *
     * @example <caption>Get color values for the histogram when using a ramp.</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz(`
     *   @histogram: s.globalHistogram(s.prop('vehicles'))
     *   color: ramp(s.prop('vehicles'), s.palettes.PRISM)
     * `);
     *
     * const legend = viz.color.getLegendData();
     * const data = viz.variables.histogram.getJoinedValues(legend.data);
     * // returns the following array
     * // [
     * //   { frequency: 10, key: 'truck', value: { r: 95, g: 70, b: 144, a: 1 } }
     * //   { frequency: 20, key: 'bike', value: { r: 29, g: 105, b: 150, a: 1 } }
     * //   { frequency: 30, key: 'car', value: { r: 56, g: 166, b: 165, a: 1 } }
     * // ]
     *
     * @example <caption>Get color values for the histogram when using a ramp. (String)</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz(`
     *   @histogram: globalHistogram($vehicles)
     *   color: ramp($vehicles, Prism)
     * `);
     *
     * const legend = viz.color.getLegendData();
     * const data = viz.variables.histogram.getJoinedValues(legend.data);
     * // returns the following array
     * // [
     * //   { frequency: 10, key: 'truck', value: { r: 95, g: 70, b: 144, a: 1 } }
     * //   { frequency: 20, key: 'bike', value: { r: 29, g: 105, b: 150, a: 1 } }
     * //   { frequency: 30, key: 'car', value: { r: 56, g: 166, b: 165, a: 1 } }
     * // ]
     * @example <caption>Get color values for the histogram using a ramp with classified data.</caption>
     * // Note: Both the ramp and the histogram expressions must use the same classification.
     *
     * const s = carto.expressions;
     * const viz = new carto.Viz(`
     *   @histogram: s.globalHistogram(s.top(s.prop('vehicles'), 2))
     *   color: ramp(s.top(s.prop('vehicles'), 2)), s.palettes.PRISM, s.rgba(0, 128, 0, 1))
     * `);
     *
     * const options = { othersLabel: 'Others '};
     * const legend = viz.color.getLegendData(options);
     * const data = viz.variables.histogram.getJoinedValues(legend.data, options);
     * // returns the following array
     * // [
     * //   { frequency: 10, key: 'truck', value: { r: 95, g: 70, b: 144, a: 1 } }
     * //   { frequency: 20, key: 'bike', value: { r: 29, g: 105, b: 150, a: 1 } }
     * //   { frequency: 30, key: 'Others', value: { r: 0, g: 128, b: 0, a: 1 } }
     * // ]
     *
     * @example <caption>Get color values for the histogram using a ramp with classified data (String).</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz(`
     *   @histogram: globalHistogram(top($vehicles, 2))
     *   color: ramp((top($vehicles, 2)), Prism, green)
     * `);
     *
     * const options = { othersLabel: 'Others '};
     * const legend = viz.color.getLegendData(options);
     * const data = viz.variables.histogram.getJoinedValues(legend.data, options);
     * // returns the following array
     * // [
     * //   { frequency: 10, key: 'truck', value: { r: 95, g: 70, b: 144, a: 1 } }
     * //   { frequency: 20, key: 'bike', value: { r: 29, g: 105, b: 150, a: 1 } }
     * //   { frequency: 30, key: 'Others', value: { r: 0, g: 128, b: 0, a: 1 } }
     * // ]
     *
     */
    getJoinedValues (values, options) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkArray"])('globalHistogram.getJoinedValues', 'values', 0, values);

        if (!values.length) {
            return [];
        }

        const config = Object.assign({}, _constants__WEBPACK_IMPORTED_MODULE_3__["DEFAULT_OPTIONS"], options);
        const joinedValues = [];

        this.value.forEach((elem) => {
            elem.x = elem.x === _constants__WEBPACK_IMPORTED_MODULE_3__["OTHERS_LABEL"]
                ? config.othersLabel
                : elem.x;
            const val = values.find(value => elem.x === value.key);

            if (val) {
                const frequency = elem.y;
                const key = val.key;
                const value = val.value;

                joinedValues.push({ frequency, key, value });
            }
        });

        return joinedValues;
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);

        this._histogram = new Map();

        if (!this.input.isA(_basic_property__WEBPACK_IMPORTED_MODULE_1__["default"])) {
            this._setHistogramForExpression();
            return;
        }

        if (this.input.type === 'number') {
            this._setHistogramForNumericValues();
            return;
        }

        this._setHistogramForCategoryValues();
    }

    _setHistogramForExpression () {
        const data = this.input.getLegendData(_constants__WEBPACK_IMPORTED_MODULE_3__["DEFAULT_OPTIONS"]).data;

        this._categories.forEach(c => {
            const category = data.find(category => c.name === category.key);
            if (category) {
                this._histogram.set(c.name, c.frequency);
            } else {
                const frequency = this._histogram.get(_constants__WEBPACK_IMPORTED_MODULE_3__["OTHERS_LABEL"]) || 0;
                this._histogram.set(_constants__WEBPACK_IMPORTED_MODULE_3__["OTHERS_LABEL"], c.frequency + parseInt(frequency));
            }
        });
    }

    _setHistogramForCategoryValues () {
        this._categories.forEach(category => {
            this._histogram.set(category.name, category.frequency);
        });
    }

    _setHistogramForNumericValues () {
        const name = this.propertyName;
        const ratio = this._metadata.featureCount / this._metadata.sample.length;

        this._metadata.sample.forEach((feature) => {
            const key = feature[name];
            const value = this._histogram.get(key) || 0;

            this._histogram.set(key, value + ratio);
        });
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/histogram/Histogram.js":
/*!*************************************************************!*\
  !*** ./src/renderer/viz/expressions/histogram/Histogram.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Histogram; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");

class Histogram extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (children) {
        super(children);
        this.type = 'histogram';
        this.inlineMaker = () => null;
    }

    get value () {
        switch (this.input.type) {
            case 'number':
                return this._hasBuckets
                    ? this._getBucketsValue(this._histogram, this._sizeOrBuckets)
                    : this._getNumericValue(this._histogram, this._sizeOrBuckets);
            case 'date':
                return this._hasBuckets
                    ? this._getBucketsValue(this._histogram, this._sizeOrBuckets)
                    : this._getDateValue(this._histogram, this._sizeOrBuckets);
            default:
                return this._getCategoryValue(this._histogram);
        }
    }

    eval () {
        return this.value;
    }

    getAllCategories () {
        return this._categories || [];
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);
        this._metadata = metadata;
        const name = this.propertyName;
        this._categories = this._metadata.properties[name]
            ? this._metadata.properties[name].categories.sort(this._sortByFrequency)
            : [];
    }

    _getCategoryValue (histogram) {
        return [...histogram]
            .map(([x, y]) => {
                return { x, y };
            })
            .sort(this._sortByFrequency)
            .map((category, index) => {
                const x = typeof category.x === 'number' && this._categories[index]
                    ? this._categories[index].name
                    : category.x;
                const y = category.y;

                return { x, y };
            });
    }

    _getNumericValue (histogram, size) {
        const array = [...histogram];
        const arrayLength = array.length;
        let min = Number.POSITIVE_INFINITY;
        let max = Number.NEGATIVE_INFINITY;

        for (let i = 0; i < arrayLength; i++) {
            const x = array[i][0];
            min = Math.min(min, x);
            max = Math.max(max, x);
        }

        const hist = Array(size).fill(0);
        const range = max - min;
        const sizeMinusOne = size - 1;

        for (let i = 0; i < arrayLength; i++) {
            const x = array[i][0];
            const y = array[i][1];
            const index = Math.min(Math.floor(size * (x - min) / range), sizeMinusOne);
            hist[index] += y;
        }

        return hist.map((count, index) => {
            return {
                x: [min + index / size * range, min + (index + 1) / size * range],
                y: count
            };
        });
    }

    _getBucketsValue ([...histogram], buckets) {
        buckets = buckets.length && buckets.length === 0 ? this._genBreakpoints(buckets) : buckets;
        const nBuckets = buckets.length;
        const hist = Array(nBuckets).fill(0);

        for (let i = 0, len = histogram.length; i < len; i++) {
            const x = histogram[i][0];
            for (let j = 0; j < nBuckets; j++) {
                const bucket = buckets[j];
                if (x >= bucket[0] && x < bucket[1]) {
                    hist[j] += histogram[i][1];
                    break;
                }
            }
        }

        return hist.map((count, index) => {
            return {
                x: buckets[index],
                y: count
            };
        });
    }

    _getDateValue (histogram, size) {
        const array = [...histogram].map((value) => {
            return { x: value[0].getTime(), y: value[1] };
        });
        const arrayLength = array.length;

        let min = Number.POSITIVE_INFINITY;
        let max = Number.NEGATIVE_INFINITY;

        for (let i = 0; i < arrayLength; i++) {
            const x = array[i].x;
            min = Math.min(min, x);
            max = Math.max(max, x);
        }

        const hist = Array(size).fill(0);
        const range = max - min;
        const sizeMinusOne = size - 1;

        for (let i = 0; i < arrayLength; i++) {
            const x = array[i].x;
            const y = array[i].y;
            const index = Math.min(Math.floor(size * (x - min) / range), sizeMinusOne);
            hist[index] += y;
        }

        return hist.map((count, index) => {
            const x0 = new Date(min + index / size * range);
            const x1 = new Date(min + (index + 1) / size * range);

            return {
                x: [x0, x1],
                y: count
            };
        });
    }

    _genBreakpoints () {
        const histogram = this._histogram.value;

        if (!histogram) {
            return;
        }

        const accumHistogram = this._getAccumHistogramFrom(histogram);
        const [min, max] = this._getMinMaxFrom(histogram);

        this._updateBreakpointsWith({ accumHistogram, min, max });
    }

    _getAccumHistogramFrom (histogram) {
        let prev = 0;
        const accumHistogram = histogram.map(({ y }) => {
            prev += y;
            return prev;
        });
        return accumHistogram;
    }

    _getMinMaxFrom (histogram) {
        const min = histogram[0].x[0];
        const max = histogram[histogram.length - 1].x[1];

        return [min, max];
    }

    _sortByFrequency (a, b) {
        const frequencyDifference = (b.y - a.y);

        if (frequencyDifference === 0) {
            const categoryA = a.x;
            const categoryB = b.x;

            if (!categoryA && !categoryB) { return 0; } // both null or undefined
            if (!categoryA) { return 1; } // categoryB first
            if (!categoryB) { return -1; } // categoryA first

            if (typeof categoryA === 'string' && typeof categoryB === 'string') {
                return categoryA.localeCompare(categoryB);
            }

            if (categoryA < categoryB) return -1; // categoryA first
            if (categoryA > categoryB) return 1; // categoryB first
            return 0;
        }

        return frequencyDifference;
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/histogram/ViewportHistogram.js":
/*!*********************************************************************!*\
  !*** ./src/renderer/viz/expressions/histogram/ViewportHistogram.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewportHistogram; });
/* harmony import */ var _Histogram__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Histogram */ "./src/renderer/viz/expressions/histogram/Histogram.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants */ "./src/renderer/viz/expressions/constants.js");
/* harmony import */ var _top__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../top */ "./src/renderer/viz/expressions/top.js");
/* harmony import */ var _constants_metadata__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../../constants/metadata */ "./src/constants/metadata.js");







/**
 * Generates a histogram based on the data from the features present in the viewport.
 *
 * The histogram can be based on a categorical expression, in which case each category will correspond to a histogram bar.
 *
 * The histogram can be based on a numeric expression, the buckets for the histogram is controllable through the `sizeOrBuckets` parameter.
 * For numeric values of sizeOrBuckets, the minimum and maximum will be computed automatically and bars will be generated at regular intervals between the minimum and maximum.
 * When providing sizeOrBuckets as a list of buckets, the values will get assigned to the first bucket matching the criteria [bucketMin <= value < bucketMax].
 *
 * The viewportHistogram can also be combined with the `top()` expression.
 *
 * Histograms are useful to get insights and create widgets outside the scope of CARTO VL, see the following example for more info.
 *
 * @param {Number} input - expression to base the histogram
 * @param {Number|Array} sizeOrBuckets - Optional (defaults to 20). Number of bars to use if `x` is a numeric expression; or user-defined buckets for numeric expressions.
 * @param {Number} weight - Optional. Weight each occurrence differently based on this weight, defaults to `1`, which will generate a simple, non-weighted count.
 * @return {ViewportHistogram} ViewportHistogram
 *
 * @example <caption>Create and use an histogram.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz(
 *     variables: {
 *       categoryHistogram: s.viewportHistogram(s.prop('type')),
 *       numericHistogram: s.viewportHistogram(s.prop('amount'), 3, 1),
 *       userDefinedHistogram: s.viewportHistogram(s.prop('amount', [[0, 10], [10, 20], [20, 30]], 1),
 *       topCategoryHistogram: s.viewportHistogram(s.top(s.prop('type'), 3))
 *     }
 * );
 * // ...
 * console.log(viz.variables.categoryHistogram.value);
 * // [{x: 'typeA', y: 10}, {x: 'typeB', y: 20}]
 * // There are 10 features of type A and 20 of type B
 *
 * console.log(viz.variables.numericHistogram.value);
 * // [{x: [0,10],  y: 20}, {x: [10,20],  y: 7}, {x: [20, 30], y: 3}]
 * // There are 20 features with an amount between 0 and 10, 7 features with an amount between 10 and 20, and 3 features with an amount between 20 and 30
 *
 *
 * @example <caption>Create and use an histogram. (String)</caption>
 * const viz = new carto.Viz(`
 *    \@categoryHistogram:    viewportHistogram($type)
 *    \@numericHistogram:     viewportHistogram($amount, 3, 1)
 *    \@userDefinedHistogram: viewportHistogram($amount, [[0, 10], [10, 20], [20, 30]], 1)
 *    \@topCategoryHistogram: viewportHistogram(top($type, 3))
 * `);
 * // ...
 * console.log(viz.variables.categoryHistogram.value);
 * // [{x: 'typeA', y: 10}, {x: 'typeB', y: 20}]
 * // There are 10 features of type A and 20 of type B
 *
 * console.log(viz.variables.numericHistogram.value);
 * // [{x: [0,10],  y: 20}, {x: [10,20],  y: 7}, {x: [20, 30], y: 3}]
 * // There are 20 features with an amount between 0 and 10, 7 features with an amount between 10 and 20, and 3 features with an amount between 20 and 30
 *
 * @memberof carto.expressions
 * @name viewportHistogram
 * @function
 * @api
 */

/**
 * ViewportHistogram Class
 *
 * Generates a histogram based on the features in the viewport.
 * This class is instanced automatically by using the `viewportHistogram` function. It is documented for its methods.
 * Read more about histogram expression at {@link carto.expressions.viewporthistogram}.
 *
 * @name expressions.ViewportHistogram
 * @abstract
 * @hideconstructor
 * @class
 * @api
 */
class ViewportHistogram extends _Histogram__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (input, sizeOrBuckets = 20, weight = 1) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 3, 'viewportHistogram');
        super({ input: Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(input), weight: Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(weight) });

        this._sizeOrBuckets = sizeOrBuckets;
        this._isViewport = true;
        this._hasBuckets = Array.isArray(sizeOrBuckets);
        this._cached = null;
    }

    get value () {
        if (this._cached === null) {
            if (!this._histogram) {
                return null;
            }
            this._cached = super.value;
        }

        return this._cached;
    }

    eval () {
        return this.value;
    }

    /**
     * Get an array of joined data by key and sorted by frequency.
     *
     * Note: It can be combined with a `ramp.getLegendData()` method. Take a look at the examples to see how it works.
     *
     * @param {Array} values - Array of { key, value } pairs
     * @return {Array} - { frequency, key, value }
     * @memberof expressions.ViewportHistogram
     * @api
     * @example <caption>Get joined data for a categorical property sorted by frequency.</caption>
     * const numberOfWheels = [
     *  { key: 'car', value: 4 },
     *  { key: 'truck', value: 8 },
     *  { key: 'bike', value: 2 }
     * ];
     *
     * const s = carto.expressions;
     * const viz = new carto.Viz({
     *   @histogram: s.viewportHistogram(s.prop('vehicles'))
     * });
     *
     * const data = viz.variables.histogram.getJoinedValues(numberOfWheels);
     * // returns an array with the following format:
     * // [
     * //   { frequency: 10, key: 'truck', value: 8 }
     * //   { frequency: 20, key: 'bike', value: 2 }
     * //   { frequency: 30, key: 'car', value: 4 }
     * // ]
     *
     * @example <caption>Get joined data for a categorical property sorted by frequency. (String)</caption>
     * const numberOfWheels = [
     *  { key: 'car', value: 4 },
     *  { key: 'truck', value: 8 },
     *  { key: 'bike', value: 2 }
     * ];
     *
     * const s = carto.expressions;
     * const viz = new carto.Viz(`
     *   @histogram: viewportHistogram($vehicles)
     * `);
     *
     * const data = viz.variables.histogram.getJoinedValues(numberOfWheels);
     * // returns an array with the following format:
     * // [
     * //   { frequency: 10, key: 'truck', value: 8 }
     * //   { frequency: 20, key: 'bike', value: 2 }
     * //   { frequency: 30, key: 'car', value: 4 }
     * // ]
     *
     * @example <caption>Get color values for the histogram when using a ramp.</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz(`
     *   @histogram: s.viewportHistogram(s.prop('vehicles'))
     *   color: ramp(s.prop('vehicles'), s.palettes.PRISM)
     * `);
     *
     * const legend = viz.color.getLegendData();
     * const data = viz.variables.histogram.getJoinedValues(legend.data);
     * // returns the following array
     * // [
     * //   { frequency: 10, key: 'truck', value: { r: 95, g: 70, b: 144, a: 1 } }
     * //   { frequency: 20, key: 'bike', value: { r: 29, g: 105, b: 150, a: 1 } }
     * //   { frequency: 30, key: 'car', value: { r: 56, g: 166, b: 165, a: 1 } }
     * // ]
     *
     * @example <caption>Get color values for the histogram when using a ramp. (String)</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz(`
     *   @histogram: viewportHistogram($vehicles)
     *   color: ramp($vehicles, Prism)
     * `);
     *
     * const legend = viz.color.getLegendData();
     * const data = viz.variables.histogram.getJoinedValues(legend.data);
     * // returns the following array
     * // [
     * //   { frequency: 10, key: 'truck', value: { r: 95, g: 70, b: 144, a: 1 } }
     * //   { frequency: 20, key: 'bike', value: { r: 29, g: 105, b: 150, a: 1 } }
     * //   { frequency: 30, key: 'car', value: { r: 56, g: 166, b: 165, a: 1 } }
     * // ]
     * @example <caption>Get color values for the histogram using a ramp with classified data.</caption>
     * // Note: Both the ramp and the histogram expressions must use the same classification.
     *
     * const s = carto.expressions;
     * const viz = new carto.Viz(`
     *   @histogram: s.viewportHistogram(s.top(s.prop('vehicles'), 2))
     *   color: ramp(s.top(s.prop('vehicles'), 2)), s.palettes.PRISM, s.rgba(0, 128, 0, 1))
     * `);
     *
     * const options = { othersLabel: 'Others '};
     * const legend = viz.color.getLegendData(options);
     * const data = viz.variables.histogram.getJoinedValues(legend.data, options);
     * // returns the following array
     * // [
     * //   { frequency: 10, key: 'truck', value: { r: 95, g: 70, b: 144, a: 1 } }
     * //   { frequency: 20, key: 'bike', value: { r: 29, g: 105, b: 150, a: 1 } }
     * //   { frequency: 30, key: 'Others', value: { r: 0, g: 128, b: 0, a: 1 } }
     * // ]
     *
     * @example <caption>Get color values for the histogram using a ramp with classified data (String).</caption>
     * const s = carto.expressions;
     * const viz = new carto.Viz(`
     *   @histogram: viewportHistogram(top($vehicles, 2))
     *   color: ramp((top($vehicles, 2)), Prism, green)
     * `);
     *
     * const options = { othersLabel: 'Others '};
     * const legend = viz.color.getLegendData(options);
     * const data = viz.variables.histogram.getJoinedValues(legend.data, options);
     * // returns the following array
     * // [
     * //   { frequency: 10, key: 'truck', value: { r: 95, g: 70, b: 144, a: 1 } }
     * //   { frequency: 20, key: 'bike', value: { r: 29, g: 105, b: 150, a: 1 } }
     * //   { frequency: 30, key: 'Others', value: { r: 0, g: 128, b: 0, a: 1 } }
     * // ]
     *
     */
    getJoinedValues (values, options) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkArray"])('viewportHistogram.getJoinedValues', 'values', 0, values);

        if (!values.length) {
            return [];
        }

        const config = Object.assign({}, _constants__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_OPTIONS"], options);
        const joinedValues = [];
        const otherValues = [];

        this.value.forEach((elem) => {
            const val = values.find(value => {
                if (Array.isArray(value.key)) {
                    return value.key[0] === elem.x[0] && value.key[1] === elem.x[1];
                }
                return elem.x === value.key;
            });

            if (val) {
                const frequency = elem.y;
                const key = val.key;
                const value = val.value;

                joinedValues.push({ frequency, key, value });
            } else {
                otherValues.push(elem.y);
            }
        });

        const others = values.find(value => config.othersLabel === value.key);

        if (others) {
            const frequency = otherValues.reduce((prev, freq) => prev + freq);
            const key = others.key;
            const value = others.value;

            joinedValues.push({ frequency, key, value });
        }

        return joinedValues.sort((a, b) => b.frequency - a.frequency);
    }

    accumViewportAgg (feature) {
        const evalFeature = this.input.eval(feature);
        const property = this.input.isA(_top__WEBPACK_IMPORTED_MODULE_3__["default"])
            ? evalFeature.label
            : evalFeature;

        if (property !== undefined) {
            const clusterCount = feature[_constants_metadata__WEBPACK_IMPORTED_MODULE_4__["CLUSTER_FEATURE_COUNT"]] || 1;
            const weight = clusterCount * this.weight.eval(feature);
            const count = this._histogram.get(property) || 0;
            this._histogram.set(property, count + weight);
        }
    }

    _resetViewportAgg (metadata) {
        if (metadata) {
            this._bindMetadata(metadata);
        }
        this._cached = null;
        this._histogram = new Map();
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/interpolators.js":
/*!*******************************************************!*\
  !*** ./src/renderer/viz/expressions/interpolators.js ***!
  \*******************************************************/
/*! exports provided: ILinear, Cubic, BounceEaseIn */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ILinear", function() { return ILinear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cubic", function() { return Cubic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BounceEaseIn", function() { return BounceEaseIn; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");




// TODO type checking

class ILinear extends genInterpolator('iLinear', inner => inner, undefined, inner => inner) { }

class Cubic extends genInterpolator(
    'cubic',
    inner => `cubicEaseInOut(${inner})`,
    `
    #ifndef CUBIC
    #define CUBIC
    float cubicEaseInOut(float p){
        if (p < 0.5) {
            return 4. * p * p * p;
        }else {
            float f = ((2. * p) - 2.);
            return 0.5 * f * f * f + 1.;
        }
    }
    #endif
`,
    inner => inner // TODO FIXME
) { }

class BounceEaseIn extends genInterpolator(
    'bounceEaseIn',
    inner => `BounceEaseIn(${inner})`,
    `
    #ifndef BOUNCE_EASE_IN
    #define BOUNCE_EASE_IN
    float BounceEaseIn_BounceEaseOut(float p)
    {
        if(p < 4./11.0)
        {
            return (121. * p * p)/16.0;
        }
        else if(p < 8./11.0)
        {
            return (363./40.0 * p * p) - (99./10.0 * p) + 17./5.0;
        }
        else if(p < 9./10.0)
        {
            return (4356./361.0 * p * p) - (35442./1805.0 * p) + 16061./1805.0;
        }
        else
        {
            return (54./5.0 * p * p) - (513./25.0 * p) + 268./25.0;
        }
    }
    float BounceEaseIn(float p)
    {
        return 1. - BounceEaseOut(1. - p);
    }
    #endif

`,
    inner => inner // TODO FIXME
) { }

// Interpolators
function genInterpolator (name, inlineMaker, preface, jsEval) {
    const fn = class Interpolator extends _base__WEBPACK_IMPORTED_MODULE_1__["default"] {
        constructor (m) {
            Object(_utils__WEBPACK_IMPORTED_MODULE_0__["checkMaxArguments"])(arguments, 1, name);

            m = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["implicitCast"])(m);
            super({ m });
        }
        eval (feature) {
            return jsEval(this.m.eval(feature));
        }
        _bindMetadata (meta) {
            super._bindMetadata(meta);
            if (this.m.type !== 'number') {
                throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
                    `Blending cannot be performed by '${this.m.type}'`,
                    _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_TYPE);
            }
            this.type = 'number';
            this._setGenericGLSL(inline => inlineMaker(inline.m), preface);
        }
    };
    fn.type = 'interpolator';
    return fn;
}


/***/ }),

/***/ "./src/renderer/viz/expressions/linear.js":
/*!************************************************!*\
  !*** ./src/renderer/viz/expressions/linear.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Linear; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../utils/util */ "./src/utils/util.js");
/* harmony import */ var _codecs_Identity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../codecs/Identity */ "./src/codecs/Identity.js");
/* harmony import */ var _utils_time_TimeZoneDate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../utils/time/TimeZoneDate */ "./src/utils/time/TimeZoneDate.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./constants */ "./src/renderer/viz/expressions/constants.js");







/**
* Linearly interpolates the value of a given input between a minimum and a maximum. If `min` and `max` are not defined they will
* default to `globalMin(input)` and `globalMax(input)`.
*
* @param {Number|Date} input - The input to be evaluated and interpolated, can be a numeric property or a date property
* @param {Number|Date} [min=globalMin(input)] - Numeric or date expression pointing to the lower limit
* @param {Number|Date} [max=globalMax(input)] - Numeric or date expression pointing to the higher limit
* @param {Number|Date} [max=globalMax(input)] - Numeric or date expression to set a timerange
* @param {Number} samples - Number of samples, which is 10 by default
* @return {Number|Date}
*
* @example <caption> Color by $speed using the CARTOColor Prism by assigning the first color in Prism to features with speeds of 10 or less, the last color in Prism to features with speeds of 100 or more and a interpolated value for the speeds in between.</caption>
* const s = carto.expressions;
* const viz = new carto.Viz({
*   color: s.ramp(s.linear(s.prop('speed'), 10, 100), s.palettes.PRISM)
* });
*
* @example <caption> Color by $speed using the CARTOColor Prism by assigning the first color in Prism to features with speeds of 10 or less, the last color in Prism to features with speeds of 100 or more and a interpolated value for the speeds in between. (String)</caption>
* const viz = new carto.Viz(`
*   color: ramp(linear($speed, 10, 100), PRISM)
* `);
*
* @example <caption> Set custom number of samples.</caption>
* const s = carto.expressions;
* const viz = new carto.Viz({
*   color: s.ramp(s.linear(s.prop('speed'), 10, 100, null, 10), s.palettes.PRISM)
* });
*
* @example <caption> Set custom number of samples. (String)</caption>
* const s = carto.expressions;
* const viz = new carto.Viz(`
*   color: ramp(linear($speed, 10, 100, null, 10), PRISM)
* `);
*
* @memberof carto.expressions
* @name linear
* @function
* @api
*/
class Linear extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (input, min, max, range, samples = _constants__WEBPACK_IMPORTED_MODULE_6__["DEFAULT_SAMPLES"]) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 5, 'linear');

        input = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(input);

        if (min && !(min instanceof _base__WEBPACK_IMPORTED_MODULE_0__["default"]) && max === undefined && range === undefined) {
            range = min;
            min = undefined;
            max = undefined;
        }

        if (min === undefined && max === undefined) {
            min = Object(_expressions__WEBPACK_IMPORTED_MODULE_2__["globalMin"])(input);
            max = Object(_expressions__WEBPACK_IMPORTED_MODULE_2__["globalMax"])(input);
        }

        min = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(min);
        max = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(max);
        samples = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(samples);

        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('linear', 'input', 0, input);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('linear', 'min', 1, min);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('linear', 'max', 2, max);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('linear', 'samples', 4, samples);

        super({ input, min, max });
        this.type = 'number';
        this.samples = samples;

        // range mode is used only for timerange inputs:
        // * 'start' of property between full range (from start of min to end of max)
        // * 'end' of property between full range (from start of min to end of max)
        // * 'unit' (default) range mapped to 0:1
        this._rangeMode = range || 'unit';
    }

    // Given a linear value 0:1, convert it back to the input value
    // for TimeRange and Date inputs the result is an interpolated Date
    converse (value) {
        if (this.input.type === 'date') {
            const min = this.min.value.getTime();
            const max = this.max.value.getTime();
            return Object(_utils_util__WEBPACK_IMPORTED_MODULE_3__["msToDate"])(value * (max - min) + min);
        } else if (this.input.type === 'timerange') {
            const minRange = Object(_utils_util__WEBPACK_IMPORTED_MODULE_3__["castTimeRange"])(this.min.value);
            const maxRange = Object(_utils_util__WEBPACK_IMPORTED_MODULE_3__["castTimeRange"])(this.max.value);
            if (minRange === undefined || maxRange === undefined) {
                // FIXME: it seems update event of layer can triggered
                // before metadata has been bounded.
                return null;
            }
            let min, max;
            switch (this._rangeMode) {
                case 'unit':
                    // timeRange here allows min, max to be simply iso strings
                    min = minRange.startValue;
                    max = maxRange.startValue;
                    break;
                case 'start':
                case 'end':
                    min = minRange.startValue;
                    max = maxRange.endValue;
                    break;
            }
            return _utils_time_TimeZoneDate__WEBPACK_IMPORTED_MODULE_5__["default"].fromValue(value * (max - min) + min, minRange.timeZone);
        }
        const min = this.min.value;
        const max = this.max.value;
        return value * (max - min) + min;
    }

    // return min, max, but for time ranges they are returned as Dates
    limits () {
        let min, max;
        if (this.input.type === 'timerange') {
            switch (this._rangeMode) {
                case 'unit':
                    min = Object(_utils_util__WEBPACK_IMPORTED_MODULE_3__["castTimeRange"])(this.min.value).startValue;
                    max = Object(_utils_util__WEBPACK_IMPORTED_MODULE_3__["castTimeRange"])(this.max.value).startValue;
                    break;
                case 'start':
                case 'end':
                    min = Object(_utils_util__WEBPACK_IMPORTED_MODULE_3__["castTimeRange"])(this.min.value).startValue;
                    max = Object(_utils_util__WEBPACK_IMPORTED_MODULE_3__["castTimeRange"])(this.max.value).endValue;
                    break;
            }
        } else {
            min = this.min.value;
            max = this.max.value;
        }
        return [min, max];
    }

    get value () {
        return {
            min: this.min,
            max: this.max,
            input: this.input.value,
            range: this._rangeMode,
            samples: this.samples
        };
    }

    eval (feature) {
        if (this.input.type === 'timerange') {
            let inputIndex;
            switch (this._rangeMode) {
                case 'unit':
                    inputIndex = 0; // start
                    break;
                case 'start':
                    inputIndex = 0; // start
                    break;
                case 'end':
                    inputIndex = 1; // end
                    break;
            }
            const input = feature._dataframe.properties[this._metadata.decodedProperties(this.input.propertyName)[inputIndex]][feature._index];

            return (input - this._internalMin) / (this._internalMax - this._internalMin);
        }

        const input = this.input.eval(feature);
        const metadata = this._metadata;
        const codec = (metadata && this.input.propertyName)
            ? metadata.codec(this.input.propertyName)
            : new _codecs_Identity__WEBPACK_IMPORTED_MODULE_4__["default"]();
        const min = codec.externalToInternal(metadata, this.min.eval(feature));
        const max = codec.externalToInternal(metadata, this.max.eval(feature));
        const value = codec.externalToInternal(metadata, input);
        return (value - min) / (max - min);
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);
        this._metadata = metadata;

        if (this.input.type === 'timerange') {
            let inputIndex, min, max;
            switch (this._rangeMode) {
                case 'unit':
                    // choose same side for all three:
                    inputIndex = 0; // start
                    min = metadata.codec(this.input.propertyName).externalToInternal(metadata, this.min.value)[inputIndex];
                    max = metadata.codec(this.input.propertyName).externalToInternal(metadata, this.max.value)[inputIndex];
                    // min in ms is castTimeRange(this.min.value).startValue;
                    // max in ms is castTimeRange(this.max.value).startValue;
                    break;
                case 'start':
                    inputIndex = 0; // start
                    min = metadata.codec(this.input.propertyName).externalToInternal(metadata, this.min.value)[0]; // start
                    max = metadata.codec(this.input.propertyName).externalToInternal(metadata, this.max.value)[1]; // end
                    // min in ms is castTimeRange(this.min.value).startValue;
                    // max in ms is castTimeRange(this.max.value).endValue;
                    break;
                case 'end':
                    inputIndex = 1; // end
                    min = metadata.codec(this.input.propertyName).externalToInternal(metadata, this.min.value)[0]; // start
                    max = metadata.codec(this.input.propertyName).externalToInternal(metadata, this.max.value)[1]; // end
                    // min in ms is castTimeRange(this.min.value).startValue;
                    // max in ms is castTimeRange(this.max.value).endValue;
                    break;
            }

            this._internalMin = min;
            this._internalMax = max;

            this.inlineMaker = (inline) => `((${inline.input[inputIndex]}-(${min.toFixed(20)}))/(${(max - min).toFixed(20)}))`;
        } else {
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('linear', 'input', 0, ['number', 'date'], this.input);
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('linear', 'min', 1, ['number', 'date'], this.min);
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('linear', 'max', 2, ['number', 'date'], this.max);
            Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('linear', 'samples', 4, ['number'], this.samples);
            // Should actually check:
            // checkType('linear', 'min', 1, this.input.type, this.min);
            // checkType('linear', 'max', 2, this.input.type, this.max);
            // but global aggregations are currently of type number even for dates

            const codec = this.input.propertyName && metadata.codec(this.input.propertyName);
            if (!codec || codec.isIdentity()) {
                // this permits using properties for the min/man expressions
                this.inlineMaker = (inline) => `((${inline.input}-${inline.min})/(${inline.max}-${inline.min}))`;
            } else {
                const smin = codec.externalToInternal(metadata, this.min.value);
                const smax = codec.externalToInternal(metadata, this.max.value);
                this.inlineMaker = (inline) => `((${inline.input}-(${smin.toFixed(20)}))/(${(smax - smin).toFixed(20)}))`;
            }
        }
    }

    getLegendData (options) {
        const min = this.min.value;
        const max = this.max.value;
        const name = this.toString();

        if (min === max) {
            return { min, max, name, data: [] };
        }

        const samples = options && options.samples
            ? options.samples
            : this.samples;

        const INC = 1 / (samples - 1);
        let data = [];

        for (let i = 0; data.length < samples; i += INC) {
            const value = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["clamp"])(i, 0, 1);
            const key = i * (max - min) + min;

            data.push({ key, value });
        }

        if (options.order && options.order === _constants__WEBPACK_IMPORTED_MODULE_6__["SORT_DESC"]) {
            data = data.sort((a, b) => b.key - a.key);
        }

        return { data, min, max, name };
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/now.js":
/*!*********************************************!*\
  !*** ./src/renderer/viz/expressions/now.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Now; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");




/**
 * Get the current timestamp. This is an advanced form of animation, `animation` expression is preferred.
 *
 * @return {Number}
 *
 * @example <caption>Update width during the time.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.mod(s.now(), 10)
 * });
 *
 * @example <caption>Update width during the time. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: now() % 10
 * `);
 *
 * @memberof carto.expressions
 * @name now
 * @function
 * @api
 */
class Now extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor () {
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkMaxArguments"])(arguments, 0, 'now');

        super({ now: Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["number"])(0) });
        this.type = 'number';
        super.inlineMaker = inline => inline.now;
    }

    get value () {
        return this.now.value;
    }

    eval () {
        return this.value;
    }

    isAnimated () {
        return true;
    }

    isPlaying () {
        return true;
    }

    _setTimestamp (timestamp) {
        this.now.value = timestamp;
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/ordering.js":
/*!**************************************************!*\
  !*** ./src/renderer/viz/expressions/ordering.js ***!
  \**************************************************/
/*! exports provided: Asc, Desc, NoOrder, Width */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Asc", function() { return Asc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Desc", function() { return Desc; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoOrder", function() { return NoOrder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Width", function() { return Width; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");



/**
 * Order ascending input a provided expression. NOTE: only works with `width()`.
 *
 * Note: ordering expressions won't assure a perfect ordering.
 * Features will be distributed in different buckets with the original order, and those buckets will be ordered.
 * This guarantees a maximum error, but not a perfect order.
 * For most operations this is imperceptible, but usage of `order` in combination with animation or multi-scale expressions (`zoomrange` and `scaled`)
 * may result in artifacts.
 *
 * @param {carto.expressions.Width} input - must be `width()`
 * @return {Order}
 *
 * @example <caption>Ascending order based on width.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   order: s.asc(s.width())
 * });
 *
 * @example <caption>Ascending order based on width. (String)</caption>
 * const viz = new carto.Viz(`
 *   order: asc(width())
 * `);
 *
 * @memberof carto.expressions
 * @name asc
 * @function
 * @api
 */
class Asc extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (input) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'asc');
        input = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(input);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('asc', 'input', 0, input);
        super({ input });
        this.type = 'orderer';
    }

    get value () {
        return 'asc';
    }

    eval () {
        return this.value;
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkInstance"])('asc', 'input', 0, Width, this.input);
    }
}

/**
 * Order descending input a provided expression. NOTE: only works with `width()`.
 *
 * Note: ordering expressions won't assure a perfect ordering.
 * Features will be distributed in different buckets with the original order, and those buckets will be ordered.
 * This guarantees a maximum error, but not a perfect order.
 * For most operations this is imperceptible, but usage of `order` in combination with animation or multi-scale expressions (`zoomrange` and `scaled`)
 * may result in artifacts.
 *
 * @param {carto.expressions.Width} input - must be `width()`
 * @return {Order}
 *
 * @example <caption>Descending order based on width.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   order: s.desc(s.width())
 * });
 *
 * @example <caption>Descending order based on width. (String)</caption>
 * const viz = new carto.Viz(`
 *   order: desc(width())
 * `);
 *
 * @memberof carto.expressions
 * @name desc
 * @function
 * @api
 */
class Desc extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (input) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'desc');
        input = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(input);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkExpression"])('desc', 'input', 0, input);
        super({ input });
        this.type = 'orderer';
    }

    get value () {
        return 'desc';
    }

    eval () {
        return this.value;
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkInstance"])('desc', 'input', 0, Width, this.input);
    }
}

/**
 * No order expression.
 *
 * @return {Order}
 *
 * @example <caption>No order.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   order: s.noOrder()
 * });
 *
 * @example <caption>No order. (String)</caption>
 * const viz = new carto.Viz(`
 *   order: noOrder()
 * `);
 *
 * @memberof carto.expressions
 * @name noOrder
 * @function
 * @api
 */
class NoOrder extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor () {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 0, 'noOrder');

        super({});
        this.type = 'orderer';
    }

    get value () {
        return 'noOrder';
    }

    eval () {
        return this.value;
    }
}

/**
 * Return the expression assigned in the `width` property. ONLY usable in an `order:` property.
 *
 * Note: ordering expressions won't assure a perfect ordering.
 * Features will be distributed in different buckets with the original order, and those buckets will be ordered.
 * This guarantees a maximum error, but not a perfect order.
 * For most operations this is imperceptible, but usage of `order` in combination with animation or multi-scale expressions (`zoomrange` and `scaled`)
 * may result in artifacts.
 *
 * @return {carto.expressions.Width}
 *
 * @example <caption>Ascending order based on width.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   order: s.asc(s.width())
 * });
 *
 * @example <caption>Ascending order based on width. (String)</caption>
 * const viz = new carto.Viz(`
 *   order: asc(width())
 * `);
 *
 * @memberof carto.expressions
 * @name width
 * @function
 * @api
 */
class Width extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor () {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'width');

        super({});
        this.type = 'propertyReference';
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/reverse/Reverse.js":
/*!*********************************************************!*\
  !*** ./src/renderer/viz/expressions/reverse/Reverse.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Reverse; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _ReversePalette__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ReversePalette */ "./src/renderer/viz/expressions/reverse/ReversePalette.js");
/* harmony import */ var _ReverseList__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ReverseList */ "./src/renderer/viz/expressions/reverse/ReverseList.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");





/**
 * Reverse the provided item.
 *
 * @param {Palette|List} input - item to be reversed
 * @return {Palette|List}
 *
 * @example <caption>Invert a Palette.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.ramp(s.prop('type'), s.reverse(s.palettes.PRISM));
 * });
 *
 * @example <caption>Invert a Palette (String).</caption>
 * const viz = new carto.Viz(`
 *   color: ramp($type, reverse(PRISM))
 * `);
 *
 * @example <caption>Invert a List.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.ramp(s.prop('count'), s.reverse([s.namedColor('red'), s.namedColor('blue')]));
 * });
 *
 * @example <caption>Invert a List (String).</caption>
 * const viz = new carto.Viz(`
 *   color: ramp($count, reverse([red, blue]))
 * `);
 *
 * @memberof carto.expressions
 * @name reverse
 * @function
 * @api
 */
class Reverse extends _base__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor (input) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_0__["checkMaxArguments"])(arguments, 1, 'reverse');
        input = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["implicitCast"])(input);
        Object(_utils__WEBPACK_IMPORTED_MODULE_0__["checkExpression"])('reverse', 'input', 0, input);
        super({ input });
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);

        if (this.input.type === 'palette') {
            Object.setPrototypeOf(this, _ReversePalette__WEBPACK_IMPORTED_MODULE_1__["default"].prototype);
        } else {
            Object.setPrototypeOf(this, _ReverseList__WEBPACK_IMPORTED_MODULE_2__["default"].prototype);
        }

        return this._bindMetadata(metadata);
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/reverse/ReverseList.js":
/*!*************************************************************!*\
  !*** ./src/renderer/viz/expressions/reverse/ReverseList.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ReverseList; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");



class ReverseList extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    _bindMetadata (metadata) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('reverse', 'array', 0, ['number-list', 'category-list', 'color-list', 'date-list', 'image-list'], this.input);

        this.type = this.input.type;
        this.childType = this.input.childType;
    }

    get elems () {
        return [...this.input.elems].reverse();
    }

    get value () {
        return this.elems.map(c => c.value);
    }

    eval (feature) {
        return this.elems.map(c => c.eval(feature));
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/reverse/ReversePalette.js":
/*!****************************************************************!*\
  !*** ./src/renderer/viz/expressions/reverse/ReversePalette.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ReversePalette; });
/* harmony import */ var _color_palettes_Palette__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../color/palettes/Palette */ "./src/renderer/viz/expressions/color/palettes/Palette.js");


class ReversePalette extends _color_palettes_Palette__WEBPACK_IMPORTED_MODULE_0__["default"] {
    _bindMetadata (metadata) {
        this.type = 'palette';
        this.childType = 'color';
        this.subPalettes = new Proxy(this.input.subPalettes, {
            get: (target, name) => {
                if (Number.isFinite(Number(name)) && Array.isArray(target[name])) {
                    return this._reversePalette(target[name]);
                }
                return target[name];
            }
        });
        this.tags = this.input.tags;
    }

    getLongestSubPalette () {
        return this._reversePalette(this.input.getLongestSubPalette());
    }

    _reversePalette (palette) {
        if (this.isQualitative()) {
            // Last color is 'others', therefore, we shouldn't change the order of that one
            const copy = [...palette];
            const others = copy.pop();
            return [...copy.reverse(), others];
        }
        return [...palette].reverse();
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/stats.js":
/*!***********************************************!*\
  !*** ./src/renderer/viz/expressions/stats.js ***!
  \***********************************************/
/*! exports provided: average, variance, standardDeviation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "average", function() { return average; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "variance", function() { return variance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "standardDeviation", function() { return standardDeviation; });

/**
 * Calculate Average
 *
 * @param {Number[]} values
 * @returns {Number} - average
 */
const average = (values) => {
    let sum = 0;
    for (let i = 0; i < values.length; i++) {
        sum += values[i];
    }
    return sum / values.length;
};
/**
 * Calculate Variance
 *
 * @param {Number[]} values
 * @param {Number} average
 * @returns {Number[]} - calculate variance for each element in values
 */
const variance = (values, average) => {
    let variances = [];
    for (let i = 0; i < values.length; i++) {
        const diff = values[i] - average;
        variances.push(diff * diff);
    }
    return variances;
};

/**
 * Calculate Standard Deviation (STD), using population deviation formula
 *
 * @param {Number[]} values
 * @returns {Number} - standard deviation
 */
const standardDeviation = (values) => {
    const avg = average(values);
    const avgVariance = average(variance(values, avg));
    return Math.sqrt(avgVariance);
};


/***/ }),

/***/ "./src/renderer/viz/expressions/time.js":
/*!**********************************************!*\
  !*** ./src/renderer/viz/expressions/time.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Time; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/util */ "./src/utils/util.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");




/**
 * Time constant expression
 *
 * @param {Date|string|number} date - The date from a JavaScript Date() object or a date encoded as a string or the number of milliseconds since Epoch.
 * @return {Date}
 *
 * @example <caption>Filter by a date between dates.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   filter: s.between(s.prop('date'), s.time('2022-03-09T00:00:00Z'), s.time('2033-08-12T00:00:00Z')
 * });
 *
 * @example <caption>Filter by a date between dates. (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: time('2022-03-09T00:00:00Z') < $date < time('2033-08-12T00:00:00Z')
 * `);
 *
 * @memberof carto.expressions
 * @name time
 * @function
 * @api
 */
class Time extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (date) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkMaxArguments"])(arguments, 1, 'time');

        super({});
        this.type = 'date';

        try {
            this.date = _utils_util__WEBPACK_IMPORTED_MODULE_1__["castDate"](date);
        } catch (error) {
            Object(_utils__WEBPACK_IMPORTED_MODULE_2__["throwInvalidType"])('time', 'date', 0, 'Date or string or number', 'other type');
        }

        this.inlineMaker = () => undefined;
    }

    get value () {
        return this.date;
    }

    eval () {
        return this.value;
    }

    isAnimated () {
        return false;
    }

    isPlaying () {
        return false;
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/timeRange.js":
/*!***************************************************!*\
  !*** ./src/renderer/viz/expressions/timeRange.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TimeRangeExpr; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../utils/util */ "./src/utils/util.js");



/**
 * Define a time range: an interval between two time points.
 *
 * ISO-formatted strings (based on ISO 8601) are used to define ranges.
 * Since `timeRange` doesn't support arbitrary intervals, but only
 * intervals based on single units of time (e.g. a month, an hour),
 * we don't use the general ISO interval format, but simply an
 * abbreviated form of the date point format, so that '2018-03' represents
 * the month of March, 2018 (i.e. the interval 2018-03-01T00:00:00/2018-04-01T00:00:00).
 *
 * @param {String} value - abbreviated ISO-formatted interval
 * @return {TimeRange} It retuns a TimeRange object.
 *
 * @memberof carto.expressions
 * @name timeRange
 * @function
 * @api
 */
class TimeRangeExpr extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (value) {
        // timeRange('2017-01') timeRange('2017-Q1')

        super({});
        this.type = 'timerange';
        this.range = _utils_util__WEBPACK_IMPORTED_MODULE_1__["castTimeRange"](value);
        this.inlineMaker = () => undefined; // TODO...
    }

    get value () {
        return {
            iso: this.range.iso.value,
            timeZone: this.range.timeZone.value,
            startValue: this.range.startValue.value,
            endValue: this.range.endValue.value,
            startDate: this.range.startDate.value,
            endDate: this.range.endDate.value
        };
    }

    eval (feature) {
        return {
            iso: this.range.iso.eval(feature),
            timeZone: this.range.timeZone.eval(feature),
            startValue: this.range.startValue.eval(feature),
            endValue: this.range.endValue.eval(feature),
            startDate: this.range.startDate.eval(feature),
            endDate: this.range.endDate.eval(feature)
        };
    }

    isAnimated () {
        return false;
    }

    isPlaying () {
        return false;
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/top.js":
/*!*********************************************!*\
  !*** ./src/renderer/viz/expressions/top.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Top; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _basic_property__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./basic/property */ "./src/renderer/viz/expressions/basic/property.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants */ "./src/renderer/viz/expressions/constants.js");







// Careful! This constant must match with the shader code of the Top expression
const MAX_TOP_BUCKETS = 16;

/**
 * Get the top `n` properties, aggregating the rest into an "others" bucket category. The "others" label is by default CARTO_VL_OTHERS.
 * This can be overwriten by setting the "others" label as the third parameter.
 *
 * @param {Category} property - Column of the table
 * @param {number} n - Number of top properties to be returned, the maximum value is 16, values higher than that will result in an error
 * @param {string} othersLabel - Custom label for "others"
 * @return {Category}
 *
 * @example <caption>Use top 3 categories to define a color ramp.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.ramp(s.top(s.prop('category'), 3), s.palettes.VIVID)
 * });
 *
 * @example <caption>Use top 3 categories to define a color ramp. (String)</caption>
 * const viz = new carto.Viz(`
 *   color: ramp(top($category, 3), VIVID)
 * `);
 *
 * @example <caption>Set custom "others" label.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   color: s.ramp(s.top(s.prop('category'), 3, 'Others'), s.palettes.VIVID)
 * });
 *
 * @example <caption>Set custom "others" label. (String)</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz(`
 *   color: ramp(top($category, 3, 'Others'), VIVID)
 * `);
 *
 * @memberof carto.expressions
 * @name top
 * @function
 * @api
 */
class Top extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (property, buckets, othersLabel = _constants__WEBPACK_IMPORTED_MODULE_5__["OTHERS_LABEL"]) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 3, 'top');

        buckets = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(buckets);
        othersLabel = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(othersLabel);

        const children = { property, buckets, othersLabel };

        for (let i = 0; i < MAX_TOP_BUCKETS; i++) {
            children[`_top${i}`] = Object(_expressions__WEBPACK_IMPORTED_MODULE_3__["number"])(0);
        }
        super(children);
        this.numBuckets = 0;
        this.type = 'category';
    }

    get value () {
        return this.eval();
    }

    eval (feature) {
        const metaColumn = this._metadata.properties[this.property.propertyName];
        const orderedCategoryNames = [...metaColumn.categories].sort((a, b) =>
            b.frequency - a.frequency
        );
        const categoryName = this.property.eval(feature);
        const index = orderedCategoryNames.findIndex(category => category.name === categoryName);
        const divisor = this.numCategoriesWithoutOthers - 1 || 1;

        return index >= this.numBuckets || index === -1
            ? { label: _constants__WEBPACK_IMPORTED_MODULE_5__["OTHERS_LABEL"], index: _constants__WEBPACK_IMPORTED_MODULE_5__["OTHERS_INDEX"] }
            : { label: categoryName, index: index / divisor };
    }

    _bindMetadata (metadata) {
        super._bindMetadata(metadata);

        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkInstance"])('top', 'property', 0, _basic_property__WEBPACK_IMPORTED_MODULE_2__["default"], this.property);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('top', 'property', 0, 'category', this.property);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkFeatureIndependent"])('top', 'buckets', 1, this.buckets);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('top', 'buckets', 1, 'number', this.buckets);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('top', 'othersLabel', 2, 'category', this.othersLabel);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkFeatureIndependent"])('top', 'othersLabel', 2, this.othersLabel);

        this._metadata = metadata;
        this._textureBuckets = null;
        this.numBuckets = this.getNumBuckets(this.buckets);
    }

    get numCategories () {
        return this.numBuckets + 1;
    }

    get numCategoriesWithoutOthers () {
        return this.numCategories - 1;
    }

    getNumBuckets (buckets) {
        let numBuckets = Math.round(buckets);

        if (numBuckets > this.property.numCategories) {
            numBuckets = this.property.numCategories;
        }

        if (numBuckets > MAX_TOP_BUCKETS) {
            const prev = buckets;

            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_4__["default"](
                `top() function has a limit of ${MAX_TOP_BUCKETS} buckets but '${prev}' buckets were specified.`,
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_4__["CartoValidationErrorTypes"].INCORRECT_VALUE
            );
        }

        return numBuckets;
    }

    _applyToShaderSource (getGLSLforProperty) {
        const childSources = {};
        this.childrenNames.forEach(name => { childSources[name] = this[name]._applyToShaderSource(getGLSLforProperty); });
        return {
            preface: this._prefaceCode(Object.values(childSources).map(s => s.preface).join('') + `
            uniform float numCategoriesWithoutOthers${this._uid};

            float top${this._uid}(float id){
                float r;
                if (${childSources._top0.inline} == id){
                    r = 0.;
                } else if (${childSources._top1.inline} == id){
                    r = 1.;
                } else if (${childSources._top2.inline} == id){
                    r = 2.;
                } else if (${childSources._top3.inline} == id){
                    r = 3.;
                } else if (${childSources._top4.inline} == id){
                    r = 4.;
                } else if (${childSources._top5.inline} == id){
                    r = 5.;
                } else if (${childSources._top6.inline} == id){
                    r = 6.;
                } else if (${childSources._top7.inline} == id){
                    r = 7.;
                } else if (${childSources._top8.inline} == id){
                    r = 8.;
                } else if (${childSources._top9.inline} == id){
                    r = 9.;
                } else if (${childSources._top10.inline} == id){
                    r = 10.;
                } else if (${childSources._top11.inline} == id){
                    r = 11.;
                } else if (${childSources._top12.inline} == id){
                    r = 12.;
                } else if (${childSources._top13.inline} == id){
                    r = 13.;
                } else if (${childSources._top14.inline} == id){
                    r = 14.;
                } else if (${childSources._top15.inline} == id){
                    r = 15.;
                }else{
                    return ${_constants__WEBPACK_IMPORTED_MODULE_5__["OTHERS_GLSL_VALUE"]};
                }
                return r/(numCategoriesWithoutOthers${this._uid}-1.);
            }`),
            inline: `top${this._uid}(${childSources.property.inline})`
        };
    }

    _postShaderCompile (program, gl) {
        this._numCategoriesLoc = gl.getUniformLocation(program, `numCategoriesWithoutOthers${this._uid}`);
        super._postShaderCompile(program, gl);
    }

    _preDraw (program, drawMetadata, gl) {
        const buckets = this.numBuckets;
        const metaColumn = this._metadata.properties[this.property.propertyName];

        const orderedCategoryNames = [...metaColumn.categories].sort((a, b) =>
            b.frequency - a.frequency
        );

        for (let i = 0; i < MAX_TOP_BUCKETS; i++) {
            this[`_top${i}`].value = Number.POSITIVE_INFINITY;
        }

        orderedCategoryNames.forEach((cat, i) => {
            if (i < buckets) {
                this[`_top${i}`].value = this._metadata.categoryToID.get(cat.name);
            }
        });

        gl.uniform1f(this._numCategoriesLoc, this.numCategoriesWithoutOthers);
        super._preDraw(program, drawMetadata, gl);
    }

    getLegendData (options) {
        const metaColumn = this._metadata.properties[this.property.propertyName];
        const orderedCategoryNames = [...metaColumn.categories].sort((a, b) =>
            b.frequency - a.frequency
        );
        const numBuckets = this.numBuckets;
        const data = [];
        const name = this.toString();
        const divisor = this.numCategoriesWithoutOthers - 1 || 1;

        orderedCategoryNames.forEach((category, i) => {
            if (i < numBuckets) {
                const key = category.name;
                const value = i / divisor;
                data.push({ key, value });
            }
        });

        if (orderedCategoryNames.length > this.buckets) {
            const othersLabel = options && options.othersLabel
                ? options.othersLabel
                : this.othersLabel.value;

            data.push({
                key: othersLabel,
                value: _constants__WEBPACK_IMPORTED_MODULE_5__["OTHERS_INDEX"]
            });
        }

        return { name, data };
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/transformation/Rotate.js":
/*!***************************************************************!*\
  !*** ./src/renderer/viz/expressions/transformation/Rotate.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Rotate; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");



/**
 * Rotate. Define a rotation in degrees.
 *
 * Limitation: only supported in combination with `symbol:`.
 *
 * @param {Number} angle - angle to rotate in degrees in clockwise direction
 * @return {Transform}
 *
 * @example <caption>Rotate 30 degrees in clockwise direction.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   symbol: s.CROSS
 *   transform: s.rotate(30)
 * });
 *
 * @example <caption>Rotate 30 degrees in clockwise direction. (String)</caption>
 * const viz = new carto.Viz(`
 *   symbol: cross
 *   transform: rotate(30)
 * `);
 *
 * @example <caption>Rotate 30 degrees in counter-clockwise direction.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   symbol: s.CROSS
 *   transform: s.rotate(-30)
 * });
 *
 * @example <caption>Rotate 30 degrees in counter-clockwise direction. (String)</caption>
 * const viz = new carto.Viz(`
 *   symbol: cross
 *   transform: rotate(-30)
 * `);
 *
 * @memberof carto.expressions
 * @name rotate
 * @function
 * @api
 */

class Rotate extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (input) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'rotate');

        const angle = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(input);
        super({ angle });
        this.type = 'transformation';
    }

    get value () {
        return this.angle.value;
    }

    eval (feature) {
        return this.angle.eval(feature);
    }

    _bindMetadata (meta) {
        super._bindMetadata(meta);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('rotate', 'angle', 0, 'number', this.angle);
    }

    _applyToShaderSource (getGLSLforProperty) {
        const angle = this.angle._applyToShaderSource(getGLSLforProperty);
        return {
            preface: this._prefaceCode(`
                ${angle.preface}

                #ifndef DEGREES_TO_RADIANS
                #define DEGREES_TO_RADIANS
                float degreesToRadians(float degrees){
                    return degrees/360.*2.*3.14159265359;
                }
                #endif
                
                vec2 rotate${this._uid}(vec2 p){
                    float angle = degreesToRadians(${angle.inline});
                    mat2 M = mat2(cos(angle), -sin(angle),
                                  sin(angle),  cos(angle));
                    return M * p;
                }`),

            inline: `rotate${this._uid}`
        };
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/transformation/Translate.js":
/*!******************************************************************!*\
  !*** ./src/renderer/viz/expressions/transformation/Translate.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Translate; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/renderer/viz/expressions/utils.js");



/**
 * Translate. Define a translation:
 *
 * @param {number} x - first numeric expression that indicates the translation in the X direction.
 * @param {number} y - second numeric expression that indicates the translation in the Y direction.
 * @return {Translate} Numeric expression
 *
 * @example <caption>Apply an x, y translation</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   transform: s.translate(10, 20)
 * });
 *
 * @example <caption>Apply an x, y translation. (String)</caption>
 * const viz = new carto.Viz(`
 *   transform: translate(10, 20)
 * `);
 *
 * @memberof carto.expressions
 * @name translate
 * @function
 * @api
 */

class Translate extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (x, y) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 2, 'translate');

        x = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(x);
        y = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["implicitCast"])(y);
        super({ x, y });
        this.type = 'transformation';
    }

    _applyToShaderSource (getGLSLforProperty) {
        const x = this.x._applyToShaderSource(getGLSLforProperty);
        const y = this.y._applyToShaderSource(getGLSLforProperty);
        return {
            preface: this._prefaceCode(`
                ${x.preface}
                ${y.preface}

                vec2 translate${this._uid}(vec2 p){
                    return p+vec2(${x.inline}, ${y.inline});
                }`),

            inline: `translate${this._uid}`
        };
    }

    get value () {
        return [this.x.value, this.y.value];
    }

    eval (feature) {
        return [this.x.eval(feature), this.y.eval(feature)];
    }

    _bindMetadata (meta) {
        super._bindMetadata(meta);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('translate', 'x', 0, 'number', this.x);
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkType"])('translate', 'y', 1, 'number', this.y);
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/transition.js":
/*!****************************************************!*\
  !*** ./src/renderer/viz/expressions/transition.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Transition; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");




/**
 * Transition returns a number from zero to one based on the elapsed number of milliseconds since the viz was instantiated.
 * The animation is not cyclic. It will stick to one once the elapsed number of milliseconds reach the animation's duration.
 *
 * @param {number} duration - Animation duration in milliseconds
 * @return {Number}
 *
 * @memberof carto.expressions
 * @name transition
 * @function
 * @api
 */
// TODO refactor to use uniformfloat class
class Transition extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (duration) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkMaxArguments"])(arguments, 1, 'transition');
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["checkNumber"])('transition', 'duration', 0, duration);
        if (duration < 0) {
            const preface = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["getStringErrorPreface"])('transition', 'duration', 0);
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
                `${preface} 'duration' must be greater than or equal to 0.`,
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_VALUE
            );
        }
        super({});
        this.aTime = Date.now();
        this.bTime = this.aTime + Number(duration);
        this.type = 'number';
    }

    get value () {
        const time = Date.now();
        this.mix = (time - this.aTime) / (this.bTime - this.aTime);
        return Math.min(this.mix, 1.0);
    }

    eval () {
        return this.value;
    }

    isAnimated () {
        return !this.mix || this.mix <= 1.0;
    }

    isPlaying () {
        return this.isAnimated();
    }

    _applyToShaderSource () {
        return {
            preface: this._prefaceCode(`uniform float anim${this._uid};\n`),
            inline: `anim${this._uid}`
        };
    }

    _postShaderCompile (program, gl) {
        this._getBinding(program).uniformLocation = gl.getUniformLocation(program, `anim${this._uid}`);
    }

    _preDraw (program, drawMetadata, gl) {
        const time = Date.now();
        this.mix = (time - this.aTime) / (this.bTime - this.aTime);
        if (this.mix > 1.0) {
            gl.uniform1f(this._getBinding(program).uniformLocation, 1);
        } else {
            gl.uniform1f(this._getBinding(program).uniformLocation, this.mix);
        }
    }
}


/***/ }),

/***/ "./src/renderer/viz/expressions/unary.js":
/*!***********************************************!*\
  !*** ./src/renderer/viz/expressions/unary.js ***!
  \***********************************************/
/*! exports provided: Log, Sqrt, Sin, Cos, Tan, Sign, Abs, IsNull, Not, Floor, Ceil */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Log", function() { return Log; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sqrt", function() { return Sqrt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sin", function() { return Sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cos", function() { return Cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tan", function() { return Tan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sign", function() { return Sign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Abs", function() { return Abs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IsNull", function() { return IsNull; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Not", function() { return Not; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Floor", function() { return Floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ceil", function() { return Ceil; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ "./src/renderer/viz/expressions/constants.js");




/**
 * Compute the natural logarithm (base e) of a number x.
 *
 * @param {Number} x - Numeric expression to compute the natural logarithm
 * @return {Number}
 *
 * @example <caption>Natural Logarithm.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.log(10)  // 2.302585092994046
 * });
 *
 * @example <caption>Natural Logarithm. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: log(10)
 * `);
 *
 * @memberof carto.expressions
 * @name log
 * @function
 * @api
 */
const Log = genUnaryOp('log', x => Math.log(x), x => `log(${x})`);

/**
 * Compute the square root of a number x.
 *
 * @param {Number} x - Numeric expression to compute the square root
 * @return {Number}
 *
 * @example <caption>Square root.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.sqrt(4)  // 2
 * });
 *
 * @example <caption>Square root. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: sqrt(4)
 * `);
 *
 * @memberof carto.expressions
 * @name sqrt
 * @function
 * @api
 */
const Sqrt = genUnaryOp('sqrt', x => Math.sqrt(x), x => `sqrt(${x})`);

/**
 * Compute the sine of a number x.
 *
 * @param {Number} x - Numeric expression to compute the sine in radians
 * @return {Number}
 *
 * @example <caption>Sin.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.sin(Math.PI/2)  // 1
 * });
 *
 * @example <caption>Sin. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: sin(PI/2)
 * `);
 *
 * @memberof carto.expressions
 * @name sin
 * @function
 * @api
 */
const Sin = genUnaryOp('sin', x => Math.sin(x), x => `sin(${x})`);

/**
 * Compute the cosine of a number x.
 *
 * @param {Number} x - Numeric expression to compute the cosine in radians
 * @return {Number}
 *
 * @example <caption>Cos.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.cos(0)  // 1
 * });
 *
 * @example <caption>Cos. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: cos(0)
 * `);
 *
 * @memberof carto.expressions
 * @name cos
 * @function
 * @api
 */
const Cos = genUnaryOp('cos', x => Math.cos(x), x => `cos(${x})`);

/**
 * Compute the tangent of a number x.
 *
 * @param {Number} x - Numeric expression to compute the tangent in radians
 * @return {Number}
 *
 * @example <caption>Tan.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.tan(0)  // 0
 * });
 *
 * @example <caption>Tan. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: tan(0)
 * `);
 *
 * @memberof carto.expressions
 * @name tan
 * @function
 * @api
 */
const Tan = genUnaryOp('tan', x => Math.tan(x), x => `tan(${x})`);

/**
 * Compute the sign of a number x, indicating whether the number is positive, negative or zero
 * This means this function will return 1 if the number is positive, -1 if the number is negative
 * 0 if the number is 0 and -0 if the number is -0.
 *
 * @param {Number} x - Numeric expression to compute the sign
 * @return {Number}
 *
 * @example <caption>Sign.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.sign(100)  // 1
 * });
 *
 * @example <caption>Sign. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: sign(100)
 * `);
 *
 * @memberof carto.expressions
 * @name sign
 * @function
 * @api
 */
const Sign = genUnaryOp('sign', x => Math.sign(x), x => `sign(${x})`);

/**
 * Compute the absolute value of a number x.
 *
 * @param {Number} x - Numeric expression to compute the absolute value
 * @return {Number}
 *
 * @example <caption>Abs.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.abs(-100)  // 100
 * });
 *
 * @example <caption>Abs. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: abs(-100) // 100
 * `);
 *
 * @memberof carto.expressions
 * @name abs
 * @function
 * @api
 */
const Abs = genUnaryOp('abs', x => Math.abs(x), x => `abs(${x})`);

/**
 * Check if a numerical or categorical property is missing (NULL value).
 *
 * This returns a numeric expression where 0 means `false` and 1 means `true`.
 *
 * @example <caption>Filter NULL values of the `numeric` property.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   filter: s.not(s.isNull(s.prop('numeric')))
 * });
 *
 * @example <caption>Filter NULL values of the `numeric` property. (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: not(isNull($numeric))
 * `);
 *
 * @param {Number} x - Numeric expression to check
 * @return {Number}
 *
 * @memberof carto.expressions
 * @name isNull
 * @function
 * @api
 */
const IsNull = genUnaryOp('isNull',
    x => x === null ? 1 : 0,
    x => `((${x} == ${_constants__WEBPACK_IMPORTED_MODULE_2__["FP32_DESIGNATED_NULL_VALUE"].toFixed(20)}) ? 1. : 0.)`,
    ['number', 'category']// TODO force property
);

/**
 * Compute the logical negation of the given expression.
 * This is internally computed as 1 - x preserving boolean behavior and allowing fuzzy logic.
 *
 *  - When x is equal to 1 not(x) will be evaluated to 0
 *  - When x is equal to 0 not(x) will be evaluated to 1
 *
 * @param {Number} x - Number to compute the not value
 * @return {Number}
 *
 * @example <caption>Not.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.not(0)  // 1
 * });
 *
 * @example <caption>Not. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: not(0)
 * `);
 *
 * @memberof carto.expressions
 * @name not
 * @function
 * @api
 */
const Not = genUnaryOp('not', x => 1 - x, x => `(1.0 - ${x})`);

/**
 * Compute the floor of the given expression.
 * Find the nearest integer less than or equal to the expression value.
 *
 *  - When x is equal to 0.8 floor(x) will be evaluated to 0
 *  - When x is equal to 1.3 floor(x) will be evaluated to 1
 *
 * @param {Number} x - Number to compute the floor value
 * @return {Number}
 *
 * @example <caption>Floor.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.floor(5.9)  // 5
 * });
 *
 * @example <caption>Floor. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: floor(5.9)
 * `);
 *
 * @memberof carto.expressions
 * @name floor
 * @function
 * @api
 */
const Floor = genUnaryOp('floor', x => Math.floor(x), x => `floor(${x})`);

/**
 * Compute the ceil of the given expression.
 * Find the nearest integer that is greater than or equal to the expression value.
 *
 *  - When x is equal to 0.8 ceil(x) will be evaluated to 1
 *  - When x is equal to 1.3 ceil(x) will be evaluated to 2
 *
 * @param {Number} x - Number to compute the ceil value
 * @return {Number}
 *
 * @example <caption>Ceil.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   width: s.ceil(5.1);  // 6
 * });
 *
 * @example <caption>Ceil. (String)</caption>
 * const viz = new carto.Viz(`
 *   width: ceil(5.1)
 * `);
 *
 * @memberof carto.expressions
 * @name ceil
 * @function
 * @api
 */
const Ceil = genUnaryOp('ceil', x => Math.ceil(x), x => `ceil(${x})`);

function genUnaryOp (name, jsFn, glsl, validTypes = 'number') {
    return class UnaryOperation extends _base__WEBPACK_IMPORTED_MODULE_1__["default"] {
        constructor (a) {
            Object(_utils__WEBPACK_IMPORTED_MODULE_0__["checkMaxArguments"])(arguments, 1, name);

            a = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["implicitCast"])(a);
            super({
                a
            });
            this.type = 'number';
            this.expressionName = name;
            this.inlineMaker = inlines => glsl(inlines.a);
        }

        get value () {
            return jsFn(this.a.value);
        }

        eval (feature) {
            return jsFn(this.a.eval(feature));
        }

        _bindMetadata (meta) {
            super._bindMetadata(meta);
            Object(_utils__WEBPACK_IMPORTED_MODULE_0__["checkType"])(name, 'x', 0, validTypes, this.a);
        }
    };
}


/***/ }),

/***/ "./src/renderer/viz/expressions/utils.js":
/*!***********************************************!*\
  !*** ./src/renderer/viz/expressions/utils.js ***!
  \***********************************************/
/*! exports provided: DEFAULT, checkMaxArguments, checkMinArguments, checkExactNumberOfArguments, implicitCast, hexToRgb, noOverrideColor, getOrdinalFromIndex, getStringErrorPreface, throwInvalidType, throwInvalidInstance, throwInvalidNumber, throwInvalidArray, throwInvalidString, throwInvalidStringValue, isArgConstructorTimeTyped, checkExpression, checkType, checkInstance, checkNumber, checkString, checkStringValue, checkArray, checkFeatureIndependent, checkFeatureDependent, clamp, mix, fract */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT", function() { return DEFAULT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkMaxArguments", function() { return checkMaxArguments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkMinArguments", function() { return checkMinArguments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkExactNumberOfArguments", function() { return checkExactNumberOfArguments; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "implicitCast", function() { return implicitCast; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hexToRgb", function() { return hexToRgb; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "noOverrideColor", function() { return noOverrideColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOrdinalFromIndex", function() { return getOrdinalFromIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStringErrorPreface", function() { return getStringErrorPreface; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throwInvalidType", function() { return throwInvalidType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throwInvalidInstance", function() { return throwInvalidInstance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throwInvalidNumber", function() { return throwInvalidNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throwInvalidArray", function() { return throwInvalidArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throwInvalidString", function() { return throwInvalidString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "throwInvalidStringValue", function() { return throwInvalidStringValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArgConstructorTimeTyped", function() { return isArgConstructorTimeTyped; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkExpression", function() { return checkExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkType", function() { return checkType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkInstance", function() { return checkInstance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkNumber", function() { return checkNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkString", function() { return checkString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkStringValue", function() { return checkStringValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkArray", function() { return checkArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkFeatureIndependent", function() { return checkFeatureIndependent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkFeatureDependent", function() { return checkFeatureDependent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mix", function() { return mix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fract", function() { return fract; });
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _errors_carto_parsing_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../errors/carto-parsing-error */ "./src/errors/carto-parsing-error.js");
/* harmony import */ var _colorspaces__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../colorspaces */ "./src/renderer/viz/colorspaces.js");






const DEFAULT = undefined;

function checkMaxArguments (constructorArguments, maxArguments, expressionName) {
    if (constructorArguments.length > maxArguments) {
        throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
            `Expression '${expressionName}' accepts just ${maxArguments} arguments, but ${constructorArguments.length} were passed.`,
            _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].TOO_MANY_ARGS
        );
    }
}

function checkMinArguments (constructorArguments, minArguments, expressionName) {
    if (constructorArguments.length < minArguments) {
        throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
            `Expression '${expressionName}' accepts at least ${minArguments} arguments, but ${constructorArguments.length} were passed.`,
            _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].NOT_ENOUGH_ARGS
        );
    }
}

function checkExactNumberOfArguments (constructorArguments, numArguments, expressionName) {
    if (constructorArguments.length !== numArguments) {
        throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
            `Expression '${expressionName}' accepts exactly ${numArguments} arguments, but ${constructorArguments.length} were passed.`,
            _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].WRONG_NUMBER_ARGS
        );
    }
}

// To support literals (string and numeric) out of the box we need to cast them implicitly on constructors
function implicitCast (value) {
    if (_isNumber(value)) {
        return Object(_expressions__WEBPACK_IMPORTED_MODULE_0__["number"])(value);
    }

    if (typeof value === 'string') {
        return Object(_expressions__WEBPACK_IMPORTED_MODULE_0__["category"])(value);
    }

    if (Array.isArray(value)) {
        return Object(_expressions__WEBPACK_IMPORTED_MODULE_0__["list"])(value);
    }

    return value;
}

function hexToRgb (hex) {
    // Evaluate #ABC
    let result = /^#?([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})$/i.exec(hex);
    if (result) {
        return {
            r: parseInt(result[1] + result[1], 16),
            g: parseInt(result[2] + result[2], 16),
            b: parseInt(result[3] + result[3], 16),
            a: 1
        };
    }

    // Evaluate #ABCD
    result = /^#?([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})([a-f\d]{1})$/i.exec(hex);
    if (result) {
        return {
            r: parseInt(result[1] + result[1], 16),
            g: parseInt(result[2] + result[2], 16),
            b: parseInt(result[3] + result[3], 16),
            a: parseInt(result[4] + result[4], 16) / 255
        };
    }

    // Evaluate #ABCDEF
    result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (result) {
        return {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16),
            a: 1
        };
    }

    // Evaluate #ABCDEFAF
    result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    if (result) {
        return {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16),
            a: parseInt(result[4], 16) / 255
        };
    }

    throw new _errors_carto_parsing_error__WEBPACK_IMPORTED_MODULE_3__["default"]('Invalid hexadecimal color');
}

function noOverrideColor () {
    return Object(_expressions__WEBPACK_IMPORTED_MODULE_0__["rgba"])(255, 255, 255, 0);
}

function getOrdinalFromIndex (index) {
    const indexToOrdinal = {
        1: 'first',
        2: 'second',
        3: 'third',
        4: 'fourth'
    };
    return indexToOrdinal[index] || String(index);
}

function getStringErrorPreface (expressionName, parameterName, parameterIndex) {
    return `${expressionName}(): invalid ${getOrdinalFromIndex(parameterIndex + 1)} parameter '${parameterName}'`;
}

function throwInvalidType (expressionName, parameterName, parameterIndex, expectedType, actualType) {
    throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](`${getStringErrorPreface(expressionName, parameterName, parameterIndex)}
        expected type was '${expectedType}', actual type was '${actualType}'`, _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_TYPE);
}

function throwInvalidInstance (expressionName, parameterName, parameterIndex, expectedClass) {
    const expectedClassNames = Array.isArray(expectedClass)
        ? expectedClass.join(', ')
        : expectedClass.name;
    throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](`${getStringErrorPreface(expressionName, parameterName, parameterIndex)}
    expected type was instance of '${expectedClassNames}'`, _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_TYPE);
}

function throwInvalidNumber (expressionName, parameterName, parameterIndex, number) {
    throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](`${getStringErrorPreface(expressionName, parameterName, parameterIndex)}
    type of '${number}' is ${typeof number}, 'number' was expected`, _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_TYPE);
}

function throwInvalidArray (expressionName, parameterName, parameterIndex, array) {
    throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](`${getStringErrorPreface(expressionName, parameterName, parameterIndex)}
    '${array}' is not an array`, _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_TYPE);
}

function throwInvalidString (expressionName, parameterName, parameterIndex, str) {
    throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](`${getStringErrorPreface(expressionName, parameterName, parameterIndex)}
    expected type was 'string', but ${str}' is not a string`, _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_TYPE);
}

function throwInvalidStringValue (expressionName, parameterName, parameterIndex, str, validValues) {
    throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](`${getStringErrorPreface(expressionName, parameterName, parameterIndex)}
    value '${str}' is not valid. It should be one of ${validValues.map(v => `'${v}'`).join(', ')}`, _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_TYPE);
}

// Returns true if the argument is of a type that cannot be strictly checked at constructor time
function isArgConstructorTimeTyped (arg) {
    switch (arg) {
        case 'number':
        case 'number-list':
        case 'number-property':
        case 'category':
        case 'category-list':
        case 'category-property':
            return false;
        default:
            return true;
    }
}

function checkExpression (expressionName, parameterName, parameterIndex, parameter) {
    if (!(parameter instanceof _base__WEBPACK_IMPORTED_MODULE_1__["default"])) {
        throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](`${getStringErrorPreface(expressionName, parameterName, parameterIndex)}
        '${parameter}' is not of type "carto.expressions.Base"`, _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_TYPE);
    }
}

function checkType (expressionName, parameterName, parameterIndex, expectedType, parameter) {
    checkExpression(expressionName, parameterName, parameterIndex, parameter);
    if (Array.isArray(expectedType)) {
        const ok = expectedType.some(type =>
            parameter.type === type
        );
        if (!ok) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](`${getStringErrorPreface(expressionName, parameterName, parameterIndex)}
            expected type was one of ${expectedType.join()}, actual type was '${parameter.type}'`, _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_TYPE);
        }
    } else if (parameter.type !== expectedType) {
        throwInvalidType(expressionName, parameterName, parameterIndex, expectedType, parameter.type);
    }
}

function checkInstance (expressionName, parameterName, parameterIndex, expectedExpression, parameter) {
    checkExpression(expressionName, parameterName, parameterIndex, parameter);

    if (Array.isArray(expectedExpression)) {
        const ok = expectedExpression.some(expression => {
            return parameter.isA(expression);
        });

        if (!ok) {
            throwInvalidInstance(expressionName, parameterName, parameterIndex, expectedExpression);
        }
    } else if (!(parameter.isA(expectedExpression))) {
        throwInvalidInstance(expressionName, parameterName, parameterIndex, expectedExpression);
    }
}

function checkNumber (expressionName, parameterName, parameterIndex, number) {
    if (!_isNumber(number)) {
        throwInvalidNumber(expressionName, parameterName, parameterIndex, number);
    }
}

function checkString (expressionName, parameterName, parameterIndex, str) {
    if (typeof str !== 'string') {
        throwInvalidString(expressionName, parameterName, parameterIndex, str);
    }
}

function checkStringValue (expressionName, parameterName, parameterIndex, str, validValues) {
    if (typeof str !== 'string') {
        throwInvalidString(expressionName, parameterName, parameterIndex, str);
    } else if (!validValues.includes(str)) {
        throwInvalidStringValue(expressionName, parameterName, parameterIndex, str, validValues);
    }
}

function checkArray (expressionName, parameterName, parameterIndex, array) {
    if (!Array.isArray(array)) {
        throwInvalidArray(expressionName, parameterName, parameterIndex, array);
    }
}

function checkFeatureIndependent (expressionName, parameterName, parameterIndex, parameter) {
    if (parameter.isFeatureDependent()) {
        throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](`${getStringErrorPreface(expressionName, parameterName, parameterIndex)}
        parameter cannot be feature dependent`, _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_VALUE);
    }
}

function checkFeatureDependent (expressionName, parameterName, parameterIndex, parameter) {
    if (!parameter.isFeatureDependent()) {
        throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](`${getStringErrorPreface(expressionName, parameterName, parameterIndex)}
        parameter must be feature dependent`, _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_VALUE);
    }
}

function clamp (x, min, max) {
    return Math.min(Math.max(x, min), max);
}

function mix (x, y, a) {
    if (typeof x === 'number') {
        return _mixNumber(x, y, a);
    }

    if (x instanceof Date) {
        return _mixDate(x, y, a);
    }

    return Object(_colorspaces__WEBPACK_IMPORTED_MODULE_4__["interpolateRGBAinCieLAB"])(x, y, a);
}

function fract (x) {
    return x - Math.floor(x);
}

function _mixDate (x, y, a) {
    const xTime = x.getTime();
    const yTime = y.getTime();
    const timeDiff = Math.abs(_mixNumber(xTime, yTime, a));

    return new Date(timeDiff);
}

function _mixNumber (x, y, a) {
    return x * (1 - a) + y * a;
}

function _isNumber (value) {
    return Number.isFinite(value) || value === Infinity || value === -Infinity || Number.isNaN(value);
}


/***/ }),

/***/ "./src/renderer/viz/expressions/viewportFeatures.js":
/*!**********************************************************!*\
  !*** ./src/renderer/viz/expressions/viewportFeatures.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ViewportFeatures; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _basic_property__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./basic/property */ "./src/renderer/viz/expressions/basic/property.js");
/* harmony import */ var _aggregation_cluster_ClusterTimeDimension__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./aggregation/cluster/ClusterTimeDimension */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterTimeDimension.js");
/* harmony import */ var _aggregation_cluster_ClusterAggregation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./aggregation/cluster/ClusterAggregation */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterAggregation.js");
/* harmony import */ var _aggregation_cluster_ClusterCount__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./aggregation/cluster/ClusterCount */ "./src/renderer/viz/expressions/aggregation/cluster/ClusterCount.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../errors/carto-runtime-error */ "./src/errors/carto-runtime-error.js");
/* harmony import */ var _interactivity_lightweightFeature__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../../interactivity/lightweightFeature */ "./src/interactivity/lightweightFeature.js");
/* harmony import */ var _interactivity_commonFeature__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../../interactivity/commonFeature */ "./src/interactivity/commonFeature.js");











/**
 * Generates a list of features in the viewport
 *
 * For each feature, the properties specified as arguments to this expression will be available.
 * Filtered features will not be present in the list.
 * This expression cannot be used for rendering, it can only be used in JavaScript code as in the example below.
 *
 * @param {...Property} properties - properties that will appear in the feature list
 * @return {ViewportFeatures} ViewportFeatures
 *
 * @example <caption>Define and use a list of features.</caption>
 * const source = carto.source.Dataset('data');
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   variables: {
 *     list: s.viewportFeatures(s.prop('value'), s.prop('category'))
 *   }
 * });
 * const layer = carto.Layer('layer', source, viz);
 * ...
 * layer.on('updated', () => {
 *   viz.variables.list.value.forEach(feature => {
 *     console.log('value:', feature.value, 'category:', feature.category);
 *   });
 * });
 *
 * @example <caption>Define and use a list of features. (String)</caption>
 * const source = carto.source.Dataset('data');
 * const viz = new carto.Viz(`
 *   \@list: viewportFeatures($value, $category)
 * `);
 * const layer = carto.Layer('layer', source, viz);
 * ...
 * layer.on('updated', () => {
 *   viz.variables.list.value.forEach(feature => {
 *     console.log('value:', feature.value, 'category:', feature.category);
 *   });
 * });
 *
 * @memberof carto.expressions
 * @name viewportFeatures
 * @function
 * @api
 */
class ViewportFeatures extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor (...properties) {
        properties = properties.map(p => Object(_utils__WEBPACK_IMPORTED_MODULE_5__["implicitCast"])(p));

        // We need to set all the properties as children of the expression
        // in order for variables to be resolved.
        // And as an additional bonus we don't need to define _getMinimumNeededSchema
        super(_childrenFromProperties(properties));
        this._value = [];
        this.type = 'featureList';
        this._isViewport = true;
        this._requiredProperties = properties;
        this._FeatureProxy = null;
    }

    _applyToShaderSource () {
        throw new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_7__["default"]('\'viewportFeatures\' cannot be used in visualizations.');
    }

    isFeatureDependent () {
        return false;
    }

    get value () {
        return this._value;
    }

    set value (value) {
        this._value = value;
    }

    eval () {
        return this.value;
    }

    _resetViewportAgg (metadata, renderLayer) {
        if (!this._FeatureProxy) {
            if (!this._requiredProperties.every(p => validProperty(p))) {
                throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["default"]('viewportFeatures arguments can only be properties', _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__["CartoValidationErrorTypes"].INCORRECT_TYPE);
            }

            const propertyNames = this._requiredProperties.map((p) => {
                return { property: p.propertyName, variable: p._variableName };
            });

            this._FeatureProxy = Object(_interactivity_lightweightFeature__WEBPACK_IMPORTED_MODULE_8__["genLightweightFeatureClass"])(propertyNames, renderLayer);
        }
        this._value = [];
    }

    accumViewportAgg (featurePieces) {
        featurePieces = Array.isArray(featurePieces) ? featurePieces : [featurePieces];

        if (featurePieces.length === 1) {
            this._value.push(new this._FeatureProxy(featurePieces[0]));
        } else {
            const pieces = featurePieces.map((piece) => { return new this._FeatureProxy(piece); });
            const compoundFeature = Object(_interactivity_commonFeature__WEBPACK_IMPORTED_MODULE_9__["getCompoundFeature"])(pieces);
            this._value.push(compoundFeature);
        }
    }
}

function _childrenFromProperties (properties) {
    let i = 0;
    const childContainer = {};
    properties.forEach(property => {
        childContainer['p' + ++i] = property;
    });
    return childContainer;
}

function validProperty (property) {
    const validExpressions = [_basic_property__WEBPACK_IMPORTED_MODULE_1__["default"], _aggregation_cluster_ClusterAggregation__WEBPACK_IMPORTED_MODULE_3__["default"], _aggregation_cluster_ClusterCount__WEBPACK_IMPORTED_MODULE_4__["default"], _aggregation_cluster_ClusterTimeDimension__WEBPACK_IMPORTED_MODULE_2__["default"]];
    return validExpressions.some(expression => property.isA(expression));
}


/***/ }),

/***/ "./src/renderer/viz/expressions/zoom.js":
/*!**********************************************!*\
  !*** ./src/renderer/viz/expressions/zoom.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Zoom; });
/* harmony import */ var _base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "./src/renderer/viz/expressions/utils.js");




/**
 * Get the current zoom level.
 *
 * @return {Number}
 *
 * @example <caption>Only show feature at zoom levels less than 7.</caption>
 * const s = carto.expressions;
 * const viz = new carto.Viz({
 *   filter: s.lt(s.zoom(), 7)
 * });
 *
 * @example <caption>Only show feature at zoom levels less than 7. (String)</caption>
 * const viz = new carto.Viz(`
 *   filter: zoom() < 7
 * `);
 *
 * @memberof carto.expressions
 * @name zoom
 * @function
 * @api
 */
class Zoom extends _base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor () {
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkMaxArguments"])(arguments, 0, 'zoom');

        super({ zoom: Object(_expressions__WEBPACK_IMPORTED_MODULE_1__["number"])(0) });
        this.type = 'number';
        super.inlineMaker = inline => inline.zoom;
    }

    get value () {
        return this.zoom.value;
    }

    eval () {
        return this.zoom.value;
    }

    _preDraw (program, drawMetadata, gl) {
        this.zoom.value = drawMetadata.zoomLevel;
        this.zoom._preDraw(program, drawMetadata, gl);
    }
}


/***/ }),

/***/ "./src/renderer/viz/parser.js":
/*!************************************!*\
  !*** ./src/renderer/viz/parser.js ***!
  \************************************/
/*! exports provided: parseVizExpression, parseVizDefinition, cleanComments */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseVizExpression", function() { return parseVizExpression; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseVizDefinition", function() { return parseVizDefinition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cleanComments", function() { return cleanComments; });
/* harmony import */ var jsep__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jsep */ "./node_modules/jsep/build/jsep.js");
/* harmony import */ var jsep__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jsep__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _expressions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./expressions */ "./src/renderer/viz/expressions.js");
/* harmony import */ var _expressions_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./expressions/utils */ "./src/renderer/viz/expressions/utils.js");
/* harmony import */ var _expressions_color_cssColorNames__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./expressions/color/cssColorNames */ "./src/renderer/viz/expressions/color/cssColorNames.js");
/* harmony import */ var _expressions_color_NamedColor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./expressions/color/NamedColor */ "./src/renderer/viz/expressions/color/NamedColor.js");
/* harmony import */ var _expressions_color_hex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./expressions/color/hex */ "./src/renderer/viz/expressions/color/hex.js");
/* harmony import */ var _expressions_base__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./expressions/base */ "./src/renderer/viz/expressions/base.js");
/* harmony import */ var _errors_carto_parsing_error__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../errors/carto-parsing-error */ "./src/errors/carto-parsing-error.js");










// TODO use Schema classes

const aggFns = [];

const lowerCaseExpressions = {};
Object.keys(_expressions__WEBPACK_IMPORTED_MODULE_1__)
    .filter(name => name[0] === name[0].toLowerCase()) // Only get expressions starting with lowercase
    .map(name => { lowerCaseExpressions[name.toLocaleLowerCase()] = _expressions__WEBPACK_IMPORTED_MODULE_1__[name]; });

lowerCaseExpressions.true = _expressions__WEBPACK_IMPORTED_MODULE_1__["TRUE"];
lowerCaseExpressions.false = _expressions__WEBPACK_IMPORTED_MODULE_1__["FALSE"];
lowerCaseExpressions.align_center = _expressions__WEBPACK_IMPORTED_MODULE_1__["ALIGN_CENTER"];
lowerCaseExpressions.align_bottom = _expressions__WEBPACK_IMPORTED_MODULE_1__["ALIGN_BOTTOM"];

lowerCaseExpressions.pi = _expressions__WEBPACK_IMPORTED_MODULE_1__["PI"];
lowerCaseExpressions.e = _expressions__WEBPACK_IMPORTED_MODULE_1__["E"];
lowerCaseExpressions.hold = _expressions__WEBPACK_IMPORTED_MODULE_1__["HOLD"];

lowerCaseExpressions.bicycle = _expressions__WEBPACK_IMPORTED_MODULE_1__["BICYCLE"];
lowerCaseExpressions.building = _expressions__WEBPACK_IMPORTED_MODULE_1__["BUILDING"];
lowerCaseExpressions.bus = _expressions__WEBPACK_IMPORTED_MODULE_1__["BUS"];
lowerCaseExpressions.car = _expressions__WEBPACK_IMPORTED_MODULE_1__["CAR"];
lowerCaseExpressions.circle = _expressions__WEBPACK_IMPORTED_MODULE_1__["CIRCLE"];
lowerCaseExpressions.circle_outline = _expressions__WEBPACK_IMPORTED_MODULE_1__["CIRCLE_OUTLINE"];
lowerCaseExpressions.cross = _expressions__WEBPACK_IMPORTED_MODULE_1__["CROSS"];
lowerCaseExpressions.flag = _expressions__WEBPACK_IMPORTED_MODULE_1__["FLAG"];
lowerCaseExpressions.house = _expressions__WEBPACK_IMPORTED_MODULE_1__["HOUSE"];
lowerCaseExpressions.marker = _expressions__WEBPACK_IMPORTED_MODULE_1__["MARKER"];
lowerCaseExpressions.marker_outline = _expressions__WEBPACK_IMPORTED_MODULE_1__["MARKER_OUTLINE"];
lowerCaseExpressions.plus = _expressions__WEBPACK_IMPORTED_MODULE_1__["PLUS"];
lowerCaseExpressions.square = _expressions__WEBPACK_IMPORTED_MODULE_1__["SQUARE"];
lowerCaseExpressions.square_outline = _expressions__WEBPACK_IMPORTED_MODULE_1__["SQUARE_OUTLINE"];
lowerCaseExpressions.star = _expressions__WEBPACK_IMPORTED_MODULE_1__["STAR"];
lowerCaseExpressions.star_outline = _expressions__WEBPACK_IMPORTED_MODULE_1__["STAR_OUTLINE"];
lowerCaseExpressions.triangle = _expressions__WEBPACK_IMPORTED_MODULE_1__["TRIANGLE"];
lowerCaseExpressions.triangle_outline = _expressions__WEBPACK_IMPORTED_MODULE_1__["TRIANGLE_OUTLINE"];

const originalBaseBlendTo = _expressions_base__WEBPACK_IMPORTED_MODULE_6__["default"].prototype.blendTo;
_expressions_base__WEBPACK_IMPORTED_MODULE_6__["default"].prototype.blendTo = function (final, ...args) {
    if (typeof final === 'string') {
        final = parseVizExpression(final);
    }
    return originalBaseBlendTo.bind(this)(final, ...args);
};

function parseVizExpression (str) {
    prepareJsep();
    const r = Object(_expressions_utils__WEBPACK_IMPORTED_MODULE_2__["implicitCast"])(parseNode(jsep__WEBPACK_IMPORTED_MODULE_0___default()(str)));
    cleanJsep();
    return r;
}

function parseVizDefinition (str) {
    prepareJsep();
    const ast = jsep__WEBPACK_IMPORTED_MODULE_0___default()(cleanComments(str));
    let vizSpec = { variables: {} };
    if (ast.type === 'Compound') {
        ast.body.map(node => parseVizNamedExpr(vizSpec, node));
    } else {
        parseVizNamedExpr(vizSpec, ast);
    }
    cleanJsep();
    return vizSpec;
}

function parseVizNamedExpr (vizSpec, node) {
    if (node.operator !== ':') {
        throw new _errors_carto_parsing_error__WEBPACK_IMPORTED_MODULE_7__["default"]('Invalid syntax.');
    }

    if (node.left.name.length && node.left.name[0] === '@') {
        node.left.name = '__cartovl_variable_' + node.left.name.substr(1);
    }

    let name = node.left.name;

    if (!name) {
        throw new _errors_carto_parsing_error__WEBPACK_IMPORTED_MODULE_7__["default"]('Invalid syntax.');
    }

    if (name.startsWith('__cartovl_variable_')) {
        name = node.left.name.substr('__cartovl_variable_'.length);
        if (name in vizSpec.variables) {
            throw new _errors_carto_parsing_error__WEBPACK_IMPORTED_MODULE_7__["default"](`Variable '${name}' is already defined.`);
        }

        vizSpec.variables[name] = Object(_expressions_utils__WEBPACK_IMPORTED_MODULE_2__["implicitCast"])(parseNode(node.right));
    } else {
        if (name in vizSpec) {
            throw new _errors_carto_parsing_error__WEBPACK_IMPORTED_MODULE_7__["default"](`Property '${name}' is already defined.`);
        }
        const value = parseNode(node.right);
        vizSpec[name] = (name === 'resolution') ? value : Object(_expressions_utils__WEBPACK_IMPORTED_MODULE_2__["implicitCast"])(value);
    }
}

function parseFunctionCall (node) {
    const name = node.callee.name.toLowerCase();
    if (aggFns.includes(name)) {
        // node.arguments[0].name += '_' + name;
        const args = node.arguments.map(arg => parseNode(arg));
        return args[0];
    }
    const args = node.arguments.map(arg => parseNode(arg));
    if (lowerCaseExpressions[name]) {
        return lowerCaseExpressions[name](...args);
    }
    throw new _errors_carto_parsing_error__WEBPACK_IMPORTED_MODULE_7__["default"](`Invalid function name '${node.callee.name}'.`);
}

function parseBinaryOperation (node) {
    const left = parseNode(node.left);
    const right = parseNode(node.right);
    switch (node.operator.toLowerCase()) {
        case '*':
            return _expressions__WEBPACK_IMPORTED_MODULE_1__["mul"](left, right);
        case '/':
            return _expressions__WEBPACK_IMPORTED_MODULE_1__["div"](left, right);
        case '+':
            return _expressions__WEBPACK_IMPORTED_MODULE_1__["add"](left, right);
        case '-':
            return _expressions__WEBPACK_IMPORTED_MODULE_1__["sub"](left, right);
        case '%':
            return _expressions__WEBPACK_IMPORTED_MODULE_1__["mod"](left, right);
        case '^':
            return _expressions__WEBPACK_IMPORTED_MODULE_1__["pow"](left, right);
        case '>':
            return _expressions__WEBPACK_IMPORTED_MODULE_1__["greaterThan"](left, right);
        case '>=':
            return _expressions__WEBPACK_IMPORTED_MODULE_1__["greaterThanOrEqualTo"](left, right);
        case '<':
            return _expressions__WEBPACK_IMPORTED_MODULE_1__["lessThan"](left, right);
        case '<=':
            return _expressions__WEBPACK_IMPORTED_MODULE_1__["lessThanOrEqualTo"](left, right);
        case '==':
            return _expressions__WEBPACK_IMPORTED_MODULE_1__["equals"](left, right);
        case '!=':
            return _expressions__WEBPACK_IMPORTED_MODULE_1__["notEquals"](left, right);
        case 'and':
            return _expressions__WEBPACK_IMPORTED_MODULE_1__["and"](left, right);
        case 'or':
            return _expressions__WEBPACK_IMPORTED_MODULE_1__["or"](left, right);
        case 'in':
            return _expressions__WEBPACK_IMPORTED_MODULE_1__["in"](left, right);
        case 'nin':
            return _expressions__WEBPACK_IMPORTED_MODULE_1__["nin"](left, right);
        default:
            throw new _errors_carto_parsing_error__WEBPACK_IMPORTED_MODULE_7__["default"](`Invalid binary operator '${node.operator}'.`);
    }
}

function parseUnaryOperation (node) {
    switch (node.operator) {
        case '-':
            return _expressions__WEBPACK_IMPORTED_MODULE_1__["mul"](-1, parseNode(node.argument));
        case '+':
            return parseNode(node.argument);
        default:
            throw new _errors_carto_parsing_error__WEBPACK_IMPORTED_MODULE_7__["default"](`Invalid unary operator '${node.operator}'.`);
    }
}

function parseIdentifier (node) {
    if (node.name.length && node.name[0] === '@') {
        node.name = '__cartovl_variable_' + node.name.substr(1);
    }
    if (node.name.startsWith('__cartovl_variable_')) {
        return _expressions__WEBPACK_IMPORTED_MODULE_1__["variable"](node.name.substr('__cartovl_variable_'.length));
    } else if (node.name[0] === '#') {
        return new _expressions_color_hex__WEBPACK_IMPORTED_MODULE_5__["default"](node.name);
    } else if (node.name[0] === '$') {
        return _expressions__WEBPACK_IMPORTED_MODULE_1__["property"](node.name.substring(1));
    } else if (_expressions__WEBPACK_IMPORTED_MODULE_1__["palettes"][node.name.toUpperCase()]) {
        return _expressions__WEBPACK_IMPORTED_MODULE_1__["palettes"][node.name.toUpperCase()];
    } else if (lowerCaseExpressions[node.name.toLowerCase()]) {
        return lowerCaseExpressions[node.name.toLowerCase()];
    } else if (_expressions_color_cssColorNames__WEBPACK_IMPORTED_MODULE_3__["CSS_COLOR_NAMES"].includes(node.name.toLowerCase())) {
        return new _expressions_color_NamedColor__WEBPACK_IMPORTED_MODULE_4__["default"](node.name.toLowerCase());
    } else {
        throw new _errors_carto_parsing_error__WEBPACK_IMPORTED_MODULE_7__["default"](`Invalid expression '${JSON.stringify(node)}'.`);
    }
}

function parseNode (node) {
    if (node.type === 'CallExpression') {
        return parseFunctionCall(node);
    } else if (node.type === 'Literal') {
        return node.value;
    } else if (node.type === 'ArrayExpression') {
        return node.elements.map(e => parseNode(e));
    } else if (node.type === 'BinaryExpression') {
        return parseBinaryOperation(node);
    } else if (node.type === 'UnaryExpression') {
        return parseUnaryOperation(node);
    } else if (node.type === 'Identifier') {
        return parseIdentifier(node);
    }
    throw new _errors_carto_parsing_error__WEBPACK_IMPORTED_MODULE_7__["default"](`Invalid expression '${JSON.stringify(node)}'.`);
}

function prepareJsep () {
    // jsep addBinaryOp pollutes its module scope, we need to remove the custom operators afterwards
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.addBinaryOp(':', 0);
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.addBinaryOp('^', 11);
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.addBinaryOp('or', 1);
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.addBinaryOp('OR', 1);
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.addBinaryOp('and', 2);
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.addBinaryOp('AND', 2);
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.addBinaryOp('in', 13);
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.addBinaryOp('IN', 1);
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.addBinaryOp('nin', 13);
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.addBinaryOp('NIN', 13);
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.addIdentifierChar('@');
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.addIdentifierChar('#');
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.removeLiteral('true');
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.removeLiteral('false');
}

function cleanJsep () {
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.removeBinaryOp('in');
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.removeBinaryOp('IN');
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.removeBinaryOp('nin');
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.removeBinaryOp('NIN');
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.removeBinaryOp('and');
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.removeBinaryOp('AND');
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.removeBinaryOp('or');
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.removeBinaryOp('OR');
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.removeBinaryOp('^');
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.removeBinaryOp(':');
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.removeIdentifierChar('@');
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.removeIdentifierChar('#');
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.addLiteral('true');
    jsep__WEBPACK_IMPORTED_MODULE_0___default.a.addLiteral('false');
}

/**
 * Remove comments from string
 * - // line comments
 * - /* block comments
 * - Keep comments inside single and double quotes tracking escape chars
 * Based on: https://j11y.io/javascript/removing-comments-in-javascript/
 */
function cleanComments (str) {
    const mode = {
        singleQuote: false,
        doubleQuote: false,
        blockComment: false,
        lineComment: false,
        escape: 0
    };

    // Adding chars to avoid index checking
    str = ('_' + str + '_').split('');

    for (let i = 0, l = str.length; i < l; i++) {
        if (mode.singleQuote) {
            if (str[i] === '\\') {
                mode.escape++;
            } else if (str[i] === '\'' && mode.escape % 2 === 0) {
                mode.singleQuote = false;
                mode.escape = 0;
            }
            continue;
        }

        if (mode.doubleQuote) {
            if (str[i] === '\\') {
                mode.escape++;
            } else if (str[i] === '"' && mode.escape % 2 === 0) {
                mode.doubleQuote = false;
                mode.escape = 0;
            }
            continue;
        }

        if (mode.blockComment) {
            if (str[i] === '*' && str[i + 1] === '/') {
                str[i + 1] = '';
                mode.blockComment = false;
            }
            str[i] = '';
            continue;
        }

        if (mode.lineComment) {
            if (str[i + 1] === '\n' || str[i + 1] === '\r') {
                mode.lineComment = false;
            }
            if (i + 1 < l) {
                str[i] = '';
            }
            continue;
        }

        mode.doubleQuote = str[i] === '"';
        mode.singleQuote = str[i] === '\'';

        if (str[i] === '/') {
            if (str[i + 1] === '*') {
                str[i] = '';
                mode.blockComment = true;
                continue;
            }
            if (str[i + 1] === '/') {
                str[i] = '';
                mode.lineComment = true;
                continue;
            }
        }
    }

    // Remove chars added before
    return str.join('').slice(1, -1);
}


/***/ }),

/***/ "./src/setup/auth-service.js":
/*!***********************************!*\
  !*** ./src/setup/auth-service.js ***!
  \***********************************/
/*! exports provided: setDefaultAuth, getDefaultAuth, checkAuth, cleanDefaultAuth */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDefaultAuth", function() { return setDefaultAuth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultAuth", function() { return getDefaultAuth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkAuth", function() { return checkAuth; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cleanDefaultAuth", function() { return cleanDefaultAuth; });
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/util */ "./src/utils/util.js");
/* harmony import */ var _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/errors/carto-validation-error */ "./src/errors/carto-validation-error.js");



let defaultAuth;

/**
 * Set default authentication parameters: [user or username] and apiKey.
 *
 * @param {Object} auth
 * @param {String} auth.username - Name of the user. For backwards compatibility also `auth.user` is allowed
 * @param {String} auth.apiKey - API key used to authenticate against CARTO
 *
 * @memberof carto
 * @api
 */
function setDefaultAuth (auth) {
    checkAuth(auth);
    defaultAuth = auth;
}

/**
 * Get default authentication
 * @return {Object}
 */
function getDefaultAuth () {
    return defaultAuth;
}

/**
 * Reset the default auth object
 */
function cleanDefaultAuth () {
    defaultAuth = undefined;
}

/**
 * Check a valid auth parameter.
 *
 * @param  {Object} auth
 */
function checkAuth (auth) {
    if (_utils_util__WEBPACK_IMPORTED_MODULE_0__["isUndefined"](auth)) {
        throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["default"]('\'auth\'', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["CartoValidationErrorTypes"].MISSING_REQUIRED);
    }
    if (!_utils_util__WEBPACK_IMPORTED_MODULE_0__["isObject"](auth)) {
        throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["default"]('\'auth\' property must be an object.', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["CartoValidationErrorTypes"].INCORRECT_TYPE);
    }
    auth.username = _utils_util__WEBPACK_IMPORTED_MODULE_0__["isUndefined"](auth.username) ? auth.user : auth.username; // backwards compatibility
    checkApiKey(auth.apiKey);
    checkUsername(auth.username);
}

function checkApiKey (apiKey) {
    if (_utils_util__WEBPACK_IMPORTED_MODULE_0__["isUndefined"](apiKey)) {
        throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["default"]('\'apiKey\'', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["CartoValidationErrorTypes"].MISSING_REQUIRED);
    }
    if (!_utils_util__WEBPACK_IMPORTED_MODULE_0__["isString"](apiKey)) {
        throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["default"]('\'apiKey\' property must be a string.', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["CartoValidationErrorTypes"].INCORRECT_TYPE);
    }
    if (apiKey === '') {
        throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["default"]('\'apiKey\' property must be not empty.', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["CartoValidationErrorTypes"].INCORRECT_VALUE);
    }
}

function checkUsername (username) {
    if (_utils_util__WEBPACK_IMPORTED_MODULE_0__["isUndefined"](username)) {
        throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["default"]('\'username\'', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["CartoValidationErrorTypes"].MISSING_REQUIRED);
    }
    if (!_utils_util__WEBPACK_IMPORTED_MODULE_0__["isString"](username)) {
        throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["default"]('\'username\' property must be a string.', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["CartoValidationErrorTypes"].INCORRECT_TYPE);
    }
    if (username === '') {
        throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["default"]('\'username\' property must be not empty.', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["CartoValidationErrorTypes"].INCORRECT_VALUE);
    }
}




/***/ }),

/***/ "./src/setup/config-service.js":
/*!*************************************!*\
  !*** ./src/setup/config-service.js ***!
  \*************************************/
/*! exports provided: setDefaultConfig, getDefaultConfig, checkConfig, cleanDefaultConfig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDefaultConfig", function() { return setDefaultConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultConfig", function() { return getDefaultConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkConfig", function() { return checkConfig; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cleanDefaultConfig", function() { return cleanDefaultConfig; });
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/util */ "./src/utils/util.js");
/* harmony import */ var _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../src/errors/carto-validation-error */ "./src/errors/carto-validation-error.js");



let defaultConfig;

/**
 * Set default configuration parameters
 *
 * @param {Object} config
 * @param {String} config.serverURL - Template URL of the CARTO Maps API server: `https://{user}.carto.com`
 *
 * @memberof carto
 * @api
 */
function setDefaultConfig (config) {
    checkConfig(config);
    defaultConfig = config;
}

/**
 * Get default config
 * @return {Object}
 */
function getDefaultConfig () {
    return defaultConfig;
}

/**
 * Clean default config object
 */
function cleanDefaultConfig () {
    defaultConfig = undefined;
}

/**
 * Check a valid config parameter.
 *
 * @param  {Object} config
 */
function checkConfig (config) {
    if (config) {
        if (!_utils_util__WEBPACK_IMPORTED_MODULE_0__["isObject"](config)) {
            throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["default"]('\'config\' property must be an object.', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["CartoValidationErrorTypes"].INCORRECT_TYPE);
        }
        _checkServerURL(config.serverURL);
    }
}

function _checkServerURL (serverURL) {
    if (!_utils_util__WEBPACK_IMPORTED_MODULE_0__["isString"](serverURL)) {
        throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["default"]('\'serverURL\' property must be a string.', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_1__["CartoValidationErrorTypes"].INCORRECT_TYPE);
    }
}




/***/ }),

/***/ "./src/sources/Base.js":
/*!*****************************!*\
  !*** ./src/sources/Base.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Base; });
class Base {
    /**
     * Base data source object.
     *
     * The current {@link carto.source|sources} available are: {@link carto.source.Dataset|Dataset}, {@link carto.source.SQL|SQL}, {@link carto.source.GeoJSON|GeoJSON} and {@link carto.source.MVT|MVT}
     *
     * Use a source to reference the data used in a {@link carto.Layer|layer}.
     *
     * @constructor Base
     * @namespace carto.source
     * @abstract
     * @api
     */
}


/***/ }),

/***/ "./src/sources/BaseWindshaft.js":
/*!**************************************!*\
  !*** ./src/sources/BaseWindshaft.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BaseWindshaft; });
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base */ "./src/sources/Base.js");
/* harmony import */ var _client_windshaft__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../client/windshaft */ "./src/client/windshaft.js");
/* harmony import */ var _setup_auth_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../setup/auth-service */ "./src/setup/auth-service.js");
/* harmony import */ var _setup_config_service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../setup/config-service */ "./src/setup/config-service.js");





const DEFAULT_SERVER_URL_TEMPLATE = 'https://{user}.carto.com';

class BaseWindshaft extends _Base__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor () {
        super();
        this._client = new _client_windshaft__WEBPACK_IMPORTED_MODULE_1__["default"](this);
    }

    initialize (auth, config) {
        this._initializeAuth(auth);
        this._initializeConfig(config);

        this._initializeServerURL();
    }

    _initializeAuth (auth) {
        this._auth = auth || Object(_setup_auth_service__WEBPACK_IMPORTED_MODULE_2__["getDefaultAuth"])();
        Object(_setup_auth_service__WEBPACK_IMPORTED_MODULE_2__["checkAuth"])(this._auth);

        this._apiKey = this._auth.apiKey;
        this._username = this._auth.username;
    }

    _initializeConfig (config) {
        this._config = config || Object(_setup_config_service__WEBPACK_IMPORTED_MODULE_3__["getDefaultConfig"])();
        Object(_setup_config_service__WEBPACK_IMPORTED_MODULE_3__["checkConfig"])(this._config);
    }

    _initializeServerURL () {
        let url = (this._config && this._config.serverURL) || DEFAULT_SERVER_URL_TEMPLATE;
        url = url.replace(/{user}/, this._username);
        this._serverURL = url;
    }

    bindLayer (addDataframe) {
        this._client.bindLayer(addDataframe);
    }

    requiresNewMetadata (viz) {
        return this._client.requiresNewMetadata(viz);
    }

    requestMetadata (viz) {
        return this._client.getMetadata(viz);
    }

    requestData (zoom, viewport) {
        return this._client.getData(zoom, viewport);
    }

    free () {
        this._client.free();
    }
}


/***/ }),

/***/ "./src/sources/DataframeCache.js":
/*!***************************************!*\
  !*** ./src/sources/DataframeCache.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DataframeCache; });
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_0__);


class DataframeCache {
    constructor () {
        const lruOptions = {
            max: 256,
            // TODO improve cache length heuristic
            length: () => 1,
            maxAge: 1000 * 60 * 60,
            dispose: (uid, dataframePromise) => {
                dataframePromise.then(dataframe => {
                    if (!dataframe.empty) {
                        dataframe.free();
                    }
                });
            }
        };
        this._cache = lru_cache__WEBPACK_IMPORTED_MODULE_0__(lruOptions);
    }

    // Get the promise of the dataframe with the provided unique ID, by querying the local cache, and using the fetch function as a fallback.
    // The `fetch` function will be called with the provided `uid` and it is expected that it will return a promise to a Dataframe
    get (uid, fetch) {
        const cachedDataframe = this._cache.get(uid);
        if (cachedDataframe) {
            return cachedDataframe;
        }

        const dataframePromise = fetch(uid);
        this._cache.set(uid, dataframePromise);
        return dataframePromise;
    }

    free () {
        this._cache.reset();
    }
}


/***/ }),

/***/ "./src/sources/Dataset.js":
/*!********************************!*\
  !*** ./src/sources/Dataset.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Dataset; });
/* harmony import */ var _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/util */ "./src/utils/util.js");
/* harmony import */ var _BaseWindshaft__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseWindshaft */ "./src/sources/BaseWindshaft.js");




class Dataset extends _BaseWindshaft__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * A dataset defines the data that will be displayed in a layer and is equivalent
     * to a table in the server.
     *
     * If you have a table named `european_cities` in your CARTO account you could load all the
     * data in a layer using a `carto.source.Dataset`.
     *
     * If you want to load data applying a SQL query see {@link carto.source.SQL|carto.source.SQL}.
     *
     * Since tables in the server are protected you must provide valid credentials in order to get access to the data.
     * This can be done {@link carto.setDefaultAuth|setting the default auth} in the carto object or providing an `auth`
     * object with your username and apiKey.
     *
     * If your server is not hosted by CARTO you must add a third parameter that includes the serverURL. This can be done {@link carto.setDefaultConfig|setting the default config} in the carto object or providing a `config`
     * object with your serverURL.
     *
     * The combination of different type of geometries on the same source is not supported. Valid geometry types are `points`, `lines` and `polygons`.
     *
     * @param {String} tableName - The name of an existing table
     * @param {Object} auth
     * @param {String} auth.apiKey - API key used to authenticate against CARTO
     * @param {String} auth.user - Name of the user
     * @param {Object} config
     * @param {String} [config.serverURL='https://{user}.carto.com'] - URL of the CARTO Maps API server
     *
     * @example
     * const source = new carto.source.Dataset('european_cities', {
     *   apiKey: 'YOUR_API_KEY_HERE',
     *   username: 'YOUR_USERNAME_HERE'
     * });
     *
     * @throws CartoError
     *
     * @memberof carto.source
     * @name Dataset
     * @api
     */
    constructor (tableName, auth, config) {
        super();
        this._checkTableName(tableName);
        this._tableName = tableName;
        this.initialize(auth, config);
    }

    _getFromClause () {
        return this._tableName;
    }

    _clone () {
        return new Dataset(this._tableName, this._auth, this._config);
    }

    _checkTableName (tableName) {
        if (_utils_util__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(tableName)) {
            throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_0__["default"]('\'tableName\'', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_0__["CartoValidationErrorTypes"].MISSING_REQUIRED);
        }
        if (!_utils_util__WEBPACK_IMPORTED_MODULE_1__["default"].isString(tableName)) {
            throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_0__["default"]('\'tableName\' property must be a string.', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_0__["CartoValidationErrorTypes"].INCORRECT_TYPE);
        }
        if (tableName === '') {
            throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_0__["default"]('\'tableName\' property must be not empty.', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_0__["CartoValidationErrorTypes"].INCORRECT_VALUE);
        }
    }
}


/***/ }),

/***/ "./src/sources/GeoJSON.js":
/*!********************************!*\
  !*** ./src/sources/GeoJSON.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GeoJSON; });
/* harmony import */ var _client_rsys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/rsys */ "./src/client/rsys.js");
/* harmony import */ var _renderer_dataframe_Dataframe__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/dataframe/Dataframe */ "./src/renderer/dataframe/Dataframe.js");
/* harmony import */ var _renderer_Metadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../renderer/Metadata */ "./src/renderer/Metadata.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/util */ "./src/utils/util.js");
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Base */ "./src/sources/Base.js");
/* harmony import */ var _geojson_GeoJSONGeometryTransformer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./geojson/GeoJSONGeometryTransformer */ "./src/sources/geojson/GeoJSONGeometryTransformer.js");
/* harmony import */ var _geojson_GeoJSONGeometryType__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./geojson/GeoJSONGeometryType */ "./src/sources/geojson/GeoJSONGeometryType.js");
/* harmony import */ var _geojson_GeoJSOMetadataBuilder__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./geojson/GeoJSOMetadataBuilder */ "./src/sources/geojson/GeoJSOMetadataBuilder.js");













const DATAFRAME_PADDING = 1024;
const SAMPLE_SIZE_FOR_CENTER = 10;

class GeoJSON extends _Base__WEBPACK_IMPORTED_MODULE_5__["default"] {
    /**
     * Create a carto.source.GeoJSON source from a GeoJSON object.
     *
     * @param {Object} data - A GeoJSON data object
     * @param {Object} options - Options
     * @param {array<string>} options.dateColumns - List of columns that contain dates.
     *
     * The combination of different type of geometries on the same source is not supported. Valid geometry types are `Point`, `LineString`, `MultiLineString`, `Polygon` and `MultiPolygon`.
     *
     * @example
     * const source = new carto.source.GeoJSON({
     *   "type": "Feature",
     *   "geometry": {
     *     "type": "Point",
     *     "coordinates": [ 0, 0 ]
     *   },
     *   "properties": {
     *     "index": 1
     *   }
     * });
     *
     * @throws CartoError
     *
     * @memberof carto.source
     * @name GeoJSON
     * @api
     */
    constructor (data, options = {}) {
        super();

        this._initializeData(data);
        this._initializeMetadataHelpers(options);
    }

    _initializeData (data) {
        this._checkData(data);

        this._data = data;
        this._features = this._featuresFromData();
        this._geomType = this._getGeomType();
        this._webMercatorCenter = this._getWebMercatorCoordsCenter();
        this._geometryTransformer = new _geojson_GeoJSONGeometryTransformer__WEBPACK_IMPORTED_MODULE_6__["default"](this._webMercatorCenter);
    }

    _initializeMetadataHelpers (options) {
        this._providedDateColumns = new Set(options.dateColumns);
        this._boundColumns = new Set();

        this._metadataBuilder = new _geojson_GeoJSOMetadataBuilder__WEBPACK_IMPORTED_MODULE_8__["GeoJSONMetadataBuilder"](this._providedDateColumns, this._boundColumns);
    }

    /**
     * Check geojson data is a proper object
     */
    _checkData (data) {
        if (_utils_util__WEBPACK_IMPORTED_MODULE_4__["default"].isUndefined(data)) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["default"]('\'data\'', _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["CartoValidationErrorTypes"].MISSING_REQUIRED);
        }
        if (!_utils_util__WEBPACK_IMPORTED_MODULE_4__["default"].isObject(data)) {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["default"]('\'data\' property must be an object.',
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["CartoValidationErrorTypes"].INCORRECT_TYPE);
        }
    }

    /**
     * Get initialized Features from data
     */
    _featuresFromData () {
        let features;

        const dataType = this._data.type;
        if (dataType === 'FeatureCollection') {
            features = this._data.features;
        } else if (dataType === 'Feature') {
            features = [this._data];
        } else {
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["default"]('\'data\' property must be a GeoJSON object.', _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["CartoValidationErrorTypes"].INCORRECT_VALUE);
        }

        this._initializePropertiesIn(features);
        return features;
    }

    /**
     * Get the GeoJSONGeometryType from the first Feature
     */
    _getGeomType () {
        return this._features[0].geometry.type;
    }

    /**
     * Get an estimated center in WebMercator coordinates, based on a sample of the Features
     * with SAMPLE_SIZE_FOR_CENTER
     */
    _getWebMercatorCoordsCenter () {
        let x = 0;
        let y = 0;
        let nPoints = 0;
        this._fetchFeatureGeometry({ sample: SAMPLE_SIZE_FOR_CENTER }, (_, geometry) => {
            const samplePoint = this._samplePoint(geometry);
            const sampleXY = _utils_util__WEBPACK_IMPORTED_MODULE_4__["default"].projectToWebMercator({ lng: samplePoint[0], lat: samplePoint[1] });
            x += sampleXY.x;
            y += sampleXY.y;
            nPoints += 1;
        });

        if (nPoints > 1) {
            x /= nPoints;
            y /= nPoints;
        }

        return { x, y };
    }

    /**
     * Get the dataframe center in a local RSys.
     */
    _getDataframeCenter () {
        const targetReferenceSystem = {
            scale: _utils_util__WEBPACK_IMPORTED_MODULE_4__["default"].WM_R,
            center: { x: 0, y: 0 }
        };
        const { x: worldX, y: worldY } = this._webMercatorCenter;
        return _client_rsys__WEBPACK_IMPORTED_MODULE_0__["wToR"](worldX, worldY, targetReferenceSystem);
    }

    bindLayer (addDataframe) {
        this._addDataframe = addDataframe;
    }

    requestMetadata (viz) {
        return Promise.resolve(this._computeMetadata(viz));
    }

    requestData () {
        if (this._dataframe) {
            const newProperties = this._decodeUnboundProperties();
            this._dataframe.addProperties();

            const newPropertyNames = Object.keys(newProperties);
            newPropertyNames.forEach(propertyName => {
                this._boundColumns.add(propertyName);
            });

            return Promise.resolve(newPropertyNames.length > 0);
        }

        this._dataframe = this._createNewDataframe();
        return Promise.resolve(true);
    }

    _createNewDataframe () {
        const dataframe = new _renderer_dataframe_Dataframe__WEBPACK_IMPORTED_MODULE_1__["default"]({
            active: true,
            center: this._getDataframeCenter(),
            geom: this._decodeGeometry(),
            properties: this._decodeUnboundProperties(),
            scale: 1,
            size: this._features.length,
            type: Object(_geojson_GeoJSONGeometryType__WEBPACK_IMPORTED_MODULE_7__["dataframeGeometryType"])(this._geomType),
            metadata: this._metadata
        });

        this._boundColumns = new Set(Object.keys(dataframe.properties));
        this._addDataframe && this._addDataframe(dataframe);

        return dataframe;
    }

    requiresNewMetadata () {
        return false;
    }

    _clone () {
        return new GeoJSON(this._data, { dateColumns: Array.from(this._providedDateColumns) });
    }

    _initializePropertiesIn (features) {
        for (let i = 0; i < features.length; i++) {
            features[i].properties = features[i].properties || {};
        }
    }

    _computeMetadata (viz) {
        this._metadata = this._metadataBuilder.buildFrom(viz, this._features);
        return this._metadata;
    }

    _decodeUnboundProperties () {
        const unboundProperties = this._getUnboundProperties();
        const unboundFieldNames = Object.keys(unboundProperties);

        for (let i = 0; i < this._features.length; i++) {
            const f = this._features[i];
            unboundFieldNames.forEach(name => {
                if (name === _renderer_Metadata__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_ID_PROPERTY"] && !Number.isFinite(f.properties[_renderer_Metadata__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_ID_PROPERTY"]])) {
                    f.properties[_renderer_Metadata__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_ID_PROPERTY"]] = -i; // using negative ids for GeoJSON features
                }
                // note that GeoJSON does not support multi-value properties
                unboundProperties[name][i] = this._metadata.codec(name).sourceToInternal(this._metadata, f.properties[name]);
            });
        }

        return unboundProperties;
    }

    _getUnboundProperties () {
        const allFields = this._metadataBuilder.getCurrentFields();

        const properties = {};
        allFields.forEach(name => {
            if (this._boundColumns.has(name)) {
                return;
            }
            // The dataframe expects to have a padding, adding DATAFRAME_PADDING empty values assures this condition is met
            properties[name] = new Float32Array(this._features.length + DATAFRAME_PADDING);
        });

        return properties;
    }

    /**
     * Take the geometry from every feature and invoke the callback with it.
     * If custom options are specified, a 'sample' can be used to skip every 'X' features
     */
    _fetchFeatureGeometry (options = {}, callback) {
        let geometry = null;
        const DEFAULT_SAMPLE = 1; // every feature
        const numFeatures = this._features.length;
        const increment = options.sample ? Math.max(1, Math.floor(numFeatures / options.sample)) : DEFAULT_SAMPLE;

        for (let i = 0; i < numFeatures; i += increment) {
            const feature = this._features[i];
            if (feature.type === 'Feature') {
                callback(i, feature.geometry);
            }
        }
        return geometry;
    }

    _allocGeometry () {
        if (this._geomType === 'Point') {
            return new Float32Array(this._features.length * 6);
        }
        return ([]);
    }

    _decodeGeometry () {
        let geometries = this._allocGeometry();

        this._fetchFeatureGeometry({}, (i, geometry) => {
            const type = geometry.type;
            const coordinates = geometry.coordinates;
            const newGeomType = Object(_geojson_GeoJSONGeometryType__WEBPACK_IMPORTED_MODULE_7__["dataframeGeometryType"])(type);
            const prevGeomType = Object(_geojson_GeoJSONGeometryType__WEBPACK_IMPORTED_MODULE_7__["dataframeGeometryType"])(this._geomType);
            if (newGeomType !== prevGeomType) {
                throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["default"](
                    `multiple geometry types not supported: found '${newGeomType}' instead of '${prevGeomType}'.`,
                    _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["CartoValidationErrorTypes"].INCORRECT_TYPE
                );
            }
            if (type === _geojson_GeoJSONGeometryType__WEBPACK_IMPORTED_MODULE_7__["GeoJSONGeometryType"].POINT) {
                const point = this._geometryTransformer.computePoint(coordinates);
                geometries[6 * i + 0] = point.x;
                geometries[6 * i + 1] = point.y;
                geometries[6 * i + 2] = point.x;
                geometries[6 * i + 3] = point.y;
                geometries[6 * i + 4] = point.x;
                geometries[6 * i + 5] = point.y;
            } else if (type === _geojson_GeoJSONGeometryType__WEBPACK_IMPORTED_MODULE_7__["GeoJSONGeometryType"].LINE_STRING) {
                const line = this._geometryTransformer.computeLineString(coordinates);
                geometries.push([line]);
            } else if (type === _geojson_GeoJSONGeometryType__WEBPACK_IMPORTED_MODULE_7__["GeoJSONGeometryType"].MULTI_LINE_STRING) {
                const multiline = this._geometryTransformer.computeMultiLineString(coordinates);
                geometries.push(multiline);
            } else if (type === _geojson_GeoJSONGeometryType__WEBPACK_IMPORTED_MODULE_7__["GeoJSONGeometryType"].POLYGON) {
                const polygon = this._geometryTransformer.computePolygon(coordinates);
                geometries.push([polygon]);
            } else if (type === _geojson_GeoJSONGeometryType__WEBPACK_IMPORTED_MODULE_7__["GeoJSONGeometryType"].MULTI_POLYGON) {
                const multipolygon = this._geometryTransformer.computeMultiPolygon(coordinates);
                geometries.push(multipolygon);
            }
        });

        return geometries;
    }

    _samplePoint (geometry) {
        const type = geometry.type;

        const coordinates = geometry.coordinates;
        if (type === _geojson_GeoJSONGeometryType__WEBPACK_IMPORTED_MODULE_7__["GeoJSONGeometryType"].POINT) {
            return coordinates;
        } else if (type === _geojson_GeoJSONGeometryType__WEBPACK_IMPORTED_MODULE_7__["GeoJSONGeometryType"].LINE_STRING) {
            return coordinates[0];
        } else if (type === _geojson_GeoJSONGeometryType__WEBPACK_IMPORTED_MODULE_7__["GeoJSONGeometryType"].MULTI_LINE_STRING || type === _geojson_GeoJSONGeometryType__WEBPACK_IMPORTED_MODULE_7__["GeoJSONGeometryType"].POLYGON) {
            return coordinates[0][0];
        } else if (type === _geojson_GeoJSONGeometryType__WEBPACK_IMPORTED_MODULE_7__["GeoJSONGeometryType"].MULTI_POLYGON) {
            return coordinates[0][0][0];
        }
    }

    free () {
    }
}


/***/ }),

/***/ "./src/sources/MVT.js":
/*!****************************!*\
  !*** ./src/sources/MVT.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MVT; });
/* harmony import */ var _renderer_dataframe_Dataframe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderer/dataframe/Dataframe */ "./src/renderer/dataframe/Dataframe.js");
/* harmony import */ var _renderer_Metadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/Metadata */ "./src/renderer/Metadata.js");
/* harmony import */ var _MVTMetadata__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MVTMetadata */ "./src/sources/MVTMetadata.js");
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Base */ "./src/sources/Base.js");
/* harmony import */ var _TileClient__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./TileClient */ "./src/sources/TileClient.js");
/* harmony import */ var _Workers_worker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Workers.worker */ "./src/sources/Workers.worker.js");
/* harmony import */ var _Workers_worker__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_Workers_worker__WEBPACK_IMPORTED_MODULE_5__);








class MVT extends _Base__WEBPACK_IMPORTED_MODULE_3__["default"] {
    /**
     * Create a carto.source.MVT.
     *
     * @param {string | string[]} templateURL - A string with the URL template of the MVT tiles in https://mytileserver.com/{z}/{x}/{y}.mvt format or a list of such templates. Usage of a list of templates with different domains is recommended since that allows the browser to make more requests in parallel.
     * @param {MVTMetadata} [metadata] - Metadata of the source, declaring property name, types and optionally ranges.
     * @param {MVTOptions} [options] - MVT source configuration, the default value will be valid for regular URL templates if the tiles are composed of only one layer
     *
     * The combination of different type of geometries on the same source is not supported. Valid geometry types are `points`, `lines` and `polygons`.
     *
     * @example
     * // Usage with multiple templateURLs as recommended
     * const metadata = new carto.source.mvt.Metadata([{ type: 'number', name: 'total_pop'}])
     * const source = new carto.source.MVT(
     *     [
     *         "https://server-a.tileserver.com/{z}/{x}/{y}.mvt",
     *         "https://server-b.tileserver.com/{z}/{x}/{y}.mvt",
     *         "https://server-c.tileserver.com/{z}/{x}/{y}.mvt",
     *         "https://server-d.tileserver.com/{z}/{x}/{y}.mvt"
     *    ],
     *    metadata
     *);
     *
     * @throws CartoError
     *
     * @memberof carto.source
     * @name MVT
     * @api
     */
    constructor (templateURL, metadata = new _MVTMetadata__WEBPACK_IMPORTED_MODULE_2__["default"](), options) {
        super();

        this._templateURL = templateURL;
        this._tileClient = new _TileClient__WEBPACK_IMPORTED_MODULE_4__["default"](templateURL);

        this._initMetadata(metadata);
        this._initOptions(options);

        this._workerDispatch = {};
        this._mID = 0;
        this._workerName = 'MVT';
    }

    _initMetadata (metadata) {
        if (!(metadata instanceof _renderer_Metadata__WEBPACK_IMPORTED_MODULE_1__["default"])) {
            metadata = new _MVTMetadata__WEBPACK_IMPORTED_MODULE_2__["default"](metadata);
        }

        metadata.setCodecs();
        this._metadata = metadata;
    }

    _initOptions (options) {
        if (options === undefined) {
            options = {
                layerID: undefined,
                viewportZoomToSourceZoom: Math.ceil,
                maxZoom: undefined
            };
        }

        options.viewportZoomToSourceZoom = options.viewportZoomToSourceZoom || Math.ceil;
        this._options = options;
    }

    get _worker () {
        if (!this._workerInstance) {
            this._workerInstance = new _Workers_worker__WEBPACK_IMPORTED_MODULE_5___default.a();
            this._workerInstance.onmessage = this._receiveMessageFromWorker.bind(this);
        }
        return this._workerInstance;
    }

    _receiveMessageFromWorker (event) {
        const { mID, dataframe } = event.data;
        if (!dataframe.empty) {
            this._updateMetadataWith(dataframe);
        }
        this._workerDispatch[mID](dataframe);
    }

    _updateMetadataWith (dataframe) {
        Object.setPrototypeOf(dataframe, _renderer_dataframe_Dataframe__WEBPACK_IMPORTED_MODULE_0__["default"].prototype);
        const metadata = dataframe.metadata;

        this._metadata.numCategories = metadata.numCategories;
        this._metadata.categoryToID = metadata.categoryToID;
        this._metadata.IDToCategory = metadata.IDToCategory;
        this._metadata.geomType = metadata.geomType;

        dataframe.metadata = this._metadata;
    }

    _clone () {
        return new MVT(this._templateURL, JSON.parse(JSON.stringify(this._metadata)), this._options);
    }

    bindLayer (addDataframe) {
        this._tileClient.bindLayer(addDataframe);
    }

    async requestMetadata () {
        return this._metadata;
    }

    requestData (zoom, viewport) {
        const urlToDataframeTransformer = this._urlToDataframeTransformer.bind(this);
        const viewportZoomToSourceZoom = this._viewportZoomToSourceZoom.bind(this);

        return this._tileClient.requestData(zoom, viewport,
            urlToDataframeTransformer, viewportZoomToSourceZoom
        );
    }

    _urlToDataframeTransformer (x, y, z, url) {
        return new Promise(resolve => {
            const validUrl = this._validUrlForWorker(url);
            this._postMessageToWorker({ x, y, z }, validUrl);

            this._metadataSent = true;
            this._workerDispatch[this._mID] = resolve;
            this._mID++;
        });
    }

    _postMessageToWorker ({ x, y, z }, url) {
        this._worker.postMessage({
            x,
            y,
            z,
            url,
            layerID: this._options.layerID,
            metadata: this._metadataSent ? undefined : this._metadata,
            mID: this._mID,
            workerName: this._workerName
        });
    }

    _viewportZoomToSourceZoom (zoom) {
        const maxZoom = this._options.maxZoom;
        const sourceZoom = this._options.viewportZoomToSourceZoom(zoom);

        if (maxZoom === undefined) {
            return sourceZoom;
        }

        return Math.min(sourceZoom, maxZoom);
    }

    _validUrlForWorker (url) {
        // Relative URLs don't work inside the Web Worker
        if (url[0] === '.') {
            let parts = window.location.pathname.split('/');
            parts.pop();
            const path = parts.join('/');
            return `${window.location.protocol}//${window.location.host}/${path}/${url}`;
        } else if (url[0] === '/') {
            return `${window.location.protocol}//${window.location.host}${url}`;
        }

        return url;
    }

    free () {
        this._tileClient.free();
    }
}

/**
 * A MVTOptions object declares a MVT configuration
 *
 * @typedef {Object} MVTOptions
 * @property {String} layerID - layerID on the MVT tiles to decode, the parameter is optional if the MVT tiles only contain one layer
 * @property {function} [viewportZoomToSourceZoom=Math.ceil] - function to transform the viewport zoom into a zoom value to replace `{z}` in the MVT URL template, undefined defaults to `Math.ceil`
 * @property {number} maxZoom - limit MVT tile requests to this zoom level, undefined defaults to no limit
 *
 * @example <caption>Use layer `myAwesomeLayer` and request tiles up to zoom level 12.</caption>
 * const options = {
 *     layerID: 'myAwesomeLayer',
 *     maxZoom: 12
 * };
 *
 * @example <caption>Use layer `myAwesomeLayer` and request tiles only at zoom levels 4, 5 and 6.</caption>
 * const options = {
 *     layerID: 'myAwesomeLayer',
 *     viewportZoomToSourceZoom: zoom => Math.min(Math.max(Math.ceil(zoom), 4), 6)
 * };
 *
 * @example <caption>Use layer `myAwesomeLayer` and request tiles only at zoom levels 0,3,6,9...</caption>
 * const options = {
 *     layerID: 'myAwesomeLayer',
 *     viewportZoomToSourceZoom: zoom => Math.round(zoom / 3) * 3
 * };
 *
 * @api
 */

/**
 * An MVTMetadata object declares metadata information of a a carto.Source.
 *
 * @typedef {Object} MVTMetadata
 * @property {MVTProperty} properties - property names, types and optionally ranges
 * @property {String} [idProperty='cartodb_id'] - property name of the property that should be used as ID
 *
 * @example <caption> Creating a MVTMetadata object</caption>
 * const metadata = {
        properties: {
          numfloors: { type: 'number' },
          cartodb_id: { type: 'number' }
        },
        idProperty: 'cartodb_id',
      };
 *
 * @api
 */

/**
 * MVTProperty objects declare a property type and, optionally, additional information like numeric ranges.
 *
 * @typedef {Object} MVTProperty
 * @property {String} type - Valid values are 'number' and 'category', 'category' must be used if the MVT encodes the property as strings, regardless of the real type
 * @property {Number} min - With `type='number'` min specifies the minimum value in the dataset, this is used in global aggregation expressions
 * @property {Number} max - With `type='number'` max specifies the maximum value in the dataset, this is used in global aggregation expressions
 *
 * @api
 */


/***/ }),

/***/ "./src/sources/MVTMetadata.js":
/*!************************************!*\
  !*** ./src/sources/MVTMetadata.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MVTMetadata; });
/* harmony import */ var _renderer_Metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderer/Metadata */ "./src/renderer/Metadata.js");
/* harmony import */ var _codecs_mvt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../codecs/mvt */ "./src/codecs/mvt/index.js");



class MVTMetadata extends _renderer_Metadata__WEBPACK_IMPORTED_MODULE_0__["default"] {
    setCodecs () {
        Object.keys(this.properties).forEach(propertyName => {
            const property = this.properties[propertyName];
            const type = property.type;
            if (type !== 'geometry') {
                property.codec = Object(_codecs_mvt__WEBPACK_IMPORTED_MODULE_1__["default"])(this, type, propertyName);
            }
        });
    }
}


/***/ }),

/***/ "./src/sources/SQL.js":
/*!****************************!*\
  !*** ./src/sources/SQL.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SQL; });
/* harmony import */ var _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../src/errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/util */ "./src/utils/util.js");
/* harmony import */ var _BaseWindshaft__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./BaseWindshaft */ "./src/sources/BaseWindshaft.js");




class SQL extends _BaseWindshaft__WEBPACK_IMPORTED_MODULE_2__["default"] {
    /**
     * A SQL defines the data that will be displayed in a layer.
     *
     * Imagine you have a table named `european_cities` and you only want to download data from european cities with population > 100000
     *
     * ```javascript
     * const source = new carto.source.SQL(`SELECT * FROM european_cities WHERE country like 'europe' AND population > 10000`, {
     *   apiKey: 'YOUR_API_KEY_HERE',
     *   username: 'YOUR_USERNAME_HERE'
     * });
     * ````
     *
     * This only downloads the data you need from the server reducing data usage.
     *
     * If you need all the data see {@link carto.source.Dataset|carto.source.Dataset}.
     *
     * Since tables in the server are protected you must provide valid credentials in order to get access to the data.
     * This can be done {@link carto.setDefaultAuth|setting the default auth} in the carto object or providing an `auth`
     * object with your username and apiKey.
     *
     * If your server is not hosted by CARTO you must add a third parameter that includes the serverURL. This can be done {@link carto.setDefaultConfig|setting the default config} in the carto object or providing a `config`
     * object with your serverURL.
     *
     * The combination of different type of geometries on the same source is not supported. Valid geometry types are `points`, `lines` and `polygons`.
     *
     * @param {String} query - A SQL query containing a SELECT statement
     * @param {Object} auth
     * @param {String} auth.apiKey - API key used to authenticate against CARTO
     * @param {String} auth.user - Name of the user
     * @param {Object} config
     * @param {String} [config.serverURL='https://{user}.carto.com'] - URL of the CARTO Maps API server
     *
     * @example
     * const source = new carto.source.SQL('SELECT * FROM european_cities', {
     *   apiKey: 'YOUR_API_KEY_HERE',
     *   username: 'YOUR_USERNAME_HERE'
     * });
     *
     * @throws CartoError
     *
     * @memberof carto.source
     * @name SQL
     * @api
     */
    constructor (query, auth, config) {
        super();
        this._checkQuery(query);
        this._query = query;
        this.initialize(auth, config);
    }

    _getFromClause () {
        return `(${this._query}) as _cdb_query_wrapper`;
    }

    _clone () {
        return new SQL(this._query, this._auth, this._config);
    }

    _checkQuery (query) {
        if (_utils_util__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(query)) {
            throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_0__["default"]('\'query\'', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_0__["CartoValidationErrorTypes"].MISSING_REQUIRED);
        }
        if (!_utils_util__WEBPACK_IMPORTED_MODULE_1__["default"].isString(query)) {
            throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_0__["default"]('\'query\' property must be a string.', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_0__["CartoValidationErrorTypes"].INCORRECT_TYPE);
        }
        if (query === '') {
            throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_0__["default"]('\'query\' property must be not empty.', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_0__["CartoValidationErrorTypes"].INCORRECT_VALUE);
        }
        let sqlRegex = /\bSELECT\b/i;
        if (!query.match(sqlRegex)) {
            throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_0__["default"]('\'query\' property must be a SQL query.', _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_0__["CartoValidationErrorTypes"].INCORRECT_VALUE);
        }
    }
}


/***/ }),

/***/ "./src/sources/TileClient.js":
/*!***********************************!*\
  !*** ./src/sources/TileClient.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TileClient; });
/* harmony import */ var _DataframeCache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./DataframeCache */ "./src/sources/DataframeCache.js");
/* harmony import */ var _client_rsys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../client/rsys */ "./src/client/rsys.js");
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/util */ "./src/utils/util.js");




class TileClient {
    constructor (templateURLs) {
        if (!Array.isArray(templateURLs)) {
            templateURLs = [templateURLs];
        }

        this._templateURLs = templateURLs;
        this._nextGroupID = 0;
        this._currentRequestGroupID = 0;
        this._oldDataframes = [];
        this._cache = new _DataframeCache__WEBPACK_IMPORTED_MODULE_0__["default"]();
    }

    bindLayer (addDataframe) {
        this._addDataframe = addDataframe;
    }

    requestData (zoom, viewport, urlToDataframeTransformer, viewportZoomToSourceZoom = Math.ceil) {
        const tiles = Object(_client_rsys__WEBPACK_IMPORTED_MODULE_1__["rTiles"])(zoom, viewport, viewportZoomToSourceZoom);
        return this._getTiles(tiles, urlToDataframeTransformer);
    }

    free () {
        this._cache.free();
        this._cache = new _DataframeCache__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this._oldDataframes = [];
    }

    _getTileUrl (x, y, z) {
        const subdomainIndex = this._getSubdomainIndex(x, y);
        return this._templateURLs[subdomainIndex].replace('{x}', x).replace('{y}', y).replace('{z}', z);
    }

    _getSubdomainIndex (x, y) {
        // Reference https://github.com/Leaflet/Leaflet/blob/v1.3.1/src/layer/tile/TileLayer.js#L214-L217
        return Math.abs(x + y) % this._templateURLs.length;
    }

    async _getTiles (tiles, urlToDataframeTransformer) {
        this._nextGroupID++;
        const requestGroupID = this._nextGroupID;

        const completedDataframes = await Promise.all(tiles.map(({ x, y, z }) => {
            return this._cache.get(`${x},${y},${z}`, () => this._requestDataframe(x, y, z, urlToDataframeTransformer)).then(dataframe => {
                dataframe.orderID = x + y / 1000;
                return dataframe;
            });
        }));

        if (requestGroupID < this._currentRequestGroupID) {
            return true;
        }
        this._currentRequestGroupID = requestGroupID;

        this._oldDataframes.forEach(d => {
            d.active = false;
        });
        completedDataframes.forEach(d => {
            d.active = true;
        });
        const dataframesChanged = !Object(_utils_util__WEBPACK_IMPORTED_MODULE_2__["isSetsEqual"])(new Set(completedDataframes), new Set(this._oldDataframes));
        this._oldDataframes = completedDataframes;
        return dataframesChanged;
    }

    async _requestDataframe (x, y, z, urlToDataframeTransformer) {
        const url = this._getTileUrl(x, y, z);
        const dataframe = await urlToDataframeTransformer(x, y, z, url);
        if (!dataframe.empty) {
            this._addDataframe(dataframe);
        }
        return dataframe;
    }
}


/***/ }),

/***/ "./src/sources/Workers.worker.js":
/*!***************************************!*\
  !*** ./src/sources/Workers.worker.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = function() {
  return __webpack_require__(/*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */ "./node_modules/worker-loader/dist/workers/InlineWorker.js")("/*!\n * CARTO VL js https://carto.com/\n * Version: 1.4.6\n * \n */\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/sources/Workers.worker.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/@mapbox/point-geometry/index.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/@mapbox/point-geometry/index.js ***!\n  \\******************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = Point;\n\n/**\n * A standalone point geometry with useful accessor, comparison, and\n * modification methods.\n *\n * @class Point\n * @param {Number} x the x-coordinate. this could be longitude or screen\n * pixels, or any other sort of unit.\n * @param {Number} y the y-coordinate. this could be latitude or screen\n * pixels, or any other sort of unit.\n * @example\n * var point = new Point(-77, 38);\n */\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nPoint.prototype = {\n\n    /**\n     * Clone this point, returning a new point that can be modified\n     * without affecting the old one.\n     * @return {Point} the clone\n     */\n    clone: function() { return new Point(this.x, this.y); },\n\n    /**\n     * Add this point's x & y coordinates to another point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    add:     function(p) { return this.clone()._add(p); },\n\n    /**\n     * Subtract this point's x & y coordinates to from point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    sub:     function(p) { return this.clone()._sub(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    multByPoint:    function(p) { return this.clone()._multByPoint(p); },\n\n    /**\n     * Divide this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    divByPoint:     function(p) { return this.clone()._divByPoint(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {Point} k factor\n     * @return {Point} output point\n     */\n    mult:    function(k) { return this.clone()._mult(k); },\n\n    /**\n     * Divide this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {Point} k factor\n     * @return {Point} output point\n     */\n    div:     function(k) { return this.clone()._div(k); },\n\n    /**\n     * Rotate this point around the 0, 0 origin by an angle a,\n     * given in radians\n     * @param {Number} a angle to rotate around, in radians\n     * @return {Point} output point\n     */\n    rotate:  function(a) { return this.clone()._rotate(a); },\n\n    /**\n     * Rotate this point around p point by an angle a,\n     * given in radians\n     * @param {Number} a angle to rotate around, in radians\n     * @param {Point} p Point to rotate around\n     * @return {Point} output point\n     */\n    rotateAround:  function(a,p) { return this.clone()._rotateAround(a,p); },\n\n    /**\n     * Multiply this point by a 4x1 transformation matrix\n     * @param {Array<Number>} m transformation matrix\n     * @return {Point} output point\n     */\n    matMult: function(m) { return this.clone()._matMult(m); },\n\n    /**\n     * Calculate this point but as a unit vector from 0, 0, meaning\n     * that the distance from the resulting point to the 0, 0\n     * coordinate will be equal to 1 and the angle from the resulting\n     * point to the 0, 0 coordinate will be the same as before.\n     * @return {Point} unit vector point\n     */\n    unit:    function() { return this.clone()._unit(); },\n\n    /**\n     * Compute a perpendicular point, where the new y coordinate\n     * is the old x coordinate and the new x coordinate is the old y\n     * coordinate multiplied by -1\n     * @return {Point} perpendicular point\n     */\n    perp:    function() { return this.clone()._perp(); },\n\n    /**\n     * Return a version of this point with the x & y coordinates\n     * rounded to integers.\n     * @return {Point} rounded point\n     */\n    round:   function() { return this.clone()._round(); },\n\n    /**\n     * Return the magitude of this point: this is the Euclidean\n     * distance from the 0, 0 coordinate to this point's x and y\n     * coordinates.\n     * @return {Number} magnitude\n     */\n    mag: function() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    },\n\n    /**\n     * Judge whether this point is equal to another point, returning\n     * true or false.\n     * @param {Point} other the other point\n     * @return {boolean} whether the points are equal\n     */\n    equals: function(other) {\n        return this.x === other.x &&\n               this.y === other.y;\n    },\n\n    /**\n     * Calculate the distance from this point to another point\n     * @param {Point} p the other point\n     * @return {Number} distance\n     */\n    dist: function(p) {\n        return Math.sqrt(this.distSqr(p));\n    },\n\n    /**\n     * Calculate the distance from this point to another point,\n     * without the square root step. Useful if you're comparing\n     * relative distances.\n     * @param {Point} p the other point\n     * @return {Number} distance\n     */\n    distSqr: function(p) {\n        var dx = p.x - this.x,\n            dy = p.y - this.y;\n        return dx * dx + dy * dy;\n    },\n\n    /**\n     * Get the angle from the 0, 0 coordinate to this point, in radians\n     * coordinates.\n     * @return {Number} angle\n     */\n    angle: function() {\n        return Math.atan2(this.y, this.x);\n    },\n\n    /**\n     * Get the angle from this point to another point, in radians\n     * @param {Point} b the other point\n     * @return {Number} angle\n     */\n    angleTo: function(b) {\n        return Math.atan2(this.y - b.y, this.x - b.x);\n    },\n\n    /**\n     * Get the angle between this point and another point, in radians\n     * @param {Point} b the other point\n     * @return {Number} angle\n     */\n    angleWith: function(b) {\n        return this.angleWithSep(b.x, b.y);\n    },\n\n    /*\n     * Find the angle of the two vectors, solving the formula for\n     * the cross product a x b = |a||b|sin() for .\n     * @param {Number} x the x-coordinate\n     * @param {Number} y the y-coordinate\n     * @return {Number} the angle in radians\n     */\n    angleWithSep: function(x, y) {\n        return Math.atan2(\n            this.x * y - this.y * x,\n            this.x * x + this.y * y);\n    },\n\n    _matMult: function(m) {\n        var x = m[0] * this.x + m[1] * this.y,\n            y = m[2] * this.x + m[3] * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _add: function(p) {\n        this.x += p.x;\n        this.y += p.y;\n        return this;\n    },\n\n    _sub: function(p) {\n        this.x -= p.x;\n        this.y -= p.y;\n        return this;\n    },\n\n    _mult: function(k) {\n        this.x *= k;\n        this.y *= k;\n        return this;\n    },\n\n    _div: function(k) {\n        this.x /= k;\n        this.y /= k;\n        return this;\n    },\n\n    _multByPoint: function(p) {\n        this.x *= p.x;\n        this.y *= p.y;\n        return this;\n    },\n\n    _divByPoint: function(p) {\n        this.x /= p.x;\n        this.y /= p.y;\n        return this;\n    },\n\n    _unit: function() {\n        this._div(this.mag());\n        return this;\n    },\n\n    _perp: function() {\n        var y = this.y;\n        this.y = this.x;\n        this.x = -y;\n        return this;\n    },\n\n    _rotate: function(angle) {\n        var cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = cos * this.x - sin * this.y,\n            y = sin * this.x + cos * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _rotateAround: function(angle, p) {\n        var cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),\n            y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _round: function() {\n        this.x = Math.round(this.x);\n        this.y = Math.round(this.y);\n        return this;\n    }\n};\n\n/**\n * Construct a point from an array if necessary, otherwise if the input\n * is already a Point, or an unknown type, return it unchanged\n * @param {Array<Number>|Point|*} a any kind of input value\n * @return {Point} constructed point, or passed-through value.\n * @example\n * // this\n * var point = Point.convert([0, 1]);\n * // is equivalent to\n * var point = new Point(0, 1);\n */\nPoint.convert = function (a) {\n    if (a instanceof Point) {\n        return a;\n    }\n    if (Array.isArray(a)) {\n        return new Point(a[0], a[1]);\n    }\n    return a;\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/@mapbox/vector-tile/index.js\":\n/*!***************************************************!*\\\n  !*** ./node_modules/@mapbox/vector-tile/index.js ***!\n  \\***************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports.VectorTile = __webpack_require__(/*! ./lib/vectortile.js */ \"./node_modules/@mapbox/vector-tile/lib/vectortile.js\");\nmodule.exports.VectorTileFeature = __webpack_require__(/*! ./lib/vectortilefeature.js */ \"./node_modules/@mapbox/vector-tile/lib/vectortilefeature.js\");\nmodule.exports.VectorTileLayer = __webpack_require__(/*! ./lib/vectortilelayer.js */ \"./node_modules/@mapbox/vector-tile/lib/vectortilelayer.js\");\n\n\n/***/ }),\n\n/***/ \"./node_modules/@mapbox/vector-tile/lib/vectortile.js\":\n/*!************************************************************!*\\\n  !*** ./node_modules/@mapbox/vector-tile/lib/vectortile.js ***!\n  \\************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar VectorTileLayer = __webpack_require__(/*! ./vectortilelayer */ \"./node_modules/@mapbox/vector-tile/lib/vectortilelayer.js\");\n\nmodule.exports = VectorTile;\n\nfunction VectorTile(pbf, end) {\n    this.layers = pbf.readFields(readTile, {}, end);\n}\n\nfunction readTile(tag, layers, pbf) {\n    if (tag === 3) {\n        var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);\n        if (layer.length) layers[layer.name] = layer;\n    }\n}\n\n\n\n/***/ }),\n\n/***/ \"./node_modules/@mapbox/vector-tile/lib/vectortilefeature.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/@mapbox/vector-tile/lib/vectortilefeature.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar Point = __webpack_require__(/*! @mapbox/point-geometry */ \"./node_modules/@mapbox/point-geometry/index.js\");\n\nmodule.exports = VectorTileFeature;\n\nfunction VectorTileFeature(pbf, end, extent, keys, values) {\n    // Public\n    this.properties = {};\n    this.extent = extent;\n    this.type = 0;\n\n    // Private\n    this._pbf = pbf;\n    this._geometry = -1;\n    this._keys = keys;\n    this._values = values;\n\n    pbf.readFields(readFeature, this, end);\n}\n\nfunction readFeature(tag, feature, pbf) {\n    if (tag == 1) feature.id = pbf.readVarint();\n    else if (tag == 2) readTag(pbf, feature);\n    else if (tag == 3) feature.type = pbf.readVarint();\n    else if (tag == 4) feature._geometry = pbf.pos;\n}\n\nfunction readTag(pbf, feature) {\n    var end = pbf.readVarint() + pbf.pos;\n\n    while (pbf.pos < end) {\n        var key = feature._keys[pbf.readVarint()],\n            value = feature._values[pbf.readVarint()];\n        feature.properties[key] = value;\n    }\n}\n\nVectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];\n\nVectorTileFeature.prototype.loadGeometry = function() {\n    var pbf = this._pbf;\n    pbf.pos = this._geometry;\n\n    var end = pbf.readVarint() + pbf.pos,\n        cmd = 1,\n        length = 0,\n        x = 0,\n        y = 0,\n        lines = [],\n        line;\n\n    while (pbf.pos < end) {\n        if (length <= 0) {\n            var cmdLen = pbf.readVarint();\n            cmd = cmdLen & 0x7;\n            length = cmdLen >> 3;\n        }\n\n        length--;\n\n        if (cmd === 1 || cmd === 2) {\n            x += pbf.readSVarint();\n            y += pbf.readSVarint();\n\n            if (cmd === 1) { // moveTo\n                if (line) lines.push(line);\n                line = [];\n            }\n\n            line.push(new Point(x, y));\n\n        } else if (cmd === 7) {\n\n            // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n            if (line) {\n                line.push(line[0].clone()); // closePolygon\n            }\n\n        } else {\n            throw new Error('unknown command ' + cmd);\n        }\n    }\n\n    if (line) lines.push(line);\n\n    return lines;\n};\n\nVectorTileFeature.prototype.bbox = function() {\n    var pbf = this._pbf;\n    pbf.pos = this._geometry;\n\n    var end = pbf.readVarint() + pbf.pos,\n        cmd = 1,\n        length = 0,\n        x = 0,\n        y = 0,\n        x1 = Infinity,\n        x2 = -Infinity,\n        y1 = Infinity,\n        y2 = -Infinity;\n\n    while (pbf.pos < end) {\n        if (length <= 0) {\n            var cmdLen = pbf.readVarint();\n            cmd = cmdLen & 0x7;\n            length = cmdLen >> 3;\n        }\n\n        length--;\n\n        if (cmd === 1 || cmd === 2) {\n            x += pbf.readSVarint();\n            y += pbf.readSVarint();\n            if (x < x1) x1 = x;\n            if (x > x2) x2 = x;\n            if (y < y1) y1 = y;\n            if (y > y2) y2 = y;\n\n        } else if (cmd !== 7) {\n            throw new Error('unknown command ' + cmd);\n        }\n    }\n\n    return [x1, y1, x2, y2];\n};\n\nVectorTileFeature.prototype.toGeoJSON = function(x, y, z) {\n    var size = this.extent * Math.pow(2, z),\n        x0 = this.extent * x,\n        y0 = this.extent * y,\n        coords = this.loadGeometry(),\n        type = VectorTileFeature.types[this.type],\n        i, j;\n\n    function project(line) {\n        for (var j = 0; j < line.length; j++) {\n            var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;\n            line[j] = [\n                (p.x + x0) * 360 / size - 180,\n                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90\n            ];\n        }\n    }\n\n    switch (this.type) {\n    case 1:\n        var points = [];\n        for (i = 0; i < coords.length; i++) {\n            points[i] = coords[i][0];\n        }\n        coords = points;\n        project(coords);\n        break;\n\n    case 2:\n        for (i = 0; i < coords.length; i++) {\n            project(coords[i]);\n        }\n        break;\n\n    case 3:\n        coords = classifyRings(coords);\n        for (i = 0; i < coords.length; i++) {\n            for (j = 0; j < coords[i].length; j++) {\n                project(coords[i][j]);\n            }\n        }\n        break;\n    }\n\n    if (coords.length === 1) {\n        coords = coords[0];\n    } else {\n        type = 'Multi' + type;\n    }\n\n    var result = {\n        type: \"Feature\",\n        geometry: {\n            type: type,\n            coordinates: coords\n        },\n        properties: this.properties\n    };\n\n    if ('id' in this) {\n        result.id = this.id;\n    }\n\n    return result;\n};\n\n// classifies an array of rings into polygons with outer rings and holes\n\nfunction classifyRings(rings) {\n    var len = rings.length;\n\n    if (len <= 1) return [rings];\n\n    var polygons = [],\n        polygon,\n        ccw;\n\n    for (var i = 0; i < len; i++) {\n        var area = signedArea(rings[i]);\n        if (area === 0) continue;\n\n        if (ccw === undefined) ccw = area < 0;\n\n        if (ccw === area < 0) {\n            if (polygon) polygons.push(polygon);\n            polygon = [rings[i]];\n\n        } else {\n            polygon.push(rings[i]);\n        }\n    }\n    if (polygon) polygons.push(polygon);\n\n    return polygons;\n}\n\nfunction signedArea(ring) {\n    var sum = 0;\n    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {\n        p1 = ring[i];\n        p2 = ring[j];\n        sum += (p2.x - p1.x) * (p1.y + p2.y);\n    }\n    return sum;\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/@mapbox/vector-tile/lib/vectortilelayer.js\":\n/*!*****************************************************************!*\\\n  !*** ./node_modules/@mapbox/vector-tile/lib/vectortilelayer.js ***!\n  \\*****************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar VectorTileFeature = __webpack_require__(/*! ./vectortilefeature.js */ \"./node_modules/@mapbox/vector-tile/lib/vectortilefeature.js\");\n\nmodule.exports = VectorTileLayer;\n\nfunction VectorTileLayer(pbf, end) {\n    // Public\n    this.version = 1;\n    this.name = null;\n    this.extent = 4096;\n    this.length = 0;\n\n    // Private\n    this._pbf = pbf;\n    this._keys = [];\n    this._values = [];\n    this._features = [];\n\n    pbf.readFields(readLayer, this, end);\n\n    this.length = this._features.length;\n}\n\nfunction readLayer(tag, layer, pbf) {\n    if (tag === 15) layer.version = pbf.readVarint();\n    else if (tag === 1) layer.name = pbf.readString();\n    else if (tag === 5) layer.extent = pbf.readVarint();\n    else if (tag === 2) layer._features.push(pbf.pos);\n    else if (tag === 3) layer._keys.push(pbf.readString());\n    else if (tag === 4) layer._values.push(readValueMessage(pbf));\n}\n\nfunction readValueMessage(pbf) {\n    var value = null,\n        end = pbf.readVarint() + pbf.pos;\n\n    while (pbf.pos < end) {\n        var tag = pbf.readVarint() >> 3;\n\n        value = tag === 1 ? pbf.readString() :\n            tag === 2 ? pbf.readFloat() :\n            tag === 3 ? pbf.readDouble() :\n            tag === 4 ? pbf.readVarint64() :\n            tag === 5 ? pbf.readVarint() :\n            tag === 6 ? pbf.readSVarint() :\n            tag === 7 ? pbf.readBoolean() : null;\n    }\n\n    return value;\n}\n\n// return feature `i` from this layer as a `VectorTileFeature`\nVectorTileLayer.prototype.feature = function(i) {\n    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');\n\n    this._pbf.pos = this._features[i];\n\n    var end = this._pbf.readVarint() + this._pbf.pos;\n    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js\":\n/*!*******************************************************************!*\\\n  !*** ./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js ***!\n  \\*******************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\n/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n(function(){\n  \"use strict\";\n\n  var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  // Use a lookup table to find the index.\n  var lookup = new Uint8Array(256);\n  for (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n  }\n\n  exports.encode = function(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer),\n    i, len = bytes.length, base64 = \"\";\n\n    for (i = 0; i < len; i+=3) {\n      base64 += chars[bytes[i] >> 2];\n      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n      base64 += chars[bytes[i + 2] & 63];\n    }\n\n    if ((len % 3) === 2) {\n      base64 = base64.substring(0, base64.length - 1) + \"=\";\n    } else if (len % 3 === 1) {\n      base64 = base64.substring(0, base64.length - 2) + \"==\";\n    }\n\n    return base64;\n  };\n\n  exports.decode =  function(base64) {\n    var bufferLength = base64.length * 0.75,\n    len = base64.length, i, p = 0,\n    encoded1, encoded2, encoded3, encoded4;\n\n    if (base64[base64.length - 1] === \"=\") {\n      bufferLength--;\n      if (base64[base64.length - 2] === \"=\") {\n        bufferLength--;\n      }\n    }\n\n    var arraybuffer = new ArrayBuffer(bufferLength),\n    bytes = new Uint8Array(arraybuffer);\n\n    for (i = 0; i < len; i+=4) {\n      encoded1 = lookup[base64.charCodeAt(i)];\n      encoded2 = lookup[base64.charCodeAt(i+1)];\n      encoded3 = lookup[base64.charCodeAt(i+2)];\n      encoded4 = lookup[base64.charCodeAt(i+3)];\n\n      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return arraybuffer;\n  };\n})();\n\n\n/***/ }),\n\n/***/ \"./node_modules/earcut/src/earcut.js\":\n/*!*******************************************!*\\\n  !*** ./node_modules/earcut/src/earcut.js ***!\n  \\*******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertice leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(ear, triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, invSize),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return p;\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize);\n                earcutLinked(c, triangles, dim, minX, minY, invSize);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m.next;\n\n    while (p !== stop) {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    }\n\n    return m;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) * invSize;\n    y = 32767 * (y - minY) * invSize;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&\n           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    if ((equals(p1, q1) && equals(p2, q2)) ||\n        (equals(p1, q2) && equals(p2, q1))) return true;\n    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&\n           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertice index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertice nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/gl-matrix/lib/gl-matrix.js\":\n/*!*************************************************!*\\\n  !*** ./node_modules/gl-matrix/lib/gl-matrix.js ***!\n  \\*************************************************/\n/*! exports provided: glMatrix, mat2, mat2d, mat3, mat4, quat, quat2, vec2, vec3, vec4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _gl_matrix_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gl-matrix/common.js */ \"./node_modules/gl-matrix/lib/gl-matrix/common.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"glMatrix\", function() { return _gl_matrix_common_js__WEBPACK_IMPORTED_MODULE_0__; });\n/* harmony import */ var _gl_matrix_mat2_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gl-matrix/mat2.js */ \"./node_modules/gl-matrix/lib/gl-matrix/mat2.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"mat2\", function() { return _gl_matrix_mat2_js__WEBPACK_IMPORTED_MODULE_1__; });\n/* harmony import */ var _gl_matrix_mat2d_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gl-matrix/mat2d.js */ \"./node_modules/gl-matrix/lib/gl-matrix/mat2d.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"mat2d\", function() { return _gl_matrix_mat2d_js__WEBPACK_IMPORTED_MODULE_2__; });\n/* harmony import */ var _gl_matrix_mat3_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./gl-matrix/mat3.js */ \"./node_modules/gl-matrix/lib/gl-matrix/mat3.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"mat3\", function() { return _gl_matrix_mat3_js__WEBPACK_IMPORTED_MODULE_3__; });\n/* harmony import */ var _gl_matrix_mat4_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gl-matrix/mat4.js */ \"./node_modules/gl-matrix/lib/gl-matrix/mat4.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"mat4\", function() { return _gl_matrix_mat4_js__WEBPACK_IMPORTED_MODULE_4__; });\n/* harmony import */ var _gl_matrix_quat_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./gl-matrix/quat.js */ \"./node_modules/gl-matrix/lib/gl-matrix/quat.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"quat\", function() { return _gl_matrix_quat_js__WEBPACK_IMPORTED_MODULE_5__; });\n/* harmony import */ var _gl_matrix_quat2_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./gl-matrix/quat2.js */ \"./node_modules/gl-matrix/lib/gl-matrix/quat2.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"quat2\", function() { return _gl_matrix_quat2_js__WEBPACK_IMPORTED_MODULE_6__; });\n/* harmony import */ var _gl_matrix_vec2_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./gl-matrix/vec2.js */ \"./node_modules/gl-matrix/lib/gl-matrix/vec2.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"vec2\", function() { return _gl_matrix_vec2_js__WEBPACK_IMPORTED_MODULE_7__; });\n/* harmony import */ var _gl_matrix_vec3_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./gl-matrix/vec3.js */ \"./node_modules/gl-matrix/lib/gl-matrix/vec3.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"vec3\", function() { return _gl_matrix_vec3_js__WEBPACK_IMPORTED_MODULE_8__; });\n/* harmony import */ var _gl_matrix_vec4_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./gl-matrix/vec4.js */ \"./node_modules/gl-matrix/lib/gl-matrix/vec4.js\");\n/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, \"vec4\", function() { return _gl_matrix_vec4_js__WEBPACK_IMPORTED_MODULE_9__; });\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\n\n/***/ }),\n\n/***/ \"./node_modules/gl-matrix/lib/gl-matrix/common.js\":\n/*!********************************************************!*\\\n  !*** ./node_modules/gl-matrix/lib/gl-matrix/common.js ***!\n  \\********************************************************/\n/*! exports provided: EPSILON, ARRAY_TYPE, RANDOM, setMatrixArrayType, toRadian, equals */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EPSILON\", function() { return EPSILON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ARRAY_TYPE\", function() { return ARRAY_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RANDOM\", function() { return RANDOM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setMatrixArrayType\", function() { return setMatrixArrayType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toRadian\", function() { return toRadian; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/**\r\n * Common utilities\r\n * @module glMatrix\r\n */\r\n\r\n// Configuration Constants\r\nvar EPSILON = 0.000001;\r\nvar ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;\r\nvar RANDOM = Math.random;\r\n\r\n/**\r\n * Sets the type of array used when creating new vectors and matrices\r\n *\r\n * @param {Type} type Array type, such as Float32Array or Array\r\n */\r\nfunction setMatrixArrayType(type) {\r\n  ARRAY_TYPE = type;\r\n}\r\n\r\nvar degree = Math.PI / 180;\r\n\r\n/**\r\n * Convert Degree To Radian\r\n *\r\n * @param {Number} a Angle in Degrees\r\n */\r\nfunction toRadian(a) {\r\n  return a * degree;\r\n}\r\n\r\n/**\r\n * Tests whether or not the arguments have approximately the same value, within an absolute\r\n * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less\r\n * than or equal to 1.0, and a relative tolerance is used for larger values)\r\n *\r\n * @param {Number} a The first number to test.\r\n * @param {Number} b The second number to test.\r\n * @returns {Boolean} True if the numbers are approximately equal, false otherwise.\r\n */\r\nfunction equals(a, b) {\r\n  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));\r\n}\n\n/***/ }),\n\n/***/ \"./node_modules/gl-matrix/lib/gl-matrix/mat2.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/gl-matrix/lib/gl-matrix/mat2.js ***!\n  \\******************************************************/\n/*! exports provided: create, clone, copy, identity, fromValues, set, transpose, invert, adjoint, determinant, multiply, rotate, scale, fromRotation, fromScaling, str, frob, LDU, add, subtract, exactEquals, equals, multiplyScalar, multiplyScalarAndAdd, mul, sub */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transpose\", function() { return transpose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"adjoint\", function() { return adjoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"determinant\", function() { return determinant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromScaling\", function() { return fromScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frob\", function() { return frob; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LDU\", function() { return LDU; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalar\", function() { return multiplyScalar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalarAndAdd\", function() { return multiplyScalarAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/lib/gl-matrix/common.js\");\n\r\n\r\n/**\r\n * 2x2 Matrix\r\n * @module mat2\r\n */\r\n\r\n/**\r\n * Creates a new identity mat2\r\n *\r\n * @returns {mat2} a new 2x2 matrix\r\n */\r\nfunction create() {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\r\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\r\n    out[1] = 0;\r\n    out[2] = 0;\r\n  }\r\n  out[0] = 1;\r\n  out[3] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new mat2 initialized with values from an existing matrix\r\n *\r\n * @param {mat2} a matrix to clone\r\n * @returns {mat2} a new 2x2 matrix\r\n */\r\nfunction clone(a) {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copy the values from one mat2 to another\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\r\nfunction copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set a mat2 to the identity matrix\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @returns {mat2} out\r\n */\r\nfunction identity(out) {\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Create a new mat2 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\r\n * @returns {mat2} out A new 2x2 matrix\r\n */\r\nfunction fromValues(m00, m01, m10, m11) {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\r\n  out[0] = m00;\r\n  out[1] = m01;\r\n  out[2] = m10;\r\n  out[3] = m11;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set the components of a mat2 to the given values\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 2)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 3)\r\n * @returns {mat2} out\r\n */\r\nfunction set(out, m00, m01, m10, m11) {\r\n  out[0] = m00;\r\n  out[1] = m01;\r\n  out[2] = m10;\r\n  out[3] = m11;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transpose the values of a mat2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\r\nfunction transpose(out, a) {\r\n  // If we are transposing ourselves we can skip a few steps but have to cache\r\n  // some values\r\n  if (out === a) {\r\n    var a1 = a[1];\r\n    out[1] = a[2];\r\n    out[2] = a1;\r\n  } else {\r\n    out[0] = a[0];\r\n    out[1] = a[2];\r\n    out[2] = a[1];\r\n    out[3] = a[3];\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Inverts a mat2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\r\nfunction invert(out, a) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n\r\n  // Calculate the determinant\r\n  var det = a0 * a3 - a2 * a1;\r\n\r\n  if (!det) {\r\n    return null;\r\n  }\r\n  det = 1.0 / det;\r\n\r\n  out[0] = a3 * det;\r\n  out[1] = -a1 * det;\r\n  out[2] = -a2 * det;\r\n  out[3] = a0 * det;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the adjugate of a mat2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the source matrix\r\n * @returns {mat2} out\r\n */\r\nfunction adjoint(out, a) {\r\n  // Caching this value is nessecary if out == a\r\n  var a0 = a[0];\r\n  out[0] = a[3];\r\n  out[1] = -a[1];\r\n  out[2] = -a[2];\r\n  out[3] = a0;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the determinant of a mat2\r\n *\r\n * @param {mat2} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\r\nfunction determinant(a) {\r\n  return a[0] * a[3] - a[2] * a[1];\r\n}\r\n\r\n/**\r\n * Multiplies two mat2's\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the first operand\r\n * @param {mat2} b the second operand\r\n * @returns {mat2} out\r\n */\r\nfunction multiply(out, a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3];\r\n  out[0] = a0 * b0 + a2 * b1;\r\n  out[1] = a1 * b0 + a3 * b1;\r\n  out[2] = a0 * b2 + a2 * b3;\r\n  out[3] = a1 * b2 + a3 * b3;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a mat2 by the given angle\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2} out\r\n */\r\nfunction rotate(out, a, rad) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n  out[0] = a0 * c + a2 * s;\r\n  out[1] = a1 * c + a3 * s;\r\n  out[2] = a0 * -s + a2 * c;\r\n  out[3] = a1 * -s + a3 * c;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Scales the mat2 by the dimensions in the given vec2\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the matrix to rotate\r\n * @param {vec2} v the vec2 to scale the matrix by\r\n * @returns {mat2} out\r\n **/\r\nfunction scale(out, a, v) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n  var v0 = v[0],\r\n      v1 = v[1];\r\n  out[0] = a0 * v0;\r\n  out[1] = a1 * v0;\r\n  out[2] = a2 * v1;\r\n  out[3] = a3 * v1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a given angle\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2.identity(dest);\r\n *     mat2.rotate(dest, dest, rad);\r\n *\r\n * @param {mat2} out mat2 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2} out\r\n */\r\nfunction fromRotation(out, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n  out[0] = c;\r\n  out[1] = s;\r\n  out[2] = -s;\r\n  out[3] = c;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2.identity(dest);\r\n *     mat2.scale(dest, dest, vec);\r\n *\r\n * @param {mat2} out mat2 receiving operation result\r\n * @param {vec2} v Scaling vector\r\n * @returns {mat2} out\r\n */\r\nfunction fromScaling(out, v) {\r\n  out[0] = v[0];\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = v[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns a string representation of a mat2\r\n *\r\n * @param {mat2} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\r\nfunction str(a) {\r\n  return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\r\n}\r\n\r\n/**\r\n * Returns Frobenius norm of a mat2\r\n *\r\n * @param {mat2} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\r\nfunction frob(a) {\r\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2));\r\n}\r\n\r\n/**\r\n * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix\r\n * @param {mat2} L the lower triangular matrix\r\n * @param {mat2} D the diagonal matrix\r\n * @param {mat2} U the upper triangular matrix\r\n * @param {mat2} a the input matrix to factorize\r\n */\r\n\r\nfunction LDU(L, D, U, a) {\r\n  L[2] = a[2] / a[0];\r\n  U[0] = a[0];\r\n  U[1] = a[1];\r\n  U[3] = a[3] - L[2] * U[1];\r\n  return [L, D, U];\r\n}\r\n\r\n/**\r\n * Adds two mat2's\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the first operand\r\n * @param {mat2} b the second operand\r\n * @returns {mat2} out\r\n */\r\nfunction add(out, a, b) {\r\n  out[0] = a[0] + b[0];\r\n  out[1] = a[1] + b[1];\r\n  out[2] = a[2] + b[2];\r\n  out[3] = a[3] + b[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the first operand\r\n * @param {mat2} b the second operand\r\n * @returns {mat2} out\r\n */\r\nfunction subtract(out, a, b) {\r\n  out[0] = a[0] - b[0];\r\n  out[1] = a[1] - b[1];\r\n  out[2] = a[2] - b[2];\r\n  out[3] = a[3] - b[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {mat2} a The first matrix.\r\n * @param {mat2} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\r\nfunction exactEquals(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\r\n}\r\n\r\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {mat2} a The first matrix.\r\n * @param {mat2} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\r\nfunction equals(a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3];\r\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));\r\n}\r\n\r\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat2} out the receiving matrix\r\n * @param {mat2} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat2} out\r\n */\r\nfunction multiplyScalar(out, a, b) {\r\n  out[0] = a[0] * b;\r\n  out[1] = a[1] * b;\r\n  out[2] = a[2] * b;\r\n  out[3] = a[3] * b;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two mat2's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat2} out the receiving vector\r\n * @param {mat2} a the first operand\r\n * @param {mat2} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat2} out\r\n */\r\nfunction multiplyScalarAndAdd(out, a, b, scale) {\r\n  out[0] = a[0] + b[0] * scale;\r\n  out[1] = a[1] + b[1] * scale;\r\n  out[2] = a[2] + b[2] * scale;\r\n  out[3] = a[3] + b[3] * scale;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Alias for {@link mat2.multiply}\r\n * @function\r\n */\r\nvar mul = multiply;\r\n\r\n/**\r\n * Alias for {@link mat2.subtract}\r\n * @function\r\n */\r\nvar sub = subtract;\n\n/***/ }),\n\n/***/ \"./node_modules/gl-matrix/lib/gl-matrix/mat2d.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/gl-matrix/lib/gl-matrix/mat2d.js ***!\n  \\*******************************************************/\n/*! exports provided: create, clone, copy, identity, fromValues, set, invert, determinant, multiply, rotate, scale, translate, fromRotation, fromScaling, fromTranslation, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"determinant\", function() { return determinant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translate\", function() { return translate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromScaling\", function() { return fromScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromTranslation\", function() { return fromTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frob\", function() { return frob; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalar\", function() { return multiplyScalar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalarAndAdd\", function() { return multiplyScalarAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/lib/gl-matrix/common.js\");\n\r\n\r\n/**\r\n * 2x3 Matrix\r\n * @module mat2d\r\n *\r\n * @description\r\n * A mat2d contains six elements defined as:\r\n * <pre>\r\n * [a, c, tx,\r\n *  b, d, ty]\r\n * </pre>\r\n * This is a short form for the 3x3 matrix:\r\n * <pre>\r\n * [a, c, tx,\r\n *  b, d, ty,\r\n *  0, 0, 1]\r\n * </pre>\r\n * The last row is ignored so the array is shorter and operations are faster.\r\n */\r\n\r\n/**\r\n * Creates a new identity mat2d\r\n *\r\n * @returns {mat2d} a new 2x3 matrix\r\n */\r\nfunction create() {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](6);\r\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\r\n    out[1] = 0;\r\n    out[2] = 0;\r\n    out[4] = 0;\r\n    out[5] = 0;\r\n  }\r\n  out[0] = 1;\r\n  out[3] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new mat2d initialized with values from an existing matrix\r\n *\r\n * @param {mat2d} a matrix to clone\r\n * @returns {mat2d} a new 2x3 matrix\r\n */\r\nfunction clone(a) {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](6);\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  out[4] = a[4];\r\n  out[5] = a[5];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copy the values from one mat2d to another\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the source matrix\r\n * @returns {mat2d} out\r\n */\r\nfunction copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  out[4] = a[4];\r\n  out[5] = a[5];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set a mat2d to the identity matrix\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @returns {mat2d} out\r\n */\r\nfunction identity(out) {\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 1;\r\n  out[4] = 0;\r\n  out[5] = 0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Create a new mat2d with the given values\r\n *\r\n * @param {Number} a Component A (index 0)\r\n * @param {Number} b Component B (index 1)\r\n * @param {Number} c Component C (index 2)\r\n * @param {Number} d Component D (index 3)\r\n * @param {Number} tx Component TX (index 4)\r\n * @param {Number} ty Component TY (index 5)\r\n * @returns {mat2d} A new mat2d\r\n */\r\nfunction fromValues(a, b, c, d, tx, ty) {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](6);\r\n  out[0] = a;\r\n  out[1] = b;\r\n  out[2] = c;\r\n  out[3] = d;\r\n  out[4] = tx;\r\n  out[5] = ty;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set the components of a mat2d to the given values\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {Number} a Component A (index 0)\r\n * @param {Number} b Component B (index 1)\r\n * @param {Number} c Component C (index 2)\r\n * @param {Number} d Component D (index 3)\r\n * @param {Number} tx Component TX (index 4)\r\n * @param {Number} ty Component TY (index 5)\r\n * @returns {mat2d} out\r\n */\r\nfunction set(out, a, b, c, d, tx, ty) {\r\n  out[0] = a;\r\n  out[1] = b;\r\n  out[2] = c;\r\n  out[3] = d;\r\n  out[4] = tx;\r\n  out[5] = ty;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Inverts a mat2d\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the source matrix\r\n * @returns {mat2d} out\r\n */\r\nfunction invert(out, a) {\r\n  var aa = a[0],\r\n      ab = a[1],\r\n      ac = a[2],\r\n      ad = a[3];\r\n  var atx = a[4],\r\n      aty = a[5];\r\n\r\n  var det = aa * ad - ab * ac;\r\n  if (!det) {\r\n    return null;\r\n  }\r\n  det = 1.0 / det;\r\n\r\n  out[0] = ad * det;\r\n  out[1] = -ab * det;\r\n  out[2] = -ac * det;\r\n  out[3] = aa * det;\r\n  out[4] = (ac * aty - ad * atx) * det;\r\n  out[5] = (ab * atx - aa * aty) * det;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the determinant of a mat2d\r\n *\r\n * @param {mat2d} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\r\nfunction determinant(a) {\r\n  return a[0] * a[3] - a[1] * a[2];\r\n}\r\n\r\n/**\r\n * Multiplies two mat2d's\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the first operand\r\n * @param {mat2d} b the second operand\r\n * @returns {mat2d} out\r\n */\r\nfunction multiply(out, a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3],\r\n      a4 = a[4],\r\n      a5 = a[5];\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3],\r\n      b4 = b[4],\r\n      b5 = b[5];\r\n  out[0] = a0 * b0 + a2 * b1;\r\n  out[1] = a1 * b0 + a3 * b1;\r\n  out[2] = a0 * b2 + a2 * b3;\r\n  out[3] = a1 * b2 + a3 * b3;\r\n  out[4] = a0 * b4 + a2 * b5 + a4;\r\n  out[5] = a1 * b4 + a3 * b5 + a5;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a mat2d by the given angle\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2d} out\r\n */\r\nfunction rotate(out, a, rad) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3],\r\n      a4 = a[4],\r\n      a5 = a[5];\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n  out[0] = a0 * c + a2 * s;\r\n  out[1] = a1 * c + a3 * s;\r\n  out[2] = a0 * -s + a2 * c;\r\n  out[3] = a1 * -s + a3 * c;\r\n  out[4] = a4;\r\n  out[5] = a5;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Scales the mat2d by the dimensions in the given vec2\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the matrix to translate\r\n * @param {vec2} v the vec2 to scale the matrix by\r\n * @returns {mat2d} out\r\n **/\r\nfunction scale(out, a, v) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3],\r\n      a4 = a[4],\r\n      a5 = a[5];\r\n  var v0 = v[0],\r\n      v1 = v[1];\r\n  out[0] = a0 * v0;\r\n  out[1] = a1 * v0;\r\n  out[2] = a2 * v1;\r\n  out[3] = a3 * v1;\r\n  out[4] = a4;\r\n  out[5] = a5;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Translates the mat2d by the dimensions in the given vec2\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the matrix to translate\r\n * @param {vec2} v the vec2 to translate the matrix by\r\n * @returns {mat2d} out\r\n **/\r\nfunction translate(out, a, v) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3],\r\n      a4 = a[4],\r\n      a5 = a[5];\r\n  var v0 = v[0],\r\n      v1 = v[1];\r\n  out[0] = a0;\r\n  out[1] = a1;\r\n  out[2] = a2;\r\n  out[3] = a3;\r\n  out[4] = a0 * v0 + a2 * v1 + a4;\r\n  out[5] = a1 * v0 + a3 * v1 + a5;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a given angle\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2d.identity(dest);\r\n *     mat2d.rotate(dest, dest, rad);\r\n *\r\n * @param {mat2d} out mat2d receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat2d} out\r\n */\r\nfunction fromRotation(out, rad) {\r\n  var s = Math.sin(rad),\r\n      c = Math.cos(rad);\r\n  out[0] = c;\r\n  out[1] = s;\r\n  out[2] = -s;\r\n  out[3] = c;\r\n  out[4] = 0;\r\n  out[5] = 0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2d.identity(dest);\r\n *     mat2d.scale(dest, dest, vec);\r\n *\r\n * @param {mat2d} out mat2d receiving operation result\r\n * @param {vec2} v Scaling vector\r\n * @returns {mat2d} out\r\n */\r\nfunction fromScaling(out, v) {\r\n  out[0] = v[0];\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = v[1];\r\n  out[4] = 0;\r\n  out[5] = 0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat2d.identity(dest);\r\n *     mat2d.translate(dest, dest, vec);\r\n *\r\n * @param {mat2d} out mat2d receiving operation result\r\n * @param {vec2} v Translation vector\r\n * @returns {mat2d} out\r\n */\r\nfunction fromTranslation(out, v) {\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 1;\r\n  out[4] = v[0];\r\n  out[5] = v[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns a string representation of a mat2d\r\n *\r\n * @param {mat2d} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\r\nfunction str(a) {\r\n  return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ')';\r\n}\r\n\r\n/**\r\n * Returns Frobenius norm of a mat2d\r\n *\r\n * @param {mat2d} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\r\nfunction frob(a) {\r\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1);\r\n}\r\n\r\n/**\r\n * Adds two mat2d's\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the first operand\r\n * @param {mat2d} b the second operand\r\n * @returns {mat2d} out\r\n */\r\nfunction add(out, a, b) {\r\n  out[0] = a[0] + b[0];\r\n  out[1] = a[1] + b[1];\r\n  out[2] = a[2] + b[2];\r\n  out[3] = a[3] + b[3];\r\n  out[4] = a[4] + b[4];\r\n  out[5] = a[5] + b[5];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the first operand\r\n * @param {mat2d} b the second operand\r\n * @returns {mat2d} out\r\n */\r\nfunction subtract(out, a, b) {\r\n  out[0] = a[0] - b[0];\r\n  out[1] = a[1] - b[1];\r\n  out[2] = a[2] - b[2];\r\n  out[3] = a[3] - b[3];\r\n  out[4] = a[4] - b[4];\r\n  out[5] = a[5] - b[5];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat2d} out the receiving matrix\r\n * @param {mat2d} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat2d} out\r\n */\r\nfunction multiplyScalar(out, a, b) {\r\n  out[0] = a[0] * b;\r\n  out[1] = a[1] * b;\r\n  out[2] = a[2] * b;\r\n  out[3] = a[3] * b;\r\n  out[4] = a[4] * b;\r\n  out[5] = a[5] * b;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two mat2d's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat2d} out the receiving vector\r\n * @param {mat2d} a the first operand\r\n * @param {mat2d} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat2d} out\r\n */\r\nfunction multiplyScalarAndAdd(out, a, b, scale) {\r\n  out[0] = a[0] + b[0] * scale;\r\n  out[1] = a[1] + b[1] * scale;\r\n  out[2] = a[2] + b[2] * scale;\r\n  out[3] = a[3] + b[3] * scale;\r\n  out[4] = a[4] + b[4] * scale;\r\n  out[5] = a[5] + b[5] * scale;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {mat2d} a The first matrix.\r\n * @param {mat2d} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\r\nfunction exactEquals(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5];\r\n}\r\n\r\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {mat2d} a The first matrix.\r\n * @param {mat2d} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\r\nfunction equals(a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3],\r\n      a4 = a[4],\r\n      a5 = a[5];\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3],\r\n      b4 = b[4],\r\n      b5 = b[5];\r\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a5), Math.abs(b5));\r\n}\r\n\r\n/**\r\n * Alias for {@link mat2d.multiply}\r\n * @function\r\n */\r\nvar mul = multiply;\r\n\r\n/**\r\n * Alias for {@link mat2d.subtract}\r\n * @function\r\n */\r\nvar sub = subtract;\n\n/***/ }),\n\n/***/ \"./node_modules/gl-matrix/lib/gl-matrix/mat3.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/gl-matrix/lib/gl-matrix/mat3.js ***!\n  \\******************************************************/\n/*! exports provided: create, fromMat4, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, rotate, scale, fromTranslation, fromRotation, fromScaling, fromMat2d, fromQuat, normalFromMat4, projection, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromMat4\", function() { return fromMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transpose\", function() { return transpose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"adjoint\", function() { return adjoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"determinant\", function() { return determinant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translate\", function() { return translate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromTranslation\", function() { return fromTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromScaling\", function() { return fromScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromMat2d\", function() { return fromMat2d; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromQuat\", function() { return fromQuat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalFromMat4\", function() { return normalFromMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"projection\", function() { return projection; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frob\", function() { return frob; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalar\", function() { return multiplyScalar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalarAndAdd\", function() { return multiplyScalarAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/lib/gl-matrix/common.js\");\n\r\n\r\n/**\r\n * 3x3 Matrix\r\n * @module mat3\r\n */\r\n\r\n/**\r\n * Creates a new identity mat3\r\n *\r\n * @returns {mat3} a new 3x3 matrix\r\n */\r\nfunction create() {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](9);\r\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\r\n    out[1] = 0;\r\n    out[2] = 0;\r\n    out[3] = 0;\r\n    out[5] = 0;\r\n    out[6] = 0;\r\n    out[7] = 0;\r\n  }\r\n  out[0] = 1;\r\n  out[4] = 1;\r\n  out[8] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copies the upper-left 3x3 values into the given mat3.\r\n *\r\n * @param {mat3} out the receiving 3x3 matrix\r\n * @param {mat4} a   the source 4x4 matrix\r\n * @returns {mat3} out\r\n */\r\nfunction fromMat4(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[4];\r\n  out[4] = a[5];\r\n  out[5] = a[6];\r\n  out[6] = a[8];\r\n  out[7] = a[9];\r\n  out[8] = a[10];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new mat3 initialized with values from an existing matrix\r\n *\r\n * @param {mat3} a matrix to clone\r\n * @returns {mat3} a new 3x3 matrix\r\n */\r\nfunction clone(a) {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](9);\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  out[4] = a[4];\r\n  out[5] = a[5];\r\n  out[6] = a[6];\r\n  out[7] = a[7];\r\n  out[8] = a[8];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copy the values from one mat3 to another\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the source matrix\r\n * @returns {mat3} out\r\n */\r\nfunction copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  out[4] = a[4];\r\n  out[5] = a[5];\r\n  out[6] = a[6];\r\n  out[7] = a[7];\r\n  out[8] = a[8];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Create a new mat3 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\r\n * @returns {mat3} A new mat3\r\n */\r\nfunction fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](9);\r\n  out[0] = m00;\r\n  out[1] = m01;\r\n  out[2] = m02;\r\n  out[3] = m10;\r\n  out[4] = m11;\r\n  out[5] = m12;\r\n  out[6] = m20;\r\n  out[7] = m21;\r\n  out[8] = m22;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set the components of a mat3 to the given values\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 3)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 4)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 5)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 6)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 7)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 8)\r\n * @returns {mat3} out\r\n */\r\nfunction set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\r\n  out[0] = m00;\r\n  out[1] = m01;\r\n  out[2] = m02;\r\n  out[3] = m10;\r\n  out[4] = m11;\r\n  out[5] = m12;\r\n  out[6] = m20;\r\n  out[7] = m21;\r\n  out[8] = m22;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set a mat3 to the identity matrix\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @returns {mat3} out\r\n */\r\nfunction identity(out) {\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 1;\r\n  out[5] = 0;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transpose the values of a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the source matrix\r\n * @returns {mat3} out\r\n */\r\nfunction transpose(out, a) {\r\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\r\n  if (out === a) {\r\n    var a01 = a[1],\r\n        a02 = a[2],\r\n        a12 = a[5];\r\n    out[1] = a[3];\r\n    out[2] = a[6];\r\n    out[3] = a01;\r\n    out[5] = a[7];\r\n    out[6] = a02;\r\n    out[7] = a12;\r\n  } else {\r\n    out[0] = a[0];\r\n    out[1] = a[3];\r\n    out[2] = a[6];\r\n    out[3] = a[1];\r\n    out[4] = a[4];\r\n    out[5] = a[7];\r\n    out[6] = a[2];\r\n    out[7] = a[5];\r\n    out[8] = a[8];\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Inverts a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the source matrix\r\n * @returns {mat3} out\r\n */\r\nfunction invert(out, a) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2];\r\n  var a10 = a[3],\r\n      a11 = a[4],\r\n      a12 = a[5];\r\n  var a20 = a[6],\r\n      a21 = a[7],\r\n      a22 = a[8];\r\n\r\n  var b01 = a22 * a11 - a12 * a21;\r\n  var b11 = -a22 * a10 + a12 * a20;\r\n  var b21 = a21 * a10 - a11 * a20;\r\n\r\n  // Calculate the determinant\r\n  var det = a00 * b01 + a01 * b11 + a02 * b21;\r\n\r\n  if (!det) {\r\n    return null;\r\n  }\r\n  det = 1.0 / det;\r\n\r\n  out[0] = b01 * det;\r\n  out[1] = (-a22 * a01 + a02 * a21) * det;\r\n  out[2] = (a12 * a01 - a02 * a11) * det;\r\n  out[3] = b11 * det;\r\n  out[4] = (a22 * a00 - a02 * a20) * det;\r\n  out[5] = (-a12 * a00 + a02 * a10) * det;\r\n  out[6] = b21 * det;\r\n  out[7] = (-a21 * a00 + a01 * a20) * det;\r\n  out[8] = (a11 * a00 - a01 * a10) * det;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the adjugate of a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the source matrix\r\n * @returns {mat3} out\r\n */\r\nfunction adjoint(out, a) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2];\r\n  var a10 = a[3],\r\n      a11 = a[4],\r\n      a12 = a[5];\r\n  var a20 = a[6],\r\n      a21 = a[7],\r\n      a22 = a[8];\r\n\r\n  out[0] = a11 * a22 - a12 * a21;\r\n  out[1] = a02 * a21 - a01 * a22;\r\n  out[2] = a01 * a12 - a02 * a11;\r\n  out[3] = a12 * a20 - a10 * a22;\r\n  out[4] = a00 * a22 - a02 * a20;\r\n  out[5] = a02 * a10 - a00 * a12;\r\n  out[6] = a10 * a21 - a11 * a20;\r\n  out[7] = a01 * a20 - a00 * a21;\r\n  out[8] = a00 * a11 - a01 * a10;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the determinant of a mat3\r\n *\r\n * @param {mat3} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\r\nfunction determinant(a) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2];\r\n  var a10 = a[3],\r\n      a11 = a[4],\r\n      a12 = a[5];\r\n  var a20 = a[6],\r\n      a21 = a[7],\r\n      a22 = a[8];\r\n\r\n  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\r\n}\r\n\r\n/**\r\n * Multiplies two mat3's\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the first operand\r\n * @param {mat3} b the second operand\r\n * @returns {mat3} out\r\n */\r\nfunction multiply(out, a, b) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2];\r\n  var a10 = a[3],\r\n      a11 = a[4],\r\n      a12 = a[5];\r\n  var a20 = a[6],\r\n      a21 = a[7],\r\n      a22 = a[8];\r\n\r\n  var b00 = b[0],\r\n      b01 = b[1],\r\n      b02 = b[2];\r\n  var b10 = b[3],\r\n      b11 = b[4],\r\n      b12 = b[5];\r\n  var b20 = b[6],\r\n      b21 = b[7],\r\n      b22 = b[8];\r\n\r\n  out[0] = b00 * a00 + b01 * a10 + b02 * a20;\r\n  out[1] = b00 * a01 + b01 * a11 + b02 * a21;\r\n  out[2] = b00 * a02 + b01 * a12 + b02 * a22;\r\n\r\n  out[3] = b10 * a00 + b11 * a10 + b12 * a20;\r\n  out[4] = b10 * a01 + b11 * a11 + b12 * a21;\r\n  out[5] = b10 * a02 + b11 * a12 + b12 * a22;\r\n\r\n  out[6] = b20 * a00 + b21 * a10 + b22 * a20;\r\n  out[7] = b20 * a01 + b21 * a11 + b22 * a21;\r\n  out[8] = b20 * a02 + b21 * a12 + b22 * a22;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Translate a mat3 by the given vector\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the matrix to translate\r\n * @param {vec2} v vector to translate by\r\n * @returns {mat3} out\r\n */\r\nfunction translate(out, a, v) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2],\r\n      a10 = a[3],\r\n      a11 = a[4],\r\n      a12 = a[5],\r\n      a20 = a[6],\r\n      a21 = a[7],\r\n      a22 = a[8],\r\n      x = v[0],\r\n      y = v[1];\r\n\r\n  out[0] = a00;\r\n  out[1] = a01;\r\n  out[2] = a02;\r\n\r\n  out[3] = a10;\r\n  out[4] = a11;\r\n  out[5] = a12;\r\n\r\n  out[6] = x * a00 + y * a10 + a20;\r\n  out[7] = x * a01 + y * a11 + a21;\r\n  out[8] = x * a02 + y * a12 + a22;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a mat3 by the given angle\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat3} out\r\n */\r\nfunction rotate(out, a, rad) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2],\r\n      a10 = a[3],\r\n      a11 = a[4],\r\n      a12 = a[5],\r\n      a20 = a[6],\r\n      a21 = a[7],\r\n      a22 = a[8],\r\n      s = Math.sin(rad),\r\n      c = Math.cos(rad);\r\n\r\n  out[0] = c * a00 + s * a10;\r\n  out[1] = c * a01 + s * a11;\r\n  out[2] = c * a02 + s * a12;\r\n\r\n  out[3] = c * a10 - s * a00;\r\n  out[4] = c * a11 - s * a01;\r\n  out[5] = c * a12 - s * a02;\r\n\r\n  out[6] = a20;\r\n  out[7] = a21;\r\n  out[8] = a22;\r\n  return out;\r\n};\r\n\r\n/**\r\n * Scales the mat3 by the dimensions in the given vec2\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the matrix to rotate\r\n * @param {vec2} v the vec2 to scale the matrix by\r\n * @returns {mat3} out\r\n **/\r\nfunction scale(out, a, v) {\r\n  var x = v[0],\r\n      y = v[1];\r\n\r\n  out[0] = x * a[0];\r\n  out[1] = x * a[1];\r\n  out[2] = x * a[2];\r\n\r\n  out[3] = y * a[3];\r\n  out[4] = y * a[4];\r\n  out[5] = y * a[5];\r\n\r\n  out[6] = a[6];\r\n  out[7] = a[7];\r\n  out[8] = a[8];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat3.identity(dest);\r\n *     mat3.translate(dest, dest, vec);\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {vec2} v Translation vector\r\n * @returns {mat3} out\r\n */\r\nfunction fromTranslation(out, v) {\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 1;\r\n  out[5] = 0;\r\n  out[6] = v[0];\r\n  out[7] = v[1];\r\n  out[8] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a given angle\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat3.identity(dest);\r\n *     mat3.rotate(dest, dest, rad);\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat3} out\r\n */\r\nfunction fromRotation(out, rad) {\r\n  var s = Math.sin(rad),\r\n      c = Math.cos(rad);\r\n\r\n  out[0] = c;\r\n  out[1] = s;\r\n  out[2] = 0;\r\n\r\n  out[3] = -s;\r\n  out[4] = c;\r\n  out[5] = 0;\r\n\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat3.identity(dest);\r\n *     mat3.scale(dest, dest, vec);\r\n *\r\n * @param {mat3} out mat3 receiving operation result\r\n * @param {vec2} v Scaling vector\r\n * @returns {mat3} out\r\n */\r\nfunction fromScaling(out, v) {\r\n  out[0] = v[0];\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n\r\n  out[3] = 0;\r\n  out[4] = v[1];\r\n  out[5] = 0;\r\n\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copies the values from a mat2d into a mat3\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat2d} a the matrix to copy\r\n * @returns {mat3} out\r\n **/\r\nfunction fromMat2d(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = 0;\r\n\r\n  out[3] = a[2];\r\n  out[4] = a[3];\r\n  out[5] = 0;\r\n\r\n  out[6] = a[4];\r\n  out[7] = a[5];\r\n  out[8] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n* Calculates a 3x3 matrix from the given quaternion\r\n*\r\n* @param {mat3} out mat3 receiving operation result\r\n* @param {quat} q Quaternion to create matrix from\r\n*\r\n* @returns {mat3} out\r\n*/\r\nfunction fromQuat(out, q) {\r\n  var x = q[0],\r\n      y = q[1],\r\n      z = q[2],\r\n      w = q[3];\r\n  var x2 = x + x;\r\n  var y2 = y + y;\r\n  var z2 = z + z;\r\n\r\n  var xx = x * x2;\r\n  var yx = y * x2;\r\n  var yy = y * y2;\r\n  var zx = z * x2;\r\n  var zy = z * y2;\r\n  var zz = z * z2;\r\n  var wx = w * x2;\r\n  var wy = w * y2;\r\n  var wz = w * z2;\r\n\r\n  out[0] = 1 - yy - zz;\r\n  out[3] = yx - wz;\r\n  out[6] = zx + wy;\r\n\r\n  out[1] = yx + wz;\r\n  out[4] = 1 - xx - zz;\r\n  out[7] = zy - wx;\r\n\r\n  out[2] = zx - wy;\r\n  out[5] = zy + wx;\r\n  out[8] = 1 - xx - yy;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\r\n*\r\n* @param {mat3} out mat3 receiving operation result\r\n* @param {mat4} a Mat4 to derive the normal matrix from\r\n*\r\n* @returns {mat3} out\r\n*/\r\nfunction normalFromMat4(out, a) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2],\r\n      a03 = a[3];\r\n  var a10 = a[4],\r\n      a11 = a[5],\r\n      a12 = a[6],\r\n      a13 = a[7];\r\n  var a20 = a[8],\r\n      a21 = a[9],\r\n      a22 = a[10],\r\n      a23 = a[11];\r\n  var a30 = a[12],\r\n      a31 = a[13],\r\n      a32 = a[14],\r\n      a33 = a[15];\r\n\r\n  var b00 = a00 * a11 - a01 * a10;\r\n  var b01 = a00 * a12 - a02 * a10;\r\n  var b02 = a00 * a13 - a03 * a10;\r\n  var b03 = a01 * a12 - a02 * a11;\r\n  var b04 = a01 * a13 - a03 * a11;\r\n  var b05 = a02 * a13 - a03 * a12;\r\n  var b06 = a20 * a31 - a21 * a30;\r\n  var b07 = a20 * a32 - a22 * a30;\r\n  var b08 = a20 * a33 - a23 * a30;\r\n  var b09 = a21 * a32 - a22 * a31;\r\n  var b10 = a21 * a33 - a23 * a31;\r\n  var b11 = a22 * a33 - a23 * a32;\r\n\r\n  // Calculate the determinant\r\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\r\n  if (!det) {\r\n    return null;\r\n  }\r\n  det = 1.0 / det;\r\n\r\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\r\n  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\r\n  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\r\n\r\n  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\r\n  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\r\n  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\r\n\r\n  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\r\n  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\r\n  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a 2D projection matrix with the given bounds\r\n *\r\n * @param {mat3} out mat3 frustum matrix will be written into\r\n * @param {number} width Width of your gl context\r\n * @param {number} height Height of gl context\r\n * @returns {mat3} out\r\n */\r\nfunction projection(out, width, height) {\r\n  out[0] = 2 / width;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = -2 / height;\r\n  out[5] = 0;\r\n  out[6] = -1;\r\n  out[7] = 1;\r\n  out[8] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns a string representation of a mat3\r\n *\r\n * @param {mat3} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\r\nfunction str(a) {\r\n  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';\r\n}\r\n\r\n/**\r\n * Returns Frobenius norm of a mat3\r\n *\r\n * @param {mat3} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\r\nfunction frob(a) {\r\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));\r\n}\r\n\r\n/**\r\n * Adds two mat3's\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the first operand\r\n * @param {mat3} b the second operand\r\n * @returns {mat3} out\r\n */\r\nfunction add(out, a, b) {\r\n  out[0] = a[0] + b[0];\r\n  out[1] = a[1] + b[1];\r\n  out[2] = a[2] + b[2];\r\n  out[3] = a[3] + b[3];\r\n  out[4] = a[4] + b[4];\r\n  out[5] = a[5] + b[5];\r\n  out[6] = a[6] + b[6];\r\n  out[7] = a[7] + b[7];\r\n  out[8] = a[8] + b[8];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the first operand\r\n * @param {mat3} b the second operand\r\n * @returns {mat3} out\r\n */\r\nfunction subtract(out, a, b) {\r\n  out[0] = a[0] - b[0];\r\n  out[1] = a[1] - b[1];\r\n  out[2] = a[2] - b[2];\r\n  out[3] = a[3] - b[3];\r\n  out[4] = a[4] - b[4];\r\n  out[5] = a[5] - b[5];\r\n  out[6] = a[6] - b[6];\r\n  out[7] = a[7] - b[7];\r\n  out[8] = a[8] - b[8];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat3} out the receiving matrix\r\n * @param {mat3} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat3} out\r\n */\r\nfunction multiplyScalar(out, a, b) {\r\n  out[0] = a[0] * b;\r\n  out[1] = a[1] * b;\r\n  out[2] = a[2] * b;\r\n  out[3] = a[3] * b;\r\n  out[4] = a[4] * b;\r\n  out[5] = a[5] * b;\r\n  out[6] = a[6] * b;\r\n  out[7] = a[7] * b;\r\n  out[8] = a[8] * b;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two mat3's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat3} out the receiving vector\r\n * @param {mat3} a the first operand\r\n * @param {mat3} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat3} out\r\n */\r\nfunction multiplyScalarAndAdd(out, a, b, scale) {\r\n  out[0] = a[0] + b[0] * scale;\r\n  out[1] = a[1] + b[1] * scale;\r\n  out[2] = a[2] + b[2] * scale;\r\n  out[3] = a[3] + b[3] * scale;\r\n  out[4] = a[4] + b[4] * scale;\r\n  out[5] = a[5] + b[5] * scale;\r\n  out[6] = a[6] + b[6] * scale;\r\n  out[7] = a[7] + b[7] * scale;\r\n  out[8] = a[8] + b[8] * scale;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {mat3} a The first matrix.\r\n * @param {mat3} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\r\nfunction exactEquals(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];\r\n}\r\n\r\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {mat3} a The first matrix.\r\n * @param {mat3} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\r\nfunction equals(a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3],\r\n      a4 = a[4],\r\n      a5 = a[5],\r\n      a6 = a[6],\r\n      a7 = a[7],\r\n      a8 = a[8];\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3],\r\n      b4 = b[4],\r\n      b5 = b[5],\r\n      b6 = b[6],\r\n      b7 = b[7],\r\n      b8 = b[8];\r\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a8), Math.abs(b8));\r\n}\r\n\r\n/**\r\n * Alias for {@link mat3.multiply}\r\n * @function\r\n */\r\nvar mul = multiply;\r\n\r\n/**\r\n * Alias for {@link mat3.subtract}\r\n * @function\r\n */\r\nvar sub = subtract;\n\n/***/ }),\n\n/***/ \"./node_modules/gl-matrix/lib/gl-matrix/mat4.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/gl-matrix/lib/gl-matrix/mat4.js ***!\n  \\******************************************************/\n/*! exports provided: create, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, scale, rotate, rotateX, rotateY, rotateZ, fromTranslation, fromScaling, fromRotation, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation, fromQuat2, getTranslation, getScaling, getRotation, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspective, perspectiveFromFieldOfView, ortho, lookAt, targetTo, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transpose\", function() { return transpose; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"adjoint\", function() { return adjoint; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"determinant\", function() { return determinant; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translate\", function() { return translate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateX\", function() { return rotateX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateY\", function() { return rotateY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateZ\", function() { return rotateZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromTranslation\", function() { return fromTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromScaling\", function() { return fromScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromXRotation\", function() { return fromXRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromYRotation\", function() { return fromYRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromZRotation\", function() { return fromZRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslation\", function() { return fromRotationTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromQuat2\", function() { return fromQuat2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTranslation\", function() { return getTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getScaling\", function() { return getScaling; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRotation\", function() { return getRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslationScale\", function() { return fromRotationTranslationScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslationScaleOrigin\", function() { return fromRotationTranslationScaleOrigin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromQuat\", function() { return fromQuat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frustum\", function() { return frustum; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"perspective\", function() { return perspective; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"perspectiveFromFieldOfView\", function() { return perspectiveFromFieldOfView; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ortho\", function() { return ortho; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lookAt\", function() { return lookAt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"targetTo\", function() { return targetTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"frob\", function() { return frob; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalar\", function() { return multiplyScalar; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiplyScalarAndAdd\", function() { return multiplyScalarAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/lib/gl-matrix/common.js\");\n\r\n\r\n/**\r\n * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.\r\n * @module mat4\r\n */\r\n\r\n/**\r\n * Creates a new identity mat4\r\n *\r\n * @returns {mat4} a new 4x4 matrix\r\n */\r\nfunction create() {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](16);\r\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\r\n    out[1] = 0;\r\n    out[2] = 0;\r\n    out[3] = 0;\r\n    out[4] = 0;\r\n    out[6] = 0;\r\n    out[7] = 0;\r\n    out[8] = 0;\r\n    out[9] = 0;\r\n    out[11] = 0;\r\n    out[12] = 0;\r\n    out[13] = 0;\r\n    out[14] = 0;\r\n  }\r\n  out[0] = 1;\r\n  out[5] = 1;\r\n  out[10] = 1;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new mat4 initialized with values from an existing matrix\r\n *\r\n * @param {mat4} a matrix to clone\r\n * @returns {mat4} a new 4x4 matrix\r\n */\r\nfunction clone(a) {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](16);\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  out[4] = a[4];\r\n  out[5] = a[5];\r\n  out[6] = a[6];\r\n  out[7] = a[7];\r\n  out[8] = a[8];\r\n  out[9] = a[9];\r\n  out[10] = a[10];\r\n  out[11] = a[11];\r\n  out[12] = a[12];\r\n  out[13] = a[13];\r\n  out[14] = a[14];\r\n  out[15] = a[15];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copy the values from one mat4 to another\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\r\nfunction copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  out[4] = a[4];\r\n  out[5] = a[5];\r\n  out[6] = a[6];\r\n  out[7] = a[7];\r\n  out[8] = a[8];\r\n  out[9] = a[9];\r\n  out[10] = a[10];\r\n  out[11] = a[11];\r\n  out[12] = a[12];\r\n  out[13] = a[13];\r\n  out[14] = a[14];\r\n  out[15] = a[15];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Create a new mat4 with the given values\r\n *\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\r\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\r\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\r\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\r\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\r\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\r\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\r\n * @returns {mat4} A new mat4\r\n */\r\nfunction fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](16);\r\n  out[0] = m00;\r\n  out[1] = m01;\r\n  out[2] = m02;\r\n  out[3] = m03;\r\n  out[4] = m10;\r\n  out[5] = m11;\r\n  out[6] = m12;\r\n  out[7] = m13;\r\n  out[8] = m20;\r\n  out[9] = m21;\r\n  out[10] = m22;\r\n  out[11] = m23;\r\n  out[12] = m30;\r\n  out[13] = m31;\r\n  out[14] = m32;\r\n  out[15] = m33;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set the components of a mat4 to the given values\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {Number} m00 Component in column 0, row 0 position (index 0)\r\n * @param {Number} m01 Component in column 0, row 1 position (index 1)\r\n * @param {Number} m02 Component in column 0, row 2 position (index 2)\r\n * @param {Number} m03 Component in column 0, row 3 position (index 3)\r\n * @param {Number} m10 Component in column 1, row 0 position (index 4)\r\n * @param {Number} m11 Component in column 1, row 1 position (index 5)\r\n * @param {Number} m12 Component in column 1, row 2 position (index 6)\r\n * @param {Number} m13 Component in column 1, row 3 position (index 7)\r\n * @param {Number} m20 Component in column 2, row 0 position (index 8)\r\n * @param {Number} m21 Component in column 2, row 1 position (index 9)\r\n * @param {Number} m22 Component in column 2, row 2 position (index 10)\r\n * @param {Number} m23 Component in column 2, row 3 position (index 11)\r\n * @param {Number} m30 Component in column 3, row 0 position (index 12)\r\n * @param {Number} m31 Component in column 3, row 1 position (index 13)\r\n * @param {Number} m32 Component in column 3, row 2 position (index 14)\r\n * @param {Number} m33 Component in column 3, row 3 position (index 15)\r\n * @returns {mat4} out\r\n */\r\nfunction set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\r\n  out[0] = m00;\r\n  out[1] = m01;\r\n  out[2] = m02;\r\n  out[3] = m03;\r\n  out[4] = m10;\r\n  out[5] = m11;\r\n  out[6] = m12;\r\n  out[7] = m13;\r\n  out[8] = m20;\r\n  out[9] = m21;\r\n  out[10] = m22;\r\n  out[11] = m23;\r\n  out[12] = m30;\r\n  out[13] = m31;\r\n  out[14] = m32;\r\n  out[15] = m33;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set a mat4 to the identity matrix\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @returns {mat4} out\r\n */\r\nfunction identity(out) {\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = 1;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[10] = 1;\r\n  out[11] = 0;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transpose the values of a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\r\nfunction transpose(out, a) {\r\n  // If we are transposing ourselves we can skip a few steps but have to cache some values\r\n  if (out === a) {\r\n    var a01 = a[1],\r\n        a02 = a[2],\r\n        a03 = a[3];\r\n    var a12 = a[6],\r\n        a13 = a[7];\r\n    var a23 = a[11];\r\n\r\n    out[1] = a[4];\r\n    out[2] = a[8];\r\n    out[3] = a[12];\r\n    out[4] = a01;\r\n    out[6] = a[9];\r\n    out[7] = a[13];\r\n    out[8] = a02;\r\n    out[9] = a12;\r\n    out[11] = a[14];\r\n    out[12] = a03;\r\n    out[13] = a13;\r\n    out[14] = a23;\r\n  } else {\r\n    out[0] = a[0];\r\n    out[1] = a[4];\r\n    out[2] = a[8];\r\n    out[3] = a[12];\r\n    out[4] = a[1];\r\n    out[5] = a[5];\r\n    out[6] = a[9];\r\n    out[7] = a[13];\r\n    out[8] = a[2];\r\n    out[9] = a[6];\r\n    out[10] = a[10];\r\n    out[11] = a[14];\r\n    out[12] = a[3];\r\n    out[13] = a[7];\r\n    out[14] = a[11];\r\n    out[15] = a[15];\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Inverts a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\r\nfunction invert(out, a) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2],\r\n      a03 = a[3];\r\n  var a10 = a[4],\r\n      a11 = a[5],\r\n      a12 = a[6],\r\n      a13 = a[7];\r\n  var a20 = a[8],\r\n      a21 = a[9],\r\n      a22 = a[10],\r\n      a23 = a[11];\r\n  var a30 = a[12],\r\n      a31 = a[13],\r\n      a32 = a[14],\r\n      a33 = a[15];\r\n\r\n  var b00 = a00 * a11 - a01 * a10;\r\n  var b01 = a00 * a12 - a02 * a10;\r\n  var b02 = a00 * a13 - a03 * a10;\r\n  var b03 = a01 * a12 - a02 * a11;\r\n  var b04 = a01 * a13 - a03 * a11;\r\n  var b05 = a02 * a13 - a03 * a12;\r\n  var b06 = a20 * a31 - a21 * a30;\r\n  var b07 = a20 * a32 - a22 * a30;\r\n  var b08 = a20 * a33 - a23 * a30;\r\n  var b09 = a21 * a32 - a22 * a31;\r\n  var b10 = a21 * a33 - a23 * a31;\r\n  var b11 = a22 * a33 - a23 * a32;\r\n\r\n  // Calculate the determinant\r\n  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n\r\n  if (!det) {\r\n    return null;\r\n  }\r\n  det = 1.0 / det;\r\n\r\n  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\r\n  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\r\n  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\r\n  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\r\n  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\r\n  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\r\n  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\r\n  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\r\n  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\r\n  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\r\n  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\r\n  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\r\n  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\r\n  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\r\n  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\r\n  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the adjugate of a mat4\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the source matrix\r\n * @returns {mat4} out\r\n */\r\nfunction adjoint(out, a) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2],\r\n      a03 = a[3];\r\n  var a10 = a[4],\r\n      a11 = a[5],\r\n      a12 = a[6],\r\n      a13 = a[7];\r\n  var a20 = a[8],\r\n      a21 = a[9],\r\n      a22 = a[10],\r\n      a23 = a[11];\r\n  var a30 = a[12],\r\n      a31 = a[13],\r\n      a32 = a[14],\r\n      a33 = a[15];\r\n\r\n  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);\r\n  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\r\n  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);\r\n  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\r\n  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\r\n  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);\r\n  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\r\n  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);\r\n  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);\r\n  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\r\n  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);\r\n  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\r\n  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\r\n  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);\r\n  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\r\n  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the determinant of a mat4\r\n *\r\n * @param {mat4} a the source matrix\r\n * @returns {Number} determinant of a\r\n */\r\nfunction determinant(a) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2],\r\n      a03 = a[3];\r\n  var a10 = a[4],\r\n      a11 = a[5],\r\n      a12 = a[6],\r\n      a13 = a[7];\r\n  var a20 = a[8],\r\n      a21 = a[9],\r\n      a22 = a[10],\r\n      a23 = a[11];\r\n  var a30 = a[12],\r\n      a31 = a[13],\r\n      a32 = a[14],\r\n      a33 = a[15];\r\n\r\n  var b00 = a00 * a11 - a01 * a10;\r\n  var b01 = a00 * a12 - a02 * a10;\r\n  var b02 = a00 * a13 - a03 * a10;\r\n  var b03 = a01 * a12 - a02 * a11;\r\n  var b04 = a01 * a13 - a03 * a11;\r\n  var b05 = a02 * a13 - a03 * a12;\r\n  var b06 = a20 * a31 - a21 * a30;\r\n  var b07 = a20 * a32 - a22 * a30;\r\n  var b08 = a20 * a33 - a23 * a30;\r\n  var b09 = a21 * a32 - a22 * a31;\r\n  var b10 = a21 * a33 - a23 * a31;\r\n  var b11 = a22 * a33 - a23 * a32;\r\n\r\n  // Calculate the determinant\r\n  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\r\n}\r\n\r\n/**\r\n * Multiplies two mat4s\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @returns {mat4} out\r\n */\r\nfunction multiply(out, a, b) {\r\n  var a00 = a[0],\r\n      a01 = a[1],\r\n      a02 = a[2],\r\n      a03 = a[3];\r\n  var a10 = a[4],\r\n      a11 = a[5],\r\n      a12 = a[6],\r\n      a13 = a[7];\r\n  var a20 = a[8],\r\n      a21 = a[9],\r\n      a22 = a[10],\r\n      a23 = a[11];\r\n  var a30 = a[12],\r\n      a31 = a[13],\r\n      a32 = a[14],\r\n      a33 = a[15];\r\n\r\n  // Cache only the current line of the second matrix\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3];\r\n  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n  b0 = b[4];b1 = b[5];b2 = b[6];b3 = b[7];\r\n  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n  b0 = b[8];b1 = b[9];b2 = b[10];b3 = b[11];\r\n  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n\r\n  b0 = b[12];b1 = b[13];b2 = b[14];b3 = b[15];\r\n  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\r\n  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\r\n  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\r\n  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Translate a mat4 by the given vector\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to translate\r\n * @param {vec3} v vector to translate by\r\n * @returns {mat4} out\r\n */\r\nfunction translate(out, a, v) {\r\n  var x = v[0],\r\n      y = v[1],\r\n      z = v[2];\r\n  var a00 = void 0,\r\n      a01 = void 0,\r\n      a02 = void 0,\r\n      a03 = void 0;\r\n  var a10 = void 0,\r\n      a11 = void 0,\r\n      a12 = void 0,\r\n      a13 = void 0;\r\n  var a20 = void 0,\r\n      a21 = void 0,\r\n      a22 = void 0,\r\n      a23 = void 0;\r\n\r\n  if (a === out) {\r\n    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\r\n    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\r\n    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\r\n    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\r\n  } else {\r\n    a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];\r\n    a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];\r\n    a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];\r\n\r\n    out[0] = a00;out[1] = a01;out[2] = a02;out[3] = a03;\r\n    out[4] = a10;out[5] = a11;out[6] = a12;out[7] = a13;\r\n    out[8] = a20;out[9] = a21;out[10] = a22;out[11] = a23;\r\n\r\n    out[12] = a00 * x + a10 * y + a20 * z + a[12];\r\n    out[13] = a01 * x + a11 * y + a21 * z + a[13];\r\n    out[14] = a02 * x + a12 * y + a22 * z + a[14];\r\n    out[15] = a03 * x + a13 * y + a23 * z + a[15];\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to scale\r\n * @param {vec3} v the vec3 to scale the matrix by\r\n * @returns {mat4} out\r\n **/\r\nfunction scale(out, a, v) {\r\n  var x = v[0],\r\n      y = v[1],\r\n      z = v[2];\r\n\r\n  out[0] = a[0] * x;\r\n  out[1] = a[1] * x;\r\n  out[2] = a[2] * x;\r\n  out[3] = a[3] * x;\r\n  out[4] = a[4] * y;\r\n  out[5] = a[5] * y;\r\n  out[6] = a[6] * y;\r\n  out[7] = a[7] * y;\r\n  out[8] = a[8] * z;\r\n  out[9] = a[9] * z;\r\n  out[10] = a[10] * z;\r\n  out[11] = a[11] * z;\r\n  out[12] = a[12];\r\n  out[13] = a[13];\r\n  out[14] = a[14];\r\n  out[15] = a[15];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a mat4 by the given angle around the given axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @param {vec3} axis the axis to rotate around\r\n * @returns {mat4} out\r\n */\r\nfunction rotate(out, a, rad, axis) {\r\n  var x = axis[0],\r\n      y = axis[1],\r\n      z = axis[2];\r\n  var len = Math.sqrt(x * x + y * y + z * z);\r\n  var s = void 0,\r\n      c = void 0,\r\n      t = void 0;\r\n  var a00 = void 0,\r\n      a01 = void 0,\r\n      a02 = void 0,\r\n      a03 = void 0;\r\n  var a10 = void 0,\r\n      a11 = void 0,\r\n      a12 = void 0,\r\n      a13 = void 0;\r\n  var a20 = void 0,\r\n      a21 = void 0,\r\n      a22 = void 0,\r\n      a23 = void 0;\r\n  var b00 = void 0,\r\n      b01 = void 0,\r\n      b02 = void 0;\r\n  var b10 = void 0,\r\n      b11 = void 0,\r\n      b12 = void 0;\r\n  var b20 = void 0,\r\n      b21 = void 0,\r\n      b22 = void 0;\r\n\r\n  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) {\r\n    return null;\r\n  }\r\n\r\n  len = 1 / len;\r\n  x *= len;\r\n  y *= len;\r\n  z *= len;\r\n\r\n  s = Math.sin(rad);\r\n  c = Math.cos(rad);\r\n  t = 1 - c;\r\n\r\n  a00 = a[0];a01 = a[1];a02 = a[2];a03 = a[3];\r\n  a10 = a[4];a11 = a[5];a12 = a[6];a13 = a[7];\r\n  a20 = a[8];a21 = a[9];a22 = a[10];a23 = a[11];\r\n\r\n  // Construct the elements of the rotation matrix\r\n  b00 = x * x * t + c;b01 = y * x * t + z * s;b02 = z * x * t - y * s;\r\n  b10 = x * y * t - z * s;b11 = y * y * t + c;b12 = z * y * t + x * s;\r\n  b20 = x * z * t + y * s;b21 = y * z * t - x * s;b22 = z * z * t + c;\r\n\r\n  // Perform rotation-specific matrix multiplication\r\n  out[0] = a00 * b00 + a10 * b01 + a20 * b02;\r\n  out[1] = a01 * b00 + a11 * b01 + a21 * b02;\r\n  out[2] = a02 * b00 + a12 * b01 + a22 * b02;\r\n  out[3] = a03 * b00 + a13 * b01 + a23 * b02;\r\n  out[4] = a00 * b10 + a10 * b11 + a20 * b12;\r\n  out[5] = a01 * b10 + a11 * b11 + a21 * b12;\r\n  out[6] = a02 * b10 + a12 * b11 + a22 * b12;\r\n  out[7] = a03 * b10 + a13 * b11 + a23 * b12;\r\n  out[8] = a00 * b20 + a10 * b21 + a20 * b22;\r\n  out[9] = a01 * b20 + a11 * b21 + a21 * b22;\r\n  out[10] = a02 * b20 + a12 * b21 + a22 * b22;\r\n  out[11] = a03 * b20 + a13 * b21 + a23 * b22;\r\n\r\n  if (a !== out) {\r\n    // If the source and destination differ, copy the unchanged last row\r\n    out[12] = a[12];\r\n    out[13] = a[13];\r\n    out[14] = a[14];\r\n    out[15] = a[15];\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a matrix by the given angle around the X axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\r\nfunction rotateX(out, a, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n  var a10 = a[4];\r\n  var a11 = a[5];\r\n  var a12 = a[6];\r\n  var a13 = a[7];\r\n  var a20 = a[8];\r\n  var a21 = a[9];\r\n  var a22 = a[10];\r\n  var a23 = a[11];\r\n\r\n  if (a !== out) {\r\n    // If the source and destination differ, copy the unchanged rows\r\n    out[0] = a[0];\r\n    out[1] = a[1];\r\n    out[2] = a[2];\r\n    out[3] = a[3];\r\n    out[12] = a[12];\r\n    out[13] = a[13];\r\n    out[14] = a[14];\r\n    out[15] = a[15];\r\n  }\r\n\r\n  // Perform axis-specific matrix multiplication\r\n  out[4] = a10 * c + a20 * s;\r\n  out[5] = a11 * c + a21 * s;\r\n  out[6] = a12 * c + a22 * s;\r\n  out[7] = a13 * c + a23 * s;\r\n  out[8] = a20 * c - a10 * s;\r\n  out[9] = a21 * c - a11 * s;\r\n  out[10] = a22 * c - a12 * s;\r\n  out[11] = a23 * c - a13 * s;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a matrix by the given angle around the Y axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\r\nfunction rotateY(out, a, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n  var a00 = a[0];\r\n  var a01 = a[1];\r\n  var a02 = a[2];\r\n  var a03 = a[3];\r\n  var a20 = a[8];\r\n  var a21 = a[9];\r\n  var a22 = a[10];\r\n  var a23 = a[11];\r\n\r\n  if (a !== out) {\r\n    // If the source and destination differ, copy the unchanged rows\r\n    out[4] = a[4];\r\n    out[5] = a[5];\r\n    out[6] = a[6];\r\n    out[7] = a[7];\r\n    out[12] = a[12];\r\n    out[13] = a[13];\r\n    out[14] = a[14];\r\n    out[15] = a[15];\r\n  }\r\n\r\n  // Perform axis-specific matrix multiplication\r\n  out[0] = a00 * c - a20 * s;\r\n  out[1] = a01 * c - a21 * s;\r\n  out[2] = a02 * c - a22 * s;\r\n  out[3] = a03 * c - a23 * s;\r\n  out[8] = a00 * s + a20 * c;\r\n  out[9] = a01 * s + a21 * c;\r\n  out[10] = a02 * s + a22 * c;\r\n  out[11] = a03 * s + a23 * c;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a matrix by the given angle around the Z axis\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to rotate\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\r\nfunction rotateZ(out, a, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n  var a00 = a[0];\r\n  var a01 = a[1];\r\n  var a02 = a[2];\r\n  var a03 = a[3];\r\n  var a10 = a[4];\r\n  var a11 = a[5];\r\n  var a12 = a[6];\r\n  var a13 = a[7];\r\n\r\n  if (a !== out) {\r\n    // If the source and destination differ, copy the unchanged last row\r\n    out[8] = a[8];\r\n    out[9] = a[9];\r\n    out[10] = a[10];\r\n    out[11] = a[11];\r\n    out[12] = a[12];\r\n    out[13] = a[13];\r\n    out[14] = a[14];\r\n    out[15] = a[15];\r\n  }\r\n\r\n  // Perform axis-specific matrix multiplication\r\n  out[0] = a00 * c + a10 * s;\r\n  out[1] = a01 * c + a11 * s;\r\n  out[2] = a02 * c + a12 * s;\r\n  out[3] = a03 * c + a13 * s;\r\n  out[4] = a10 * c - a00 * s;\r\n  out[5] = a11 * c - a01 * s;\r\n  out[6] = a12 * c - a02 * s;\r\n  out[7] = a13 * c - a03 * s;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, dest, vec);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {vec3} v Translation vector\r\n * @returns {mat4} out\r\n */\r\nfunction fromTranslation(out, v) {\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = 1;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[10] = 1;\r\n  out[11] = 0;\r\n  out[12] = v[0];\r\n  out[13] = v[1];\r\n  out[14] = v[2];\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a vector scaling\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.scale(dest, dest, vec);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {vec3} v Scaling vector\r\n * @returns {mat4} out\r\n */\r\nfunction fromScaling(out, v) {\r\n  out[0] = v[0];\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = v[1];\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[10] = v[2];\r\n  out[11] = 0;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a given angle around a given axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotate(dest, dest, rad, axis);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @param {vec3} axis the axis to rotate around\r\n * @returns {mat4} out\r\n */\r\nfunction fromRotation(out, rad, axis) {\r\n  var x = axis[0],\r\n      y = axis[1],\r\n      z = axis[2];\r\n  var len = Math.sqrt(x * x + y * y + z * z);\r\n  var s = void 0,\r\n      c = void 0,\r\n      t = void 0;\r\n\r\n  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) {\r\n    return null;\r\n  }\r\n\r\n  len = 1 / len;\r\n  x *= len;\r\n  y *= len;\r\n  z *= len;\r\n\r\n  s = Math.sin(rad);\r\n  c = Math.cos(rad);\r\n  t = 1 - c;\r\n\r\n  // Perform rotation-specific matrix multiplication\r\n  out[0] = x * x * t + c;\r\n  out[1] = y * x * t + z * s;\r\n  out[2] = z * x * t - y * s;\r\n  out[3] = 0;\r\n  out[4] = x * y * t - z * s;\r\n  out[5] = y * y * t + c;\r\n  out[6] = z * y * t + x * s;\r\n  out[7] = 0;\r\n  out[8] = x * z * t + y * s;\r\n  out[9] = y * z * t - x * s;\r\n  out[10] = z * z * t + c;\r\n  out[11] = 0;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from the given angle around the X axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateX(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\r\nfunction fromXRotation(out, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n\r\n  // Perform axis-specific matrix multiplication\r\n  out[0] = 1;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = c;\r\n  out[6] = s;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = -s;\r\n  out[10] = c;\r\n  out[11] = 0;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from the given angle around the Y axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateY(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\r\nfunction fromYRotation(out, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n\r\n  // Perform axis-specific matrix multiplication\r\n  out[0] = c;\r\n  out[1] = 0;\r\n  out[2] = -s;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = 1;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = s;\r\n  out[9] = 0;\r\n  out[10] = c;\r\n  out[11] = 0;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from the given angle around the Z axis\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.rotateZ(dest, dest, rad);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {Number} rad the angle to rotate the matrix by\r\n * @returns {mat4} out\r\n */\r\nfunction fromZRotation(out, rad) {\r\n  var s = Math.sin(rad);\r\n  var c = Math.cos(rad);\r\n\r\n  // Perform axis-specific matrix multiplication\r\n  out[0] = c;\r\n  out[1] = s;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = -s;\r\n  out[5] = c;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[10] = 1;\r\n  out[11] = 0;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a quaternion rotation and vector translation\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {vec3} v Translation vector\r\n * @returns {mat4} out\r\n */\r\nfunction fromRotationTranslation(out, q, v) {\r\n  // Quaternion math\r\n  var x = q[0],\r\n      y = q[1],\r\n      z = q[2],\r\n      w = q[3];\r\n  var x2 = x + x;\r\n  var y2 = y + y;\r\n  var z2 = z + z;\r\n\r\n  var xx = x * x2;\r\n  var xy = x * y2;\r\n  var xz = x * z2;\r\n  var yy = y * y2;\r\n  var yz = y * z2;\r\n  var zz = z * z2;\r\n  var wx = w * x2;\r\n  var wy = w * y2;\r\n  var wz = w * z2;\r\n\r\n  out[0] = 1 - (yy + zz);\r\n  out[1] = xy + wz;\r\n  out[2] = xz - wy;\r\n  out[3] = 0;\r\n  out[4] = xy - wz;\r\n  out[5] = 1 - (xx + zz);\r\n  out[6] = yz + wx;\r\n  out[7] = 0;\r\n  out[8] = xz + wy;\r\n  out[9] = yz - wx;\r\n  out[10] = 1 - (xx + yy);\r\n  out[11] = 0;\r\n  out[12] = v[0];\r\n  out[13] = v[1];\r\n  out[14] = v[2];\r\n  out[15] = 1;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new mat4 from a dual quat.\r\n *\r\n * @param {mat4} out Matrix\r\n * @param {quat2} a Dual Quaternion\r\n * @returns {mat4} mat4 receiving operation result\r\n */\r\nfunction fromQuat2(out, a) {\r\n  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\r\n  var bx = -a[0],\r\n      by = -a[1],\r\n      bz = -a[2],\r\n      bw = a[3],\r\n      ax = a[4],\r\n      ay = a[5],\r\n      az = a[6],\r\n      aw = a[7];\r\n\r\n  var magnitude = bx * bx + by * by + bz * bz + bw * bw;\r\n  //Only scale if it makes sense\r\n  if (magnitude > 0) {\r\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;\r\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;\r\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;\r\n  } else {\r\n    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\r\n    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\r\n    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\r\n  }\r\n  fromRotationTranslation(out, a, translation);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the translation vector component of a transformation\r\n *  matrix. If a matrix is built with fromRotationTranslation,\r\n *  the returned vector will be the same as the translation vector\r\n *  originally supplied.\r\n * @param  {vec3} out Vector to receive translation component\r\n * @param  {mat4} mat Matrix to be decomposed (input)\r\n * @return {vec3} out\r\n */\r\nfunction getTranslation(out, mat) {\r\n  out[0] = mat[12];\r\n  out[1] = mat[13];\r\n  out[2] = mat[14];\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the scaling factor component of a transformation\r\n *  matrix. If a matrix is built with fromRotationTranslationScale\r\n *  with a normalized Quaternion paramter, the returned vector will be\r\n *  the same as the scaling vector\r\n *  originally supplied.\r\n * @param  {vec3} out Vector to receive scaling factor component\r\n * @param  {mat4} mat Matrix to be decomposed (input)\r\n * @return {vec3} out\r\n */\r\nfunction getScaling(out, mat) {\r\n  var m11 = mat[0];\r\n  var m12 = mat[1];\r\n  var m13 = mat[2];\r\n  var m21 = mat[4];\r\n  var m22 = mat[5];\r\n  var m23 = mat[6];\r\n  var m31 = mat[8];\r\n  var m32 = mat[9];\r\n  var m33 = mat[10];\r\n\r\n  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);\r\n  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);\r\n  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns a quaternion representing the rotational component\r\n *  of a transformation matrix. If a matrix is built with\r\n *  fromRotationTranslation, the returned quaternion will be the\r\n *  same as the quaternion originally supplied.\r\n * @param {quat} out Quaternion to receive the rotation component\r\n * @param {mat4} mat Matrix to be decomposed (input)\r\n * @return {quat} out\r\n */\r\nfunction getRotation(out, mat) {\r\n  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n  var trace = mat[0] + mat[5] + mat[10];\r\n  var S = 0;\r\n\r\n  if (trace > 0) {\r\n    S = Math.sqrt(trace + 1.0) * 2;\r\n    out[3] = 0.25 * S;\r\n    out[0] = (mat[6] - mat[9]) / S;\r\n    out[1] = (mat[8] - mat[2]) / S;\r\n    out[2] = (mat[1] - mat[4]) / S;\r\n  } else if (mat[0] > mat[5] && mat[0] > mat[10]) {\r\n    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;\r\n    out[3] = (mat[6] - mat[9]) / S;\r\n    out[0] = 0.25 * S;\r\n    out[1] = (mat[1] + mat[4]) / S;\r\n    out[2] = (mat[8] + mat[2]) / S;\r\n  } else if (mat[5] > mat[10]) {\r\n    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;\r\n    out[3] = (mat[8] - mat[2]) / S;\r\n    out[0] = (mat[1] + mat[4]) / S;\r\n    out[1] = 0.25 * S;\r\n    out[2] = (mat[6] + mat[9]) / S;\r\n  } else {\r\n    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;\r\n    out[3] = (mat[1] - mat[4]) / S;\r\n    out[0] = (mat[8] + mat[2]) / S;\r\n    out[1] = (mat[6] + mat[9]) / S;\r\n    out[2] = 0.25 * S;\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *     mat4.scale(dest, scale)\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {vec3} v Translation vector\r\n * @param {vec3} s Scaling vector\r\n * @returns {mat4} out\r\n */\r\nfunction fromRotationTranslationScale(out, q, v, s) {\r\n  // Quaternion math\r\n  var x = q[0],\r\n      y = q[1],\r\n      z = q[2],\r\n      w = q[3];\r\n  var x2 = x + x;\r\n  var y2 = y + y;\r\n  var z2 = z + z;\r\n\r\n  var xx = x * x2;\r\n  var xy = x * y2;\r\n  var xz = x * z2;\r\n  var yy = y * y2;\r\n  var yz = y * z2;\r\n  var zz = z * z2;\r\n  var wx = w * x2;\r\n  var wy = w * y2;\r\n  var wz = w * z2;\r\n  var sx = s[0];\r\n  var sy = s[1];\r\n  var sz = s[2];\r\n\r\n  out[0] = (1 - (yy + zz)) * sx;\r\n  out[1] = (xy + wz) * sx;\r\n  out[2] = (xz - wy) * sx;\r\n  out[3] = 0;\r\n  out[4] = (xy - wz) * sy;\r\n  out[5] = (1 - (xx + zz)) * sy;\r\n  out[6] = (yz + wx) * sy;\r\n  out[7] = 0;\r\n  out[8] = (xz + wy) * sz;\r\n  out[9] = (yz - wx) * sz;\r\n  out[10] = (1 - (xx + yy)) * sz;\r\n  out[11] = 0;\r\n  out[12] = v[0];\r\n  out[13] = v[1];\r\n  out[14] = v[2];\r\n  out[15] = 1;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin\r\n * This is equivalent to (but much faster than):\r\n *\r\n *     mat4.identity(dest);\r\n *     mat4.translate(dest, vec);\r\n *     mat4.translate(dest, origin);\r\n *     let quatMat = mat4.create();\r\n *     quat4.toMat4(quat, quatMat);\r\n *     mat4.multiply(dest, quatMat);\r\n *     mat4.scale(dest, scale)\r\n *     mat4.translate(dest, negativeOrigin);\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat4} q Rotation quaternion\r\n * @param {vec3} v Translation vector\r\n * @param {vec3} s Scaling vector\r\n * @param {vec3} o The origin vector around which to scale and rotate\r\n * @returns {mat4} out\r\n */\r\nfunction fromRotationTranslationScaleOrigin(out, q, v, s, o) {\r\n  // Quaternion math\r\n  var x = q[0],\r\n      y = q[1],\r\n      z = q[2],\r\n      w = q[3];\r\n  var x2 = x + x;\r\n  var y2 = y + y;\r\n  var z2 = z + z;\r\n\r\n  var xx = x * x2;\r\n  var xy = x * y2;\r\n  var xz = x * z2;\r\n  var yy = y * y2;\r\n  var yz = y * z2;\r\n  var zz = z * z2;\r\n  var wx = w * x2;\r\n  var wy = w * y2;\r\n  var wz = w * z2;\r\n\r\n  var sx = s[0];\r\n  var sy = s[1];\r\n  var sz = s[2];\r\n\r\n  var ox = o[0];\r\n  var oy = o[1];\r\n  var oz = o[2];\r\n\r\n  var out0 = (1 - (yy + zz)) * sx;\r\n  var out1 = (xy + wz) * sx;\r\n  var out2 = (xz - wy) * sx;\r\n  var out4 = (xy - wz) * sy;\r\n  var out5 = (1 - (xx + zz)) * sy;\r\n  var out6 = (yz + wx) * sy;\r\n  var out8 = (xz + wy) * sz;\r\n  var out9 = (yz - wx) * sz;\r\n  var out10 = (1 - (xx + yy)) * sz;\r\n\r\n  out[0] = out0;\r\n  out[1] = out1;\r\n  out[2] = out2;\r\n  out[3] = 0;\r\n  out[4] = out4;\r\n  out[5] = out5;\r\n  out[6] = out6;\r\n  out[7] = 0;\r\n  out[8] = out8;\r\n  out[9] = out9;\r\n  out[10] = out10;\r\n  out[11] = 0;\r\n  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);\r\n  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);\r\n  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);\r\n  out[15] = 1;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates a 4x4 matrix from the given quaternion\r\n *\r\n * @param {mat4} out mat4 receiving operation result\r\n * @param {quat} q Quaternion to create matrix from\r\n *\r\n * @returns {mat4} out\r\n */\r\nfunction fromQuat(out, q) {\r\n  var x = q[0],\r\n      y = q[1],\r\n      z = q[2],\r\n      w = q[3];\r\n  var x2 = x + x;\r\n  var y2 = y + y;\r\n  var z2 = z + z;\r\n\r\n  var xx = x * x2;\r\n  var yx = y * x2;\r\n  var yy = y * y2;\r\n  var zx = z * x2;\r\n  var zy = z * y2;\r\n  var zz = z * z2;\r\n  var wx = w * x2;\r\n  var wy = w * y2;\r\n  var wz = w * z2;\r\n\r\n  out[0] = 1 - yy - zz;\r\n  out[1] = yx + wz;\r\n  out[2] = zx - wy;\r\n  out[3] = 0;\r\n\r\n  out[4] = yx - wz;\r\n  out[5] = 1 - xx - zz;\r\n  out[6] = zy + wx;\r\n  out[7] = 0;\r\n\r\n  out[8] = zx + wy;\r\n  out[9] = zy - wx;\r\n  out[10] = 1 - xx - yy;\r\n  out[11] = 0;\r\n\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = 0;\r\n  out[15] = 1;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a frustum matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {Number} left Left bound of the frustum\r\n * @param {Number} right Right bound of the frustum\r\n * @param {Number} bottom Bottom bound of the frustum\r\n * @param {Number} top Top bound of the frustum\r\n * @param {Number} near Near bound of the frustum\r\n * @param {Number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\r\nfunction frustum(out, left, right, bottom, top, near, far) {\r\n  var rl = 1 / (right - left);\r\n  var tb = 1 / (top - bottom);\r\n  var nf = 1 / (near - far);\r\n  out[0] = near * 2 * rl;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = near * 2 * tb;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = (right + left) * rl;\r\n  out[9] = (top + bottom) * tb;\r\n  out[10] = (far + near) * nf;\r\n  out[11] = -1;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[14] = far * near * 2 * nf;\r\n  out[15] = 0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a perspective projection matrix with the given bounds.\r\n * Passing null/undefined/no value for far will generate infinite projection matrix.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} fovy Vertical field of view in radians\r\n * @param {number} aspect Aspect ratio. typically viewport width/height\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum, can be null or Infinity\r\n * @returns {mat4} out\r\n */\r\nfunction perspective(out, fovy, aspect, near, far) {\r\n  var f = 1.0 / Math.tan(fovy / 2),\r\n      nf = void 0;\r\n  out[0] = f / aspect;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = f;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[11] = -1;\r\n  out[12] = 0;\r\n  out[13] = 0;\r\n  out[15] = 0;\r\n  if (far != null && far !== Infinity) {\r\n    nf = 1 / (near - far);\r\n    out[10] = (far + near) * nf;\r\n    out[14] = 2 * far * near * nf;\r\n  } else {\r\n    out[10] = -1;\r\n    out[14] = -2 * near;\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a perspective projection matrix with the given field of view.\r\n * This is primarily useful for generating projection matrices to be used\r\n * with the still experiemental WebVR API.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\r\nfunction perspectiveFromFieldOfView(out, fov, near, far) {\r\n  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);\r\n  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);\r\n  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);\r\n  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);\r\n  var xScale = 2.0 / (leftTan + rightTan);\r\n  var yScale = 2.0 / (upTan + downTan);\r\n\r\n  out[0] = xScale;\r\n  out[1] = 0.0;\r\n  out[2] = 0.0;\r\n  out[3] = 0.0;\r\n  out[4] = 0.0;\r\n  out[5] = yScale;\r\n  out[6] = 0.0;\r\n  out[7] = 0.0;\r\n  out[8] = -((leftTan - rightTan) * xScale * 0.5);\r\n  out[9] = (upTan - downTan) * yScale * 0.5;\r\n  out[10] = far / (near - far);\r\n  out[11] = -1.0;\r\n  out[12] = 0.0;\r\n  out[13] = 0.0;\r\n  out[14] = far * near / (near - far);\r\n  out[15] = 0.0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a orthogonal projection matrix with the given bounds\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {number} left Left bound of the frustum\r\n * @param {number} right Right bound of the frustum\r\n * @param {number} bottom Bottom bound of the frustum\r\n * @param {number} top Top bound of the frustum\r\n * @param {number} near Near bound of the frustum\r\n * @param {number} far Far bound of the frustum\r\n * @returns {mat4} out\r\n */\r\nfunction ortho(out, left, right, bottom, top, near, far) {\r\n  var lr = 1 / (left - right);\r\n  var bt = 1 / (bottom - top);\r\n  var nf = 1 / (near - far);\r\n  out[0] = -2 * lr;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 0;\r\n  out[4] = 0;\r\n  out[5] = -2 * bt;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  out[8] = 0;\r\n  out[9] = 0;\r\n  out[10] = 2 * nf;\r\n  out[11] = 0;\r\n  out[12] = (left + right) * lr;\r\n  out[13] = (top + bottom) * bt;\r\n  out[14] = (far + near) * nf;\r\n  out[15] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a look-at matrix with the given eye position, focal point, and up axis.\r\n * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {vec3} eye Position of the viewer\r\n * @param {vec3} center Point the viewer is looking at\r\n * @param {vec3} up vec3 pointing up\r\n * @returns {mat4} out\r\n */\r\nfunction lookAt(out, eye, center, up) {\r\n  var x0 = void 0,\r\n      x1 = void 0,\r\n      x2 = void 0,\r\n      y0 = void 0,\r\n      y1 = void 0,\r\n      y2 = void 0,\r\n      z0 = void 0,\r\n      z1 = void 0,\r\n      z2 = void 0,\r\n      len = void 0;\r\n  var eyex = eye[0];\r\n  var eyey = eye[1];\r\n  var eyez = eye[2];\r\n  var upx = up[0];\r\n  var upy = up[1];\r\n  var upz = up[2];\r\n  var centerx = center[0];\r\n  var centery = center[1];\r\n  var centerz = center[2];\r\n\r\n  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) {\r\n    return identity(out);\r\n  }\r\n\r\n  z0 = eyex - centerx;\r\n  z1 = eyey - centery;\r\n  z2 = eyez - centerz;\r\n\r\n  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\r\n  z0 *= len;\r\n  z1 *= len;\r\n  z2 *= len;\r\n\r\n  x0 = upy * z2 - upz * z1;\r\n  x1 = upz * z0 - upx * z2;\r\n  x2 = upx * z1 - upy * z0;\r\n  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\r\n  if (!len) {\r\n    x0 = 0;\r\n    x1 = 0;\r\n    x2 = 0;\r\n  } else {\r\n    len = 1 / len;\r\n    x0 *= len;\r\n    x1 *= len;\r\n    x2 *= len;\r\n  }\r\n\r\n  y0 = z1 * x2 - z2 * x1;\r\n  y1 = z2 * x0 - z0 * x2;\r\n  y2 = z0 * x1 - z1 * x0;\r\n\r\n  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\r\n  if (!len) {\r\n    y0 = 0;\r\n    y1 = 0;\r\n    y2 = 0;\r\n  } else {\r\n    len = 1 / len;\r\n    y0 *= len;\r\n    y1 *= len;\r\n    y2 *= len;\r\n  }\r\n\r\n  out[0] = x0;\r\n  out[1] = y0;\r\n  out[2] = z0;\r\n  out[3] = 0;\r\n  out[4] = x1;\r\n  out[5] = y1;\r\n  out[6] = z1;\r\n  out[7] = 0;\r\n  out[8] = x2;\r\n  out[9] = y2;\r\n  out[10] = z2;\r\n  out[11] = 0;\r\n  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\r\n  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\r\n  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\r\n  out[15] = 1;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a matrix that makes something look at something else.\r\n *\r\n * @param {mat4} out mat4 frustum matrix will be written into\r\n * @param {vec3} eye Position of the viewer\r\n * @param {vec3} center Point the viewer is looking at\r\n * @param {vec3} up vec3 pointing up\r\n * @returns {mat4} out\r\n */\r\nfunction targetTo(out, eye, target, up) {\r\n  var eyex = eye[0],\r\n      eyey = eye[1],\r\n      eyez = eye[2],\r\n      upx = up[0],\r\n      upy = up[1],\r\n      upz = up[2];\r\n\r\n  var z0 = eyex - target[0],\r\n      z1 = eyey - target[1],\r\n      z2 = eyez - target[2];\r\n\r\n  var len = z0 * z0 + z1 * z1 + z2 * z2;\r\n  if (len > 0) {\r\n    len = 1 / Math.sqrt(len);\r\n    z0 *= len;\r\n    z1 *= len;\r\n    z2 *= len;\r\n  }\r\n\r\n  var x0 = upy * z2 - upz * z1,\r\n      x1 = upz * z0 - upx * z2,\r\n      x2 = upx * z1 - upy * z0;\r\n\r\n  len = x0 * x0 + x1 * x1 + x2 * x2;\r\n  if (len > 0) {\r\n    len = 1 / Math.sqrt(len);\r\n    x0 *= len;\r\n    x1 *= len;\r\n    x2 *= len;\r\n  }\r\n\r\n  out[0] = x0;\r\n  out[1] = x1;\r\n  out[2] = x2;\r\n  out[3] = 0;\r\n  out[4] = z1 * x2 - z2 * x1;\r\n  out[5] = z2 * x0 - z0 * x2;\r\n  out[6] = z0 * x1 - z1 * x0;\r\n  out[7] = 0;\r\n  out[8] = z0;\r\n  out[9] = z1;\r\n  out[10] = z2;\r\n  out[11] = 0;\r\n  out[12] = eyex;\r\n  out[13] = eyey;\r\n  out[14] = eyez;\r\n  out[15] = 1;\r\n  return out;\r\n};\r\n\r\n/**\r\n * Returns a string representation of a mat4\r\n *\r\n * @param {mat4} a matrix to represent as a string\r\n * @returns {String} string representation of the matrix\r\n */\r\nfunction str(a) {\r\n  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';\r\n}\r\n\r\n/**\r\n * Returns Frobenius norm of a mat4\r\n *\r\n * @param {mat4} a the matrix to calculate Frobenius norm of\r\n * @returns {Number} Frobenius norm\r\n */\r\nfunction frob(a) {\r\n  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));\r\n}\r\n\r\n/**\r\n * Adds two mat4's\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @returns {mat4} out\r\n */\r\nfunction add(out, a, b) {\r\n  out[0] = a[0] + b[0];\r\n  out[1] = a[1] + b[1];\r\n  out[2] = a[2] + b[2];\r\n  out[3] = a[3] + b[3];\r\n  out[4] = a[4] + b[4];\r\n  out[5] = a[5] + b[5];\r\n  out[6] = a[6] + b[6];\r\n  out[7] = a[7] + b[7];\r\n  out[8] = a[8] + b[8];\r\n  out[9] = a[9] + b[9];\r\n  out[10] = a[10] + b[10];\r\n  out[11] = a[11] + b[11];\r\n  out[12] = a[12] + b[12];\r\n  out[13] = a[13] + b[13];\r\n  out[14] = a[14] + b[14];\r\n  out[15] = a[15] + b[15];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Subtracts matrix b from matrix a\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @returns {mat4} out\r\n */\r\nfunction subtract(out, a, b) {\r\n  out[0] = a[0] - b[0];\r\n  out[1] = a[1] - b[1];\r\n  out[2] = a[2] - b[2];\r\n  out[3] = a[3] - b[3];\r\n  out[4] = a[4] - b[4];\r\n  out[5] = a[5] - b[5];\r\n  out[6] = a[6] - b[6];\r\n  out[7] = a[7] - b[7];\r\n  out[8] = a[8] - b[8];\r\n  out[9] = a[9] - b[9];\r\n  out[10] = a[10] - b[10];\r\n  out[11] = a[11] - b[11];\r\n  out[12] = a[12] - b[12];\r\n  out[13] = a[13] - b[13];\r\n  out[14] = a[14] - b[14];\r\n  out[15] = a[15] - b[15];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Multiply each element of the matrix by a scalar.\r\n *\r\n * @param {mat4} out the receiving matrix\r\n * @param {mat4} a the matrix to scale\r\n * @param {Number} b amount to scale the matrix's elements by\r\n * @returns {mat4} out\r\n */\r\nfunction multiplyScalar(out, a, b) {\r\n  out[0] = a[0] * b;\r\n  out[1] = a[1] * b;\r\n  out[2] = a[2] * b;\r\n  out[3] = a[3] * b;\r\n  out[4] = a[4] * b;\r\n  out[5] = a[5] * b;\r\n  out[6] = a[6] * b;\r\n  out[7] = a[7] * b;\r\n  out[8] = a[8] * b;\r\n  out[9] = a[9] * b;\r\n  out[10] = a[10] * b;\r\n  out[11] = a[11] * b;\r\n  out[12] = a[12] * b;\r\n  out[13] = a[13] * b;\r\n  out[14] = a[14] * b;\r\n  out[15] = a[15] * b;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two mat4's after multiplying each element of the second operand by a scalar value.\r\n *\r\n * @param {mat4} out the receiving vector\r\n * @param {mat4} a the first operand\r\n * @param {mat4} b the second operand\r\n * @param {Number} scale the amount to scale b's elements by before adding\r\n * @returns {mat4} out\r\n */\r\nfunction multiplyScalarAndAdd(out, a, b, scale) {\r\n  out[0] = a[0] + b[0] * scale;\r\n  out[1] = a[1] + b[1] * scale;\r\n  out[2] = a[2] + b[2] * scale;\r\n  out[3] = a[3] + b[3] * scale;\r\n  out[4] = a[4] + b[4] * scale;\r\n  out[5] = a[5] + b[5] * scale;\r\n  out[6] = a[6] + b[6] * scale;\r\n  out[7] = a[7] + b[7] * scale;\r\n  out[8] = a[8] + b[8] * scale;\r\n  out[9] = a[9] + b[9] * scale;\r\n  out[10] = a[10] + b[10] * scale;\r\n  out[11] = a[11] + b[11] * scale;\r\n  out[12] = a[12] + b[12] * scale;\r\n  out[13] = a[13] + b[13] * scale;\r\n  out[14] = a[14] + b[14] * scale;\r\n  out[15] = a[15] + b[15] * scale;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {mat4} a The first matrix.\r\n * @param {mat4} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\r\nfunction exactEquals(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];\r\n}\r\n\r\n/**\r\n * Returns whether or not the matrices have approximately the same elements in the same position.\r\n *\r\n * @param {mat4} a The first matrix.\r\n * @param {mat4} b The second matrix.\r\n * @returns {Boolean} True if the matrices are equal, false otherwise.\r\n */\r\nfunction equals(a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n  var a4 = a[4],\r\n      a5 = a[5],\r\n      a6 = a[6],\r\n      a7 = a[7];\r\n  var a8 = a[8],\r\n      a9 = a[9],\r\n      a10 = a[10],\r\n      a11 = a[11];\r\n  var a12 = a[12],\r\n      a13 = a[13],\r\n      a14 = a[14],\r\n      a15 = a[15];\r\n\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3];\r\n  var b4 = b[4],\r\n      b5 = b[5],\r\n      b6 = b[6],\r\n      b7 = b[7];\r\n  var b8 = b[8],\r\n      b9 = b[9],\r\n      b10 = b[10],\r\n      b11 = b[11];\r\n  var b12 = b[12],\r\n      b13 = b[13],\r\n      b14 = b[14],\r\n      b15 = b[15];\r\n\r\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a15), Math.abs(b15));\r\n}\r\n\r\n/**\r\n * Alias for {@link mat4.multiply}\r\n * @function\r\n */\r\nvar mul = multiply;\r\n\r\n/**\r\n * Alias for {@link mat4.subtract}\r\n * @function\r\n */\r\nvar sub = subtract;\n\n/***/ }),\n\n/***/ \"./node_modules/gl-matrix/lib/gl-matrix/quat.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/gl-matrix/lib/gl-matrix/quat.js ***!\n  \\******************************************************/\n/*! exports provided: create, identity, setAxisAngle, getAxisAngle, multiply, rotateX, rotateY, rotateZ, calculateW, slerp, random, invert, conjugate, fromMat3, fromEuler, str, clone, fromValues, copy, set, add, mul, scale, dot, lerp, length, len, squaredLength, sqrLen, normalize, exactEquals, equals, rotationTo, sqlerp, setAxes */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setAxisAngle\", function() { return setAxisAngle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAxisAngle\", function() { return getAxisAngle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateX\", function() { return rotateX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateY\", function() { return rotateY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateZ\", function() { return rotateZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"calculateW\", function() { return calculateW; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"slerp\", function() { return slerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"conjugate\", function() { return conjugate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromMat3\", function() { return fromMat3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromEuler\", function() { return fromEuler; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotationTo\", function() { return rotationTo; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqlerp\", function() { return sqlerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setAxes\", function() { return setAxes; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/lib/gl-matrix/common.js\");\n/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat3.js */ \"./node_modules/gl-matrix/lib/gl-matrix/mat3.js\");\n/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec3.js */ \"./node_modules/gl-matrix/lib/gl-matrix/vec3.js\");\n/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vec4.js */ \"./node_modules/gl-matrix/lib/gl-matrix/vec4.js\");\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Quaternion\r\n * @module quat\r\n */\r\n\r\n/**\r\n * Creates a new identity quat\r\n *\r\n * @returns {quat} a new quaternion\r\n */\r\nfunction create() {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\r\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\r\n    out[0] = 0;\r\n    out[1] = 0;\r\n    out[2] = 0;\r\n  }\r\n  out[3] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set a quat to the identity quaternion\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @returns {quat} out\r\n */\r\nfunction identity(out) {\r\n  out[0] = 0;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 1;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Sets a quat from the given angle and rotation axis,\r\n * then returns it.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {vec3} axis the axis around which to rotate\r\n * @param {Number} rad the angle in radians\r\n * @returns {quat} out\r\n **/\r\nfunction setAxisAngle(out, axis, rad) {\r\n  rad = rad * 0.5;\r\n  var s = Math.sin(rad);\r\n  out[0] = s * axis[0];\r\n  out[1] = s * axis[1];\r\n  out[2] = s * axis[2];\r\n  out[3] = Math.cos(rad);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Gets the rotation axis and angle for a given\r\n *  quaternion. If a quaternion is created with\r\n *  setAxisAngle, this method will return the same\r\n *  values as providied in the original parameter list\r\n *  OR functionally equivalent values.\r\n * Example: The quaternion formed by axis [0, 0, 1] and\r\n *  angle -90 is the same as the quaternion formed by\r\n *  [0, 0, 1] and 270. This method favors the latter.\r\n * @param  {vec3} out_axis  Vector receiving the axis of rotation\r\n * @param  {quat} q     Quaternion to be decomposed\r\n * @return {Number}     Angle, in radians, of the rotation\r\n */\r\nfunction getAxisAngle(out_axis, q) {\r\n  var rad = Math.acos(q[3]) * 2.0;\r\n  var s = Math.sin(rad / 2.0);\r\n  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) {\r\n    out_axis[0] = q[0] / s;\r\n    out_axis[1] = q[1] / s;\r\n    out_axis[2] = q[2] / s;\r\n  } else {\r\n    // If s is zero, return any axis (no rotation - axis does not matter)\r\n    out_axis[0] = 1;\r\n    out_axis[1] = 0;\r\n    out_axis[2] = 0;\r\n  }\r\n  return rad;\r\n}\r\n\r\n/**\r\n * Multiplies two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @returns {quat} out\r\n */\r\nfunction multiply(out, a, b) {\r\n  var ax = a[0],\r\n      ay = a[1],\r\n      az = a[2],\r\n      aw = a[3];\r\n  var bx = b[0],\r\n      by = b[1],\r\n      bz = b[2],\r\n      bw = b[3];\r\n\r\n  out[0] = ax * bw + aw * bx + ay * bz - az * by;\r\n  out[1] = ay * bw + aw * by + az * bx - ax * bz;\r\n  out[2] = az * bw + aw * bz + ax * by - ay * bx;\r\n  out[3] = aw * bw - ax * bx - ay * by - az * bz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a quaternion by the given angle about the X axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {quat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\r\nfunction rotateX(out, a, rad) {\r\n  rad *= 0.5;\r\n\r\n  var ax = a[0],\r\n      ay = a[1],\r\n      az = a[2],\r\n      aw = a[3];\r\n  var bx = Math.sin(rad),\r\n      bw = Math.cos(rad);\r\n\r\n  out[0] = ax * bw + aw * bx;\r\n  out[1] = ay * bw + az * bx;\r\n  out[2] = az * bw - ay * bx;\r\n  out[3] = aw * bw - ax * bx;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a quaternion by the given angle about the Y axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {quat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\r\nfunction rotateY(out, a, rad) {\r\n  rad *= 0.5;\r\n\r\n  var ax = a[0],\r\n      ay = a[1],\r\n      az = a[2],\r\n      aw = a[3];\r\n  var by = Math.sin(rad),\r\n      bw = Math.cos(rad);\r\n\r\n  out[0] = ax * bw - az * by;\r\n  out[1] = ay * bw + aw * by;\r\n  out[2] = az * bw + ax * by;\r\n  out[3] = aw * bw - ay * by;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a quaternion by the given angle about the Z axis\r\n *\r\n * @param {quat} out quat receiving operation result\r\n * @param {quat} a quat to rotate\r\n * @param {number} rad angle (in radians) to rotate\r\n * @returns {quat} out\r\n */\r\nfunction rotateZ(out, a, rad) {\r\n  rad *= 0.5;\r\n\r\n  var ax = a[0],\r\n      ay = a[1],\r\n      az = a[2],\r\n      aw = a[3];\r\n  var bz = Math.sin(rad),\r\n      bw = Math.cos(rad);\r\n\r\n  out[0] = ax * bw + ay * bz;\r\n  out[1] = ay * bw - ax * bz;\r\n  out[2] = az * bw + aw * bz;\r\n  out[3] = aw * bw - az * bz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the W component of a quat from the X, Y, and Z components.\r\n * Assumes that quaternion is 1 unit in length.\r\n * Any existing W component will be ignored.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate W component of\r\n * @returns {quat} out\r\n */\r\nfunction calculateW(out, a) {\r\n  var x = a[0],\r\n      y = a[1],\r\n      z = a[2];\r\n\r\n  out[0] = x;\r\n  out[1] = y;\r\n  out[2] = z;\r\n  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\r\n  return out;\r\n}\r\n\r\n/**\r\n * Performs a spherical linear interpolation between two quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n */\r\nfunction slerp(out, a, b, t) {\r\n  // benchmarks:\r\n  //    http://jsperf.com/quaternion-slerp-implementations\r\n  var ax = a[0],\r\n      ay = a[1],\r\n      az = a[2],\r\n      aw = a[3];\r\n  var bx = b[0],\r\n      by = b[1],\r\n      bz = b[2],\r\n      bw = b[3];\r\n\r\n  var omega = void 0,\r\n      cosom = void 0,\r\n      sinom = void 0,\r\n      scale0 = void 0,\r\n      scale1 = void 0;\r\n\r\n  // calc cosine\r\n  cosom = ax * bx + ay * by + az * bz + aw * bw;\r\n  // adjust signs (if necessary)\r\n  if (cosom < 0.0) {\r\n    cosom = -cosom;\r\n    bx = -bx;\r\n    by = -by;\r\n    bz = -bz;\r\n    bw = -bw;\r\n  }\r\n  // calculate coefficients\r\n  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) {\r\n    // standard case (slerp)\r\n    omega = Math.acos(cosom);\r\n    sinom = Math.sin(omega);\r\n    scale0 = Math.sin((1.0 - t) * omega) / sinom;\r\n    scale1 = Math.sin(t * omega) / sinom;\r\n  } else {\r\n    // \"from\" and \"to\" quaternions are very close\r\n    //  ... so we can do a linear interpolation\r\n    scale0 = 1.0 - t;\r\n    scale1 = t;\r\n  }\r\n  // calculate final values\r\n  out[0] = scale0 * ax + scale1 * bx;\r\n  out[1] = scale0 * ay + scale1 * by;\r\n  out[2] = scale0 * az + scale1 * bz;\r\n  out[3] = scale0 * aw + scale1 * bw;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a random quaternion\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @returns {quat} out\r\n */\r\nfunction random(out) {\r\n  // Implementation of http://planning.cs.uiuc.edu/node198.html\r\n  // TODO: Calling random 3 times is probably not the fastest solution\r\n  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]();\r\n  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]();\r\n  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]();\r\n\r\n  var sqrt1MinusU1 = Math.sqrt(1 - u1);\r\n  var sqrtU1 = Math.sqrt(u1);\r\n\r\n  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);\r\n  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);\r\n  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);\r\n  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the inverse of a quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate inverse of\r\n * @returns {quat} out\r\n */\r\nfunction invert(out, a) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\r\n  var invDot = dot ? 1.0 / dot : 0;\r\n\r\n  // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\r\n\r\n  out[0] = -a0 * invDot;\r\n  out[1] = -a1 * invDot;\r\n  out[2] = -a2 * invDot;\r\n  out[3] = a3 * invDot;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the conjugate of a quat\r\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quat to calculate conjugate of\r\n * @returns {quat} out\r\n */\r\nfunction conjugate(out, a) {\r\n  out[0] = -a[0];\r\n  out[1] = -a[1];\r\n  out[2] = -a[2];\r\n  out[3] = a[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a quaternion from the given 3x3 rotation matrix.\r\n *\r\n * NOTE: The resultant quaternion is not normalized, so you should be sure\r\n * to renormalize the quaternion yourself where necessary.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {mat3} m rotation matrix\r\n * @returns {quat} out\r\n * @function\r\n */\r\nfunction fromMat3(out, m) {\r\n  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\r\n  // article \"Quaternion Calculus and Fast Animation\".\r\n  var fTrace = m[0] + m[4] + m[8];\r\n  var fRoot = void 0;\r\n\r\n  if (fTrace > 0.0) {\r\n    // |w| > 1/2, may as well choose w > 1/2\r\n    fRoot = Math.sqrt(fTrace + 1.0); // 2w\r\n    out[3] = 0.5 * fRoot;\r\n    fRoot = 0.5 / fRoot; // 1/(4w)\r\n    out[0] = (m[5] - m[7]) * fRoot;\r\n    out[1] = (m[6] - m[2]) * fRoot;\r\n    out[2] = (m[1] - m[3]) * fRoot;\r\n  } else {\r\n    // |w| <= 1/2\r\n    var i = 0;\r\n    if (m[4] > m[0]) i = 1;\r\n    if (m[8] > m[i * 3 + i]) i = 2;\r\n    var j = (i + 1) % 3;\r\n    var k = (i + 2) % 3;\r\n\r\n    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\r\n    out[i] = 0.5 * fRoot;\r\n    fRoot = 0.5 / fRoot;\r\n    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\r\n    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\r\n    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\r\n  }\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a quaternion from the given euler angle x, y, z.\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {x} Angle to rotate around X axis in degrees.\r\n * @param {y} Angle to rotate around Y axis in degrees.\r\n * @param {z} Angle to rotate around Z axis in degrees.\r\n * @returns {quat} out\r\n * @function\r\n */\r\nfunction fromEuler(out, x, y, z) {\r\n  var halfToRad = 0.5 * Math.PI / 180.0;\r\n  x *= halfToRad;\r\n  y *= halfToRad;\r\n  z *= halfToRad;\r\n\r\n  var sx = Math.sin(x);\r\n  var cx = Math.cos(x);\r\n  var sy = Math.sin(y);\r\n  var cy = Math.cos(y);\r\n  var sz = Math.sin(z);\r\n  var cz = Math.cos(z);\r\n\r\n  out[0] = sx * cy * cz - cx * sy * sz;\r\n  out[1] = cx * sy * cz + sx * cy * sz;\r\n  out[2] = cx * cy * sz - sx * sy * cz;\r\n  out[3] = cx * cy * cz + sx * sy * sz;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns a string representation of a quatenion\r\n *\r\n * @param {quat} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\r\nfunction str(a) {\r\n  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\r\n}\r\n\r\n/**\r\n * Creates a new quat initialized with values from an existing quaternion\r\n *\r\n * @param {quat} a quaternion to clone\r\n * @returns {quat} a new quaternion\r\n * @function\r\n */\r\nvar clone = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"clone\"];\r\n\r\n/**\r\n * Creates a new quat initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {quat} a new quaternion\r\n * @function\r\n */\r\nvar fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"fromValues\"];\r\n\r\n/**\r\n * Copy the values from one quat to another\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the source quaternion\r\n * @returns {quat} out\r\n * @function\r\n */\r\nvar copy = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"copy\"];\r\n\r\n/**\r\n * Set the components of a quat to the given values\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {quat} out\r\n * @function\r\n */\r\nvar set = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"set\"];\r\n\r\n/**\r\n * Adds two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @returns {quat} out\r\n * @function\r\n */\r\nvar add = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"add\"];\r\n\r\n/**\r\n * Alias for {@link quat.multiply}\r\n * @function\r\n */\r\nvar mul = multiply;\r\n\r\n/**\r\n * Scales a quat by a scalar number\r\n *\r\n * @param {quat} out the receiving vector\r\n * @param {quat} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {quat} out\r\n * @function\r\n */\r\nvar scale = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"scale\"];\r\n\r\n/**\r\n * Calculates the dot product of two quat's\r\n *\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @returns {Number} dot product of a and b\r\n * @function\r\n */\r\nvar dot = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"dot\"];\r\n\r\n/**\r\n * Performs a linear interpolation between two quat's\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n * @function\r\n */\r\nvar lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"lerp\"];\r\n\r\n/**\r\n * Calculates the length of a quat\r\n *\r\n * @param {quat} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\r\nvar length = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"length\"];\r\n\r\n/**\r\n * Alias for {@link quat.length}\r\n * @function\r\n */\r\nvar len = length;\r\n\r\n/**\r\n * Calculates the squared length of a quat\r\n *\r\n * @param {quat} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n * @function\r\n */\r\nvar squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"squaredLength\"];\r\n\r\n/**\r\n * Alias for {@link quat.squaredLength}\r\n * @function\r\n */\r\nvar sqrLen = squaredLength;\r\n\r\n/**\r\n * Normalize a quat\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a quaternion to normalize\r\n * @returns {quat} out\r\n * @function\r\n */\r\nvar normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"normalize\"];\r\n\r\n/**\r\n * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {quat} a The first quaternion.\r\n * @param {quat} b The second quaternion.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\nvar exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"exactEquals\"];\r\n\r\n/**\r\n * Returns whether or not the quaternions have approximately the same elements in the same position.\r\n *\r\n * @param {quat} a The first vector.\r\n * @param {quat} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\nvar equals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__[\"equals\"];\r\n\r\n/**\r\n * Sets a quaternion to represent the shortest rotation from one\r\n * vector to another.\r\n *\r\n * Both vectors are assumed to be unit length.\r\n *\r\n * @param {quat} out the receiving quaternion.\r\n * @param {vec3} a the initial vector\r\n * @param {vec3} b the destination vector\r\n * @returns {quat} out\r\n */\r\nvar rotationTo = function () {\r\n  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"create\"]();\r\n  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"fromValues\"](1, 0, 0);\r\n  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"fromValues\"](0, 1, 0);\r\n\r\n  return function (out, a, b) {\r\n    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"dot\"](a, b);\r\n    if (dot < -0.999999) {\r\n      _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"cross\"](tmpvec3, xUnitVec3, a);\r\n      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"len\"](tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"cross\"](tmpvec3, yUnitVec3, a);\r\n      _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"normalize\"](tmpvec3, tmpvec3);\r\n      setAxisAngle(out, tmpvec3, Math.PI);\r\n      return out;\r\n    } else if (dot > 0.999999) {\r\n      out[0] = 0;\r\n      out[1] = 0;\r\n      out[2] = 0;\r\n      out[3] = 1;\r\n      return out;\r\n    } else {\r\n      _vec3_js__WEBPACK_IMPORTED_MODULE_2__[\"cross\"](tmpvec3, a, b);\r\n      out[0] = tmpvec3[0];\r\n      out[1] = tmpvec3[1];\r\n      out[2] = tmpvec3[2];\r\n      out[3] = 1 + dot;\r\n      return normalize(out, out);\r\n    }\r\n  };\r\n}();\r\n\r\n/**\r\n * Performs a spherical linear interpolation with two control points\r\n *\r\n * @param {quat} out the receiving quaternion\r\n * @param {quat} a the first operand\r\n * @param {quat} b the second operand\r\n * @param {quat} c the third operand\r\n * @param {quat} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat} out\r\n */\r\nvar sqlerp = function () {\r\n  var temp1 = create();\r\n  var temp2 = create();\r\n\r\n  return function (out, a, b, c, d, t) {\r\n    slerp(temp1, a, d, t);\r\n    slerp(temp2, b, c, t);\r\n    slerp(out, temp1, temp2, 2 * t * (1 - t));\r\n\r\n    return out;\r\n  };\r\n}();\r\n\r\n/**\r\n * Sets the specified quaternion with values corresponding to the given\r\n * axes. Each axis is a vec3 and is expected to be unit length and\r\n * perpendicular to all other specified axes.\r\n *\r\n * @param {vec3} view  the vector representing the viewing direction\r\n * @param {vec3} right the vector representing the local \"right\" direction\r\n * @param {vec3} up    the vector representing the local \"up\" direction\r\n * @returns {quat} out\r\n */\r\nvar setAxes = function () {\r\n  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_1__[\"create\"]();\r\n\r\n  return function (out, view, right, up) {\r\n    matr[0] = right[0];\r\n    matr[3] = right[1];\r\n    matr[6] = right[2];\r\n\r\n    matr[1] = up[0];\r\n    matr[4] = up[1];\r\n    matr[7] = up[2];\r\n\r\n    matr[2] = -view[0];\r\n    matr[5] = -view[1];\r\n    matr[8] = -view[2];\r\n\r\n    return normalize(out, fromMat3(out, matr));\r\n  };\r\n}();\n\n/***/ }),\n\n/***/ \"./node_modules/gl-matrix/lib/gl-matrix/quat2.js\":\n/*!*******************************************************!*\\\n  !*** ./node_modules/gl-matrix/lib/gl-matrix/quat2.js ***!\n  \\*******************************************************/\n/*! exports provided: create, clone, fromValues, fromRotationTranslationValues, fromRotationTranslation, fromTranslation, fromRotation, fromMat4, copy, identity, set, getReal, getDual, setReal, setDual, getTranslation, translate, rotateX, rotateY, rotateZ, rotateByQuatAppend, rotateByQuatPrepend, rotateAroundAxis, add, multiply, mul, scale, dot, lerp, invert, conjugate, length, len, squaredLength, sqrLen, normalize, str, exactEquals, equals */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslationValues\", function() { return fromRotationTranslationValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotationTranslation\", function() { return fromRotationTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromTranslation\", function() { return fromTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromRotation\", function() { return fromRotation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromMat4\", function() { return fromMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identity\", function() { return identity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getReal\", function() { return getReal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDual\", function() { return getDual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setReal\", function() { return setReal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setDual\", function() { return setDual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTranslation\", function() { return getTranslation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"translate\", function() { return translate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateX\", function() { return rotateX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateY\", function() { return rotateY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateZ\", function() { return rotateZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateByQuatAppend\", function() { return rotateByQuatAppend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateByQuatPrepend\", function() { return rotateByQuatPrepend; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateAroundAxis\", function() { return rotateAroundAxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"invert\", function() { return invert; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"conjugate\", function() { return conjugate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/lib/gl-matrix/common.js\");\n/* harmony import */ var _quat_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./quat.js */ \"./node_modules/gl-matrix/lib/gl-matrix/quat.js\");\n/* harmony import */ var _mat4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mat4.js */ \"./node_modules/gl-matrix/lib/gl-matrix/mat4.js\");\n\r\n\r\n\r\n\r\n/**\r\n * Dual Quaternion<br>\r\n * Format: [real, dual]<br>\r\n * Quaternion format: XYZW<br>\r\n * Make sure to have normalized dual quaternions, otherwise the functions may not work as intended.<br>\r\n * @module quat2\r\n */\r\n\r\n/**\r\n * Creates a new identity dual quat\r\n *\r\n * @returns {quat2} a new dual quaternion [real -> rotation, dual -> translation]\r\n */\r\nfunction create() {\r\n  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](8);\r\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\r\n    dq[0] = 0;\r\n    dq[1] = 0;\r\n    dq[2] = 0;\r\n    dq[4] = 0;\r\n    dq[5] = 0;\r\n    dq[6] = 0;\r\n    dq[7] = 0;\r\n  }\r\n  dq[3] = 1;\r\n  return dq;\r\n}\r\n\r\n/**\r\n * Creates a new quat initialized with values from an existing quaternion\r\n *\r\n * @param {quat2} a dual quaternion to clone\r\n * @returns {quat2} new dual quaternion\r\n * @function\r\n */\r\nfunction clone(a) {\r\n  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](8);\r\n  dq[0] = a[0];\r\n  dq[1] = a[1];\r\n  dq[2] = a[2];\r\n  dq[3] = a[3];\r\n  dq[4] = a[4];\r\n  dq[5] = a[5];\r\n  dq[6] = a[6];\r\n  dq[7] = a[7];\r\n  return dq;\r\n}\r\n\r\n/**\r\n * Creates a new dual quat initialized with the given values\r\n *\r\n * @param {Number} x1 X component\r\n * @param {Number} y1 Y component\r\n * @param {Number} z1 Z component\r\n * @param {Number} w1 W component\r\n * @param {Number} x2 X component\r\n * @param {Number} y2 Y component\r\n * @param {Number} z2 Z component\r\n * @param {Number} w2 W component\r\n * @returns {quat2} new dual quaternion\r\n * @function\r\n */\r\nfunction fromValues(x1, y1, z1, w1, x2, y2, z2, w2) {\r\n  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](8);\r\n  dq[0] = x1;\r\n  dq[1] = y1;\r\n  dq[2] = z1;\r\n  dq[3] = w1;\r\n  dq[4] = x2;\r\n  dq[5] = y2;\r\n  dq[6] = z2;\r\n  dq[7] = w2;\r\n  return dq;\r\n}\r\n\r\n/**\r\n * Creates a new dual quat from the given values (quat and translation)\r\n *\r\n * @param {Number} x1 X component\r\n * @param {Number} y1 Y component\r\n * @param {Number} z1 Z component\r\n * @param {Number} w1 W component\r\n * @param {Number} x2 X component (translation)\r\n * @param {Number} y2 Y component (translation)\r\n * @param {Number} z2 Z component (translation)\r\n * @returns {quat2} new dual quaternion\r\n * @function\r\n */\r\nfunction fromRotationTranslationValues(x1, y1, z1, w1, x2, y2, z2) {\r\n  var dq = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](8);\r\n  dq[0] = x1;\r\n  dq[1] = y1;\r\n  dq[2] = z1;\r\n  dq[3] = w1;\r\n  var ax = x2 * 0.5,\r\n      ay = y2 * 0.5,\r\n      az = z2 * 0.5;\r\n  dq[4] = ax * w1 + ay * z1 - az * y1;\r\n  dq[5] = ay * w1 + az * x1 - ax * z1;\r\n  dq[6] = az * w1 + ax * y1 - ay * x1;\r\n  dq[7] = -ax * x1 - ay * y1 - az * z1;\r\n  return dq;\r\n}\r\n\r\n/**\r\n * Creates a dual quat from a quaternion and a translation\r\n *\r\n * @param {quat2} dual quaternion receiving operation result\r\n * @param {quat} q quaternion\r\n * @param {vec3} t tranlation vector\r\n * @returns {quat2} dual quaternion receiving operation result\r\n * @function\r\n */\r\nfunction fromRotationTranslation(out, q, t) {\r\n  var ax = t[0] * 0.5,\r\n      ay = t[1] * 0.5,\r\n      az = t[2] * 0.5,\r\n      bx = q[0],\r\n      by = q[1],\r\n      bz = q[2],\r\n      bw = q[3];\r\n  out[0] = bx;\r\n  out[1] = by;\r\n  out[2] = bz;\r\n  out[3] = bw;\r\n  out[4] = ax * bw + ay * bz - az * by;\r\n  out[5] = ay * bw + az * bx - ax * bz;\r\n  out[6] = az * bw + ax * by - ay * bx;\r\n  out[7] = -ax * bx - ay * by - az * bz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a dual quat from a translation\r\n *\r\n * @param {quat2} dual quaternion receiving operation result\r\n * @param {vec3} t translation vector\r\n * @returns {quat2} dual quaternion receiving operation result\r\n * @function\r\n */\r\nfunction fromTranslation(out, t) {\r\n  out[0] = 0;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 1;\r\n  out[4] = t[0] * 0.5;\r\n  out[5] = t[1] * 0.5;\r\n  out[6] = t[2] * 0.5;\r\n  out[7] = 0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a dual quat from a quaternion\r\n *\r\n * @param {quat2} dual quaternion receiving operation result\r\n * @param {quat} q the quaternion\r\n * @returns {quat2} dual quaternion receiving operation result\r\n * @function\r\n */\r\nfunction fromRotation(out, q) {\r\n  out[0] = q[0];\r\n  out[1] = q[1];\r\n  out[2] = q[2];\r\n  out[3] = q[3];\r\n  out[4] = 0;\r\n  out[5] = 0;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new dual quat from a matrix (4x4)\r\n *\r\n * @param {quat2} out the dual quaternion\r\n * @param {mat4} a the matrix\r\n * @returns {quat2} dual quat receiving operation result\r\n * @function\r\n */\r\nfunction fromMat4(out, a) {\r\n  //TODO Optimize this\r\n  var outer = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"create\"]();\r\n  _mat4_js__WEBPACK_IMPORTED_MODULE_2__[\"getRotation\"](outer, a);\r\n  var t = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\r\n  _mat4_js__WEBPACK_IMPORTED_MODULE_2__[\"getTranslation\"](t, a);\r\n  fromRotationTranslation(out, outer, t);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copy the values from one dual quat to another\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the source dual quaternion\r\n * @returns {quat2} out\r\n * @function\r\n */\r\nfunction copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  out[4] = a[4];\r\n  out[5] = a[5];\r\n  out[6] = a[6];\r\n  out[7] = a[7];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set a dual quat to the identity dual quaternion\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @returns {quat2} out\r\n */\r\nfunction identity(out) {\r\n  out[0] = 0;\r\n  out[1] = 0;\r\n  out[2] = 0;\r\n  out[3] = 1;\r\n  out[4] = 0;\r\n  out[5] = 0;\r\n  out[6] = 0;\r\n  out[7] = 0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set the components of a dual quat to the given values\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {Number} x1 X component\r\n * @param {Number} y1 Y component\r\n * @param {Number} z1 Z component\r\n * @param {Number} w1 W component\r\n * @param {Number} x2 X component\r\n * @param {Number} y2 Y component\r\n * @param {Number} z2 Z component\r\n * @param {Number} w2 W component\r\n * @returns {quat2} out\r\n * @function\r\n */\r\nfunction set(out, x1, y1, z1, w1, x2, y2, z2, w2) {\r\n  out[0] = x1;\r\n  out[1] = y1;\r\n  out[2] = z1;\r\n  out[3] = w1;\r\n\r\n  out[4] = x2;\r\n  out[5] = y2;\r\n  out[6] = z2;\r\n  out[7] = w2;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Gets the real part of a dual quat\r\n * @param  {quat} out real part\r\n * @param  {quat2} a Dual Quaternion\r\n * @return {quat} real part\r\n */\r\nvar getReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"copy\"];\r\n\r\n/**\r\n * Gets the dual part of a dual quat\r\n * @param  {quat} out dual part\r\n * @param  {quat2} a Dual Quaternion\r\n * @return {quat} dual part\r\n */\r\nfunction getDual(out, a) {\r\n  out[0] = a[4];\r\n  out[1] = a[5];\r\n  out[2] = a[6];\r\n  out[3] = a[7];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set the real component of a dual quat to the given quaternion\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {quat} q a quaternion representing the real part\r\n * @returns {quat2} out\r\n * @function\r\n */\r\nvar setReal = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"copy\"];\r\n\r\n/**\r\n * Set the dual component of a dual quat to the given quaternion\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {quat} q a quaternion representing the dual part\r\n * @returns {quat2} out\r\n * @function\r\n */\r\nfunction setDual(out, q) {\r\n  out[4] = q[0];\r\n  out[5] = q[1];\r\n  out[6] = q[2];\r\n  out[7] = q[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Gets the translation of a normalized dual quat\r\n * @param  {vec3} out translation\r\n * @param  {quat2} a Dual Quaternion to be decomposed\r\n * @return {vec3} translation\r\n */\r\nfunction getTranslation(out, a) {\r\n  var ax = a[4],\r\n      ay = a[5],\r\n      az = a[6],\r\n      aw = a[7],\r\n      bx = -a[0],\r\n      by = -a[1],\r\n      bz = -a[2],\r\n      bw = a[3];\r\n  out[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;\r\n  out[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;\r\n  out[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Translates a dual quat by the given vector\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to translate\r\n * @param {vec3} v vector to translate by\r\n * @returns {quat2} out\r\n */\r\nfunction translate(out, a, v) {\r\n  var ax1 = a[0],\r\n      ay1 = a[1],\r\n      az1 = a[2],\r\n      aw1 = a[3],\r\n      bx1 = v[0] * 0.5,\r\n      by1 = v[1] * 0.5,\r\n      bz1 = v[2] * 0.5,\r\n      ax2 = a[4],\r\n      ay2 = a[5],\r\n      az2 = a[6],\r\n      aw2 = a[7];\r\n  out[0] = ax1;\r\n  out[1] = ay1;\r\n  out[2] = az1;\r\n  out[3] = aw1;\r\n  out[4] = aw1 * bx1 + ay1 * bz1 - az1 * by1 + ax2;\r\n  out[5] = aw1 * by1 + az1 * bx1 - ax1 * bz1 + ay2;\r\n  out[6] = aw1 * bz1 + ax1 * by1 - ay1 * bx1 + az2;\r\n  out[7] = -ax1 * bx1 - ay1 * by1 - az1 * bz1 + aw2;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a dual quat around the X axis\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {number} rad how far should the rotation be\r\n * @returns {quat2} out\r\n */\r\nfunction rotateX(out, a, rad) {\r\n  var bx = -a[0],\r\n      by = -a[1],\r\n      bz = -a[2],\r\n      bw = a[3],\r\n      ax = a[4],\r\n      ay = a[5],\r\n      az = a[6],\r\n      aw = a[7],\r\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\r\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\r\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\r\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\r\n  _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"rotateX\"](out, a, rad);\r\n  bx = out[0];\r\n  by = out[1];\r\n  bz = out[2];\r\n  bw = out[3];\r\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\r\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\r\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\r\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a dual quat around the Y axis\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {number} rad how far should the rotation be\r\n * @returns {quat2} out\r\n */\r\nfunction rotateY(out, a, rad) {\r\n  var bx = -a[0],\r\n      by = -a[1],\r\n      bz = -a[2],\r\n      bw = a[3],\r\n      ax = a[4],\r\n      ay = a[5],\r\n      az = a[6],\r\n      aw = a[7],\r\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\r\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\r\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\r\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\r\n  _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"rotateY\"](out, a, rad);\r\n  bx = out[0];\r\n  by = out[1];\r\n  bz = out[2];\r\n  bw = out[3];\r\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\r\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\r\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\r\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a dual quat around the Z axis\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {number} rad how far should the rotation be\r\n * @returns {quat2} out\r\n */\r\nfunction rotateZ(out, a, rad) {\r\n  var bx = -a[0],\r\n      by = -a[1],\r\n      bz = -a[2],\r\n      bw = a[3],\r\n      ax = a[4],\r\n      ay = a[5],\r\n      az = a[6],\r\n      aw = a[7],\r\n      ax1 = ax * bw + aw * bx + ay * bz - az * by,\r\n      ay1 = ay * bw + aw * by + az * bx - ax * bz,\r\n      az1 = az * bw + aw * bz + ax * by - ay * bx,\r\n      aw1 = aw * bw - ax * bx - ay * by - az * bz;\r\n  _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"rotateZ\"](out, a, rad);\r\n  bx = out[0];\r\n  by = out[1];\r\n  bz = out[2];\r\n  bw = out[3];\r\n  out[4] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\r\n  out[5] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\r\n  out[6] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\r\n  out[7] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a dual quat by a given quaternion (a * q)\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {quat} q quaternion to rotate by\r\n * @returns {quat2} out\r\n */\r\nfunction rotateByQuatAppend(out, a, q) {\r\n  var qx = q[0],\r\n      qy = q[1],\r\n      qz = q[2],\r\n      qw = q[3],\r\n      ax = a[0],\r\n      ay = a[1],\r\n      az = a[2],\r\n      aw = a[3];\r\n\r\n  out[0] = ax * qw + aw * qx + ay * qz - az * qy;\r\n  out[1] = ay * qw + aw * qy + az * qx - ax * qz;\r\n  out[2] = az * qw + aw * qz + ax * qy - ay * qx;\r\n  out[3] = aw * qw - ax * qx - ay * qy - az * qz;\r\n  ax = a[4];\r\n  ay = a[5];\r\n  az = a[6];\r\n  aw = a[7];\r\n  out[4] = ax * qw + aw * qx + ay * qz - az * qy;\r\n  out[5] = ay * qw + aw * qy + az * qx - ax * qz;\r\n  out[6] = az * qw + aw * qz + ax * qy - ay * qx;\r\n  out[7] = aw * qw - ax * qx - ay * qy - az * qz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a dual quat by a given quaternion (q * a)\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat} q quaternion to rotate by\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @returns {quat2} out\r\n */\r\nfunction rotateByQuatPrepend(out, q, a) {\r\n  var qx = q[0],\r\n      qy = q[1],\r\n      qz = q[2],\r\n      qw = q[3],\r\n      bx = a[0],\r\n      by = a[1],\r\n      bz = a[2],\r\n      bw = a[3];\r\n\r\n  out[0] = qx * bw + qw * bx + qy * bz - qz * by;\r\n  out[1] = qy * bw + qw * by + qz * bx - qx * bz;\r\n  out[2] = qz * bw + qw * bz + qx * by - qy * bx;\r\n  out[3] = qw * bw - qx * bx - qy * by - qz * bz;\r\n  bx = a[4];\r\n  by = a[5];\r\n  bz = a[6];\r\n  bw = a[7];\r\n  out[4] = qx * bw + qw * bx + qy * bz - qz * by;\r\n  out[5] = qy * bw + qw * by + qz * bx - qx * bz;\r\n  out[6] = qz * bw + qw * bz + qx * by - qy * bx;\r\n  out[7] = qw * bw - qx * bx - qy * by - qz * bz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotates a dual quat around a given axis. Does the normalisation automatically\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the dual quaternion to rotate\r\n * @param {vec3} axis the axis to rotate around\r\n * @param {Number} rad how far the rotation should be\r\n * @returns {quat2} out\r\n */\r\nfunction rotateAroundAxis(out, a, axis, rad) {\r\n  //Special case for rad = 0\r\n  if (Math.abs(rad) < _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"]) {\r\n    return copy(out, a);\r\n  }\r\n  var axisLength = Math.sqrt(axis[0] * axis[0] + axis[1] * axis[1] + axis[2] * axis[2]);\r\n\r\n  rad = rad * 0.5;\r\n  var s = Math.sin(rad);\r\n  var bx = s * axis[0] / axisLength;\r\n  var by = s * axis[1] / axisLength;\r\n  var bz = s * axis[2] / axisLength;\r\n  var bw = Math.cos(rad);\r\n\r\n  var ax1 = a[0],\r\n      ay1 = a[1],\r\n      az1 = a[2],\r\n      aw1 = a[3];\r\n  out[0] = ax1 * bw + aw1 * bx + ay1 * bz - az1 * by;\r\n  out[1] = ay1 * bw + aw1 * by + az1 * bx - ax1 * bz;\r\n  out[2] = az1 * bw + aw1 * bz + ax1 * by - ay1 * bx;\r\n  out[3] = aw1 * bw - ax1 * bx - ay1 * by - az1 * bz;\r\n\r\n  var ax = a[4],\r\n      ay = a[5],\r\n      az = a[6],\r\n      aw = a[7];\r\n  out[4] = ax * bw + aw * bx + ay * bz - az * by;\r\n  out[5] = ay * bw + aw * by + az * bx - ax * bz;\r\n  out[6] = az * bw + aw * bz + ax * by - ay * bx;\r\n  out[7] = aw * bw - ax * bx - ay * by - az * bz;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two dual quat's\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the first operand\r\n * @param {quat2} b the second operand\r\n * @returns {quat2} out\r\n * @function\r\n */\r\nfunction add(out, a, b) {\r\n  out[0] = a[0] + b[0];\r\n  out[1] = a[1] + b[1];\r\n  out[2] = a[2] + b[2];\r\n  out[3] = a[3] + b[3];\r\n  out[4] = a[4] + b[4];\r\n  out[5] = a[5] + b[5];\r\n  out[6] = a[6] + b[6];\r\n  out[7] = a[7] + b[7];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Multiplies two dual quat's\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a the first operand\r\n * @param {quat2} b the second operand\r\n * @returns {quat2} out\r\n */\r\nfunction multiply(out, a, b) {\r\n  var ax0 = a[0],\r\n      ay0 = a[1],\r\n      az0 = a[2],\r\n      aw0 = a[3],\r\n      bx1 = b[4],\r\n      by1 = b[5],\r\n      bz1 = b[6],\r\n      bw1 = b[7],\r\n      ax1 = a[4],\r\n      ay1 = a[5],\r\n      az1 = a[6],\r\n      aw1 = a[7],\r\n      bx0 = b[0],\r\n      by0 = b[1],\r\n      bz0 = b[2],\r\n      bw0 = b[3];\r\n  out[0] = ax0 * bw0 + aw0 * bx0 + ay0 * bz0 - az0 * by0;\r\n  out[1] = ay0 * bw0 + aw0 * by0 + az0 * bx0 - ax0 * bz0;\r\n  out[2] = az0 * bw0 + aw0 * bz0 + ax0 * by0 - ay0 * bx0;\r\n  out[3] = aw0 * bw0 - ax0 * bx0 - ay0 * by0 - az0 * bz0;\r\n  out[4] = ax0 * bw1 + aw0 * bx1 + ay0 * bz1 - az0 * by1 + ax1 * bw0 + aw1 * bx0 + ay1 * bz0 - az1 * by0;\r\n  out[5] = ay0 * bw1 + aw0 * by1 + az0 * bx1 - ax0 * bz1 + ay1 * bw0 + aw1 * by0 + az1 * bx0 - ax1 * bz0;\r\n  out[6] = az0 * bw1 + aw0 * bz1 + ax0 * by1 - ay0 * bx1 + az1 * bw0 + aw1 * bz0 + ax1 * by0 - ay1 * bx0;\r\n  out[7] = aw0 * bw1 - ax0 * bx1 - ay0 * by1 - az0 * bz1 + aw1 * bw0 - ax1 * bx0 - ay1 * by0 - az1 * bz0;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Alias for {@link quat2.multiply}\r\n * @function\r\n */\r\nvar mul = multiply;\r\n\r\n/**\r\n * Scales a dual quat by a scalar number\r\n *\r\n * @param {quat2} out the receiving dual quat\r\n * @param {quat2} a the dual quat to scale\r\n * @param {Number} b amount to scale the dual quat by\r\n * @returns {quat2} out\r\n * @function\r\n */\r\nfunction scale(out, a, b) {\r\n  out[0] = a[0] * b;\r\n  out[1] = a[1] * b;\r\n  out[2] = a[2] * b;\r\n  out[3] = a[3] * b;\r\n  out[4] = a[4] * b;\r\n  out[5] = a[5] * b;\r\n  out[6] = a[6] * b;\r\n  out[7] = a[7] * b;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the dot product of two dual quat's (The dot product of the real parts)\r\n *\r\n * @param {quat2} a the first operand\r\n * @param {quat2} b the second operand\r\n * @returns {Number} dot product of a and b\r\n * @function\r\n */\r\nvar dot = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"dot\"];\r\n\r\n/**\r\n * Performs a linear interpolation between two dual quats's\r\n * NOTE: The resulting dual quaternions won't always be normalized (The error is most noticeable when t = 0.5)\r\n *\r\n * @param {quat2} out the receiving dual quat\r\n * @param {quat2} a the first operand\r\n * @param {quat2} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {quat2} out\r\n */\r\nfunction lerp(out, a, b, t) {\r\n  var mt = 1 - t;\r\n  if (dot(a, b) < 0) t = -t;\r\n\r\n  out[0] = a[0] * mt + b[0] * t;\r\n  out[1] = a[1] * mt + b[1] * t;\r\n  out[2] = a[2] * mt + b[2] * t;\r\n  out[3] = a[3] * mt + b[3] * t;\r\n  out[4] = a[4] * mt + b[4] * t;\r\n  out[5] = a[5] * mt + b[5] * t;\r\n  out[6] = a[6] * mt + b[6] * t;\r\n  out[7] = a[7] * mt + b[7] * t;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the inverse of a dual quat. If they are normalized, conjugate is cheaper\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a dual quat to calculate inverse of\r\n * @returns {quat2} out\r\n */\r\nfunction invert(out, a) {\r\n  var sqlen = squaredLength(a);\r\n  out[0] = -a[0] / sqlen;\r\n  out[1] = -a[1] / sqlen;\r\n  out[2] = -a[2] / sqlen;\r\n  out[3] = a[3] / sqlen;\r\n  out[4] = -a[4] / sqlen;\r\n  out[5] = -a[5] / sqlen;\r\n  out[6] = -a[6] / sqlen;\r\n  out[7] = a[7] / sqlen;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the conjugate of a dual quat\r\n * If the dual quaternion is normalized, this function is faster than quat2.inverse and produces the same result.\r\n *\r\n * @param {quat2} out the receiving quaternion\r\n * @param {quat2} a quat to calculate conjugate of\r\n * @returns {quat2} out\r\n */\r\nfunction conjugate(out, a) {\r\n  out[0] = -a[0];\r\n  out[1] = -a[1];\r\n  out[2] = -a[2];\r\n  out[3] = a[3];\r\n  out[4] = -a[4];\r\n  out[5] = -a[5];\r\n  out[6] = -a[6];\r\n  out[7] = a[7];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the length of a dual quat\r\n *\r\n * @param {quat2} a dual quat to calculate length of\r\n * @returns {Number} length of a\r\n * @function\r\n */\r\nvar length = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"length\"];\r\n\r\n/**\r\n * Alias for {@link quat2.length}\r\n * @function\r\n */\r\nvar len = length;\r\n\r\n/**\r\n * Calculates the squared length of a dual quat\r\n *\r\n * @param {quat2} a dual quat to calculate squared length of\r\n * @returns {Number} squared length of a\r\n * @function\r\n */\r\nvar squaredLength = _quat_js__WEBPACK_IMPORTED_MODULE_1__[\"squaredLength\"];\r\n\r\n/**\r\n * Alias for {@link quat2.squaredLength}\r\n * @function\r\n */\r\nvar sqrLen = squaredLength;\r\n\r\n/**\r\n * Normalize a dual quat\r\n *\r\n * @param {quat2} out the receiving dual quaternion\r\n * @param {quat2} a dual quaternion to normalize\r\n * @returns {quat2} out\r\n * @function\r\n */\r\nfunction normalize(out, a) {\r\n  var magnitude = squaredLength(a);\r\n  if (magnitude > 0) {\r\n    magnitude = Math.sqrt(magnitude);\r\n\r\n    var a0 = a[0] / magnitude;\r\n    var a1 = a[1] / magnitude;\r\n    var a2 = a[2] / magnitude;\r\n    var a3 = a[3] / magnitude;\r\n\r\n    var b0 = a[4];\r\n    var b1 = a[5];\r\n    var b2 = a[6];\r\n    var b3 = a[7];\r\n\r\n    var a_dot_b = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;\r\n\r\n    out[0] = a0;\r\n    out[1] = a1;\r\n    out[2] = a2;\r\n    out[3] = a3;\r\n\r\n    out[4] = (b0 - a0 * a_dot_b) / magnitude;\r\n    out[5] = (b1 - a1 * a_dot_b) / magnitude;\r\n    out[6] = (b2 - a2 * a_dot_b) / magnitude;\r\n    out[7] = (b3 - a3 * a_dot_b) / magnitude;\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns a string representation of a dual quatenion\r\n *\r\n * @param {quat2} a dual quaternion to represent as a string\r\n * @returns {String} string representation of the dual quat\r\n */\r\nfunction str(a) {\r\n  return 'quat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ')';\r\n}\r\n\r\n/**\r\n * Returns whether or not the dual quaternions have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {quat2} a the first dual quaternion.\r\n * @param {quat2} b the second dual quaternion.\r\n * @returns {Boolean} true if the dual quaternions are equal, false otherwise.\r\n */\r\nfunction exactEquals(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7];\r\n}\r\n\r\n/**\r\n * Returns whether or not the dual quaternions have approximately the same elements in the same position.\r\n *\r\n * @param {quat2} a the first dual quat.\r\n * @param {quat2} b the second dual quat.\r\n * @returns {Boolean} true if the dual quats are equal, false otherwise.\r\n */\r\nfunction equals(a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3],\r\n      a4 = a[4],\r\n      a5 = a[5],\r\n      a6 = a[6],\r\n      a7 = a[7];\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3],\r\n      b4 = b[4],\r\n      b5 = b[5],\r\n      b6 = b[6],\r\n      b7 = b[7];\r\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a7), Math.abs(b7));\r\n}\n\n/***/ }),\n\n/***/ \"./node_modules/gl-matrix/lib/gl-matrix/vec2.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/gl-matrix/lib/gl-matrix/vec2.js ***!\n  \\******************************************************/\n/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, str, exactEquals, equals, len, sub, mul, div, dist, sqrDist, sqrLen, forEach */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"divide\", function() { return divide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ceil\", function() { return ceil; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"floor\", function() { return floor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"min\", function() { return min; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"max\", function() { return max; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"round\", function() { return round; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleAndAdd\", function() { return scaleAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return distance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredDistance\", function() { return squaredDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"negate\", function() { return negate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cross\", function() { return cross; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat2\", function() { return transformMat2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat2d\", function() { return transformMat2d; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat3\", function() { return transformMat3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat4\", function() { return transformMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotate\", function() { return rotate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"angle\", function() { return angle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"div\", function() { return div; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dist\", function() { return dist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrDist\", function() { return sqrDist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forEach\", function() { return forEach; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/lib/gl-matrix/common.js\");\n\r\n\r\n/**\r\n * 2 Dimensional Vector\r\n * @module vec2\r\n */\r\n\r\n/**\r\n * Creates a new, empty vec2\r\n *\r\n * @returns {vec2} a new 2D vector\r\n */\r\nfunction create() {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](2);\r\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\r\n    out[0] = 0;\r\n    out[1] = 0;\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new vec2 initialized with values from an existing vector\r\n *\r\n * @param {vec2} a vector to clone\r\n * @returns {vec2} a new 2D vector\r\n */\r\nfunction clone(a) {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](2);\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new vec2 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} a new 2D vector\r\n */\r\nfunction fromValues(x, y) {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](2);\r\n  out[0] = x;\r\n  out[1] = y;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copy the values from one vec2 to another\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the source vector\r\n * @returns {vec2} out\r\n */\r\nfunction copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set the components of a vec2 to the given values\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @returns {vec2} out\r\n */\r\nfunction set(out, x, y) {\r\n  out[0] = x;\r\n  out[1] = y;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\nfunction add(out, a, b) {\r\n  out[0] = a[0] + b[0];\r\n  out[1] = a[1] + b[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\nfunction subtract(out, a, b) {\r\n  out[0] = a[0] - b[0];\r\n  out[1] = a[1] - b[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Multiplies two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\nfunction multiply(out, a, b) {\r\n  out[0] = a[0] * b[0];\r\n  out[1] = a[1] * b[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Divides two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\nfunction divide(out, a, b) {\r\n  out[0] = a[0] / b[0];\r\n  out[1] = a[1] / b[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Math.ceil the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to ceil\r\n * @returns {vec2} out\r\n */\r\nfunction ceil(out, a) {\r\n  out[0] = Math.ceil(a[0]);\r\n  out[1] = Math.ceil(a[1]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Math.floor the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to floor\r\n * @returns {vec2} out\r\n */\r\nfunction floor(out, a) {\r\n  out[0] = Math.floor(a[0]);\r\n  out[1] = Math.floor(a[1]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the minimum of two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\nfunction min(out, a, b) {\r\n  out[0] = Math.min(a[0], b[0]);\r\n  out[1] = Math.min(a[1], b[1]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the maximum of two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec2} out\r\n */\r\nfunction max(out, a, b) {\r\n  out[0] = Math.max(a[0], b[0]);\r\n  out[1] = Math.max(a[1], b[1]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Math.round the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to round\r\n * @returns {vec2} out\r\n */\r\nfunction round(out, a) {\r\n  out[0] = Math.round(a[0]);\r\n  out[1] = Math.round(a[1]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Scales a vec2 by a scalar number\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec2} out\r\n */\r\nfunction scale(out, a, b) {\r\n  out[0] = a[0] * b;\r\n  out[1] = a[1] * b;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two vec2's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec2} out\r\n */\r\nfunction scaleAndAdd(out, a, b, scale) {\r\n  out[0] = a[0] + b[0] * scale;\r\n  out[1] = a[1] + b[1] * scale;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the euclidian distance between two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\r\nfunction distance(a, b) {\r\n  var x = b[0] - a[0],\r\n      y = b[1] - a[1];\r\n  return Math.sqrt(x * x + y * y);\r\n}\r\n\r\n/**\r\n * Calculates the squared euclidian distance between two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\r\nfunction squaredDistance(a, b) {\r\n  var x = b[0] - a[0],\r\n      y = b[1] - a[1];\r\n  return x * x + y * y;\r\n}\r\n\r\n/**\r\n * Calculates the length of a vec2\r\n *\r\n * @param {vec2} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\r\nfunction length(a) {\r\n  var x = a[0],\r\n      y = a[1];\r\n  return Math.sqrt(x * x + y * y);\r\n}\r\n\r\n/**\r\n * Calculates the squared length of a vec2\r\n *\r\n * @param {vec2} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\r\nfunction squaredLength(a) {\r\n  var x = a[0],\r\n      y = a[1];\r\n  return x * x + y * y;\r\n}\r\n\r\n/**\r\n * Negates the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to negate\r\n * @returns {vec2} out\r\n */\r\nfunction negate(out, a) {\r\n  out[0] = -a[0];\r\n  out[1] = -a[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the inverse of the components of a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to invert\r\n * @returns {vec2} out\r\n */\r\nfunction inverse(out, a) {\r\n  out[0] = 1.0 / a[0];\r\n  out[1] = 1.0 / a[1];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Normalize a vec2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a vector to normalize\r\n * @returns {vec2} out\r\n */\r\nfunction normalize(out, a) {\r\n  var x = a[0],\r\n      y = a[1];\r\n  var len = x * x + y * y;\r\n  if (len > 0) {\r\n    //TODO: evaluate use of glm_invsqrt here?\r\n    len = 1 / Math.sqrt(len);\r\n    out[0] = a[0] * len;\r\n    out[1] = a[1] * len;\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the dot product of two vec2's\r\n *\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\r\nfunction dot(a, b) {\r\n  return a[0] * b[0] + a[1] * b[1];\r\n}\r\n\r\n/**\r\n * Computes the cross product of two vec2's\r\n * Note that the cross product must by definition produce a 3D vector\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @returns {vec3} out\r\n */\r\nfunction cross(out, a, b) {\r\n  var z = a[0] * b[1] - a[1] * b[0];\r\n  out[0] = out[1] = 0;\r\n  out[2] = z;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Performs a linear interpolation between two vec2's\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the first operand\r\n * @param {vec2} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec2} out\r\n */\r\nfunction lerp(out, a, b, t) {\r\n  var ax = a[0],\r\n      ay = a[1];\r\n  out[0] = ax + t * (b[0] - ax);\r\n  out[1] = ay + t * (b[1] - ay);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec2} out\r\n */\r\nfunction random(out, scale) {\r\n  scale = scale || 1.0;\r\n  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2.0 * Math.PI;\r\n  out[0] = Math.cos(r) * scale;\r\n  out[1] = Math.sin(r) * scale;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec2 with a mat2\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat2} m matrix to transform with\r\n * @returns {vec2} out\r\n */\r\nfunction transformMat2(out, a, m) {\r\n  var x = a[0],\r\n      y = a[1];\r\n  out[0] = m[0] * x + m[2] * y;\r\n  out[1] = m[1] * x + m[3] * y;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec2 with a mat2d\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat2d} m matrix to transform with\r\n * @returns {vec2} out\r\n */\r\nfunction transformMat2d(out, a, m) {\r\n  var x = a[0],\r\n      y = a[1];\r\n  out[0] = m[0] * x + m[2] * y + m[4];\r\n  out[1] = m[1] * x + m[3] * y + m[5];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec2 with a mat3\r\n * 3rd vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat3} m matrix to transform with\r\n * @returns {vec2} out\r\n */\r\nfunction transformMat3(out, a, m) {\r\n  var x = a[0],\r\n      y = a[1];\r\n  out[0] = m[0] * x + m[3] * y + m[6];\r\n  out[1] = m[1] * x + m[4] * y + m[7];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec2 with a mat4\r\n * 3rd vector component is implicitly '0'\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec2} out the receiving vector\r\n * @param {vec2} a the vector to transform\r\n * @param {mat4} m matrix to transform with\r\n * @returns {vec2} out\r\n */\r\nfunction transformMat4(out, a, m) {\r\n  var x = a[0];\r\n  var y = a[1];\r\n  out[0] = m[0] * x + m[4] * y + m[12];\r\n  out[1] = m[1] * x + m[5] * y + m[13];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotate a 2D vector\r\n * @param {vec2} out The receiving vec2\r\n * @param {vec2} a The vec2 point to rotate\r\n * @param {vec2} b The origin of the rotation\r\n * @param {Number} c The angle of rotation\r\n * @returns {vec2} out\r\n */\r\nfunction rotate(out, a, b, c) {\r\n  //Translate point to the origin\r\n  var p0 = a[0] - b[0],\r\n      p1 = a[1] - b[1],\r\n      sinC = Math.sin(c),\r\n      cosC = Math.cos(c);\r\n\r\n  //perform rotation and translate to correct position\r\n  out[0] = p0 * cosC - p1 * sinC + b[0];\r\n  out[1] = p0 * sinC + p1 * cosC + b[1];\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Get the angle between two 2D vectors\r\n * @param {vec2} a The first operand\r\n * @param {vec2} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\r\nfunction angle(a, b) {\r\n  var x1 = a[0],\r\n      y1 = a[1],\r\n      x2 = b[0],\r\n      y2 = b[1];\r\n\r\n  var len1 = x1 * x1 + y1 * y1;\r\n  if (len1 > 0) {\r\n    //TODO: evaluate use of glm_invsqrt here?\r\n    len1 = 1 / Math.sqrt(len1);\r\n  }\r\n\r\n  var len2 = x2 * x2 + y2 * y2;\r\n  if (len2 > 0) {\r\n    //TODO: evaluate use of glm_invsqrt here?\r\n    len2 = 1 / Math.sqrt(len2);\r\n  }\r\n\r\n  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;\r\n\r\n  if (cosine > 1.0) {\r\n    return 0;\r\n  } else if (cosine < -1.0) {\r\n    return Math.PI;\r\n  } else {\r\n    return Math.acos(cosine);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {vec2} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\r\nfunction str(a) {\r\n  return 'vec2(' + a[0] + ', ' + a[1] + ')';\r\n}\r\n\r\n/**\r\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\r\n *\r\n * @param {vec2} a The first vector.\r\n * @param {vec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\nfunction exactEquals(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1];\r\n}\r\n\r\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {vec2} a The first vector.\r\n * @param {vec2} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\nfunction equals(a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1];\r\n  var b0 = b[0],\r\n      b1 = b[1];\r\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a1), Math.abs(b1));\r\n}\r\n\r\n/**\r\n * Alias for {@link vec2.length}\r\n * @function\r\n */\r\nvar len = length;\r\n\r\n/**\r\n * Alias for {@link vec2.subtract}\r\n * @function\r\n */\r\nvar sub = subtract;\r\n\r\n/**\r\n * Alias for {@link vec2.multiply}\r\n * @function\r\n */\r\nvar mul = multiply;\r\n\r\n/**\r\n * Alias for {@link vec2.divide}\r\n * @function\r\n */\r\nvar div = divide;\r\n\r\n/**\r\n * Alias for {@link vec2.distance}\r\n * @function\r\n */\r\nvar dist = distance;\r\n\r\n/**\r\n * Alias for {@link vec2.squaredDistance}\r\n * @function\r\n */\r\nvar sqrDist = squaredDistance;\r\n\r\n/**\r\n * Alias for {@link vec2.squaredLength}\r\n * @function\r\n */\r\nvar sqrLen = squaredLength;\r\n\r\n/**\r\n * Perform some operation over an array of vec2s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\r\nvar forEach = function () {\r\n  var vec = create();\r\n\r\n  return function (a, stride, offset, count, fn, arg) {\r\n    var i = void 0,\r\n        l = void 0;\r\n    if (!stride) {\r\n      stride = 2;\r\n    }\r\n\r\n    if (!offset) {\r\n      offset = 0;\r\n    }\r\n\r\n    if (count) {\r\n      l = Math.min(count * stride + offset, a.length);\r\n    } else {\r\n      l = a.length;\r\n    }\r\n\r\n    for (i = offset; i < l; i += stride) {\r\n      vec[0] = a[i];vec[1] = a[i + 1];\r\n      fn(vec, vec, arg);\r\n      a[i] = vec[0];a[i + 1] = vec[1];\r\n    }\r\n\r\n    return a;\r\n  };\r\n}();\n\n/***/ }),\n\n/***/ \"./node_modules/gl-matrix/lib/gl-matrix/vec3.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/gl-matrix/lib/gl-matrix/vec3.js ***!\n  \\******************************************************/\n/*! exports provided: create, clone, length, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, squaredLength, negate, inverse, normalize, dot, cross, lerp, hermite, bezier, random, transformMat4, transformMat3, transformQuat, rotateX, rotateY, rotateZ, angle, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"divide\", function() { return divide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ceil\", function() { return ceil; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"floor\", function() { return floor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"min\", function() { return min; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"max\", function() { return max; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"round\", function() { return round; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleAndAdd\", function() { return scaleAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return distance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredDistance\", function() { return squaredDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"negate\", function() { return negate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cross\", function() { return cross; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"hermite\", function() { return hermite; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bezier\", function() { return bezier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat4\", function() { return transformMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat3\", function() { return transformMat3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformQuat\", function() { return transformQuat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateX\", function() { return rotateX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateY\", function() { return rotateY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rotateZ\", function() { return rotateZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"angle\", function() { return angle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"div\", function() { return div; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dist\", function() { return dist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrDist\", function() { return sqrDist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forEach\", function() { return forEach; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/lib/gl-matrix/common.js\");\n\r\n\r\n/**\r\n * 3 Dimensional Vector\r\n * @module vec3\r\n */\r\n\r\n/**\r\n * Creates a new, empty vec3\r\n *\r\n * @returns {vec3} a new 3D vector\r\n */\r\nfunction create() {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\r\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\r\n    out[0] = 0;\r\n    out[1] = 0;\r\n    out[2] = 0;\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new vec3 initialized with values from an existing vector\r\n *\r\n * @param {vec3} a vector to clone\r\n * @returns {vec3} a new 3D vector\r\n */\r\nfunction clone(a) {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the length of a vec3\r\n *\r\n * @param {vec3} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\r\nfunction length(a) {\r\n  var x = a[0];\r\n  var y = a[1];\r\n  var z = a[2];\r\n  return Math.sqrt(x * x + y * y + z * z);\r\n}\r\n\r\n/**\r\n * Creates a new vec3 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} a new 3D vector\r\n */\r\nfunction fromValues(x, y, z) {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](3);\r\n  out[0] = x;\r\n  out[1] = y;\r\n  out[2] = z;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copy the values from one vec3 to another\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the source vector\r\n * @returns {vec3} out\r\n */\r\nfunction copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set the components of a vec3 to the given values\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @returns {vec3} out\r\n */\r\nfunction set(out, x, y, z) {\r\n  out[0] = x;\r\n  out[1] = y;\r\n  out[2] = z;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\nfunction add(out, a, b) {\r\n  out[0] = a[0] + b[0];\r\n  out[1] = a[1] + b[1];\r\n  out[2] = a[2] + b[2];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\nfunction subtract(out, a, b) {\r\n  out[0] = a[0] - b[0];\r\n  out[1] = a[1] - b[1];\r\n  out[2] = a[2] - b[2];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Multiplies two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\nfunction multiply(out, a, b) {\r\n  out[0] = a[0] * b[0];\r\n  out[1] = a[1] * b[1];\r\n  out[2] = a[2] * b[2];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Divides two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\nfunction divide(out, a, b) {\r\n  out[0] = a[0] / b[0];\r\n  out[1] = a[1] / b[1];\r\n  out[2] = a[2] / b[2];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Math.ceil the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to ceil\r\n * @returns {vec3} out\r\n */\r\nfunction ceil(out, a) {\r\n  out[0] = Math.ceil(a[0]);\r\n  out[1] = Math.ceil(a[1]);\r\n  out[2] = Math.ceil(a[2]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Math.floor the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to floor\r\n * @returns {vec3} out\r\n */\r\nfunction floor(out, a) {\r\n  out[0] = Math.floor(a[0]);\r\n  out[1] = Math.floor(a[1]);\r\n  out[2] = Math.floor(a[2]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the minimum of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\nfunction min(out, a, b) {\r\n  out[0] = Math.min(a[0], b[0]);\r\n  out[1] = Math.min(a[1], b[1]);\r\n  out[2] = Math.min(a[2], b[2]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the maximum of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\nfunction max(out, a, b) {\r\n  out[0] = Math.max(a[0], b[0]);\r\n  out[1] = Math.max(a[1], b[1]);\r\n  out[2] = Math.max(a[2], b[2]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Math.round the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to round\r\n * @returns {vec3} out\r\n */\r\nfunction round(out, a) {\r\n  out[0] = Math.round(a[0]);\r\n  out[1] = Math.round(a[1]);\r\n  out[2] = Math.round(a[2]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Scales a vec3 by a scalar number\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec3} out\r\n */\r\nfunction scale(out, a, b) {\r\n  out[0] = a[0] * b;\r\n  out[1] = a[1] * b;\r\n  out[2] = a[2] * b;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two vec3's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec3} out\r\n */\r\nfunction scaleAndAdd(out, a, b, scale) {\r\n  out[0] = a[0] + b[0] * scale;\r\n  out[1] = a[1] + b[1] * scale;\r\n  out[2] = a[2] + b[2] * scale;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the euclidian distance between two vec3's\r\n *\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\r\nfunction distance(a, b) {\r\n  var x = b[0] - a[0];\r\n  var y = b[1] - a[1];\r\n  var z = b[2] - a[2];\r\n  return Math.sqrt(x * x + y * y + z * z);\r\n}\r\n\r\n/**\r\n * Calculates the squared euclidian distance between two vec3's\r\n *\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\r\nfunction squaredDistance(a, b) {\r\n  var x = b[0] - a[0];\r\n  var y = b[1] - a[1];\r\n  var z = b[2] - a[2];\r\n  return x * x + y * y + z * z;\r\n}\r\n\r\n/**\r\n * Calculates the squared length of a vec3\r\n *\r\n * @param {vec3} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\r\nfunction squaredLength(a) {\r\n  var x = a[0];\r\n  var y = a[1];\r\n  var z = a[2];\r\n  return x * x + y * y + z * z;\r\n}\r\n\r\n/**\r\n * Negates the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to negate\r\n * @returns {vec3} out\r\n */\r\nfunction negate(out, a) {\r\n  out[0] = -a[0];\r\n  out[1] = -a[1];\r\n  out[2] = -a[2];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the inverse of the components of a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to invert\r\n * @returns {vec3} out\r\n */\r\nfunction inverse(out, a) {\r\n  out[0] = 1.0 / a[0];\r\n  out[1] = 1.0 / a[1];\r\n  out[2] = 1.0 / a[2];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Normalize a vec3\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a vector to normalize\r\n * @returns {vec3} out\r\n */\r\nfunction normalize(out, a) {\r\n  var x = a[0];\r\n  var y = a[1];\r\n  var z = a[2];\r\n  var len = x * x + y * y + z * z;\r\n  if (len > 0) {\r\n    //TODO: evaluate use of glm_invsqrt here?\r\n    len = 1 / Math.sqrt(len);\r\n    out[0] = a[0] * len;\r\n    out[1] = a[1] * len;\r\n    out[2] = a[2] * len;\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the dot product of two vec3's\r\n *\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\r\nfunction dot(a, b) {\r\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\r\n}\r\n\r\n/**\r\n * Computes the cross product of two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @returns {vec3} out\r\n */\r\nfunction cross(out, a, b) {\r\n  var ax = a[0],\r\n      ay = a[1],\r\n      az = a[2];\r\n  var bx = b[0],\r\n      by = b[1],\r\n      bz = b[2];\r\n\r\n  out[0] = ay * bz - az * by;\r\n  out[1] = az * bx - ax * bz;\r\n  out[2] = ax * by - ay * bx;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Performs a linear interpolation between two vec3's\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\r\nfunction lerp(out, a, b, t) {\r\n  var ax = a[0];\r\n  var ay = a[1];\r\n  var az = a[2];\r\n  out[0] = ax + t * (b[0] - ax);\r\n  out[1] = ay + t * (b[1] - ay);\r\n  out[2] = az + t * (b[2] - az);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Performs a hermite interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @param {vec3} c the third operand\r\n * @param {vec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\r\nfunction hermite(out, a, b, c, d, t) {\r\n  var factorTimes2 = t * t;\r\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\r\n  var factor2 = factorTimes2 * (t - 2) + t;\r\n  var factor3 = factorTimes2 * (t - 1);\r\n  var factor4 = factorTimes2 * (3 - 2 * t);\r\n\r\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\r\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\r\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Performs a bezier interpolation with two control points\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the first operand\r\n * @param {vec3} b the second operand\r\n * @param {vec3} c the third operand\r\n * @param {vec3} d the fourth operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec3} out\r\n */\r\nfunction bezier(out, a, b, c, d, t) {\r\n  var inverseFactor = 1 - t;\r\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\r\n  var factorTimes2 = t * t;\r\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\r\n  var factor2 = 3 * t * inverseFactorTimesTwo;\r\n  var factor3 = 3 * factorTimes2 * inverseFactor;\r\n  var factor4 = factorTimes2 * t;\r\n\r\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\r\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\r\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec3} out\r\n */\r\nfunction random(out, scale) {\r\n  scale = scale || 1.0;\r\n\r\n  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2.0 * Math.PI;\r\n  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2.0 - 1.0;\r\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\r\n\r\n  out[0] = Math.cos(r) * zScale;\r\n  out[1] = Math.sin(r) * zScale;\r\n  out[2] = z * scale;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec3 with a mat4.\r\n * 4th vector component is implicitly '1'\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to transform\r\n * @param {mat4} m matrix to transform with\r\n * @returns {vec3} out\r\n */\r\nfunction transformMat4(out, a, m) {\r\n  var x = a[0],\r\n      y = a[1],\r\n      z = a[2];\r\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\r\n  w = w || 1.0;\r\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\r\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\r\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec3 with a mat3.\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to transform\r\n * @param {mat3} m the 3x3 matrix to transform with\r\n * @returns {vec3} out\r\n */\r\nfunction transformMat3(out, a, m) {\r\n  var x = a[0],\r\n      y = a[1],\r\n      z = a[2];\r\n  out[0] = x * m[0] + y * m[3] + z * m[6];\r\n  out[1] = x * m[1] + y * m[4] + z * m[7];\r\n  out[2] = x * m[2] + y * m[5] + z * m[8];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec3 with a quat\r\n * Can also be used for dual quaternions. (Multiply it with the real part)\r\n *\r\n * @param {vec3} out the receiving vector\r\n * @param {vec3} a the vector to transform\r\n * @param {quat} q quaternion to transform with\r\n * @returns {vec3} out\r\n */\r\nfunction transformQuat(out, a, q) {\r\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\r\n  var qx = q[0],\r\n      qy = q[1],\r\n      qz = q[2],\r\n      qw = q[3];\r\n  var x = a[0],\r\n      y = a[1],\r\n      z = a[2];\r\n  // var qvec = [qx, qy, qz];\r\n  // var uv = vec3.cross([], qvec, a);\r\n  var uvx = qy * z - qz * y,\r\n      uvy = qz * x - qx * z,\r\n      uvz = qx * y - qy * x;\r\n  // var uuv = vec3.cross([], qvec, uv);\r\n  var uuvx = qy * uvz - qz * uvy,\r\n      uuvy = qz * uvx - qx * uvz,\r\n      uuvz = qx * uvy - qy * uvx;\r\n  // vec3.scale(uv, uv, 2 * w);\r\n  var w2 = qw * 2;\r\n  uvx *= w2;\r\n  uvy *= w2;\r\n  uvz *= w2;\r\n  // vec3.scale(uuv, uuv, 2);\r\n  uuvx *= 2;\r\n  uuvy *= 2;\r\n  uuvz *= 2;\r\n  // return vec3.add(out, a, vec3.add(out, uv, uuv));\r\n  out[0] = x + uvx + uuvx;\r\n  out[1] = y + uvy + uuvy;\r\n  out[2] = z + uvz + uuvz;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotate a 3D vector around the x-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {vec3} a The vec3 point to rotate\r\n * @param {vec3} b The origin of the rotation\r\n * @param {Number} c The angle of rotation\r\n * @returns {vec3} out\r\n */\r\nfunction rotateX(out, a, b, c) {\r\n  var p = [],\r\n      r = [];\r\n  //Translate point to the origin\r\n  p[0] = a[0] - b[0];\r\n  p[1] = a[1] - b[1];\r\n  p[2] = a[2] - b[2];\r\n\r\n  //perform rotation\r\n  r[0] = p[0];\r\n  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);\r\n  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);\r\n\r\n  //translate to correct position\r\n  out[0] = r[0] + b[0];\r\n  out[1] = r[1] + b[1];\r\n  out[2] = r[2] + b[2];\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotate a 3D vector around the y-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {vec3} a The vec3 point to rotate\r\n * @param {vec3} b The origin of the rotation\r\n * @param {Number} c The angle of rotation\r\n * @returns {vec3} out\r\n */\r\nfunction rotateY(out, a, b, c) {\r\n  var p = [],\r\n      r = [];\r\n  //Translate point to the origin\r\n  p[0] = a[0] - b[0];\r\n  p[1] = a[1] - b[1];\r\n  p[2] = a[2] - b[2];\r\n\r\n  //perform rotation\r\n  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);\r\n  r[1] = p[1];\r\n  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);\r\n\r\n  //translate to correct position\r\n  out[0] = r[0] + b[0];\r\n  out[1] = r[1] + b[1];\r\n  out[2] = r[2] + b[2];\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Rotate a 3D vector around the z-axis\r\n * @param {vec3} out The receiving vec3\r\n * @param {vec3} a The vec3 point to rotate\r\n * @param {vec3} b The origin of the rotation\r\n * @param {Number} c The angle of rotation\r\n * @returns {vec3} out\r\n */\r\nfunction rotateZ(out, a, b, c) {\r\n  var p = [],\r\n      r = [];\r\n  //Translate point to the origin\r\n  p[0] = a[0] - b[0];\r\n  p[1] = a[1] - b[1];\r\n  p[2] = a[2] - b[2];\r\n\r\n  //perform rotation\r\n  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);\r\n  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);\r\n  r[2] = p[2];\r\n\r\n  //translate to correct position\r\n  out[0] = r[0] + b[0];\r\n  out[1] = r[1] + b[1];\r\n  out[2] = r[2] + b[2];\r\n\r\n  return out;\r\n}\r\n\r\n/**\r\n * Get the angle between two 3D vectors\r\n * @param {vec3} a The first operand\r\n * @param {vec3} b The second operand\r\n * @returns {Number} The angle in radians\r\n */\r\nfunction angle(a, b) {\r\n  var tempA = fromValues(a[0], a[1], a[2]);\r\n  var tempB = fromValues(b[0], b[1], b[2]);\r\n\r\n  normalize(tempA, tempA);\r\n  normalize(tempB, tempB);\r\n\r\n  var cosine = dot(tempA, tempB);\r\n\r\n  if (cosine > 1.0) {\r\n    return 0;\r\n  } else if (cosine < -1.0) {\r\n    return Math.PI;\r\n  } else {\r\n    return Math.acos(cosine);\r\n  }\r\n}\r\n\r\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {vec3} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\r\nfunction str(a) {\r\n  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';\r\n}\r\n\r\n/**\r\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {vec3} a The first vector.\r\n * @param {vec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\nfunction exactEquals(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\r\n}\r\n\r\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {vec3} a The first vector.\r\n * @param {vec3} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\nfunction equals(a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2];\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2];\r\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a2), Math.abs(b2));\r\n}\r\n\r\n/**\r\n * Alias for {@link vec3.subtract}\r\n * @function\r\n */\r\nvar sub = subtract;\r\n\r\n/**\r\n * Alias for {@link vec3.multiply}\r\n * @function\r\n */\r\nvar mul = multiply;\r\n\r\n/**\r\n * Alias for {@link vec3.divide}\r\n * @function\r\n */\r\nvar div = divide;\r\n\r\n/**\r\n * Alias for {@link vec3.distance}\r\n * @function\r\n */\r\nvar dist = distance;\r\n\r\n/**\r\n * Alias for {@link vec3.squaredDistance}\r\n * @function\r\n */\r\nvar sqrDist = squaredDistance;\r\n\r\n/**\r\n * Alias for {@link vec3.length}\r\n * @function\r\n */\r\nvar len = length;\r\n\r\n/**\r\n * Alias for {@link vec3.squaredLength}\r\n * @function\r\n */\r\nvar sqrLen = squaredLength;\r\n\r\n/**\r\n * Perform some operation over an array of vec3s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\r\nvar forEach = function () {\r\n  var vec = create();\r\n\r\n  return function (a, stride, offset, count, fn, arg) {\r\n    var i = void 0,\r\n        l = void 0;\r\n    if (!stride) {\r\n      stride = 3;\r\n    }\r\n\r\n    if (!offset) {\r\n      offset = 0;\r\n    }\r\n\r\n    if (count) {\r\n      l = Math.min(count * stride + offset, a.length);\r\n    } else {\r\n      l = a.length;\r\n    }\r\n\r\n    for (i = offset; i < l; i += stride) {\r\n      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];\r\n      fn(vec, vec, arg);\r\n      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];\r\n    }\r\n\r\n    return a;\r\n  };\r\n}();\n\n/***/ }),\n\n/***/ \"./node_modules/gl-matrix/lib/gl-matrix/vec4.js\":\n/*!******************************************************!*\\\n  !*** ./node_modules/gl-matrix/lib/gl-matrix/vec4.js ***!\n  \\******************************************************/\n/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, lerp, random, transformMat4, transformQuat, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"create\", function() { return create; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clone\", function() { return clone; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromValues\", function() { return fromValues; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"copy\", function() { return copy; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"set\", function() { return set; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"add\", function() { return add; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"subtract\", function() { return subtract; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"multiply\", function() { return multiply; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"divide\", function() { return divide; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ceil\", function() { return ceil; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"floor\", function() { return floor; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"min\", function() { return min; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"max\", function() { return max; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"round\", function() { return round; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scale\", function() { return scale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"scaleAndAdd\", function() { return scaleAndAdd; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"distance\", function() { return distance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredDistance\", function() { return squaredDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"length\", function() { return length; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"squaredLength\", function() { return squaredLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"negate\", function() { return negate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"inverse\", function() { return inverse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lerp\", function() { return lerp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"random\", function() { return random; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformMat4\", function() { return transformMat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"transformQuat\", function() { return transformQuat; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"str\", function() { return str; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"exactEquals\", function() { return exactEquals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equals\", function() { return equals; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mul\", function() { return mul; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"div\", function() { return div; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dist\", function() { return dist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrDist\", function() { return sqrDist; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"len\", function() { return len; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sqrLen\", function() { return sqrLen; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"forEach\", function() { return forEach; });\n/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ \"./node_modules/gl-matrix/lib/gl-matrix/common.js\");\n\r\n\r\n/**\r\n * 4 Dimensional Vector\r\n * @module vec4\r\n */\r\n\r\n/**\r\n * Creates a new, empty vec4\r\n *\r\n * @returns {vec4} a new 4D vector\r\n */\r\nfunction create() {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\r\n  if (_common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"] != Float32Array) {\r\n    out[0] = 0;\r\n    out[1] = 0;\r\n    out[2] = 0;\r\n    out[3] = 0;\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new vec4 initialized with values from an existing vector\r\n *\r\n * @param {vec4} a vector to clone\r\n * @returns {vec4} a new 4D vector\r\n */\r\nfunction clone(a) {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Creates a new vec4 initialized with the given values\r\n *\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {vec4} a new 4D vector\r\n */\r\nfunction fromValues(x, y, z, w) {\r\n  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__[\"ARRAY_TYPE\"](4);\r\n  out[0] = x;\r\n  out[1] = y;\r\n  out[2] = z;\r\n  out[3] = w;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Copy the values from one vec4 to another\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the source vector\r\n * @returns {vec4} out\r\n */\r\nfunction copy(out, a) {\r\n  out[0] = a[0];\r\n  out[1] = a[1];\r\n  out[2] = a[2];\r\n  out[3] = a[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Set the components of a vec4 to the given values\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {Number} x X component\r\n * @param {Number} y Y component\r\n * @param {Number} z Z component\r\n * @param {Number} w W component\r\n * @returns {vec4} out\r\n */\r\nfunction set(out, x, y, z, w) {\r\n  out[0] = x;\r\n  out[1] = y;\r\n  out[2] = z;\r\n  out[3] = w;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\r\nfunction add(out, a, b) {\r\n  out[0] = a[0] + b[0];\r\n  out[1] = a[1] + b[1];\r\n  out[2] = a[2] + b[2];\r\n  out[3] = a[3] + b[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Subtracts vector b from vector a\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\r\nfunction subtract(out, a, b) {\r\n  out[0] = a[0] - b[0];\r\n  out[1] = a[1] - b[1];\r\n  out[2] = a[2] - b[2];\r\n  out[3] = a[3] - b[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Multiplies two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\r\nfunction multiply(out, a, b) {\r\n  out[0] = a[0] * b[0];\r\n  out[1] = a[1] * b[1];\r\n  out[2] = a[2] * b[2];\r\n  out[3] = a[3] * b[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Divides two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\r\nfunction divide(out, a, b) {\r\n  out[0] = a[0] / b[0];\r\n  out[1] = a[1] / b[1];\r\n  out[2] = a[2] / b[2];\r\n  out[3] = a[3] / b[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Math.ceil the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to ceil\r\n * @returns {vec4} out\r\n */\r\nfunction ceil(out, a) {\r\n  out[0] = Math.ceil(a[0]);\r\n  out[1] = Math.ceil(a[1]);\r\n  out[2] = Math.ceil(a[2]);\r\n  out[3] = Math.ceil(a[3]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Math.floor the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to floor\r\n * @returns {vec4} out\r\n */\r\nfunction floor(out, a) {\r\n  out[0] = Math.floor(a[0]);\r\n  out[1] = Math.floor(a[1]);\r\n  out[2] = Math.floor(a[2]);\r\n  out[3] = Math.floor(a[3]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the minimum of two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\r\nfunction min(out, a, b) {\r\n  out[0] = Math.min(a[0], b[0]);\r\n  out[1] = Math.min(a[1], b[1]);\r\n  out[2] = Math.min(a[2], b[2]);\r\n  out[3] = Math.min(a[3], b[3]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the maximum of two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {vec4} out\r\n */\r\nfunction max(out, a, b) {\r\n  out[0] = Math.max(a[0], b[0]);\r\n  out[1] = Math.max(a[1], b[1]);\r\n  out[2] = Math.max(a[2], b[2]);\r\n  out[3] = Math.max(a[3], b[3]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Math.round the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to round\r\n * @returns {vec4} out\r\n */\r\nfunction round(out, a) {\r\n  out[0] = Math.round(a[0]);\r\n  out[1] = Math.round(a[1]);\r\n  out[2] = Math.round(a[2]);\r\n  out[3] = Math.round(a[3]);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Scales a vec4 by a scalar number\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the vector to scale\r\n * @param {Number} b amount to scale the vector by\r\n * @returns {vec4} out\r\n */\r\nfunction scale(out, a, b) {\r\n  out[0] = a[0] * b;\r\n  out[1] = a[1] * b;\r\n  out[2] = a[2] * b;\r\n  out[3] = a[3] * b;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Adds two vec4's after scaling the second operand by a scalar value\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @param {Number} scale the amount to scale b by before adding\r\n * @returns {vec4} out\r\n */\r\nfunction scaleAndAdd(out, a, b, scale) {\r\n  out[0] = a[0] + b[0] * scale;\r\n  out[1] = a[1] + b[1] * scale;\r\n  out[2] = a[2] + b[2] * scale;\r\n  out[3] = a[3] + b[3] * scale;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the euclidian distance between two vec4's\r\n *\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {Number} distance between a and b\r\n */\r\nfunction distance(a, b) {\r\n  var x = b[0] - a[0];\r\n  var y = b[1] - a[1];\r\n  var z = b[2] - a[2];\r\n  var w = b[3] - a[3];\r\n  return Math.sqrt(x * x + y * y + z * z + w * w);\r\n}\r\n\r\n/**\r\n * Calculates the squared euclidian distance between two vec4's\r\n *\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {Number} squared distance between a and b\r\n */\r\nfunction squaredDistance(a, b) {\r\n  var x = b[0] - a[0];\r\n  var y = b[1] - a[1];\r\n  var z = b[2] - a[2];\r\n  var w = b[3] - a[3];\r\n  return x * x + y * y + z * z + w * w;\r\n}\r\n\r\n/**\r\n * Calculates the length of a vec4\r\n *\r\n * @param {vec4} a vector to calculate length of\r\n * @returns {Number} length of a\r\n */\r\nfunction length(a) {\r\n  var x = a[0];\r\n  var y = a[1];\r\n  var z = a[2];\r\n  var w = a[3];\r\n  return Math.sqrt(x * x + y * y + z * z + w * w);\r\n}\r\n\r\n/**\r\n * Calculates the squared length of a vec4\r\n *\r\n * @param {vec4} a vector to calculate squared length of\r\n * @returns {Number} squared length of a\r\n */\r\nfunction squaredLength(a) {\r\n  var x = a[0];\r\n  var y = a[1];\r\n  var z = a[2];\r\n  var w = a[3];\r\n  return x * x + y * y + z * z + w * w;\r\n}\r\n\r\n/**\r\n * Negates the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to negate\r\n * @returns {vec4} out\r\n */\r\nfunction negate(out, a) {\r\n  out[0] = -a[0];\r\n  out[1] = -a[1];\r\n  out[2] = -a[2];\r\n  out[3] = -a[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns the inverse of the components of a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to invert\r\n * @returns {vec4} out\r\n */\r\nfunction inverse(out, a) {\r\n  out[0] = 1.0 / a[0];\r\n  out[1] = 1.0 / a[1];\r\n  out[2] = 1.0 / a[2];\r\n  out[3] = 1.0 / a[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Normalize a vec4\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a vector to normalize\r\n * @returns {vec4} out\r\n */\r\nfunction normalize(out, a) {\r\n  var x = a[0];\r\n  var y = a[1];\r\n  var z = a[2];\r\n  var w = a[3];\r\n  var len = x * x + y * y + z * z + w * w;\r\n  if (len > 0) {\r\n    len = 1 / Math.sqrt(len);\r\n    out[0] = x * len;\r\n    out[1] = y * len;\r\n    out[2] = z * len;\r\n    out[3] = w * len;\r\n  }\r\n  return out;\r\n}\r\n\r\n/**\r\n * Calculates the dot product of two vec4's\r\n *\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @returns {Number} dot product of a and b\r\n */\r\nfunction dot(a, b) {\r\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\r\n}\r\n\r\n/**\r\n * Performs a linear interpolation between two vec4's\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the first operand\r\n * @param {vec4} b the second operand\r\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\r\n * @returns {vec4} out\r\n */\r\nfunction lerp(out, a, b, t) {\r\n  var ax = a[0];\r\n  var ay = a[1];\r\n  var az = a[2];\r\n  var aw = a[3];\r\n  out[0] = ax + t * (b[0] - ax);\r\n  out[1] = ay + t * (b[1] - ay);\r\n  out[2] = az + t * (b[2] - az);\r\n  out[3] = aw + t * (b[3] - aw);\r\n  return out;\r\n}\r\n\r\n/**\r\n * Generates a random vector with the given scale\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\r\n * @returns {vec4} out\r\n */\r\nfunction random(out, scale) {\r\n  scale = scale || 1.0;\r\n\r\n  // Marsaglia, George. Choosing a Point from the Surface of a\r\n  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.\r\n  // http://projecteuclid.org/euclid.aoms/1177692644;\r\n  var v1, v2, v3, v4;\r\n  var s1, s2;\r\n  do {\r\n    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2 - 1;\r\n    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2 - 1;\r\n    s1 = v1 * v1 + v2 * v2;\r\n  } while (s1 >= 1);\r\n  do {\r\n    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2 - 1;\r\n    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__[\"RANDOM\"]() * 2 - 1;\r\n    s2 = v3 * v3 + v4 * v4;\r\n  } while (s2 >= 1);\r\n\r\n  var d = Math.sqrt((1 - s1) / s2);\r\n  out[0] = scale * v1;\r\n  out[1] = scale * v2;\r\n  out[2] = scale * v3 * d;\r\n  out[3] = scale * v4 * d;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec4 with a mat4.\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the vector to transform\r\n * @param {mat4} m matrix to transform with\r\n * @returns {vec4} out\r\n */\r\nfunction transformMat4(out, a, m) {\r\n  var x = a[0],\r\n      y = a[1],\r\n      z = a[2],\r\n      w = a[3];\r\n  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\r\n  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\r\n  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\r\n  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\r\n  return out;\r\n}\r\n\r\n/**\r\n * Transforms the vec4 with a quat\r\n *\r\n * @param {vec4} out the receiving vector\r\n * @param {vec4} a the vector to transform\r\n * @param {quat} q quaternion to transform with\r\n * @returns {vec4} out\r\n */\r\nfunction transformQuat(out, a, q) {\r\n  var x = a[0],\r\n      y = a[1],\r\n      z = a[2];\r\n  var qx = q[0],\r\n      qy = q[1],\r\n      qz = q[2],\r\n      qw = q[3];\r\n\r\n  // calculate quat * vec\r\n  var ix = qw * x + qy * z - qz * y;\r\n  var iy = qw * y + qz * x - qx * z;\r\n  var iz = qw * z + qx * y - qy * x;\r\n  var iw = -qx * x - qy * y - qz * z;\r\n\r\n  // calculate result * inverse quat\r\n  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\r\n  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\r\n  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\r\n  out[3] = a[3];\r\n  return out;\r\n}\r\n\r\n/**\r\n * Returns a string representation of a vector\r\n *\r\n * @param {vec4} a vector to represent as a string\r\n * @returns {String} string representation of the vector\r\n */\r\nfunction str(a) {\r\n  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\r\n}\r\n\r\n/**\r\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\r\n *\r\n * @param {vec4} a The first vector.\r\n * @param {vec4} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\nfunction exactEquals(a, b) {\r\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];\r\n}\r\n\r\n/**\r\n * Returns whether or not the vectors have approximately the same elements in the same position.\r\n *\r\n * @param {vec4} a The first vector.\r\n * @param {vec4} b The second vector.\r\n * @returns {Boolean} True if the vectors are equal, false otherwise.\r\n */\r\nfunction equals(a, b) {\r\n  var a0 = a[0],\r\n      a1 = a[1],\r\n      a2 = a[2],\r\n      a3 = a[3];\r\n  var b0 = b[0],\r\n      b1 = b[1],\r\n      b2 = b[2],\r\n      b3 = b[3];\r\n  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__[\"EPSILON\"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));\r\n}\r\n\r\n/**\r\n * Alias for {@link vec4.subtract}\r\n * @function\r\n */\r\nvar sub = subtract;\r\n\r\n/**\r\n * Alias for {@link vec4.multiply}\r\n * @function\r\n */\r\nvar mul = multiply;\r\n\r\n/**\r\n * Alias for {@link vec4.divide}\r\n * @function\r\n */\r\nvar div = divide;\r\n\r\n/**\r\n * Alias for {@link vec4.distance}\r\n * @function\r\n */\r\nvar dist = distance;\r\n\r\n/**\r\n * Alias for {@link vec4.squaredDistance}\r\n * @function\r\n */\r\nvar sqrDist = squaredDistance;\r\n\r\n/**\r\n * Alias for {@link vec4.length}\r\n * @function\r\n */\r\nvar len = length;\r\n\r\n/**\r\n * Alias for {@link vec4.squaredLength}\r\n * @function\r\n */\r\nvar sqrLen = squaredLength;\r\n\r\n/**\r\n * Perform some operation over an array of vec4s.\r\n *\r\n * @param {Array} a the array of vectors to iterate over\r\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\r\n * @param {Number} offset Number of elements to skip at the beginning of the array\r\n * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array\r\n * @param {Function} fn Function to call for each vector in the array\r\n * @param {Object} [arg] additional argument to pass to fn\r\n * @returns {Array} a\r\n * @function\r\n */\r\nvar forEach = function () {\r\n  var vec = create();\r\n\r\n  return function (a, stride, offset, count, fn, arg) {\r\n    var i = void 0,\r\n        l = void 0;\r\n    if (!stride) {\r\n      stride = 4;\r\n    }\r\n\r\n    if (!offset) {\r\n      offset = 0;\r\n    }\r\n\r\n    if (count) {\r\n      l = Math.min(count * stride + offset, a.length);\r\n    } else {\r\n      l = a.length;\r\n    }\r\n\r\n    for (i = offset; i < l; i += stride) {\r\n      vec[0] = a[i];vec[1] = a[i + 1];vec[2] = a[i + 2];vec[3] = a[i + 3];\r\n      fn(vec, vec, arg);\r\n      a[i] = vec[0];a[i + 1] = vec[1];a[i + 2] = vec[2];a[i + 3] = vec[3];\r\n    }\r\n\r\n    return a;\r\n  };\r\n}();\n\n/***/ }),\n\n/***/ \"./node_modules/ieee754/index.js\":\n/*!***************************************!*\\\n  !*** ./node_modules/ieee754/index.js ***!\n  \\***************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n/***/ }),\n\n/***/ \"./node_modules/pako/index.js\":\n/*!************************************!*\\\n  !*** ./node_modules/pako/index.js ***!\n  \\************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// Top level file is just a mixin of submodules & constants\n\n\nvar assign    = __webpack_require__(/*! ./lib/utils/common */ \"./node_modules/pako/lib/utils/common.js\").assign;\n\nvar deflate   = __webpack_require__(/*! ./lib/deflate */ \"./node_modules/pako/lib/deflate.js\");\nvar inflate   = __webpack_require__(/*! ./lib/inflate */ \"./node_modules/pako/lib/inflate.js\");\nvar constants = __webpack_require__(/*! ./lib/zlib/constants */ \"./node_modules/pako/lib/zlib/constants.js\");\n\nvar pako = {};\n\nassign(pako, deflate, inflate, constants);\n\nmodule.exports = pako;\n\n\n/***/ }),\n\n/***/ \"./node_modules/pako/lib/deflate.js\":\n/*!******************************************!*\\\n  !*** ./node_modules/pako/lib/deflate.js ***!\n  \\******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\nvar zlib_deflate = __webpack_require__(/*! ./zlib/deflate */ \"./node_modules/pako/lib/zlib/deflate.js\");\nvar utils        = __webpack_require__(/*! ./utils/common */ \"./node_modules/pako/lib/utils/common.js\");\nvar strings      = __webpack_require__(/*! ./utils/strings */ \"./node_modules/pako/lib/utils/strings.js\");\nvar msg          = __webpack_require__(/*! ./zlib/messages */ \"./node_modules/pako/lib/zlib/messages.js\");\nvar ZStream      = __webpack_require__(/*! ./zlib/zstream */ \"./node_modules/pako/lib/zlib/zstream.js\");\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n\n\n/***/ }),\n\n/***/ \"./node_modules/pako/lib/inflate.js\":\n/*!******************************************!*\\\n  !*** ./node_modules/pako/lib/inflate.js ***!\n  \\******************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\nvar zlib_inflate = __webpack_require__(/*! ./zlib/inflate */ \"./node_modules/pako/lib/zlib/inflate.js\");\nvar utils        = __webpack_require__(/*! ./utils/common */ \"./node_modules/pako/lib/utils/common.js\");\nvar strings      = __webpack_require__(/*! ./utils/strings */ \"./node_modules/pako/lib/utils/strings.js\");\nvar c            = __webpack_require__(/*! ./zlib/constants */ \"./node_modules/pako/lib/zlib/constants.js\");\nvar msg          = __webpack_require__(/*! ./zlib/messages */ \"./node_modules/pako/lib/zlib/messages.js\");\nvar ZStream      = __webpack_require__(/*! ./zlib/zstream */ \"./node_modules/pako/lib/zlib/zstream.js\");\nvar GZheader     = __webpack_require__(/*! ./zlib/gzheader */ \"./node_modules/pako/lib/zlib/gzheader.js\");\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overridden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n\n  // Setup dictionary\n  if (opt.dictionary) {\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) { //In raw mode we need to set the dictionary early\n      status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== c.Z_OK) {\n        throw new Error(msg[status]);\n      }\n    }\n  }\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): output data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 aligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n\n\n/***/ }),\n\n/***/ \"./node_modules/pako/lib/utils/common.js\":\n/*!***********************************************!*\\\n  !*** ./node_modules/pako/lib/utils/common.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\nfunction _has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n\n\n/***/ }),\n\n/***/ \"./node_modules/pako/lib/utils/strings.js\":\n/*!************************************************!*\\\n  !*** ./node_modules/pako/lib/utils/strings.js ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n// String encode/decode helpers\n\n\n\nvar utils = __webpack_require__(/*! ./common */ \"./node_modules/pako/lib/utils/common.js\");\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safari\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // On Chrome, the arguments in a function call that are allowed is `65534`.\n  // If the length of the buffer is smaller than that, we can use this optimization,\n  // otherwise we will take a slower path.\n  if (len < 65534) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means buffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/pako/lib/zlib/adler32.js\":\n/*!***********************************************!*\\\n  !*** ./node_modules/pako/lib/zlib/adler32.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It isn't worth it to make additional optimizations as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n\n\n/***/ }),\n\n/***/ \"./node_modules/pako/lib/zlib/constants.js\":\n/*!*************************************************!*\\\n  !*** ./node_modules/pako/lib/zlib/constants.js ***!\n  \\*************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/pako/lib/zlib/crc32.js\":\n/*!*********************************************!*\\\n  !*** ./node_modules/pako/lib/zlib/crc32.js ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n\n\n/***/ }),\n\n/***/ \"./node_modules/pako/lib/zlib/deflate.js\":\n/*!***********************************************!*\\\n  !*** ./node_modules/pako/lib/zlib/deflate.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\nvar trees   = __webpack_require__(/*! ./trees */ \"./node_modules/pako/lib/zlib/trees.js\");\nvar adler32 = __webpack_require__(/*! ./adler32 */ \"./node_modules/pako/lib/zlib/adler32.js\");\nvar crc32   = __webpack_require__(/*! ./crc32 */ \"./node_modules/pako/lib/zlib/crc32.js\");\nvar msg     = __webpack_require__(/*! ./messages */ \"./node_modules/pako/lib/zlib/messages.js\");\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n        );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n\n\n/***/ }),\n\n/***/ \"./node_modules/pako/lib/zlib/gzheader.js\":\n/*!************************************************!*\\\n  !*** ./node_modules/pako/lib/zlib/gzheader.js ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n\n\n/***/ }),\n\n/***/ \"./node_modules/pako/lib/zlib/inffast.js\":\n/*!***********************************************!*\\\n  !*** ./node_modules/pako/lib/zlib/inffast.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/pako/lib/zlib/inflate.js\":\n/*!***********************************************!*\\\n  !*** ./node_modules/pako/lib/zlib/inflate.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils         = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\nvar adler32       = __webpack_require__(/*! ./adler32 */ \"./node_modules/pako/lib/zlib/adler32.js\");\nvar crc32         = __webpack_require__(/*! ./crc32 */ \"./node_modules/pako/lib/zlib/crc32.js\");\nvar inflate_fast  = __webpack_require__(/*! ./inffast */ \"./node_modules/pako/lib/zlib/inffast.js\");\nvar inflate_table = __webpack_require__(/*! ./inftrees */ \"./node_modules/pako/lib/zlib/inftrees.js\");\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n      case HEAD:\n        if (state.wrap === 0) {\n          state.mode = TYPEDO;\n          break;\n        }\n        //=== NEEDBITS(16);\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n          state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          state.mode = FLAGS;\n          break;\n        }\n        state.flags = 0;           /* expect zlib header */\n        if (state.head) {\n          state.head.done = false;\n        }\n        if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n          (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n          strm.msg = 'incorrect header check';\n          state.mode = BAD;\n          break;\n        }\n        if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n        len = (hold & 0x0f)/*BITS(4)*/ + 8;\n        if (state.wbits === 0) {\n          state.wbits = len;\n        }\n        else if (len > state.wbits) {\n          strm.msg = 'invalid window size';\n          state.mode = BAD;\n          break;\n        }\n        state.dmax = 1 << len;\n        //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = hold & 0x200 ? DICTID : TYPE;\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        break;\n      case FLAGS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.flags = hold;\n        if ((state.flags & 0xff) !== Z_DEFLATED) {\n          strm.msg = 'unknown compression method';\n          state.mode = BAD;\n          break;\n        }\n        if (state.flags & 0xe000) {\n          strm.msg = 'unknown header flags set';\n          state.mode = BAD;\n          break;\n        }\n        if (state.head) {\n          state.head.text = ((hold >> 8) & 1);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = TIME;\n        /* falls through */\n      case TIME:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.time = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC4(state.check, hold)\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          hbuf[2] = (hold >>> 16) & 0xff;\n          hbuf[3] = (hold >>> 24) & 0xff;\n          state.check = crc32(state.check, hbuf, 4, 0);\n          //===\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = OS;\n        /* falls through */\n      case OS:\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (state.head) {\n          state.head.xflags = (hold & 0xff);\n          state.head.os = (hold >> 8);\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = EXLEN;\n        /* falls through */\n      case EXLEN:\n        if (state.flags & 0x0400) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length = hold;\n          if (state.head) {\n            state.head.extra_len = hold;\n          }\n          if (state.flags & 0x0200) {\n            //=== CRC2(state.check, hold);\n            hbuf[0] = hold & 0xff;\n            hbuf[1] = (hold >>> 8) & 0xff;\n            state.check = crc32(state.check, hbuf, 2, 0);\n            //===//\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        else if (state.head) {\n          state.head.extra = null/*Z_NULL*/;\n        }\n        state.mode = EXTRA;\n        /* falls through */\n      case EXTRA:\n        if (state.flags & 0x0400) {\n          copy = state.length;\n          if (copy > have) { copy = have; }\n          if (copy) {\n            if (state.head) {\n              len = state.head.extra_len - state.length;\n              if (!state.head.extra) {\n                // Use untyped array for more convenient processing later\n                state.head.extra = new Array(state.head.extra_len);\n              }\n              utils.arraySet(\n                state.head.extra,\n                input,\n                next,\n                // extra field is limited to 65536 bytes\n                // - no need for additional size check\n                copy,\n                /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n                len\n              );\n              //zmemcpy(state.head.extra + len, next,\n              //        len + copy > state.head.extra_max ?\n              //        state.head.extra_max - len : copy);\n            }\n            if (state.flags & 0x0200) {\n              state.check = crc32(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            state.length -= copy;\n          }\n          if (state.length) { break inf_leave; }\n        }\n        state.length = 0;\n        state.mode = NAME;\n        /* falls through */\n      case NAME:\n        if (state.flags & 0x0800) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            // TODO: 2 or 1 bytes?\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.name_max*/)) {\n              state.head.name += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.name = null;\n        }\n        state.length = 0;\n        state.mode = COMMENT;\n        /* falls through */\n      case COMMENT:\n        if (state.flags & 0x1000) {\n          if (have === 0) { break inf_leave; }\n          copy = 0;\n          do {\n            len = input[next + copy++];\n            /* use constant limit because in js we should not preallocate memory */\n            if (state.head && len &&\n                (state.length < 65536 /*state.head.comm_max*/)) {\n              state.head.comment += String.fromCharCode(len);\n            }\n          } while (len && copy < have);\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          if (len) { break inf_leave; }\n        }\n        else if (state.head) {\n          state.head.comment = null;\n        }\n        state.mode = HCRC;\n        /* falls through */\n      case HCRC:\n        if (state.flags & 0x0200) {\n          //=== NEEDBITS(16); */\n          while (bits < 16) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.check & 0xffff)) {\n            strm.msg = 'header crc mismatch';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n        }\n        if (state.head) {\n          state.head.hcrc = ((state.flags >> 9) & 1);\n          state.head.done = true;\n        }\n        strm.adler = state.check = 0;\n        state.mode = TYPE;\n        break;\n      case DICTID:\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        strm.adler = state.check = zswap32(hold);\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = DICT;\n        /* falls through */\n      case DICT:\n        if (state.havedict === 0) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          return Z_NEED_DICT;\n        }\n        strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n        state.mode = TYPE;\n        /* falls through */\n      case TYPE:\n        if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case TYPEDO:\n        if (state.last) {\n          //--- BYTEBITS() ---//\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          //---//\n          state.mode = CHECK;\n          break;\n        }\n        //=== NEEDBITS(3); */\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.last = (hold & 0x01)/*BITS(1)*/;\n        //--- DROPBITS(1) ---//\n        hold >>>= 1;\n        bits -= 1;\n        //---//\n\n        switch ((hold & 0x03)/*BITS(2)*/) {\n          case 0:                             /* stored block */\n            //Tracev((stderr, \"inflate:     stored block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = STORED;\n            break;\n          case 1:                             /* fixed block */\n            fixedtables(state);\n            //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = LEN_;             /* decode codes */\n            if (flush === Z_TREES) {\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n              break inf_leave;\n            }\n            break;\n          case 2:                             /* dynamic block */\n            //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n            //        state.last ? \" (last)\" : \"\"));\n            state.mode = TABLE;\n            break;\n          case 3:\n            strm.msg = 'invalid block type';\n            state.mode = BAD;\n        }\n        //--- DROPBITS(2) ---//\n        hold >>>= 2;\n        bits -= 2;\n        //---//\n        break;\n      case STORED:\n        //--- BYTEBITS() ---// /* go to byte boundary */\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        //=== NEEDBITS(32); */\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n          strm.msg = 'invalid stored block lengths';\n          state.mode = BAD;\n          break;\n        }\n        state.length = hold & 0xffff;\n        //Tracev((stderr, \"inflate:       stored length %u\\n\",\n        //        state.length));\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = COPY_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case COPY_:\n        state.mode = COPY;\n        /* falls through */\n      case COPY:\n        copy = state.length;\n        if (copy) {\n          if (copy > have) { copy = have; }\n          if (copy > left) { copy = left; }\n          if (copy === 0) { break inf_leave; }\n          //--- zmemcpy(put, next, copy); ---\n          utils.arraySet(output, input, next, copy, put);\n          //---//\n          have -= copy;\n          next += copy;\n          left -= copy;\n          put += copy;\n          state.length -= copy;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       stored end\\n\"));\n        state.mode = TYPE;\n        break;\n      case TABLE:\n        //=== NEEDBITS(14); */\n        while (bits < 14) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n        //--- DROPBITS(5) ---//\n        hold >>>= 5;\n        bits -= 5;\n        //---//\n        state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n        //--- DROPBITS(4) ---//\n        hold >>>= 4;\n        bits -= 4;\n        //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n        if (state.nlen > 286 || state.ndist > 30) {\n          strm.msg = 'too many length or distance symbols';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n        state.have = 0;\n        state.mode = LENLENS;\n        /* falls through */\n      case LENLENS:\n        while (state.have < state.ncode) {\n          //=== NEEDBITS(3);\n          while (bits < 3) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n          //--- DROPBITS(3) ---//\n          hold >>>= 3;\n          bits -= 3;\n          //---//\n        }\n        while (state.have < 19) {\n          state.lens[order[state.have++]] = 0;\n        }\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        //state.next = state.codes;\n        //state.lencode = state.next;\n        // Switch to use dynamic table\n        state.lencode = state.lendyn;\n        state.lenbits = 7;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n        state.lenbits = opts.bits;\n\n        if (ret) {\n          strm.msg = 'invalid code lengths set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n        state.have = 0;\n        state.mode = CODELENS;\n        /* falls through */\n      case CODELENS:\n        while (state.have < state.nlen + state.ndist) {\n          for (;;) {\n            here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          if (here_val < 16) {\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            state.lens[state.have++] = here_val;\n          }\n          else {\n            if (here_val === 16) {\n              //=== NEEDBITS(here.bits + 2);\n              n = here_bits + 2;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              if (state.have === 0) {\n                strm.msg = 'invalid bit length repeat';\n                state.mode = BAD;\n                break;\n              }\n              len = state.lens[state.have - 1];\n              copy = 3 + (hold & 0x03);//BITS(2);\n              //--- DROPBITS(2) ---//\n              hold >>>= 2;\n              bits -= 2;\n              //---//\n            }\n            else if (here_val === 17) {\n              //=== NEEDBITS(here.bits + 3);\n              n = here_bits + 3;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 3 + (hold & 0x07);//BITS(3);\n              //--- DROPBITS(3) ---//\n              hold >>>= 3;\n              bits -= 3;\n              //---//\n            }\n            else {\n              //=== NEEDBITS(here.bits + 7);\n              n = here_bits + 7;\n              while (bits < n) {\n                if (have === 0) { break inf_leave; }\n                have--;\n                hold += input[next++] << bits;\n                bits += 8;\n              }\n              //===//\n              //--- DROPBITS(here.bits) ---//\n              hold >>>= here_bits;\n              bits -= here_bits;\n              //---//\n              len = 0;\n              copy = 11 + (hold & 0x7f);//BITS(7);\n              //--- DROPBITS(7) ---//\n              hold >>>= 7;\n              bits -= 7;\n              //---//\n            }\n            if (state.have + copy > state.nlen + state.ndist) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            while (copy--) {\n              state.lens[state.have++] = len;\n            }\n          }\n        }\n\n        /* handle error breaks in while */\n        if (state.mode === BAD) { break; }\n\n        /* check for end-of-block code (better have one) */\n        if (state.lens[256] === 0) {\n          strm.msg = 'invalid code -- missing end-of-block';\n          state.mode = BAD;\n          break;\n        }\n\n        /* build code tables -- note: do not change the lenbits or distbits\n           values here (9 and 6) without reading the comments in inftrees.h\n           concerning the ENOUGH constants, which depend on those values */\n        state.lenbits = 9;\n\n        opts = { bits: state.lenbits };\n        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.lenbits = opts.bits;\n        // state.lencode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid literal/lengths set';\n          state.mode = BAD;\n          break;\n        }\n\n        state.distbits = 6;\n        //state.distcode.copy(state.codes);\n        // Switch to use dynamic table\n        state.distcode = state.distdyn;\n        opts = { bits: state.distbits };\n        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n        // We have separate tables & no pointers. 2 commented lines below not needed.\n        // state.next_index = opts.table_index;\n        state.distbits = opts.bits;\n        // state.distcode = state.next;\n\n        if (ret) {\n          strm.msg = 'invalid distances set';\n          state.mode = BAD;\n          break;\n        }\n        //Tracev((stderr, 'inflate:       codes ok\\n'));\n        state.mode = LEN_;\n        if (flush === Z_TREES) { break inf_leave; }\n        /* falls through */\n      case LEN_:\n        state.mode = LEN;\n        /* falls through */\n      case LEN:\n        if (have >= 6 && left >= 258) {\n          //--- RESTORE() ---\n          strm.next_out = put;\n          strm.avail_out = left;\n          strm.next_in = next;\n          strm.avail_in = have;\n          state.hold = hold;\n          state.bits = bits;\n          //---\n          inflate_fast(strm, _out);\n          //--- LOAD() ---\n          put = strm.next_out;\n          output = strm.output;\n          left = strm.avail_out;\n          next = strm.next_in;\n          input = strm.input;\n          have = strm.avail_in;\n          hold = state.hold;\n          bits = state.bits;\n          //---\n\n          if (state.mode === TYPE) {\n            state.back = -1;\n          }\n          break;\n        }\n        state.back = 0;\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if (here_bits <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_op && (here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.lencode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        state.length = here_val;\n        if (here_op === 0) {\n          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n          //        \"inflate:         literal '%c'\\n\" :\n          //        \"inflate:         literal 0x%02x\\n\", here.val));\n          state.mode = LIT;\n          break;\n        }\n        if (here_op & 32) {\n          //Tracevv((stderr, \"inflate:         end of block\\n\"));\n          state.back = -1;\n          state.mode = TYPE;\n          break;\n        }\n        if (here_op & 64) {\n          strm.msg = 'invalid literal/length code';\n          state.mode = BAD;\n          break;\n        }\n        state.extra = here_op & 15;\n        state.mode = LENEXT;\n        /* falls through */\n      case LENEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n        state.was = state.length;\n        state.mode = DIST;\n        /* falls through */\n      case DIST:\n        for (;;) {\n          here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if ((here_op & 0xf0) === 0) {\n          last_bits = here_bits;\n          last_op = here_op;\n          last_val = here_val;\n          for (;;) {\n            here = state.distcode[last_val +\n                    ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n            here_bits = here >>> 24;\n            here_op = (here >>> 16) & 0xff;\n            here_val = here & 0xffff;\n\n            if ((last_bits + here_bits) <= bits) { break; }\n            //--- PULLBYTE() ---//\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n            //---//\n          }\n          //--- DROPBITS(last.bits) ---//\n          hold >>>= last_bits;\n          bits -= last_bits;\n          //---//\n          state.back += last_bits;\n        }\n        //--- DROPBITS(here.bits) ---//\n        hold >>>= here_bits;\n        bits -= here_bits;\n        //---//\n        state.back += here_bits;\n        if (here_op & 64) {\n          strm.msg = 'invalid distance code';\n          state.mode = BAD;\n          break;\n        }\n        state.offset = here_val;\n        state.extra = (here_op) & 15;\n        state.mode = DISTEXT;\n        /* falls through */\n      case DISTEXT:\n        if (state.extra) {\n          //=== NEEDBITS(state.extra);\n          n = state.extra;\n          while (bits < n) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n          //--- DROPBITS(state.extra) ---//\n          hold >>>= state.extra;\n          bits -= state.extra;\n          //---//\n          state.back += state.extra;\n        }\n//#ifdef INFLATE_STRICT\n        if (state.offset > state.dmax) {\n          strm.msg = 'invalid distance too far back';\n          state.mode = BAD;\n          break;\n        }\n//#endif\n        //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n        state.mode = MATCH;\n        /* falls through */\n      case MATCH:\n        if (left === 0) { break inf_leave; }\n        copy = _out - left;\n        if (state.offset > copy) {         /* copy from window */\n          copy = state.offset - copy;\n          if (copy > state.whave) {\n            if (state.sane) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break;\n            }\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n          }\n          if (copy > state.wnext) {\n            copy -= state.wnext;\n            from = state.wsize - copy;\n          }\n          else {\n            from = state.wnext - copy;\n          }\n          if (copy > state.length) { copy = state.length; }\n          from_source = state.window;\n        }\n        else {                              /* copy from output */\n          from_source = output;\n          from = put - state.offset;\n          copy = state.length;\n        }\n        if (copy > left) { copy = left; }\n        left -= copy;\n        state.length -= copy;\n        do {\n          output[put++] = from_source[from++];\n        } while (--copy);\n        if (state.length === 0) { state.mode = LEN; }\n        break;\n      case LIT:\n        if (left === 0) { break inf_leave; }\n        output[put++] = state.length;\n        left--;\n        state.mode = LEN;\n        break;\n      case CHECK:\n        if (state.wrap) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            // Use '|' instead of '+' to make sure that result is signed\n            hold |= input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          _out -= left;\n          strm.total_out += _out;\n          state.total += _out;\n          if (_out) {\n            strm.adler = state.check =\n                /*UPDATE(state.check, put - _out, _out);*/\n                (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n          }\n          _out = left;\n          // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n          if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n            strm.msg = 'incorrect data check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n        }\n        state.mode = LENGTH;\n        /* falls through */\n      case LENGTH:\n        if (state.wrap && state.flags) {\n          //=== NEEDBITS(32);\n          while (bits < 32) {\n            if (have === 0) { break inf_leave; }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          //===//\n          if (hold !== (state.total & 0xffffffff)) {\n            strm.msg = 'incorrect length check';\n            state.mode = BAD;\n            break;\n          }\n          //=== INITBITS();\n          hold = 0;\n          bits = 0;\n          //===//\n          //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n        }\n        state.mode = DONE;\n        /* falls through */\n      case DONE:\n        ret = Z_STREAM_END;\n        break inf_leave;\n      case BAD:\n        ret = Z_DATA_ERROR;\n        break inf_leave;\n      case MEM:\n        return Z_MEM_ERROR;\n      case SYNC:\n        /* falls through */\n      default:\n        return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n\n\n/***/ }),\n\n/***/ \"./node_modules/pako/lib/zlib/inftrees.js\":\n/*!************************************************!*\\\n  !*** ./node_modules/pako/lib/zlib/inftrees.js ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/pako/lib/zlib/messages.js\":\n/*!************************************************!*\\\n  !*** ./node_modules/pako/lib/zlib/messages.js ***!\n  \\************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n\n/***/ }),\n\n/***/ \"./node_modules/pako/lib/zlib/trees.js\":\n/*!*********************************************!*\\\n  !*** ./node_modules/pako/lib/zlib/trees.js ***!\n  \\*********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n/* eslint-disable space-unary-ops */\n\nvar utils = __webpack_require__(/*! ../utils/common */ \"./node_modules/pako/lib/utils/common.js\");\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defaults,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n\n\n/***/ }),\n\n/***/ \"./node_modules/pako/lib/zlib/zstream.js\":\n/*!***********************************************!*\\\n  !*** ./node_modules/pako/lib/zlib/zstream.js ***!\n  \\***********************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n\n\n/***/ }),\n\n/***/ \"./node_modules/pbf/index.js\":\n/*!***********************************!*\\\n  !*** ./node_modules/pbf/index.js ***!\n  \\***********************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = Pbf;\n\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\");\n\nfunction Pbf(buf) {\n    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);\n    this.pos = 0;\n    this.type = 0;\n    this.length = this.buf.length;\n}\n\nPbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum\nPbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64\nPbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields\nPbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32\n\nvar SHIFT_LEFT_32 = (1 << 16) * (1 << 16),\n    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\n\nPbf.prototype = {\n\n    destroy: function() {\n        this.buf = null;\n    },\n\n    // === READING =================================================================\n\n    readFields: function(readField, result, end) {\n        end = end || this.length;\n\n        while (this.pos < end) {\n            var val = this.readVarint(),\n                tag = val >> 3,\n                startPos = this.pos;\n\n            this.type = val & 0x7;\n            readField(tag, result, this);\n\n            if (this.pos === startPos) this.skip(val);\n        }\n        return result;\n    },\n\n    readMessage: function(readField, result) {\n        return this.readFields(readField, result, this.readVarint() + this.pos);\n    },\n\n    readFixed32: function() {\n        var val = readUInt32(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n    },\n\n    readSFixed32: function() {\n        var val = readInt32(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n    },\n\n    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)\n\n    readFixed64: function() {\n        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    },\n\n    readSFixed64: function() {\n        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    },\n\n    readFloat: function() {\n        var val = ieee754.read(this.buf, this.pos, true, 23, 4);\n        this.pos += 4;\n        return val;\n    },\n\n    readDouble: function() {\n        var val = ieee754.read(this.buf, this.pos, true, 52, 8);\n        this.pos += 8;\n        return val;\n    },\n\n    readVarint: function(isSigned) {\n        var buf = this.buf,\n            val, b;\n\n        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;\n        b = buf[this.pos];   val |= (b & 0x0f) << 28;\n\n        return readVarintRemainder(val, isSigned, this);\n    },\n\n    readVarint64: function() { // for compatibility with v2.0.1\n        return this.readVarint(true);\n    },\n\n    readSVarint: function() {\n        var num = this.readVarint();\n        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding\n    },\n\n    readBoolean: function() {\n        return Boolean(this.readVarint());\n    },\n\n    readString: function() {\n        var end = this.readVarint() + this.pos,\n            str = readUtf8(this.buf, this.pos, end);\n        this.pos = end;\n        return str;\n    },\n\n    readBytes: function() {\n        var end = this.readVarint() + this.pos,\n            buffer = this.buf.subarray(this.pos, end);\n        this.pos = end;\n        return buffer;\n    },\n\n    // verbose for performance reasons; doesn't affect gzipped size\n\n    readPackedVarint: function(arr, isSigned) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readVarint(isSigned));\n        return arr;\n    },\n    readPackedSVarint: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSVarint());\n        return arr;\n    },\n    readPackedBoolean: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readBoolean());\n        return arr;\n    },\n    readPackedFloat: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFloat());\n        return arr;\n    },\n    readPackedDouble: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readDouble());\n        return arr;\n    },\n    readPackedFixed32: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFixed32());\n        return arr;\n    },\n    readPackedSFixed32: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSFixed32());\n        return arr;\n    },\n    readPackedFixed64: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFixed64());\n        return arr;\n    },\n    readPackedSFixed64: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSFixed64());\n        return arr;\n    },\n\n    skip: function(val) {\n        var type = val & 0x7;\n        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}\n        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;\n        else if (type === Pbf.Fixed32) this.pos += 4;\n        else if (type === Pbf.Fixed64) this.pos += 8;\n        else throw new Error('Unimplemented type: ' + type);\n    },\n\n    // === WRITING =================================================================\n\n    writeTag: function(tag, type) {\n        this.writeVarint((tag << 3) | type);\n    },\n\n    realloc: function(min) {\n        var length = this.length || 16;\n\n        while (length < this.pos + min) length *= 2;\n\n        if (length !== this.length) {\n            var buf = new Uint8Array(length);\n            buf.set(this.buf);\n            this.buf = buf;\n            this.length = length;\n        }\n    },\n\n    finish: function() {\n        this.length = this.pos;\n        this.pos = 0;\n        return this.buf.subarray(0, this.length);\n    },\n\n    writeFixed32: function(val) {\n        this.realloc(4);\n        writeInt32(this.buf, val, this.pos);\n        this.pos += 4;\n    },\n\n    writeSFixed32: function(val) {\n        this.realloc(4);\n        writeInt32(this.buf, val, this.pos);\n        this.pos += 4;\n    },\n\n    writeFixed64: function(val) {\n        this.realloc(8);\n        writeInt32(this.buf, val & -1, this.pos);\n        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n    },\n\n    writeSFixed64: function(val) {\n        this.realloc(8);\n        writeInt32(this.buf, val & -1, this.pos);\n        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n    },\n\n    writeVarint: function(val) {\n        val = +val || 0;\n\n        if (val > 0xfffffff || val < 0) {\n            writeBigVarint(val, this);\n            return;\n        }\n\n        this.realloc(4);\n\n        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] =   (val >>> 7) & 0x7f;\n    },\n\n    writeSVarint: function(val) {\n        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);\n    },\n\n    writeBoolean: function(val) {\n        this.writeVarint(Boolean(val));\n    },\n\n    writeString: function(str) {\n        str = String(str);\n        this.realloc(str.length * 4);\n\n        this.pos++; // reserve 1 byte for short string length\n\n        var startPos = this.pos;\n        // write the string directly to the buffer and see how much was written\n        this.pos = writeUtf8(this.buf, str, this.pos);\n        var len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    },\n\n    writeFloat: function(val) {\n        this.realloc(4);\n        ieee754.write(this.buf, val, this.pos, true, 23, 4);\n        this.pos += 4;\n    },\n\n    writeDouble: function(val) {\n        this.realloc(8);\n        ieee754.write(this.buf, val, this.pos, true, 52, 8);\n        this.pos += 8;\n    },\n\n    writeBytes: function(buffer) {\n        var len = buffer.length;\n        this.writeVarint(len);\n        this.realloc(len);\n        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];\n    },\n\n    writeRawMessage: function(fn, obj) {\n        this.pos++; // reserve 1 byte for short message length\n\n        // write the message directly to the buffer and see how much was written\n        var startPos = this.pos;\n        fn(obj, this);\n        var len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    },\n\n    writeMessage: function(tag, fn, obj) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeRawMessage(fn, obj);\n    },\n\n    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },\n    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },\n    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },\n    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },\n    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },\n    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },\n    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },\n    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },\n    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },\n\n    writeBytesField: function(tag, buffer) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeBytes(buffer);\n    },\n    writeFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFixed32(val);\n    },\n    writeSFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeSFixed32(val);\n    },\n    writeFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeFixed64(val);\n    },\n    writeSFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeSFixed64(val);\n    },\n    writeVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeVarint(val);\n    },\n    writeSVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeSVarint(val);\n    },\n    writeStringField: function(tag, str) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeString(str);\n    },\n    writeFloatField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFloat(val);\n    },\n    writeDoubleField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeDouble(val);\n    },\n    writeBooleanField: function(tag, val) {\n        this.writeVarintField(tag, Boolean(val));\n    }\n};\n\nfunction readVarintRemainder(l, s, p) {\n    var buf = p.buf,\n        h, b;\n\n    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);\n\n    throw new Error('Expected varint not more than 10 bytes');\n}\n\nfunction readPackedEnd(pbf) {\n    return pbf.type === Pbf.Bytes ?\n        pbf.readVarint() + pbf.pos : pbf.pos + 1;\n}\n\nfunction toNum(low, high, isSigned) {\n    if (isSigned) {\n        return high * 0x100000000 + (low >>> 0);\n    }\n\n    return ((high >>> 0) * 0x100000000) + (low >>> 0);\n}\n\nfunction writeBigVarint(val, pbf) {\n    var low, high;\n\n    if (val >= 0) {\n        low  = (val % 0x100000000) | 0;\n        high = (val / 0x100000000) | 0;\n    } else {\n        low  = ~(-val % 0x100000000);\n        high = ~(-val / 0x100000000);\n\n        if (low ^ 0xffffffff) {\n            low = (low + 1) | 0;\n        } else {\n            low = 0;\n            high = (high + 1) | 0;\n        }\n    }\n\n    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {\n        throw new Error('Given varint doesn\\'t fit into 10 bytes');\n    }\n\n    pbf.realloc(10);\n\n    writeBigVarintLow(low, high, pbf);\n    writeBigVarintHigh(high, pbf);\n}\n\nfunction writeBigVarintLow(low, high, pbf) {\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos]   = low & 0x7f;\n}\n\nfunction writeBigVarintHigh(high, pbf) {\n    var lsb = (high & 0x07) << 4;\n\n    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f;\n}\n\nfunction makeRoomForExtraLength(startPos, len, pbf) {\n    var extraLen =\n        len <= 0x3fff ? 1 :\n        len <= 0x1fffff ? 2 :\n        len <= 0xfffffff ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));\n\n    // if 1 byte isn't enough for encoding message length, shift the data to the right\n    pbf.realloc(extraLen);\n    for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];\n}\n\nfunction writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }\nfunction writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }\nfunction writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }\nfunction writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }\nfunction writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }\nfunction writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }\nfunction writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }\nfunction writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }\nfunction writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }\n\n// Buffer code below from https://github.com/feross/buffer, MIT-licensed\n\nfunction readUInt32(buf, pos) {\n    return ((buf[pos]) |\n        (buf[pos + 1] << 8) |\n        (buf[pos + 2] << 16)) +\n        (buf[pos + 3] * 0x1000000);\n}\n\nfunction writeInt32(buf, val, pos) {\n    buf[pos] = val;\n    buf[pos + 1] = (val >>> 8);\n    buf[pos + 2] = (val >>> 16);\n    buf[pos + 3] = (val >>> 24);\n}\n\nfunction readInt32(buf, pos) {\n    return ((buf[pos]) |\n        (buf[pos + 1] << 8) |\n        (buf[pos + 2] << 16)) +\n        (buf[pos + 3] << 24);\n}\n\nfunction readUtf8(buf, pos, end) {\n    var str = '';\n    var i = pos;\n\n    while (i < end) {\n        var b0 = buf[i];\n        var c = null; // codepoint\n        var bytesPerSequence =\n            b0 > 0xEF ? 4 :\n            b0 > 0xDF ? 3 :\n            b0 > 0xBF ? 2 : 1;\n\n        if (i + bytesPerSequence > end) break;\n\n        var b1, b2, b3;\n\n        if (bytesPerSequence === 1) {\n            if (b0 < 0x80) {\n                c = b0;\n            }\n        } else if (bytesPerSequence === 2) {\n            b1 = buf[i + 1];\n            if ((b1 & 0xC0) === 0x80) {\n                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);\n                if (c <= 0x7F) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 3) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);\n                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 4) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            b3 = buf[i + 3];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);\n                if (c <= 0xFFFF || c >= 0x110000) {\n                    c = null;\n                }\n            }\n        }\n\n        if (c === null) {\n            c = 0xFFFD;\n            bytesPerSequence = 1;\n\n        } else if (c > 0xFFFF) {\n            c -= 0x10000;\n            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);\n            c = 0xDC00 | c & 0x3FF;\n        }\n\n        str += String.fromCharCode(c);\n        i += bytesPerSequence;\n    }\n\n    return str;\n}\n\nfunction writeUtf8(buf, str, pos) {\n    for (var i = 0, c, lead; i < str.length; i++) {\n        c = str.charCodeAt(i); // code point\n\n        if (c > 0xD7FF && c < 0xE000) {\n            if (lead) {\n                if (c < 0xDC00) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                    lead = c;\n                    continue;\n                } else {\n                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;\n                    lead = null;\n                }\n            } else {\n                if (c > 0xDBFF || (i + 1 === str.length)) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                } else {\n                    lead = c;\n                }\n                continue;\n            }\n        } else if (lead) {\n            buf[pos++] = 0xEF;\n            buf[pos++] = 0xBF;\n            buf[pos++] = 0xBD;\n            lead = null;\n        }\n\n        if (c < 0x80) {\n            buf[pos++] = c;\n        } else {\n            if (c < 0x800) {\n                buf[pos++] = c >> 0x6 | 0xC0;\n            } else {\n                if (c < 0x10000) {\n                    buf[pos++] = c >> 0xC | 0xE0;\n                } else {\n                    buf[pos++] = c >> 0x12 | 0xF0;\n                    buf[pos++] = c >> 0xC & 0x3F | 0x80;\n                }\n                buf[pos++] = c >> 0x6 & 0x3F | 0x80;\n            }\n            buf[pos++] = c & 0x3F | 0x80;\n        }\n    }\n    return pos;\n}\n\n\n/***/ }),\n\n/***/ \"./src/client/WindshaftMetadata.js\":\n/*!*****************************************!*\\\n  !*** ./src/client/WindshaftMetadata.js ***!\n  \\*****************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return WindshaftMetadata; });\n/* harmony import */ var _sources_MVTMetadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sources/MVTMetadata */ \"./src/sources/MVTMetadata.js\");\n/* harmony import */ var _codecs_windshaft__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../codecs/windshaft */ \"./src/codecs/windshaft/index.js\");\n\n\n\n// // Windshaft metadata internal structure of properties\n// properties: {\n//     // There's an entry here for every column of the original dataset/SQL query\n//     simple_value: { type: 'number', min: 10, max: 1000 },\n\n//     // Now, that's all there's to it for other sources,\n//     // but for Windshaft sources things more complicated:\n\n//     // There might be multiple aggregated properties derived from one base column\n//     value: {\n//         type: 'number' // this is the type of the base column and all aggregated properties\n//         aggregation: {\n//             // actual properties received and decoded are _cdb_agg_sum_value and _cdb_avg_sum_value\n//             sum: '_cdb_agg_sum_value',\n//             avg: '_cdb_agg_sum_value'\n//         }\n//     },\n\n//     // Then we can have dimension properties, also derived from a base column\n//     // here time1 is a date column of the dataset/query; but what we receive is\n//     // a _cdb_dim_month_time1 property of numeric type.\n//     // these dimension properties are triggered by clusterMonth/clusterMonthIso etc\n//     time1: {\n//         type: 'date' // this is the type of the base column only,\n//         min: '2017-01-01T00:00:00',  // stats of the base column\n//         max: '2018-12-01T00:00:00',\n//         dimension: {\n//             type: 'number', // type of the actual property received and decoded\n//             grouping: {},// (to be changed to group) grouping parameters\n//             propertyName: \"_cdb_dim_month_time1\",\n//             min: 1,      // actual stats of property _cdb_dim_month_time1\n//             max: 24\n//         }\n//     },\n\n//     // But wait, there's more, we can transfer a date dimension as an iso string property\n//     // but then expose it as two date properties, one for the start of each period and\n//     // one from the end (if not used, any of them may not be present)\n//     // these dimension properties are triggered by clusterMonthStart/clusterMonthEnd etc.\n//     time2: {\n//         type: 'date' // this is the type of the base column only,\n//         min: '2017-01-01T00:00:00',  // stats of the base column\n//         max: '2018-12-01T00:00:00',\n//         dimension: {\n//             type: 'category', // type of the actual (source) property received internally\n//             grouping: {},// (to be changed to group) grouping parameters\n//             propertyName: \"_cdb_dim_month_time1\", // source property\n//             min: '2017-01', // stats of property _cdb_dim_month_time1\n//             max: '2017-12',\n//             range: [\n//                 // here come the actual decoded (internal) properties!!:\n//                 // the types of these properties is 'date'\n//                 '_cdb_dim_month_time1_start',\n//                 '_cdb_dim_month_time1_end'\n//             }\n//         }\n//     }\n// }\n\nclass WindshaftMetadata extends _sources_MVTMetadata__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor (...args) {\n        super(...args);\n        this.propertyKeys = [];\n        this.baseNames = {};\n        Object.keys(this.properties).forEach(baseName => {\n            const property = this.properties[baseName];\n            if (property.aggregations) {\n                Object.values(property.aggregations).forEach(propName => {\n                    this._addProperty(baseName, propName);\n                });\n            } else if (property.dimension) {\n                if (property.dimension.range) {\n                    property.dimension.range.forEach(rangePropertyName => {\n                        this._addProperty(baseName, rangePropertyName, false);\n                    });\n                    // add source property too, for stats\n                    this._addProperty(baseName, property.dimension.propertyName);\n                } else {\n                    this._addProperty(baseName, property.dimension.propertyName);\n                }\n            } else {\n                this._addProperty(baseName, baseName);\n            }\n        });\n    }\n\n    _addProperty (baseName, propertyName, addToKeys = true) {\n        this.baseNames[propertyName] = baseName;\n        if (addToKeys) {\n            this.propertyKeys.push(propertyName);\n        }\n    }\n\n    _dimensionInfo (propertyName) {\n        const baseName = this.baseName(propertyName) || propertyName;\n        const column = this.properties[baseName];\n        let dimension = null;\n        if (baseName !== propertyName) {\n            if (baseName !== propertyName && column.dimension) {\n                dimension = column.dimension;\n            }\n        }\n        const baseType = column.type;\n        const sourceType = dimension ? dimensionBaseType(dimension) : baseType;\n        // type of the dataframe properties\n        const dataframeType = dimension ? dimensionType(dimension, propertyName) : sourceType;\n        return { baseName, column, dimension, dataframeType, baseType, sourceType };\n    }\n\n    baseName (propertyName) {\n        return this.baseNames[propertyName];\n    }\n\n    decodedProperties (propertyName) {\n        const { dimension } = this._dimensionInfo(propertyName);\n        if (dimension && dimension.grouping && dimension.range) {\n            return dimension.range;\n        }\n        return super.decodedProperties(propertyName);\n    }\n\n    // Stats usage: (is internal, external or source representation preferable?)\n    // * global aggregations\n    // * coding/decoding\n    stats (propertyName) {\n        const { dimension } = this._dimensionInfo(propertyName);\n        if (dimension && dimension.grouping) {\n            return dimension;\n        }\n        return super.stats(propertyName);\n    }\n\n    setCodecs () {\n        setMetadataCodecs(this);\n    }\n\n    sourcePropertyName (propertyName) {\n        const baseName = this.baseName(propertyName);\n        const dimension = this.properties[baseName].dimension;\n        if (dimension && dimension.range) {\n            return dimension.propertyName;\n        }\n        return propertyName;\n    }\n}\n\nfunction dimensionType (dimension, propertyName) {\n    if (dimension.range) {\n        return 'date';\n    }\n    return dimension.type;\n}\n\nfunction dimensionBaseType (dimension) {\n    return dimension.type;\n}\n\nfunction setMetadataCodecs (metadata) {\n    // assign codecs\n    // a single codec kept per base property\n    // so, all its aggregations share the same encoding.\n    // form a dimension, the kept codec is that of the dimension\n    Object.keys(metadata.properties).forEach(baseName => {\n        const property = metadata.properties[baseName];\n        const baseType = property.type;\n        if (baseType !== 'geometry') {\n            const dimType = property.dimension ? property.dimension.type : null;\n            const dimName = dimType ? property.dimension.propertyName : baseName;\n            const actualDimType = (dimType === 'category' && property.dimension.range) ? 'timerange' : dimType;\n            property.codec = Object(_codecs_windshaft__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(metadata, actualDimType || baseType, dimName || baseName);\n        }\n    });\n}\n\n\n/***/ }),\n\n/***/ \"./src/client/WindshaftWorker.js\":\n/*!***************************************!*\\\n  !*** ./src/client/WindshaftWorker.js ***!\n  \\***************************************/\n/*! exports provided: WindshaftWorker */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WindshaftWorker\", function() { return WindshaftWorker; });\n/* harmony import */ var _sources_MVTWorker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../sources/MVTWorker */ \"./src/sources/MVTWorker.js\");\n/* harmony import */ var _WindshaftMetadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WindshaftMetadata */ \"./src/client/WindshaftMetadata.js\");\n\n\n\nclass WindshaftWorker extends _sources_MVTWorker__WEBPACK_IMPORTED_MODULE_0__[\"MVTWorker\"] {\n    castMetadata (metadata) {\n        Object.setPrototypeOf(metadata, _WindshaftMetadata__WEBPACK_IMPORTED_MODULE_1__[\"default\"].prototype);\n        metadata.setCodecs();\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/client/mvt/feature-decoder.js\":\n/*!*******************************************!*\\\n  !*** ./src/client/mvt/feature-decoder.js ***!\n  \\*******************************************/\n/*! exports provided: Polygon, decodeLines, decodePolygons, signedPolygonArea, clipPolygon */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Polygon\", function() { return Polygon; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decodeLines\", function() { return decodeLines; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decodePolygons\", function() { return decodePolygons; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"signedPolygonArea\", function() { return signedPolygonArea; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"clipPolygon\", function() { return clipPolygon; });\n/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/geometry */ \"./src/utils/geometry.js\");\n\nclass Polygon {\n    constructor () {\n        this.flat = [];\n        this.holes = [];\n        this.clipped = [];\n        this.clippedType = []; // Store a bitmask of the clipped half-planes\n    }\n}\n\nfunction decodeLines (geometries, mvtExtent) {\n    let decodedGeometries = [];\n    geometries.map(l => {\n        let line = [];\n        l.map(point => {\n            line.push([2 * point.x / mvtExtent - 1, 2 * (1 - point.y / mvtExtent) - 1]);\n        });\n        decodedGeometries.push(...clipLine(line));\n    });\n    return decodedGeometries;\n}\n\n/*\n    All this clockwise non-sense is needed because the MVT decoder dont decode the MVT fully.\n    It doesn't distinguish between internal polygon rings (which defines holes) or external ones, which defines more polygons (mulipolygons)\n    See:\n        https://github.com/mapbox/vector-tile-spec/tree/master/2.1\n        https://en.wikipedia.org/wiki/Shoelace_formula\n*/\nfunction decodePolygons (geometries, mvtExtent) {\n    let currentPolygon = null;\n    let decoded = [];\n    let invertedOrientation;\n    geometries.forEach(geom => {\n        let area = signedPolygonArea(geom);\n        if (area === 0) {\n            return;\n        }\n        if (invertedOrientation === undefined) {\n            // According to the MVT spec this condition cannot happen for\n            // MVT spec compliant tiles, but many buggy implementations\n            // don't comply with this rule when generating tiles\n            // Also, other implementations accept this out-of-the-spec condition\n            invertedOrientation = area > 0;\n        }\n        const isExternalPolygon = invertedOrientation ? area > 0 : area < 0;\n\n        const preClippedVertices = _getPreClippedVertices(geom, mvtExtent);\n\n        if (isExternalPolygon) {\n            if (currentPolygon) {\n                decoded.push(currentPolygon);\n            }\n\n            currentPolygon = new Polygon();\n        }\n\n        currentPolygon = clipPolygon(preClippedVertices, currentPolygon, !isExternalPolygon);\n    });\n\n    if (currentPolygon) {\n        decoded.push(currentPolygon);\n    }\n\n    return decoded;\n}\n\nfunction signedPolygonArea (vertices) {\n    // https://en.wikipedia.org/wiki/Shoelace_formula\n    let a = 0;\n    for (let i = 0; i < vertices.length; i++) {\n        let j = (i + 1) % vertices.length;\n        a += vertices[i].x * vertices[j].y;\n        a -= vertices[j].x * vertices[i].y;\n    }\n    return a / 2;\n}\n\nconst CLIPMAX = 1;\nconst CLIPMIN = -CLIPMAX;\n\nconst clippingEdges = [\n    {\n        // Right edge; x <= CLIPMAX for points inside\n        inside: p => p[0] <= CLIPMAX,\n        intersect: (a, b) => _utils_geometry__WEBPACK_IMPORTED_MODULE_0__[\"default\"].intersect(a, b, [CLIPMAX, -100], [CLIPMAX, 100])\n    },\n    {\n        // Top edge; y <= CLIPMAX for points inside\n        inside: p => p[1] <= CLIPMAX,\n        intersect: (a, b) => _utils_geometry__WEBPACK_IMPORTED_MODULE_0__[\"default\"].intersect(a, b, [-100, CLIPMAX], [100, CLIPMAX])\n    },\n    {\n        // Left edge; x >= CLIPMIN for points inside\n        inside: p => p[0] >= CLIPMIN,\n        intersect: (a, b) => _utils_geometry__WEBPACK_IMPORTED_MODULE_0__[\"default\"].intersect(a, b, [CLIPMIN, -100], [CLIPMIN, 100])\n    },\n    {\n        // Bottom edge; y >= CLIPMIN for points inside\n        inside: p => p[1] >= CLIPMIN,\n        intersect: (a, b) => _utils_geometry__WEBPACK_IMPORTED_MODULE_0__[\"default\"].intersect(a, b, [-100, CLIPMIN], [100, CLIPMIN])\n    }\n];\nconst numberOfEdges = clippingEdges.length;\n\nfunction clipPolygon (preClippedVertices, polygon, isHole) {\n    // Sutherland-Hodgman Algorithm to clip polygons to the tile\n    // https://www.cs.drexel.edu/~david/Classes/CS430/Lectures/L-05_Polygons.6.pdf\n\n    let clippedTypes = {};\n\n    // for each clipping edge\n    for (let i = 0; i < numberOfEdges; i++) {\n        const preClippedVertices2 = [];\n        const clippedTypes2 = {};\n\n        const setClippedType = (vertexIndex, oldVertexIndex, edge = -1) => {\n            let clippedType = 0;\n            if (oldVertexIndex >= 0) {\n                clippedType = clippedTypes[oldVertexIndex] || 0;\n            }\n            if (edge >= 0) {\n                clippedType = clippedType | (1 << edge);\n            }\n            if (clippedType) {\n                clippedTypes2[vertexIndex] = clippedType;\n            }\n        };\n\n        // for each edge on polygon\n        for (let k = 0; k < preClippedVertices.length - 1; k++) {\n            // clip polygon edge\n            const a = preClippedVertices[k];\n            const b = preClippedVertices[k + 1];\n\n            const insideA = clippingEdges[i].inside(a);\n            const insideB = clippingEdges[i].inside(b);\n\n            if (insideA && insideB) {\n                // case 1: both inside, push B vertex\n                setClippedType(preClippedVertices2.length, k + 1);\n                preClippedVertices2.push(b);\n            } else if (insideA) {\n                // case 2: just B outside, push intersection\n                const intersectionPoint = clippingEdges[i].intersect(a, b);\n                setClippedType(preClippedVertices2.length, k + 1, i);\n                preClippedVertices2.push(intersectionPoint);\n            } else if (insideB) {\n                // case 4: just A outside: push intersection, push B\n                const intersectionPoint = clippingEdges[i].intersect(a, b);\n                setClippedType(preClippedVertices2.length, k, i);\n                preClippedVertices2.push(intersectionPoint);\n                setClippedType(preClippedVertices2.length, k + 1);\n                preClippedVertices2.push(b);\n            } else {\n                // case 3: both outside: do nothing\n            }\n        }\n        if (preClippedVertices2.length) {\n            if (clippedTypes2[0]) {\n                clippedTypes2[preClippedVertices2.length] = clippedTypes2[0];\n            }\n            preClippedVertices2.push(preClippedVertices2[0]);\n        }\n        preClippedVertices = preClippedVertices2;\n        clippedTypes = clippedTypes2;\n    }\n\n    // rings with less than 3 vertices are degenerate\n    const MIN_VALID_NUM_VERTICES = 3;\n\n    // preClippedVertices is closed by repeating the first vertex\n    if (preClippedVertices.length >= MIN_VALID_NUM_VERTICES + 1) {\n        if (isHole) {\n            polygon.holes.push(polygon.flat.length / 2);\n        }\n        preClippedVertices.forEach(v => {\n            polygon.flat.push(v[0], v[1]);\n        });\n        Object.keys(clippedTypes).forEach(i => {\n            polygon.clipped.push(Number(i) * 2);\n            polygon.clippedType.push(clippedTypes[i]);\n        });\n    }\n\n    return polygon;\n}\n\nfunction _getPreClippedVertices (geom, mvtExtent) {\n    return geom.map((coord) => {\n        let x = coord.x;\n        let y = coord.y;\n\n        x = 2 * x / mvtExtent - 1;\n        y = 2 * (1 - y / mvtExtent) - 1;\n\n        return [x, y];\n    });\n}\n\nfunction clipLine (line) {\n    // linestring clipping based on the Cohen-Sutherland algorithm\n    // input is a single linestring [point0, point1, ...]\n    // output is an array of flat linestrings:\n    // [[p0x, p0y, p1x, p1y, ...], ...]\n    let clippedLine = [];\n    const clippedLines = [];\n    function clipType (point) {\n        let type = 0;\n        for (let i = 0; i < numberOfEdges; i++) {\n            type = type | (clippingEdges[i].inside(point) ? 0 : (1 << i));\n        }\n        return type;\n    }\n    function intersect (point1, point2, type) {\n        for (let i = 0; i < numberOfEdges; i++) {\n            const mask = 1 << i;\n            if (type & mask) {\n                const p = clippingEdges[i].intersect(point1, point2);\n                type = clipType(p) & ~mask;\n                return [p, type];\n            }\n        }\n    }\n    let point0 = line[0];\n    let type0 = clipType(point0);\n    for (let i = 1; i < line.length; ++i) {\n        let point1 = line[i];\n        let type1 = clipType(point1);\n        const nextType = type1;\n        const nextPoint = point1;\n\n        for (; ;) {\n            if (!(type0 | type1)) {\n                // both points inside\n                clippedLine.push(...point0);\n                if (type1 !== nextType) {\n                    clippedLine.push(...point1);\n                    if (i < line.length - 1) {\n                        // break line\n                        clippedLines.push(clippedLine);\n                        clippedLine = [];\n                    }\n                } else if (i === line.length - 1) {\n                    clippedLine.push(...point1);\n                }\n                break;\n            } else if (type0 & type1) {\n                // both points outside\n                break;\n            } else if (type0) {\n                // only point1 inside\n                [point0, type0] = intersect(point0, point1, type0);\n            } else {\n                // only point0 inside\n                [point1, type1] = intersect(point0, point1, type1);\n            }\n        }\n\n        point0 = nextPoint;\n        type0 = nextType;\n    }\n\n    clippedLine = _removeDuplicatedVerticesOnLine(clippedLine);\n    if (clippedLine.length > 0) {\n        clippedLines.push(clippedLine);\n    }\n\n    return clippedLines;\n}\n\nfunction _removeDuplicatedVerticesOnLine (line) {\n    const result = [];\n    let prevX;\n    let prevY;\n    for (let i = 0; i < line.length; i += 2) {\n        const x = line[i];\n        const y = line[i + 1];\n        if (x !== prevX || y !== prevY) {\n            result.push(x, y);\n            prevX = x;\n            prevY = y;\n        }\n    }\n    return result;\n}\n\n\n/***/ }),\n\n/***/ \"./src/client/rsys.js\":\n/*!****************************!*\\\n  !*** ./src/client/rsys.js ***!\n  \\****************************/\n/*! exports provided: wToR, rTiles, getRsysFromTile, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"wToR\", function() { return wToR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rTiles\", function() { return rTiles; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getRsysFromTile\", function() { return getRsysFromTile; });\n/**\n * An RSys defines a local coordinate system that maps the coordinates\n * in the range -1 <= x <= +1; -1 <= y <= +1 to an arbitrary rectangle\n * in an external coordinate system. (e.g. Dataframe coordinates to World coordinates)\n * It is the combination of a translation and anisotropic scaling.\n * @typedef {Object} RSys - Renderer relative coordinate system\n * @property {RPoint} center - Position of the local system in external coordinates\n * @property {number} scale - Y-scale (local Y-distance / external Y-distance)\n*/\n\n/*\n * Random notes\n *\n * We can redefine Dataframe to use a Rsys instead of center, scale\n * and we can use an Rsys for the Renderer's canvas.\n *\n * Some interesting World coordinate systems:\n *\n * WM (Webmercator): represents a part of the world (excluding polar regions)\n * with coordinates in the range +/-WM_R for both X and Y. (positive orientation: E,N)\n *\n * NWMC (Normalized Webmercator Coordinates): represents the Webmercator *square*\n * with coordinates in the range +/-1. Results from dividing Webmercator coordinates\n * by WM_R. (positive orientation: E,N)\n *\n * TC (Tile coordinates): integers in [0, 2^Z) for zoom level Z. Example: the tile 0/0/0 (zoom, x, y) is the root tile.\n * (positive orientation: E,S)\n *\n * An RSys's rectangle (its bounds) is the area covered by the local coordinates in\n * the range +/-1.\n *\n * When an RSys external coordinate system is WM or NWMC, we can compute:\n * * Minimum zoom level for which tiles are no larger than the RSys rectangle:\n *   Math.ceil(Math.log2(1 / r.scale));\n * * Maximum zoom level for which tiles are no smaller than the rectangle:\n *   Math.floor(Math.log2(1 / r.scale));\n * (note that 1 / r.scale is the fraction of the World height that the local rectangle's height represents)\n *\n * We'll use the term World coordinates below for the *external* reference system\n * of an RSys (usually NWMC).\n */\n\n/* eslint no-unused-vars: [\"off\"] */\n\n/**\n * R coordinates to World\n * @param {RSys} r - ref. of the passed coordinates\n * @param {number} x - x coordinate in r\n * @param {number} y - y coordinate in r\n * @return {RPoint} World coordinates\n */\nfunction rToW (r, x, y) {\n    return { x: x * r.scale + r.center.x, y: y * r.scale + r.center.y };\n}\n\n/**\n * World coordinates to local RSys\n * @param {number} x - x W-coordinate\n * @param {number} y - y W-coordinate\n * @param {RSys} r - target ref. system\n * @return {RPoint} R coordinates\n */\nfunction wToR (x, y, r) {\n    return { x: (x - r.center.x) / r.scale, y: (y - r.center.y) / r.scale };\n}\n\n/**\n * RSys of a tile (mapping local tile coordinates in +/-1 to NWMC)\n * @param {number} x - TC x coordinate\n * @param {number} y - TC y coordinate\n * @param {number} z - Tile zoom level\n * @return {RSys}\n */\nfunction tileRsys (x, y, z) {\n    let max = Math.pow(2, z);\n    return { scale: 1 / max, center: { x: 2 * (x + 0.5) / max - 1, y: 1 - 2 * (y + 0.5) / max } };\n}\n\n/**\n * TC tiles that intersect the local rectangle of an RSys\n * (with the largest tile size no larger than the rectangle)\n * @param {RSys} rsys\n * @return {Array} - array of TC tiles {x, y, z}\n */\nfunction rTiles (zoom, bounds, viewportZoomToSourceZoom = Math.ceil, extend = 0) {\n    const z = viewportZoomToSourceZoom(zoom);\n    if (typeof z === 'number') {\n        return wRectangleTiles(z, bounds, extend);\n    }\n    return [];\n}\n\n/**\n * TC tiles of a given zoom level that intersect a W rectangle\n * @param {number} z\n * @param {Array} wr - rectangle extents [minx, miny, maxx, maxy]\n * @param {number} ex - extend tiles rectangle. Default 0\n * @return {Array} - array of TC tiles {x, y, z}\n */\nfunction wRectangleTiles (z, wr, ex = 0) {\n    const [wMinx, wMiny, wMaxx, wMaxy] = wr;\n    const n = (1 << z); // for 0 <= z <= 30 equals Math.pow(2, z)\n\n    const clamp = x => Math.min(Math.max(x, 0), n - 1);\n    // compute tile coordinate ranges\n    const tMinx = clamp(Math.floor(n * (wMinx + 1) * 0.5)) - ex;\n    const tMaxx = clamp(Math.ceil(n * (wMaxx + 1) * 0.5) - 1) + ex;\n    const tMiny = clamp(Math.floor(n * (1 - wMaxy) * 0.5)) - ex;\n    const tMaxy = clamp(Math.ceil(n * (1 - wMiny) * 0.5) - 1) + ex;\n    let tiles = [];\n    for (let x = tMinx; x <= tMaxx; ++x) {\n        for (let y = tMiny; y <= tMaxy; ++y) {\n            tiles.push({ x, y, z });\n        }\n    }\n    return tiles;\n}\n\n/**\n * Get the Rsys of a tile where the Rsys's center is the tile center and the Rsys's scale is the tile extent.\n * @param {*} x\n * @param {*} y\n * @param {*} z\n * @returns {RSys}\n */\nfunction getRsysFromTile (x, y, z) {\n    return {\n        center: {\n            x: ((x + 0.5) / Math.pow(2, z)) * 2.0 - 1,\n            y: (1.0 - (y + 0.5) / Math.pow(2, z)) * 2.0 - 1.0\n        },\n        scale: 1 / Math.pow(2, z)\n    };\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({ rTiles, getRsysFromTile, wToR });\n\n\n/***/ }),\n\n/***/ \"./src/codecs/Base.js\":\n/*!****************************!*\\\n  !*** ./src/codecs/Base.js ***!\n  \\****************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return BaseCodec; });\n// A Dataframe property Codec is used to transform between property value encodings.\n// Three different encodings are handled:\n// * The `source` encoding correspond to the format in which\n//   the property values appear in the data sources (e.g. in MVT)\n// * The `internal` encoding is used in Dataframe properties\n//   apt for GPU consumption.\n// * The `external` encoding is the format in which feature\n//   properties are presented to the user\n//   (e.g. `property.eval(feature)` or `globalMin(property)`)\n// The Codec base class serves both as a base for derived codecs.\n// Codecs are associated to source properties.\n// There are two kind of codecs:\n// * Scalar (simple) encoder: source value is encoded as a single internal value\n// * Range encoder: a source value encodes as a pair [lo, hi] of values.\nclass BaseCodec {\n    constructor (metadata, propertyName) {\n        if (metadata && propertyName) {\n            this._baseName = metadata.baseName(propertyName);\n        }\n    }\n\n    isRange () {\n        return false;\n    }\n\n    isIdentity () {\n        return false;\n    }\n\n    // Convert source encoding to internal;\n    // Result is an array [lo, hi] for ranges and a value for scalar codecs\n    // Used to encode sources into dataframe properties.\n    sourceToInternal (metadata, v) {\n        return v;\n    }\n\n    // Convert internal encoding to external;\n    // Input may be one for scalar, or two values (hi, lo) for ranges.\n    // Used to present dataframe features.\n    internalToExternal (metadata, v) {\n        return v;\n    }\n\n    // Convert external encoding back to source values.\n    // Used to generate SQL filters: (apply to constant/global)\n    externalToSource (metadata, v) {\n        return v;\n    }\n\n    // Convert source encoding to external encoding.\n    // Used to present source stats values (global aggregations)\n    // to match the format of constant expressions.\n    sourceToExternal (metadata, v) {\n        return this.internalToExternal(metadata, this.sourceToInternal(metadata, v));\n    }\n\n    // Convert external to internal encoding.\n    // Result is a value for scalar codecs\n    // and [lo, hi] for range codecs.\n    // used to to apply filters in GLSL inlined code;\n    // evaluate binary operations property vs external (constant/global\n    externalToInternal (metadata, v) {\n        return this.sourceToInternal(metadata, this.externalToSource(metadata, v));\n    }\n\n    // Generate GLSL inline expression to map a property value\n    // to the internal encoding of another property.\n    // Used to bind some binary operations between properties.\n    inlineInternalMatch (thisValue, _otherCodec) {\n        return `${thisValue}`;\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/codecs/Category.js\":\n/*!********************************!*\\\n  !*** ./src/codecs/Category.js ***!\n  \\********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return CategoryCodec; });\n/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base */ \"./src/codecs/Base.js\");\n\n\nclass CategoryCodec extends _Base__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    sourceToInternal (metadata, propertyValue) {\n        return metadata.categorizeString(this._baseName, propertyValue);\n    }\n\n    internalToExternal (metadata, propertyValue) {\n        return metadata.IDToCategory.get(propertyValue);\n    }\n\n    sourceToExternal (metadata, propertyValue) {\n        return propertyValue;\n    }\n\n    externalToSource (metadata, v) {\n        return v;\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/codecs/Identity.js\":\n/*!********************************!*\\\n  !*** ./src/codecs/Identity.js ***!\n  \\********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return IdentityCodec; });\n/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Base */ \"./src/codecs/Base.js\");\n\n\n// The Identity codec class serves\n// as the default, identity encoding, in which all three\n// encodings are exactly the same.\nclass IdentityCodec extends _Base__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    isIdentity () {\n        return true;\n    }\n\n    sourceToInternal (metadata, v) {\n        return v;\n    }\n\n    internalToExternal (metadata, v) {\n        return v;\n    }\n\n    sourceToExternal (metadata, v) {\n        return v;\n    }\n\n    externalToSource (metadata, v) {\n        return v;\n    }\n\n    externalToInternal (metadata, v) {\n        return v;\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/codecs/Number.js\":\n/*!******************************!*\\\n  !*** ./src/codecs/Number.js ***!\n  \\******************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return NumberCodec; });\n/* harmony import */ var _Identity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Identity */ \"./src/codecs/Identity.js\");\n/* harmony import */ var _renderer_viz_expressions_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/viz/expressions/constants */ \"./src/renderer/viz/expressions/constants.js\");\n\n\n\nclass NumberCodec extends _Identity__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    sourceToInternal (metadata, propertyValue) {\n        if (isNaN(propertyValue) || propertyValue == null) {\n            propertyValue = _renderer_viz_expressions_constants__WEBPACK_IMPORTED_MODULE_1__[\"FP32_DESIGNATED_NULL_VALUE\"];\n        }\n        return propertyValue;\n    }\n\n    internalToExternal (metadata, value) {\n        if (value === _renderer_viz_expressions_constants__WEBPACK_IMPORTED_MODULE_1__[\"FP32_DESIGNATED_NULL_VALUE\"]) {\n            value = null;\n        }\n        return value;\n    }\n\n    externalToInternal (metadata, value) {\n        if (value === null) {\n            value = _renderer_viz_expressions_constants__WEBPACK_IMPORTED_MODULE_1__[\"FP32_DESIGNATED_NULL_VALUE\"];\n        }\n        return value;\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/codecs/mvt/Category.js\":\n/*!************************************!*\\\n  !*** ./src/codecs/mvt/Category.js ***!\n  \\************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MVTCategoryCodec; });\n/* harmony import */ var _Category__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Category */ \"./src/codecs/Category.js\");\n/* harmony import */ var _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../errors/carto-runtime-error */ \"./src/errors/carto-runtime-error.js\");\n\n\n\nclass MVTCategoryCodec extends _Category__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    sourceToInternal (metadata, propertyValue) {\n        const propertyValueType = typeof propertyValue;\n        if (propertyValue !== null && propertyValueType !== 'undefined' && propertyValueType !== 'string') {\n            // In general Codecs are unique per original base property, not per source property,\n            // but for the generic MVT sources we don't support multiple source properties per base property (e.g. aggregations)\n            // so it would suffice to keep the property name in the Codec class.\n            // For more general solutions we'd need to provide the source property name as an argument to this method.\n            throw new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\n                `MVT decoding error. Metadata property '${this._baseName}' is of type 'category' but the MVT tile contained a feature property of type '${propertyValueType}': '${propertyValue}'`,\n                _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_1__[\"CartoRuntimeErrorTypes\"].MVT\n            );\n        }\n        return super.sourceToInternal(metadata, propertyValue);\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/codecs/mvt/Number.js\":\n/*!**********************************!*\\\n  !*** ./src/codecs/mvt/Number.js ***!\n  \\**********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MVTNumberCodec; });\n/* harmony import */ var _Number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Number */ \"./src/codecs/Number.js\");\n/* harmony import */ var _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../errors/carto-runtime-error */ \"./src/errors/carto-runtime-error.js\");\n\n\n\nclass MVTNumberCodec extends _Number__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    sourceToInternal (metadata, propertyValue) {\n        const propertyValueType = typeof propertyValue;\n        if (propertyValue !== null && propertyValueType !== 'undefined' && propertyValueType !== 'number') {\n            throw new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_1__[\"default\"](\n                `MVT decoding error. Metadata property '${this._baseName}' is of type 'number' but the MVT tile contained a feature property of type '${propertyValueType}': '${propertyValue}'`,\n                _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_1__[\"CartoRuntimeErrorTypes\"].MVT\n            );\n        }\n        return super.sourceToInternal(metadata, propertyValue);\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/codecs/mvt/index.js\":\n/*!*********************************!*\\\n  !*** ./src/codecs/mvt/index.js ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MVTCodecFactory; });\n/* harmony import */ var _Number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Number */ \"./src/codecs/mvt/Number.js\");\n/* harmony import */ var _Category__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Category */ \"./src/codecs/mvt/Category.js\");\n/* harmony import */ var _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../errors/carto-runtime-error */ \"./src/errors/carto-runtime-error.js\");\n\n\n\n\nfunction MVTCodecFactory (metadata, type, propertyName) {\n    switch (type) {\n        case 'number':\n            return new _Number__WEBPACK_IMPORTED_MODULE_0__[\"default\"](metadata, propertyName);\n        case 'category':\n            return new _Category__WEBPACK_IMPORTED_MODULE_1__[\"default\"](metadata, propertyName);\n        default:\n            throw new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_2__[\"default\"](\n                `MVT decoding error. Feature property value of type '${type}' cannot be decoded.`,\n                _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_2__[\"CartoRuntimeErrorTypes\"].MVT\n            );\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/codecs/windshaft/TimeRange.js\":\n/*!*******************************************!*\\\n  !*** ./src/codecs/windshaft/TimeRange.js ***!\n  \\*******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return TimeRangeCodec; });\n/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Base */ \"./src/codecs/Base.js\");\n/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/util */ \"./src/utils/util.js\");\n\n\n\nclass TimeRangeCodec extends _Base__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor (metadata, propertyName) {\n        super(metadata, propertyName);\n\n        const stats = metadata.stats(propertyName);\n        const { min } = stats;\n        const timeZone = stats.grouping && stats.grouping.timezone;\n        const timeRange = _utils_util__WEBPACK_IMPORTED_MODULE_1__[\"timeRange\"]({ timeZone, iso: min });\n\n        this._min = timeRange.startValue / 1000;\n        this._timeZone = timeZone;\n    }\n\n    isRange () {\n        return true;\n    }\n\n    sourceToInternal (metadata, propertyValue) {\n        const timeRange = _utils_util__WEBPACK_IMPORTED_MODULE_1__[\"timeRange\"]({ iso: propertyValue });\n        return [timeRange.startValue / 1000, timeRange.endValue / 1000].map(v => (v - this._min));\n    }\n\n    internalToExternal (metadata, [lo, hi]) {\n        return _utils_util__WEBPACK_IMPORTED_MODULE_1__[\"timeRange\"]({\n            start: (lo + this._min) * 1000,\n            end: (hi + this._min) * 1000,\n            timeZone: this._timeZone\n        });\n    }\n\n    externalToSource (metadata, v) {\n        return _utils_util__WEBPACK_IMPORTED_MODULE_1__[\"castTimeRange\"](v, this._timeZone)._iso;\n    }\n\n    sourceToExternal (metadata, v) {\n        return _utils_util__WEBPACK_IMPORTED_MODULE_1__[\"timeRange\"]({ iso: v, timeZone: this._timeZone });\n    }\n\n    inlineInternalMatch (thisValue, otherCodec) {\n        const offset = otherCodec._min.getTime() - this._min.getTime();\n        return `(${thisValue}-${offset.toFixed(20)})`;\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/codecs/windshaft/WindshaftDate.js\":\n/*!***********************************************!*\\\n  !*** ./src/codecs/windshaft/WindshaftDate.js ***!\n  \\***********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return WindshaftDateCodec; });\n/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Base */ \"./src/codecs/Base.js\");\n/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/util */ \"./src/utils/util.js\");\n\n\n\nclass WindshaftDateCodec extends _Base__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor (metadata, propertyName) {\n        super(metadata, propertyName);\n\n        const { min } = metadata.stats(propertyName);\n        this._min_ms = min * 1000;\n        this._min_date = _utils_util__WEBPACK_IMPORTED_MODULE_1__[\"msToDate\"](this._min_ms);\n    }\n\n    sourceToInternal (metadata, propertyValue) {\n        return _utils_util__WEBPACK_IMPORTED_MODULE_1__[\"msToDate\"](propertyValue * 1000) - this._min_date;\n    }\n\n    internalToExternal (metadata, propertyValue) {\n        let value = propertyValue;\n        value += this._min_ms;\n        return _utils_util__WEBPACK_IMPORTED_MODULE_1__[\"msToDate\"](value);\n    }\n\n    externalToSource (metadata, v) {\n        return v.getTime() / 1000;\n    }\n\n    sourceToExternal (metadata, v) {\n        return asDate(v);\n    }\n\n    inlineInternalMatch (thisValue, otherCodec) {\n        const offset = otherCodec._min_ms - this._min_ms;\n        return `(${thisValue}-${offset.toFixed(20)})`;\n    }\n}\n\n// convert seconds epoch (source encoding) or Date to Date\nfunction asDate (value) {\n    if (value instanceof Date) {\n        return value;\n    }\n    return _utils_util__WEBPACK_IMPORTED_MODULE_1__[\"msToDate\"](value * 1000);\n}\n\n\n/***/ }),\n\n/***/ \"./src/codecs/windshaft/index.js\":\n/*!***************************************!*\\\n  !*** ./src/codecs/windshaft/index.js ***!\n  \\***************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return windshaftCodecFactory; });\n/* harmony import */ var _Number__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Number */ \"./src/codecs/Number.js\");\n/* harmony import */ var _Category__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Category */ \"./src/codecs/Category.js\");\n/* harmony import */ var _WindshaftDate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WindshaftDate */ \"./src/codecs/windshaft/WindshaftDate.js\");\n/* harmony import */ var _TimeRange__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./TimeRange */ \"./src/codecs/windshaft/TimeRange.js\");\n/* harmony import */ var _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../errors/carto-maps-api-error */ \"./src/errors/carto-maps-api-error.js\");\n\n\n\n\n\n\nfunction windshaftCodecFactory (metadata, type, propertyName) {\n    switch (type) {\n        case 'number':\n            return new _Number__WEBPACK_IMPORTED_MODULE_0__[\"default\"](metadata, propertyName);\n        case 'category':\n            return new _Category__WEBPACK_IMPORTED_MODULE_1__[\"default\"](metadata, propertyName);\n        case 'date':\n            return new _WindshaftDate__WEBPACK_IMPORTED_MODULE_2__[\"default\"](metadata, propertyName);\n        case 'timerange':\n            return new _TimeRange__WEBPACK_IMPORTED_MODULE_3__[\"default\"](metadata, propertyName);\n        default:\n            throw new _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_4__[\"default\"](\n                `Windshaft MVT decoding error. Feature property value of type '${type}' cannot be decoded.`,\n                _errors_carto_maps_api_error__WEBPACK_IMPORTED_MODULE_4__[\"CartoMapsAPIErrorTypes\"].NOT_SUPPORTED);\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/errors/carto-error.js\":\n/*!***********************************!*\\\n  !*** ./src/errors/carto-error.js ***!\n  \\***********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return CartoError; });\n/**\n * Represents an error in the carto library.\n *\n * @typedef {Object} CartoError\n * @property {String} message - A short error description\n * @property {String} name - The name of the error \"CartoError\"\n * @property {String} type - The type of the error \"CartoError\"\n * @property {Object} originalError - An object containing the internal/original error\n *\n * @event CartoError\n * @api\n */\n\n/**\n * @namespace CartoErrors\n * @api\n *\n*/\nclass CartoError extends Error {\n    /**\n     * Build a cartoError from a generic error.\n     * @constructor\n     *\n     * @return {CartoError} A well formed object representing the error.\n     */\n    constructor (error) {\n        if (!error) {\n            throw Error('Invalid CartoError, a message is mandatory');\n        }\n\n        if (!error.message) {\n            throw Error('Invalid CartoError, a message is mandatory');\n        }\n\n        if (!error.type) {\n            throw Error('Invalid CartoError, a type is mandatory');\n        }\n\n        super(`${error.type} ${error.message}`);\n        this.name = 'CartoError';\n        this.type = error.type;\n        this.originalError = error;\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/errors/carto-maps-api-error.js\":\n/*!********************************************!*\\\n  !*** ./src/errors/carto-maps-api-error.js ***!\n  \\********************************************/\n/*! exports provided: default, CartoMapsAPIErrorTypes */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return CartoMapsAPIError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CartoMapsAPIErrorTypes\", function() { return CartoMapsAPIErrorTypes; });\n/* harmony import */ var _carto_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./carto-error */ \"./src/errors/carto-error.js\");\n\n\n/**\n * Utility to build a cartoError related to MapsAPI errors.\n *\n * @return {CartoError} A well formed object representing the error.\n */\n\n/**\n * CartoMapsAPIError types:\n * - [Error]\n * - [Not supported]\n * - [Security]\n *\n * @name CartoMapsAPIError\n * @memberof CartoError\n * @api\n*/\n\nclass CartoMapsAPIError extends _carto_error__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor (message, type = CartoMapsAPIErrorTypes.DEFAULT) {\n        super({ message, type });\n        this.name = 'CartoMapsAPIError';\n    }\n}\n\nconst CartoMapsAPIErrorTypes = {\n    DEFAULT: '[Error]',\n    SQL: '[SQL]',\n    NOT_SUPPORTED: '[Not supported]',\n    SECURITY: '[Security]'\n};\n\n\n/***/ }),\n\n/***/ \"./src/errors/carto-parsing-error.js\":\n/*!*******************************************!*\\\n  !*** ./src/errors/carto-parsing-error.js ***!\n  \\*******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return CartoParsingError; });\n/* harmony import */ var _carto_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./carto-error */ \"./src/errors/carto-error.js\");\n\n\n/**\n * Utility to build a cartoError related to Parsing errors.\n *\n * @return {CartoError} A well formed object representing the error.\n */\n\n/**\n * CartoParsingError types:\n * - [Error]\n *\n * @name CartoParsingError\n * @memberof CartoError\n * @api\n*/\n\nclass CartoParsingError extends _carto_error__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor (message) {\n        const type = '[Error]';\n        super({ message, type });\n        this.name = 'CartoParsingError';\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/errors/carto-runtime-error.js\":\n/*!*******************************************!*\\\n  !*** ./src/errors/carto-runtime-error.js ***!\n  \\*******************************************/\n/*! exports provided: default, CartoRuntimeErrorTypes */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return CartoRuntimeError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CartoRuntimeErrorTypes\", function() { return CartoRuntimeErrorTypes; });\n/* harmony import */ var _carto_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./carto-error */ \"./src/errors/carto-error.js\");\n\n\n/**\n * Utility to build a cartoError related to Runtime errors.\n *\n * @return {CartoError} A well formed object representing the error.\n */\n\n/**\n * CartoRuntimeError types:\n * - [Error]\n * - [Not supported]\n * - [WebGL]\n * - [MVT]\n *\n * @name CartoRuntimeError\n * @memberof CartoError\n * @api\n*/\nclass CartoRuntimeError extends _carto_error__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor (message, type = CartoRuntimeErrorTypes.DEFAULT) {\n        super({ message, type });\n        this.name = 'CartoRuntimeError';\n    }\n}\n\nconst CartoRuntimeErrorTypes = {\n    DEFAULT: '[Error]',\n    NOT_SUPPORTED: '[Not supported]',\n    WEB_GL: '[WebGL]',\n    MVT: '[MVT]'\n};\n\n\n/***/ }),\n\n/***/ \"./src/errors/carto-validation-error.js\":\n/*!**********************************************!*\\\n  !*** ./src/errors/carto-validation-error.js ***!\n  \\**********************************************/\n/*! exports provided: default, CartoValidationErrorTypes */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return CartoValidationError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CartoValidationErrorTypes\", function() { return CartoValidationErrorTypes; });\n/* harmony import */ var _carto_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./carto-error */ \"./src/errors/carto-error.js\");\n\n\n/**\n * Utility to build a cartoError related to validation errors.\n *\n * @return {CartoError} A well formed object representing the error.\n */\n\n/**\n * CartoValidationError types:\n * - [Error]\n * - [Missing required property]\n * - [Property with an incorrect type]\n * - [Incorrect value]\n * - [Too many arguments]\n * - [Not enough arguments]\n * - [Wrong number of arguments]\n *\n * @name CartoValidationError\n * @memberof CartoError\n * @api\n*/\nclass CartoValidationError extends _carto_error__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    constructor (message, type = CartoValidationErrorTypes.DEFAULT) {\n        super({ message, type });\n        this.name = 'CartoValidationError';\n    }\n}\n\nconst CartoValidationErrorTypes = {\n    DEFAULT: '[Error]',\n    MISSING_REQUIRED: '[Missing required property]',\n    INCORRECT_TYPE: '[Property with an incorrect type]',\n    INCORRECT_VALUE: '[Incorrect value]',\n    TOO_MANY_ARGS: '[Too many arguments]',\n    NOT_ENOUGH_ARGS: '[Not enough arguments]',\n    WRONG_NUMBER_ARGS: '[Wrong number of arguments]'\n};\n\n\n/***/ }),\n\n/***/ \"./src/renderer/Metadata.js\":\n/*!**********************************!*\\\n  !*** ./src/renderer/Metadata.js ***!\n  \\**********************************/\n/*! exports provided: DEFAULT_ID_PROPERTY, IDENTITY, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_ID_PROPERTY\", function() { return DEFAULT_ID_PROPERTY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IDENTITY\", function() { return IDENTITY; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Metadata; });\n/* harmony import */ var _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors/carto-runtime-error */ \"./src/errors/carto-runtime-error.js\");\n/* harmony import */ var _codecs_Identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../codecs/Identity */ \"./src/codecs/Identity.js\");\n/* harmony import */ var _viz_expressions_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./viz/expressions/constants */ \"./src/renderer/viz/expressions/constants.js\");\n\n\n\n\nconst DEFAULT_MVT_EXTENT = 4096;\nconst DEFAULT_ID_PROPERTY = 'cartodb_id';\n\n// The IDENTITY metadata contains zero properties\nconst IDENTITY = {\n    properties: {}\n};\n\nclass Metadata {\n    constructor ({ properties, featureCount, sample, geomType, isAggregated, idProperty, extent } = { properties: {} }) {\n        this.properties = properties;\n        this.featureCount = featureCount;\n        this.sample = sample;\n        this.geomType = geomType;\n        this.isAggregated = isAggregated;\n        this.idProperty = idProperty || DEFAULT_ID_PROPERTY;\n        if (!this.properties.hasOwnProperty(this.idProperty)) {\n            this.properties[this.idProperty] = { type: 'number' };\n        }\n\n        this.categoryToID = new Map();\n        this.IDToCategory = new Map();\n        this.numCategories = 0;\n        this.extent = extent || DEFAULT_MVT_EXTENT;\n\n        Object.values(properties).map(property => {\n            property.categories = property.categories || [];\n            property.categories.map(category => this.categorizeString(property, category.name, true));\n        });\n\n        this.propertyKeys = Object.keys(properties);\n    }\n\n    setCodecs () {\n        throw new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_0__[\"default\"]('You must call \"setCodecs\" once you have determined the proper subclass');\n    }\n\n    categorizeString (propertyName, category, init = false) {\n        if (category === undefined) {\n            category = null;\n        }\n        if (this.categoryToID.has(category)) {\n            return this.categoryToID.get(category);\n        }\n        if (!init && category !== null) {\n            this.properties[propertyName].categories.push({\n                name: category,\n                frequency: Number.NaN\n            });\n        }\n        const categoryId = category === null ? _viz_expressions_constants__WEBPACK_IMPORTED_MODULE_2__[\"FP32_DESIGNATED_NULL_VALUE\"] : this.numCategories;\n        this.categoryToID.set(category, categoryId);\n        this.IDToCategory.set(categoryId, category);\n        this.numCategories++;\n        return categoryId;\n    }\n\n    // dataframe properties into which a single source property is decoded\n    // TODO: rename as encodedProperties or dataframeProperties\n    decodedProperties (propertyName) {\n        return [propertyName];\n    }\n\n    // property of the data origin (dataset, query) from which\n    // a (source or dataframe) property is derived\n    baseName (propertyName) {\n        return propertyName;\n    }\n\n    // property transferred from the source from which\n    // a (source or dataframe) property it so be computed\n    // TODO: move to windshaft metadata\n    sourcePropertyName (propertyName) {\n        return propertyName;\n    }\n\n    stats (propertyName) {\n        return this.properties[propertyName];\n    }\n\n    codec (propertyName) {\n        const name = this.baseName(propertyName);\n\n        return this.properties[name] && this.properties[name].codec\n            ? this.properties[name].codec\n            : new _codecs_Identity__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/renderer/dataframe/DummyDataframe.js\":\n/*!**************************************************!*\\\n  !*** ./src/renderer/dataframe/DummyDataframe.js ***!\n  \\**************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return DummyDataframe; });\n/* harmony import */ var _decoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../decoder */ \"./src/renderer/decoder/index.js\");\n/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/geometry */ \"./src/utils/geometry.js\");\n\n\n\nclass DummyDataframe {\n    constructor ({ active, center, properties, propertiesArrayBuffer, scale, type, geom, size, metadata, x, y, z }) {\n        this.active = active;\n        this.center = center;\n        this.properties = properties;\n        this.propertiesArrayBuffer = propertiesArrayBuffer;\n        this.scale = scale;\n        this.type = type;\n        this.decodedGeom = Object(_decoder__WEBPACK_IMPORTED_MODULE_0__[\"decodeGeom\"])(type, geom);\n\n        this.numVertex = (type === _utils_geometry__WEBPACK_IMPORTED_MODULE_1__[\"GEOMETRY_TYPE\"].POINT) ? size * 3 : this.decodedGeom.vertices.length / 2;\n        this.numFeatures = type === _utils_geometry__WEBPACK_IMPORTED_MODULE_1__[\"GEOMETRY_TYPE\"].POINT ? size : this.decodedGeom.breakpoints.length || this.numVertex;\n        this.propertyTex = [];\n        this.metadata = metadata;\n        this.propertyCount = 0;\n        this.x = x;\n        this.y = y;\n        this.z = z;\n\n        this._aabb = Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_1__[\"computeAABB\"])(geom, type);\n        this._centroids = Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_1__[\"computeCentroids\"])(this.decodedGeom, type);\n\n        this.t1 = [0.1, 0.1, 0.1, 0.1];\n        this.t2 = [0.1, 0.1, 0.1, 0.1];\n        this.t3 = [0.1, 0.1, 0.1, 0.1];\n        this.t4 = [0.1, 0.1, 0.1, 0.1];\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/renderer/decoder/common.js\":\n/*!****************************************!*\\\n  !*** ./src/renderer/decoder/common.js ***!\n  \\****************************************/\n/*! exports provided: addLineString, resizeBuffer */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"addLineString\", function() { return addLineString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resizeBuffer\", function() { return resizeBuffer; });\n/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/geometry */ \"./src/utils/geometry.js\");\n\n\n/**\n * Create a triangulated lineString: zero-sized, vertex-shader expanded triangle list\n * with `miter` joins. For angle < 60 joins are automatically adjusted to `bevel`.\n * https://github.com/CartoDB/carto-vl/wiki/Line-rendering\n */\nfunction addLineString (lineString, geomBuffer, index, isPolygon, skipCallback) {\n    let prevPoint, currentPoint;\n    let prevNormal, nextNormal;\n    let drawLine;\n\n    // We need at least two points\n    if (lineString.length >= 4) {\n        // Initialize the first two points\n        prevPoint = [lineString[0], lineString[1]];\n        let i = 2;\n        // The second point may be the same as the first one, iterate to find the first different one\n        for (;i <= lineString.length; i += 2) {\n            currentPoint = [lineString[i], lineString[i + 1]];\n            if (prevPoint[0] !== currentPoint[0] || prevPoint[1] !== currentPoint[1]) {\n                i += 2;\n                break;\n            }\n        }\n        prevNormal = Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_0__[\"getLineNormal\"])(prevPoint, currentPoint);\n        for (;i <= lineString.length; i += 2) {\n            drawLine = !(skipCallback && skipCallback(i));\n\n            let nextPoint;\n            // With lines, the ending point won't have a nextPoint\n            if (i <= lineString.length - 2) {\n                nextPoint = [lineString[i], lineString[i + 1]];\n            } else if (isPolygon) {\n                nextPoint = [lineString[2], lineString[3]];\n            }\n\n            if (drawLine &&\n                !(prevPoint[0] === currentPoint[0] && prevPoint[1] === currentPoint[1])) {\n                // First triangle\n                geomBuffer.vertices[index] = prevPoint[0];\n                geomBuffer.normals[index++] = -prevNormal[0];\n                geomBuffer.vertices[index] = prevPoint[1];\n                geomBuffer.normals[index++] = -prevNormal[1];\n                geomBuffer.vertices[index] = prevPoint[0];\n                geomBuffer.normals[index++] = prevNormal[0];\n                geomBuffer.vertices[index] = prevPoint[1];\n                geomBuffer.normals[index++] = prevNormal[1];\n                geomBuffer.vertices[index] = currentPoint[0];\n                geomBuffer.normals[index++] = prevNormal[0];\n                geomBuffer.vertices[index] = currentPoint[1];\n                geomBuffer.normals[index++] = prevNormal[1];\n\n                // Second triangle\n                geomBuffer.vertices[index] = prevPoint[0];\n                geomBuffer.normals[index++] = -prevNormal[0];\n                geomBuffer.vertices[index] = prevPoint[1];\n                geomBuffer.normals[index++] = -prevNormal[1];\n                geomBuffer.vertices[index] = currentPoint[0];\n                geomBuffer.normals[index++] = prevNormal[0];\n                geomBuffer.vertices[index] = currentPoint[1];\n                geomBuffer.normals[index++] = prevNormal[1];\n                geomBuffer.vertices[index] = currentPoint[0];\n                geomBuffer.normals[index++] = -prevNormal[0];\n                geomBuffer.vertices[index] = currentPoint[1];\n                geomBuffer.normals[index++] = -prevNormal[1];\n            }\n\n            if (nextPoint && !(nextPoint[0] === currentPoint[0] && nextPoint[1] === currentPoint[1])) {\n                nextNormal = Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_0__[\"getLineNormal\"])(currentPoint, nextPoint);\n\n                if (drawLine) {\n                    // `turnLeft` indicates that the nextLine turns to the left\n                    // `joinNormal` contains the direction and size for the `miter` vertex\n                    //  If this is not defined means that the join must be `bevel`.\n                    let { turnLeft, joinNormal } = Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_0__[\"getJoinNormal\"])(prevNormal, nextNormal);\n\n                    let leftNormal = turnLeft ? prevNormal : Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_0__[\"neg\"])(nextNormal);\n                    let rightNormal = turnLeft ? nextNormal : Object(_utils_geometry__WEBPACK_IMPORTED_MODULE_0__[\"neg\"])(prevNormal);\n\n                    // Third triangle\n                    geomBuffer.vertices[index] = currentPoint[0];\n                    geomBuffer.normals[index++] = 0;\n                    geomBuffer.vertices[index] = currentPoint[1];\n                    // Mark vertex to be stroke in PolygonShader with the\n                    // non-zero value 1e-37, so it validates the expression\n                    // `normal != vec2(0.)` without affecting the vertex position.\n                    geomBuffer.normals[index++] = isPolygon ? 1e-37 : 0;\n                    geomBuffer.vertices[index] = currentPoint[0];\n                    geomBuffer.normals[index++] = leftNormal[0];\n                    geomBuffer.vertices[index] = currentPoint[1];\n                    geomBuffer.normals[index++] = leftNormal[1];\n                    geomBuffer.vertices[index] = currentPoint[0];\n                    geomBuffer.normals[index++] = rightNormal[0];\n                    geomBuffer.vertices[index] = currentPoint[1];\n                    geomBuffer.normals[index++] = rightNormal[1];\n\n                    if (joinNormal) {\n                        // Forth triangle\n                        geomBuffer.vertices[index] = currentPoint[0];\n                        geomBuffer.normals[index++] = joinNormal[0];\n                        geomBuffer.vertices[index] = currentPoint[1];\n                        geomBuffer.normals[index++] = joinNormal[1];\n                        geomBuffer.vertices[index] = currentPoint[0];\n                        geomBuffer.normals[index++] = rightNormal[0];\n                        geomBuffer.vertices[index] = currentPoint[1];\n                        geomBuffer.normals[index++] = rightNormal[1];\n                        geomBuffer.vertices[index] = currentPoint[0];\n                        geomBuffer.normals[index++] = leftNormal[0];\n                        geomBuffer.vertices[index] = currentPoint[1];\n                        geomBuffer.normals[index++] = leftNormal[1];\n                    }\n                }\n            } else {\n                nextNormal = prevNormal;\n            }\n\n            // Update the variables for the next iteration\n            prevPoint = currentPoint;\n            currentPoint = nextPoint;\n            prevNormal = nextNormal;\n        }\n    }\n    return index;\n}\n\n/**\n * Resize a Float32Array buffer in an efficient way\n */\nfunction resizeBuffer (oldBuffer, newSize) {\n    const newBuffer = new Float32Array(newSize);\n    newBuffer.set(oldBuffer);\n    return newBuffer;\n}\n\n\n/***/ }),\n\n/***/ \"./src/renderer/decoder/index.js\":\n/*!***************************************!*\\\n  !*** ./src/renderer/decoder/index.js ***!\n  \\***************************************/\n/*! exports provided: decodeGeom */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decodeGeom\", function() { return decodeGeom; });\n/* harmony import */ var _pointDecoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pointDecoder */ \"./src/renderer/decoder/pointDecoder.js\");\n/* harmony import */ var _lineDecoder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lineDecoder */ \"./src/renderer/decoder/lineDecoder.js\");\n/* harmony import */ var _polygonDecoder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polygonDecoder */ \"./src/renderer/decoder/polygonDecoder.js\");\n/* harmony import */ var _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../errors/carto-runtime-error */ \"./src/errors/carto-runtime-error.js\");\n/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/geometry */ \"./src/utils/geometry.js\");\n\n\n\n\n\n\nfunction decodeGeom (geomType, geom) {\n    switch (geomType) {\n        case _utils_geometry__WEBPACK_IMPORTED_MODULE_4__[\"GEOMETRY_TYPE\"].POINT:\n            return Object(_pointDecoder__WEBPACK_IMPORTED_MODULE_0__[\"decodePoint\"])(geom);\n        case _utils_geometry__WEBPACK_IMPORTED_MODULE_4__[\"GEOMETRY_TYPE\"].LINE:\n            return Object(_lineDecoder__WEBPACK_IMPORTED_MODULE_1__[\"decodeLine\"])(geom);\n        case _utils_geometry__WEBPACK_IMPORTED_MODULE_4__[\"GEOMETRY_TYPE\"].POLYGON:\n            return Object(_polygonDecoder__WEBPACK_IMPORTED_MODULE_2__[\"decodePolygon\"])(geom);\n        default:\n            throw new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](\n                `Unimplemented geometry type: '${geomType}'.`,\n                _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_3__[\"CartoRuntimeErrorTypes\"].NOT_SUPPORTED\n            );\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/renderer/decoder/lineDecoder.js\":\n/*!*********************************************!*\\\n  !*** ./src/renderer/decoder/lineDecoder.js ***!\n  \\*********************************************/\n/*! exports provided: decodeLine */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decodeLine\", function() { return decodeLine; });\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ \"./src/renderer/decoder/common.js\");\n\n\n// If the geometry type is GEOMETRY_TYPE.LINE it will generate the appropriate zero-sized, vertex-shader expanded triangle list with `miter` and `bevel` joins.\n// The geom will be an array of coordinates in this case\n\nconst STATIC_INITIAL_BUFFER_SIZE = 1024 * 1024; // 4 MB\nconst MAX_VERTICES_COORDINATES_PER_SEGMENT = 24;\n\nlet index = 0;\nlet geomBuffer = {\n    vertices: new Float32Array(STATIC_INITIAL_BUFFER_SIZE),\n    normals: new Float32Array(STATIC_INITIAL_BUFFER_SIZE)\n};\n\nfunction decodeLine (geometry) {\n    let breakpoints = []; // Array of indices (to vertexArray) that separate each feature\n    let featureIDToVertexIndex = new Map();\n\n    index = 0;\n    for (let i = 0; i < geometry.length; i++) {\n        const feature = geometry[i];\n        for (let j = 0; j < feature.length; j++) {\n            // Increase buffers size if required\n            resizeBuffers(MAX_VERTICES_COORDINATES_PER_SEGMENT * feature[j].length);\n\n            // Add line string\n            index = Object(_common__WEBPACK_IMPORTED_MODULE_0__[\"addLineString\"])(feature[j], geomBuffer, index);\n        }\n\n        featureIDToVertexIndex.set(breakpoints.length, breakpoints.length === 0\n            ? { start: 0, end: index }\n            : { start: featureIDToVertexIndex.get(breakpoints.length - 1).end, end: index });\n\n        breakpoints.push(index);\n    }\n\n    const verticesArrayBuffer = new ArrayBuffer(4 * index);\n    const normalsArrayBuffer = new ArrayBuffer(4 * index);\n    const vertices = new Float32Array(verticesArrayBuffer);\n    const normals = new Float32Array(normalsArrayBuffer);\n    for (let i = 0; i < index; i++) {\n        vertices[i] = geomBuffer.vertices[i];\n        normals[i] = geomBuffer.normals[i];\n    }\n    return {\n        vertices,\n        normals,\n        verticesArrayBuffer,\n        normalsArrayBuffer,\n        featureIDToVertexIndex,\n        breakpoints\n    };\n}\n\n// Resize buffers as needed if `additionalSize` floats overflow the current buffers.\nfunction resizeBuffers (additionalSize) {\n    const minimumNeededSize = index + additionalSize;\n    if (minimumNeededSize > geomBuffer.vertices.length) {\n        const newSize = 2 * minimumNeededSize;\n        geomBuffer.vertices = Object(_common__WEBPACK_IMPORTED_MODULE_0__[\"resizeBuffer\"])(geomBuffer.vertices, newSize);\n        geomBuffer.normals = Object(_common__WEBPACK_IMPORTED_MODULE_0__[\"resizeBuffer\"])(geomBuffer.normals, newSize);\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/renderer/decoder/pointDecoder.js\":\n/*!**********************************************!*\\\n  !*** ./src/renderer/decoder/pointDecoder.js ***!\n  \\**********************************************/\n/*! exports provided: decodePoint */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decodePoint\", function() { return decodePoint; });\n// If the geometry type is GEOMETRY_TYPE.POINT it will pass through the geom (the vertex array)\n\nfunction decodePoint (verticesArrayBuffer) {\n    return {\n        verticesArrayBuffer: verticesArrayBuffer,\n        vertices: new Float32Array(verticesArrayBuffer),\n        breakpoints: []\n    };\n}\n\n\n/***/ }),\n\n/***/ \"./src/renderer/decoder/polygonDecoder.js\":\n/*!************************************************!*\\\n  !*** ./src/renderer/decoder/polygonDecoder.js ***!\n  \\************************************************/\n/*! exports provided: decodePolygon */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decodePolygon\", function() { return decodePolygon; });\n/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! earcut */ \"./node_modules/earcut/src/earcut.js\");\n/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(earcut__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common */ \"./src/renderer/decoder/common.js\");\n\n\n\n// If the geometry type is GEOMETRY_TYPE.POLYGON it will triangulate the polygon list (geom)\n// geom will be a list of polygons in which each polygon will have a flat array of vertices and a list of holes indices\n// Example:\n/*   let geom = [{\n       flat: [\n         0.,0., 1.,0., 1.,1., 0.,1., 0.,0, //A square\n         0.25,0.25, 0.75,0.25, 0.75,0.75, 0.25,0.75, 0.25,0.25//A small square\n       ]\n       holes: [5]\n     }]\n*/\n\nconst STATIC_INITIAL_BUFFER_SIZE = 1024 * 1024 * 2; // 8 MB\nconst VERTEX_COORDINATES_PER_TRIANGLE = 2;\nconst MAX_VERTICES_COORDINATES_PER_SEGMENT = 24;\n\nlet index = 0;\nlet geomBuffer = {\n    vertices: new Float32Array(STATIC_INITIAL_BUFFER_SIZE),\n    normals: new Float32Array(STATIC_INITIAL_BUFFER_SIZE)\n};\n\nfunction decodePolygon (geometry) {\n    let breakpoints = []; // Array of indices (to vertexArray) that separate each feature\n    let featureIDToVertexIndex = new Map();\n\n    index = 0;\n    for (let i = 0; i < geometry.length; i++) {\n        const feature = geometry[i];\n        for (let j = 0; j < feature.length; j++) {\n            const polygon = feature[j];\n            const triangles = earcut__WEBPACK_IMPORTED_MODULE_0__(polygon.flat, polygon.holes);\n\n            // Increase buffers size if required\n            resizeBuffers(VERTEX_COORDINATES_PER_TRIANGLE * triangles.length +\n                MAX_VERTICES_COORDINATES_PER_SEGMENT * polygon.flat.length);\n\n            // Add polygon\n            for (let k = 0; k < triangles.length; k++) {\n                addVertex(polygon.flat, 2 * triangles[k]);\n            }\n\n            // Add polygon stroke\n            index = Object(_common__WEBPACK_IMPORTED_MODULE_1__[\"addLineString\"])(polygon.flat, geomBuffer, index, true, (pointIndex) => {\n                // Skip adding the line which connects two rings OR is clipped\n                return polygon.holes.includes((pointIndex - 2) / 2) || isClipped(polygon, pointIndex - 4, pointIndex - 2);\n            });\n        }\n\n        featureIDToVertexIndex.set(breakpoints.length, breakpoints.length === 0\n            ? { start: 0, end: index }\n            : { start: featureIDToVertexIndex.get(breakpoints.length - 1).end, end: index });\n\n        breakpoints.push(index);\n    }\n\n    const verticesArrayBuffer = new ArrayBuffer(4 * index);\n    const normalsArrayBuffer = new ArrayBuffer(4 * index);\n    const vertices = new Float32Array(verticesArrayBuffer);\n    const normals = new Float32Array(normalsArrayBuffer);\n    for (let i = 0; i < index; i++) {\n        vertices[i] = geomBuffer.vertices[i];\n        normals[i] = geomBuffer.normals[i];\n    }\n    return {\n        vertices,\n        normals,\n        verticesArrayBuffer,\n        normalsArrayBuffer,\n        featureIDToVertexIndex,\n        breakpoints\n    };\n}\n\n// Resize buffers as needed if `additionalSize` floats overflow the current buffers\nfunction resizeBuffers (additionalSize) {\n    const minimumNeededSize = index + additionalSize;\n    if (minimumNeededSize > geomBuffer.vertices.length) {\n        const newSize = 2 * minimumNeededSize;\n        geomBuffer.vertices = Object(_common__WEBPACK_IMPORTED_MODULE_1__[\"resizeBuffer\"])(geomBuffer.vertices, newSize);\n        geomBuffer.normals = Object(_common__WEBPACK_IMPORTED_MODULE_1__[\"resizeBuffer\"])(geomBuffer.normals, newSize);\n    }\n}\n\n// Add vertex in triangles.\nfunction addVertex (array, vertexIndex) {\n    geomBuffer.vertices[index] = array[vertexIndex];\n    geomBuffer.normals[index++] = 0;\n    geomBuffer.vertices[index] = array[vertexIndex + 1];\n    geomBuffer.normals[index++] = 0;\n}\n\nfunction isClipped (polygon, i, j) {\n    if (polygon.clipped.includes(i) && polygon.clipped.includes(j)) {\n        if (polygon.clippedType[polygon.clipped.indexOf(i)] &\n            polygon.clippedType[polygon.clipped.indexOf(j)]) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n/***/ }),\n\n/***/ \"./src/renderer/viz/expressions/constants.js\":\n/*!***************************************************!*\\\n  !*** ./src/renderer/viz/expressions/constants.js ***!\n  \\***************************************************/\n/*! exports provided: DEFAULT_RAMP_OTHERS, DEFAULT_SAMPLES, OTHERS_GLSL_VALUE, OTHERS_INDEX, OTHERS_LABEL, SORT_DESC, SORT_ASC, DEFAULT_OPTIONS, FP32_DESIGNATED_NULL_VALUE */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_RAMP_OTHERS\", function() { return DEFAULT_RAMP_OTHERS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_SAMPLES\", function() { return DEFAULT_SAMPLES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OTHERS_GLSL_VALUE\", function() { return OTHERS_GLSL_VALUE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OTHERS_INDEX\", function() { return OTHERS_INDEX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OTHERS_LABEL\", function() { return OTHERS_LABEL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SORT_DESC\", function() { return SORT_DESC; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SORT_ASC\", function() { return SORT_ASC; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEFAULT_OPTIONS\", function() { return DEFAULT_OPTIONS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FP32_DESIGNATED_NULL_VALUE\", function() { return FP32_DESIGNATED_NULL_VALUE; });\nconst DEFAULT_RAMP_OTHERS = 'DEFAULT_RAMP_OTHERS';\nconst DEFAULT_SAMPLES = 10;\nconst OTHERS_GLSL_VALUE = '(-1.)';\nconst OTHERS_INDEX = -1;\nconst OTHERS_LABEL = 'CARTO_VL_OTHERS';\nconst SORT_DESC = 'DESC';\nconst SORT_ASC = 'ASC';\nconst DEFAULT_OPTIONS = {\n    othersLabel: OTHERS_LABEL,\n    samples: DEFAULT_SAMPLES,\n    order: SORT_ASC\n};\n\nconst FP32_DESIGNATED_NULL_VALUE = -(1 << 24);\n\n\n/***/ }),\n\n/***/ \"./src/renderer/viz/expressions/stats.js\":\n/*!***********************************************!*\\\n  !*** ./src/renderer/viz/expressions/stats.js ***!\n  \\***********************************************/\n/*! exports provided: average, variance, standardDeviation */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"average\", function() { return average; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"variance\", function() { return variance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"standardDeviation\", function() { return standardDeviation; });\n\n/**\n * Calculate Average\n *\n * @param {Number[]} values\n * @returns {Number} - average\n */\nconst average = (values) => {\n    let sum = 0;\n    for (let i = 0; i < values.length; i++) {\n        sum += values[i];\n    }\n    return sum / values.length;\n};\n/**\n * Calculate Variance\n *\n * @param {Number[]} values\n * @param {Number} average\n * @returns {Number[]} - calculate variance for each element in values\n */\nconst variance = (values, average) => {\n    let variances = [];\n    for (let i = 0; i < values.length; i++) {\n        const diff = values[i] - average;\n        variances.push(diff * diff);\n    }\n    return variances;\n};\n\n/**\n * Calculate Standard Deviation (STD), using population deviation formula\n *\n * @param {Number[]} values\n * @returns {Number} - standard deviation\n */\nconst standardDeviation = (values) => {\n    const avg = average(values);\n    const avgVariance = average(variance(values, avg));\n    return Math.sqrt(avgVariance);\n};\n\n\n/***/ }),\n\n/***/ \"./src/sources/MVTMetadata.js\":\n/*!************************************!*\\\n  !*** ./src/sources/MVTMetadata.js ***!\n  \\************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return MVTMetadata; });\n/* harmony import */ var _renderer_Metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../renderer/Metadata */ \"./src/renderer/Metadata.js\");\n/* harmony import */ var _codecs_mvt__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../codecs/mvt */ \"./src/codecs/mvt/index.js\");\n\n\n\nclass MVTMetadata extends _renderer_Metadata__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n    setCodecs () {\n        Object.keys(this.properties).forEach(propertyName => {\n            const property = this.properties[propertyName];\n            const type = property.type;\n            if (type !== 'geometry') {\n                property.codec = Object(_codecs_mvt__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, type, propertyName);\n            }\n        });\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/sources/MVTWorker.js\":\n/*!**********************************!*\\\n  !*** ./src/sources/MVTWorker.js ***!\n  \\**********************************/\n/*! exports provided: MVTWorker */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MVTWorker\", function() { return MVTWorker; });\n/* harmony import */ var _mapbox_vector_tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mapbox/vector-tile */ \"./node_modules/@mapbox/vector-tile/index.js\");\n/* harmony import */ var _mapbox_vector_tile__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mapbox_vector_tile__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var pbf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pbf */ \"./node_modules/pbf/index.js\");\n/* harmony import */ var pbf__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pbf__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _client_rsys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../client/rsys */ \"./src/client/rsys.js\");\n/* harmony import */ var _client_mvt_feature_decoder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../client/mvt/feature-decoder */ \"./src/client/mvt/feature-decoder.js\");\n/* harmony import */ var _MVTMetadata__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./MVTMetadata */ \"./src/sources/MVTMetadata.js\");\n/* harmony import */ var _renderer_dataframe_DummyDataframe__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../renderer/dataframe/DummyDataframe */ \"./src/renderer/dataframe/DummyDataframe.js\");\n/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../errors/carto-validation-error */ \"./src/errors/carto-validation-error.js\");\n/* harmony import */ var _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../errors/carto-runtime-error */ \"./src/errors/carto-runtime-error.js\");\n/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/geometry */ \"./src/utils/geometry.js\");\n\n\n\n\n\n\n\n\n\n\n// TODO import correctly\nconst RTT_WIDTH = 1024;\n\n// Constants for '@mapbox/vector-tile' geometry types, from https://github.com/mapbox/vector-tile-js/blob/v1.3.0/lib/vectortilefeature.js#L39\nconst mvtDecoderGeomTypes = { point: 1, line: 2, polygon: 3 };\n\nconst MVT_TO_CARTO_TYPES = {\n    1: _utils_geometry__WEBPACK_IMPORTED_MODULE_8__[\"GEOMETRY_TYPE\"].POINT,\n    2: _utils_geometry__WEBPACK_IMPORTED_MODULE_8__[\"GEOMETRY_TYPE\"].LINE,\n    3: _utils_geometry__WEBPACK_IMPORTED_MODULE_8__[\"GEOMETRY_TYPE\"].POLYGON\n};\n\nclass MVTWorker {\n    // Worker API\n    onmessage (event) {\n        this.processEvent(event).then(message => {\n            const transferables = [];\n            if (!message.dataframe.empty) {\n                transferables.push(message.dataframe.propertiesArrayBuffer);\n                transferables.push(message.dataframe.decodedGeom.verticesArrayBuffer);\n                if (message.dataframe.decodedGeom.normalsArrayBuffer) {\n                    transferables.push(message.dataframe.decodedGeom.normalsArrayBuffer);\n                }\n            }\n            postMessage(message, transferables);\n        });\n    }\n    async processEvent (event) {\n        const params = event.data;\n        if (params.metadata) {\n            this.castMetadata(params.metadata);\n            this.metadata = params.metadata;\n        }\n        const dataframe = await this._requestDataframe(params.x, params.y, params.z, params.url, params.layerID, this.metadata);\n        return {\n            mID: params.mID,\n            dataframe\n        };\n    }\n\n    castMetadata (metadata) {\n        Object.setPrototypeOf(metadata, _MVTMetadata__WEBPACK_IMPORTED_MODULE_4__[\"default\"].prototype);\n        metadata.setCodecs();\n    }\n\n    async _requestDataframe (x, y, z, url, layerID, metadata) {\n        const response = await fetch(url);\n        const dataframe = await this.urlToDataframeTransformer(response, x, y, z, layerID, metadata);\n        return dataframe;\n    }\n\n    async urlToDataframeTransformer (response, x, y, z, layerID, metadata) {\n        const MVT_EXTENT = metadata.extent;\n        const arrayBuffer = await response.arrayBuffer();\n        if (arrayBuffer.byteLength === 0 || response === 'null') {\n            return { empty: true };\n        }\n        const tile = new _mapbox_vector_tile__WEBPACK_IMPORTED_MODULE_0__[\"VectorTile\"](new pbf__WEBPACK_IMPORTED_MODULE_1__(arrayBuffer));\n\n        if (Object.keys(tile.layers).length > 1 && !layerID) {\n            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__[\"default\"](\n                `LayerID parameter wasn't specified and the MVT tile contains multiple layers: ${JSON.stringify(Object.keys(tile.layers))}.`,\n                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__[\"CartoValidationErrorTypes\"].MISSING_REQUIRED\n            );\n        }\n\n        const mvtLayer = tile.layers[layerID || Object.keys(tile.layers)[0]]; // FIXME this!!!\n\n        if (!mvtLayer) {\n            return { empty: true };\n        }\n\n        const { geometries, properties, propertiesArrayBuffer, numFeatures } = this._decodeMVTLayer(mvtLayer, metadata, MVT_EXTENT);\n        const rs = _client_rsys__WEBPACK_IMPORTED_MODULE_2__[\"getRsysFromTile\"](x, y, z);\n        const dataframe = this._generateDataFrame(rs, geometries, properties, propertiesArrayBuffer, numFeatures, metadata.geomType, metadata);\n\n        return dataframe;\n    }\n\n    _decodeMVTLayer (mvtLayer, metadata, mvtExtent) {\n        if (!mvtLayer.length) {\n            return { properties: [], geometries: {}, propertiesArrayBuffer: [], numFeatures: 0 };\n        }\n        if (!metadata.geomType) {\n            metadata.geomType = this._autoDiscoverType(mvtLayer);\n        }\n        switch (metadata.geomType) {\n            case _utils_geometry__WEBPACK_IMPORTED_MODULE_8__[\"GEOMETRY_TYPE\"].POINT:\n                const arrayBuffer = new ArrayBuffer(mvtLayer.length * 2 * 3 * 4);// SIZEOF\n                return this._decode(mvtLayer, metadata, mvtExtent, arrayBuffer);\n            case _utils_geometry__WEBPACK_IMPORTED_MODULE_8__[\"GEOMETRY_TYPE\"].LINE:\n                return this._decode(mvtLayer, metadata, mvtExtent, [], _client_mvt_feature_decoder__WEBPACK_IMPORTED_MODULE_3__[\"decodeLines\"]);\n            case _utils_geometry__WEBPACK_IMPORTED_MODULE_8__[\"GEOMETRY_TYPE\"].POLYGON:\n                return this._decode(mvtLayer, metadata, mvtExtent, [], _client_mvt_feature_decoder__WEBPACK_IMPORTED_MODULE_3__[\"decodePolygons\"]);\n            default:\n                throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__[\"default\"](`MVT: invalid geometry type '${metadata.geomType}'`, _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__[\"CartoValidationErrorTypes\"].INCORRECT_TYPE);\n        }\n    }\n\n    _autoDiscoverType (mvtLayer) {\n        const type = mvtLayer.feature(0).type;\n        switch (type) {\n            case mvtDecoderGeomTypes.point:\n                return _utils_geometry__WEBPACK_IMPORTED_MODULE_8__[\"GEOMETRY_TYPE\"].POINT;\n            case mvtDecoderGeomTypes.line:\n                return _utils_geometry__WEBPACK_IMPORTED_MODULE_8__[\"GEOMETRY_TYPE\"].LINE;\n            case mvtDecoderGeomTypes.polygon:\n                return _utils_geometry__WEBPACK_IMPORTED_MODULE_8__[\"GEOMETRY_TYPE\"].POLYGON;\n            default:\n                throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__[\"default\"](`MVT: invalid geometry type '${type}'`, _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__[\"CartoValidationErrorTypes\"].INCORRECT_TYPE);\n        }\n    }\n\n    _decode (mvtLayer, metadata, mvtExtent, geometries, decodeFn) {\n        let numFeatures = 0;\n        let pointGeometries;\n        if (geometries) {\n            pointGeometries = new Float32Array(geometries);\n        }\n        const { properties, propertiesArrayBuffer } = this._initializePropertyArrays(metadata, mvtLayer.length);\n        const scalarPropertyCodecs = this._scalarPropertyCodecs(metadata);\n        const rangePropertyCodecs = this._rangePropertyCodecs(metadata);\n        for (let i = 0; i < mvtLayer.length; i++) {\n            const f = mvtLayer.feature(i);\n            this._checkType(f, metadata.geomType);\n            const geom = f.loadGeometry();\n            if (decodeFn) {\n                const decodedPolygons = decodeFn(geom, mvtExtent);\n                geometries.push(decodedPolygons);\n            } else {\n                // TODO refactor\n                const x = 2 * (geom[0][0].x) / mvtExtent - 1.0;\n                const y = 2 * (1.0 - (geom[0][0].y) / mvtExtent) - 1.0;\n                // Tiles may contain points in the border;\n                // we'll avoid here duplicated points between tiles by excluding the 1-edge\n                if (x < -1 || x >= 1 || y < -1 || y >= 1) {\n                    continue;\n                }\n                pointGeometries[6 * numFeatures + 0] = x;\n                pointGeometries[6 * numFeatures + 1] = y;\n                pointGeometries[6 * numFeatures + 2] = x;\n                pointGeometries[6 * numFeatures + 3] = y;\n                pointGeometries[6 * numFeatures + 4] = x;\n                pointGeometries[6 * numFeatures + 5] = y;\n            }\n            if (f.properties[metadata.idProperty] === undefined) {\n                throw new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_7__[\"default\"](\n                    `MVT feature with undefined idProperty '${metadata.idProperty}'`,\n                    _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_7__[\"CartoRuntimeErrorTypes\"].MVT\n                );\n            }\n            this._decodeProperties(metadata, scalarPropertyCodecs, rangePropertyCodecs, properties, f, numFeatures);\n            numFeatures++;\n        }\n\n        return { properties, propertiesArrayBuffer, geometries, numFeatures };\n    }\n\n    // Currently only mvtLayers with the same type in every feature are supported\n    _checkType (feature, expected) {\n        const type = feature.type;\n        const actual = MVT_TO_CARTO_TYPES[type];\n        if (actual !== expected) {\n            throw new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_7__[\"default\"](\n                `MVT: mixed geometry types in the same layer. Layer has type: ${expected} but feature was ${actual}`,\n                _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_7__[\"CartoRuntimeErrorTypes\"].MVT\n            );\n        }\n    }\n\n    _initializePropertyArrays (metadata, length) {\n        const propertyNames = this._getPropertyNamesFrom(metadata);\n        const { properties, propertiesArrayBuffer } = this._getPropertiesFor(propertyNames, length);\n        return { propertyNames, properties, propertiesArrayBuffer };\n    }\n\n    _getSourcePropertyNamesFrom (metadata) {\n        return metadata.propertyKeys.filter(name => metadata.properties[metadata.baseName(name)].type !== 'geometry');\n    }\n\n    _getPropertyNamesFrom (metadata) {\n        const propertyNames = [];\n        this._getSourcePropertyNamesFrom(metadata).forEach(sourceName => {\n            metadata.decodedProperties(sourceName).forEach(propertyName => {\n                propertyNames.push(propertyName);\n            });\n        });\n        return propertyNames;\n    }\n\n    _getPropertiesFor (propertyNames, length) {\n        const properties = {};\n        const size = Math.ceil(length / RTT_WIDTH) * RTT_WIDTH;\n\n        const arrayBuffer = new ArrayBuffer(4 * size * propertyNames.length);\n        const propertiesArrayBuffer = arrayBuffer;\n        for (let i = 0; i < propertyNames.length; i++) {\n            const propertyName = propertyNames[i];\n            properties[propertyName] = new Float32Array(arrayBuffer, i * 4 * size, size);\n        }\n\n        return { properties, propertiesArrayBuffer };\n    }\n\n    _scalarPropertyCodecs (metadata) {\n        return this._getSourcePropertyNamesFrom(metadata)\n            .map(prop => [prop, metadata.codec(prop)])\n            .filter(([_, codec]) => !codec.isRange());\n    }\n\n    _rangePropertyCodecs (metadata) {\n        return this._getSourcePropertyNamesFrom(metadata)\n            .map(prop => [prop, metadata.decodedProperties(prop), metadata.codec(prop)])\n            .filter(([_prop, _dprop, codec]) => codec.isRange());\n    }\n\n    _decodeProperties (metadata, scalarPropertyCodecs, rangePropertyCodecs, properties, feature, i) {\n        let length = scalarPropertyCodecs.length;\n        for (let j = 0; j < length; j++) {\n            const [propertyName, codec] = scalarPropertyCodecs[j];\n            const propertyValue = feature.properties[propertyName];\n            properties[propertyName][i] = codec.sourceToInternal(metadata, propertyValue);\n        }\n\n        length = rangePropertyCodecs.length;\n        for (let j = 0; j < length; j++) {\n            const [propertyName, [loPropertyName, hiPropertyName], codec] = rangePropertyCodecs[j];\n            const propertyValue = feature.properties[propertyName];\n            const [loValue, hiValue] = codec.sourceToInternal(metadata, propertyValue);\n            properties[loPropertyName][i] = loValue;\n            properties[hiPropertyName][i] = hiValue;\n        }\n    }\n\n    _generateDataFrame (rs, geometry, properties, propertiesArrayBuffer, size, type, metadata) {\n        return new _renderer_dataframe_DummyDataframe__WEBPACK_IMPORTED_MODULE_5__[\"default\"]({\n            active: false,\n            center: rs.center,\n            geom: geometry,\n            properties: properties,\n            propertiesArrayBuffer: propertiesArrayBuffer,\n            scale: rs.scale,\n            size: size,\n            type: type,\n            metadata\n        });\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/sources/Workers.worker.js\":\n/*!***************************************!*\\\n  !*** ./src/sources/Workers.worker.js ***!\n  \\***************************************/\n/*! no exports provided */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _MVTWorker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MVTWorker */ \"./src/sources/MVTWorker.js\");\n/* harmony import */ var _client_WindshaftWorker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../client/WindshaftWorker */ \"./src/client/WindshaftWorker.js\");\n/* harmony import */ var _bigquery_BQTilesetWorker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bigquery/BQTilesetWorker */ \"./src/sources/bigquery/BQTilesetWorker.js\");\n\n\n\n\n// This file publishes a Web Worker onmessage function that will redirect incoming messages\n// based on an ID (`workerName`) defined by the message sender\n// to each different Worker implementation\n\nconst workers = {\n    MVT: new _MVTWorker__WEBPACK_IMPORTED_MODULE_0__[\"MVTWorker\"](),\n    windshaft: new _client_WindshaftWorker__WEBPACK_IMPORTED_MODULE_1__[\"WindshaftWorker\"](),\n    BigQueryTileset: new _bigquery_BQTilesetWorker__WEBPACK_IMPORTED_MODULE_2__[\"BigQueryTilesetWorker\"]()\n};\n\nonmessage = function (event) {\n    return workers[event.data.workerName].onmessage(event);\n};\n\n\n/***/ }),\n\n/***/ \"./src/sources/bigquery/BQClient.js\":\n/*!******************************************!*\\\n  !*** ./src/sources/bigquery/BQClient.js ***!\n  \\******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return BigQueryClient; });\nconst ENDPOINT_URL = 'https://bigquery.googleapis.com/bigquery/v2';\nconst QUERY_TIMEOUT = 5 * 1000;\nconst POLLING_TIMEOUT = 2 * 60 * 1000;\n\nclass BigQueryClient {\n    constructor (projectId, token) {\n        this._projectId = projectId;\n        this._token = token;\n        this._activeJobs = {};\n    }\n\n    async list () {\n        return this.fetch('GET', 'jobs');\n    }\n\n    async insert () {\n        return this.fetch('POST', 'jobs');\n    }\n\n    async get (jobId) {\n        return this.fetch('GET', `jobs/${jobId}`);\n    }\n\n    async cancel (jobId) {\n        return this.fetch('POST', `jobs/${jobId}/cancel`);\n    }\n\n    async query (sqlQuery) {\n        return this.fetch('POST', 'queries', {\n            kind: 'bigquery#queryRequest',\n            query: sqlQuery,\n            useLegacySql: false,\n            timeoutMs: QUERY_TIMEOUT,\n            useQueryCache: true\n        });\n    }\n\n    async getQueryResults (jobId) {\n        return this.fetch('GET', `queries/${jobId}?timeoutMs=${QUERY_TIMEOUT}`);\n    }\n\n    async execute (sqlQuery) {\n        const result = await this.query(sqlQuery);\n        if (result.error) {\n            throw Error(`[${result.error.status}] ${result.error.message}`);\n        }\n        return this._pollingQuery(result);\n    }\n\n    async _pollingQuery (result) {\n        return new Promise((resolve, reject) => {\n            if (result.jobComplete) {\n                resolve(result);\n            } else {\n                const jobId = result.jobReference.jobId;\n                this._updateJobTime(jobId);\n                if (this._jobTimeout(jobId)) {\n                    this._cancelJob(jobId, reject);\n                } else {\n                    this._getJobResult(jobId, resolve);\n                }\n            }\n        });\n    }\n\n    _jobTimeout (jobId) {\n        return this._activeJobs[jobId] >= POLLING_TIMEOUT;\n    }\n\n    _updateJobTime (jobId) {\n        if (jobId in this._activeJobs) {\n            this._activeJobs[jobId] += QUERY_TIMEOUT;\n        } else {\n            this._activeJobs[jobId] = QUERY_TIMEOUT;\n        }\n    }\n\n    async _cancelJob (jobId, reject) {\n        const result = await this.cancel(jobId);\n        delete this._activeJobs[jobId];\n        reject(result);\n    }\n\n    async _getJobResult (jobId, resolve) {\n        const result = await this.getQueryResults(jobId);\n        if (result.jobComplete) {\n            resolve(result);\n        } else {\n            resolve(this._pollingQuery(result));\n        }\n    }\n\n    async fetch (method, url, body) {\n        const response = await fetch(`${ENDPOINT_URL}/projects/${this._projectId}/${url}`, {\n            method,\n            headers: {\n                'Authorization': `Bearer ${this._token}`,\n                'Content-Type': 'application/json'\n            },\n            body: body && JSON.stringify(body)\n        });\n        return response.json();\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/sources/bigquery/BQQuadkey.js\":\n/*!*******************************************!*\\\n  !*** ./src/sources/bigquery/BQQuadkey.js ***!\n  \\*******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return GilbertPartition; });\n/* eslint-disable */\n\n\nconst PARTITION_UNPARTITIONED = 0;\n\n/**\n * Assigns partitions to zoom levels given the number of partitions and zoom ranges available\n * Partitions always start at 1 (0 is used for outside levels) and end at the **partitions** parameter\n *\n * On the default situation (zmin = 0) we assign to the max zoom level, 3/4ths of the available partitions\n * since approximately 75% of the tiles are always found in the highest zoom. Then, we assign 75%\n * of the **remaining** space to the zoom level right below it, 75%(75%(75%)) to the next one, and so on.\n *\n * When (zmin != 0) we divide the \"saved\" partition space in the same proportion as the full partition table\n *\n * When (zstep != 1) we assign those partitions to the next valid zoom level\n */\nfunction partition_range_by_zoom(partition_count, param = { z, zmin, zmax, zstep }) {\n\n    if (param.z < 0 || param.zmin < 0 || param.zmax < 0 || param.zstep < 1 ||\n        param.z < param.zmin || param.z > param.zmax || param.partition_count < 1 ||\n        (param.z != param.zmin && ((param.z - param.zmin) % param.zstep) !== 0)) {\n        return { min: PARTITION_UNPARTITIONED, max: PARTITION_UNPARTITIONED };\n    }\n\n    /* Adapt levels to always start from 0 */\n    const zstep = param.zstep;\n    const zmin = 0;\n    let zmax = param.zmax - param.zmin;\n    zmax = zmax - (zmax % zstep);\n    let z = param.z - param.zmin;\n    let range_initial_z = z - zstep + 1;\n\n    const global_start = 1;\n    const global_end = partition_count;\n\n    if (zmin == zmax || global_start == global_end) {\n        return { min: global_start, max: global_end };\n    }\n\n    /* Note that the z0 level gets special treatment since it gets the whole 100% of its remaining space */\n    let z_partitions = 0;\n    let partition_start;\n    if (z == 0) {\n        z_partitions = 4 * global_end / Math.pow(4, zmax + 1);\n        partition_start = 0;\n    } else {\n        for (let acc = range_initial_z; acc <= z; acc++) {\n            z_partitions += 3 * global_end / Math.pow(4, zmax - acc + 1);\n        }\n        partition_start = global_end / Math.pow(4, zmax - range_initial_z + 1);\n    }\n    const partition_end = partition_start + z_partitions;\n    /* We round the start (instead of using floor) to give the lower zoom levels more partitions as \n     * they tend to be overcrowded, especially in rectangles with a great difference between height and width\n     */\n    partition_start = Math.round(partition_start);\n    return {\n        min: partition_start + global_start,\n        max: Math.min(global_end, Math.max(Math.floor(partition_end), partition_start) + global_start)\n    };\n}\n\n/* Finds the position of `target` inside the Gilbert curve defined by the rectangle:\n * cursor: Current position (start)\n * vector_main: Main direction of movement.\n *              It should move only on one axis, and it can be positive or negative.\n * vector_sec: Secondary direction of movement. Orthogonal to and smaller than vector_main.\n *\n * This is currently recursive, so the value is being add up inside target.counter\n */\nfunction gilbert2d(cursor = { x, y },\n    vector_main = { x, y },\n    vector_sec = { x, y },\n    target = { counter, x, y }) {\n    /* Vector direction of movement (-1, 0 or +1) */\n    const main_dirx = Math.sign(vector_main.x);\n    const main_diry = Math.sign(vector_main.y);\n    const sec_dirx = Math.sign(vector_sec.x);\n    const sec_diry = Math.sign(vector_sec.y);\n\n    const xmin = Math.min(cursor.x, cursor.x + vector_main.x - main_dirx + vector_sec.x - sec_dirx);\n    const xmax = Math.max(cursor.x, cursor.x + vector_main.x - main_dirx + vector_sec.x - sec_dirx);\n    const ymin = Math.min(cursor.y, cursor.y + vector_main.y - main_diry + vector_sec.y - sec_diry);\n    const ymax = Math.max(cursor.y, cursor.y + vector_main.y - main_diry + vector_sec.y - sec_diry);\n    if (target.x < xmin || target.x > xmax || target.y < ymin || target.y > ymax) {\n        /* The tile we are looking for is not insde this rectangle. Add up its size and do a fast exit */\n        target.counter += (xmax - xmin + 1) * (ymax - ymin + 1);\n        return -1;\n    }\n\n    /* We can calculate the magnitude of the vectors this way because one of the coordinates\n     * will always be 0 */\n    const vector_main_magnitude = Math.abs(vector_main.x + vector_main.y);\n    const vector_sec_magnitude = Math.abs(vector_sec.x + vector_sec.y);\n\n    if (vector_main_magnitude == 1 || vector_sec_magnitude == 1) {\n        /* We have either one row or one column. Either way, the position is the distance between\n         * the current point and the target */\n        target.counter += Math.abs((cursor.x - target.x) + (cursor.y - target.y));\n        return target.counter;\n    }\n\n    const vector_main_half = {\n        x: Math.floor(vector_main.x / 2),\n        y: Math.floor(vector_main.y / 2)\n    };\n\n    if (2 * vector_main_magnitude > 3 * vector_sec_magnitude) {\n        const vector_main_half_magnitude = Math.abs(vector_main_half.x + vector_main_half.y);\n        if ((vector_main_half_magnitude % 2) && (vector_main_magnitude > 2)) {\n            /* Prefer even steps */\n            vector_main_half.x += main_dirx;\n            vector_main_half.y += main_diry;\n        }\n\n        /* We split the main vector into 2 parts */\n        const first = gilbert2d({ x: cursor.x, y: cursor.y },\n            vector_main_half,\n            vector_sec,\n            target);\n        if (first !== -1)\n            return first;\n        return gilbert2d({ x: cursor.x + vector_main_half.x, y: cursor.y + vector_main_half.y },\n            { x: vector_main.x - vector_main_half.x, y: vector_main.y - vector_main_half.y },\n            vector_sec,\n            target);\n    } else {\n        const vector_sec_half = {\n            x: Math.floor(vector_sec.x / 2),\n            y: Math.floor(vector_sec.y / 2)\n        };\n        const vector_sec_half_magnitude = Math.abs(vector_sec_half.x + vector_sec_half.y);\n        if ((vector_sec_half_magnitude % 2) && (vector_sec_magnitude > 2)) {\n            /* Prefer even steps */\n            vector_sec_half.x += sec_dirx;\n            vector_sec_half.y += sec_diry;\n        }\n\n        /* We split the whole rectangle into 3 parts */\n\n        /* Bottom half left (flipped so it finishes on top of the starting point) */\n        const first = gilbert2d({ x: cursor.x, y: cursor.y },\n            vector_sec_half,\n            vector_main_half,\n            target);\n        if (first !== -1)\n            return first;\n\n        /* Top (left to right) */\n        const second = gilbert2d({ x: cursor.x + vector_sec_half.x, y: cursor.y + vector_sec_half.y },\n            vector_main,\n            { x: vector_sec.x - vector_sec_half.x, y: vector_sec.y - vector_sec_half.y },\n            target);\n        if (second !== -1)\n            return second;\n\n        /* Bottom half right */\n        return gilbert2d({\n            x: cursor.x + (vector_main.x - main_dirx) + (vector_sec_half.x - sec_dirx),\n            y: cursor.y + (vector_main.y - main_diry) + (vector_sec_half.y - sec_diry)\n        },\n            { x: - vector_sec_half.x, y: - vector_sec_half.y },\n            { x: - (vector_main.x - vector_main_half.x), y: - (vector_main.y - vector_main_half.y) },\n            target);\n    }\n}\n\n/**\n * Given a rectangle coordinate (x : [0, width) ^ y : [ 0 .. height)) and its height and width,\n * it returns the position of the given coordinate in the Gilbert curve filling the rectangle\n * The result will be an integer number n : [0, (width * height) - 1]\n */\nfunction gilbert2d_tile(target_tile = { x, y }, width, height) {\n    if (width < 1 || height < 1)\n        throw `Invalid Gilbert rectangle. Got: Width (${width}). Height: (${height})`;\n    const tile = { x: target_tile.x, y: target_tile.y, counter: 0 };\n    const start_point = { x: 0, y: 0 };\n\n    let main_vector = { x: 0, y: height };\n    let secondary_vector = { x: width, y: 0 };\n    if (width > height) {\n        main_vector = { x: width, y: 0 };\n        secondary_vector = { x: 0, y: height };\n    }\n    return gilbert2d(start_point, main_vector, secondary_vector, tile);\n}\n\nclass GilbertPartition {\n    /**\n     * partition_count: Number of partitions assigned for the whole dataset\n     * z_range: Range of accepted zoom levels (e.g: { zmin: 0, zmax: 15 })\n     * zmax_bbox: Bounding box of the dataset for the maximum accepted zoom level (i.e. z_range.zmax)\n     *            These are tile coordinates (x, y) not geography coordinates\n     */\n    constructor(partition_count,\n        z_range = { zmin, zmax, zstep },\n        zmax_bbox = { xmin, xmax, ymin, ymax }) {\n        this.partition_count = parseInt(partition_count);\n        this.z_range = {\n            zmin: parseInt(z_range.zmin),\n            zmax: parseInt(z_range.zmax),\n            zstep: parseInt(z_range.zstep)\n        };\n        this.zmax_bbox = {\n            xmin: parseInt(zmax_bbox.xmin),\n            xmax: parseInt(zmax_bbox.xmax),\n            ymin: parseInt(zmax_bbox.ymin),\n            ymax: parseInt(zmax_bbox.ymax)\n        };\n\n        if (!partition_count || partition_count < 1)\n            throw `Unexpected partition count. Expected a positive integer. Got ${partition_count}`;\n        if (!this.z_range)\n            throw `Missing z_range`;\n        if (isNaN(this.z_range.zmin) || isNaN(this.z_range.zmax) || isNaN(this.z_range.zstep))\n            throw `Invalid z_range. Both zmin, zmax and zstep need to be defined. Got ${JSON.stringify(z_range)}`;\n        if (this.z_range.zmin > this.z_range.zmax || this.z_range.zmin < 0 || this.zstep < 1)\n            throw `Invalid z_range received. Got (${JSON.stringify(z_range)})`;\n        if (!this.zmax_bbox)\n            throw `Missing zmax_bbox`;\n        if (isNaN(this.zmax_bbox.xmin) || isNaN(this.zmax_bbox.xmax) ||\n            isNaN(this.zmax_bbox.ymin) || isNaN(this.zmax_bbox.ymax))\n            throw `Invalid zmax_bbox. All xmin, xmax, ymin and ymax need to be defined. Got (${JSON.stringify(zmax_bbox)})`;\n        if (this.zmax_bbox.xmin > this.zmax_bbox.xmax || this.zmax_bbox.xmin < 0 ||\n            this.zmax_bbox.ymin > this.zmax_bbox.ymax || this.zmax_bbox.ymin < 0)\n            throw `Invalid bbox received. Got (${JSON.stringify(zmax_bbox)})`;\n    }\n\n    getPartition(tile = { z: 0, x: 0, y: 0 }) {\n        const rxmin = this.zmax_bbox.xmin >> (this.z_range.zmax - tile.z);\n        const rxmax = this.zmax_bbox.xmax >> (this.z_range.zmax - tile.z);\n        const rymin = this.zmax_bbox.ymin >> (this.z_range.zmax - tile.z);\n        const rymax = this.zmax_bbox.ymax >> (this.z_range.zmax - tile.z);\n        if (tile.z < this.z_range.zmin || tile.z > this.z_range.zmax ||\n            tile.x < rxmin || tile.x > rxmax ||\n            tile.y < rymin || tile.y > rymax) {\n            return PARTITION_UNPARTITIONED;\n        }\n\n        const partition_range = partition_range_by_zoom(this.partition_count,\n            { z: tile.z, zmin: this.z_range.zmin, zmax: this.z_range.zmax, zstep: this.z_range.zstep });\n        const usable_partitions = partition_range.max - partition_range.min + 1;\n        if (usable_partitions == 1) {\n            return partition_range.min;\n        }\n\n        /* We switch to a rectangle starting at 0, 0 so it's easier to reason about it\n         * The rectangle goes from (0, 0) to (rwidth - 1, rheight - 1)\n         */\n        const x = tile.x - rxmin;\n        const y = tile.y - rymin;\n        const rwidth = rxmax - rxmin + 1;\n        const rheight = rymax - rymin + 1;\n        const rectangle_size = rwidth * rheight;\n\n        /* We need to divide this **rectangle** into equal sized areas, so what we do is to create a\n         * Hilbert curve and then divide this 1d line into the necessary parts.\n         *\n         * If this was a perfect square, we would interleave bits from x and y, but in a rectangle\n         * that would leave many empty spaces, so the partitions would be irregular (or some even empty)\n         *\n         * Instead we use a Generalized Hilbert curve based on https://github.com/jakubcerveny/gilbert\n         * by Jakub erven\n         *\n         */\n        const gilbert_position = gilbert2d_tile({ x: x, y: y }, rwidth, rheight);\n        if (gilbert_position === -1 || gilbert_position >= rwidth * rheight) {\n            throw `Unexpected gilbert partition (${gilbert_position}) for tile ${tile.z}/${tile.x}/${tile.y} ` +\n            `=> ${x}/${y} : ${rwidth}, ${rheight})`;\n        }\n\n        /* The gilbert_position goes from 0 to rectangle_size - 1 */\n        return partition_range.min + Math.floor(usable_partitions * gilbert_position / rectangle_size);\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/sources/bigquery/BQTilesetClient.js\":\n/*!*************************************************!*\\\n  !*** ./src/sources/bigquery/BQTilesetClient.js ***!\n  \\*************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return BigQueryTilesetClient; });\n/* harmony import */ var _BQClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BQClient */ \"./src/sources/bigquery/BQClient.js\");\n/* harmony import */ var _BQQuadkey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BQQuadkey */ \"./src/sources/bigquery/BQQuadkey.js\");\n/* harmony import */ var base64_arraybuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! base64-arraybuffer */ \"./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js\");\n/* harmony import */ var base64_arraybuffer__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(base64_arraybuffer__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! pako */ \"./node_modules/pako/index.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(pako__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n// Singleton\nlet _partitioner = null;\n\nclass BigQueryTilesetClient {\n    constructor (projectId, token) {\n        this._client = new _BQClient__WEBPACK_IMPORTED_MODULE_0__[\"default\"](projectId, token);\n    }\n\n    async fetchMetadata (dataset, tileset) {\n        const sqlQuery = `\n            SELECT name, value\n            FROM \\`${dataset}.metadata\\`\n            WHERE table_name = '${tileset}'`;\n\n        const result = await this._execute(sqlQuery);\n\n        const metadata = {};\n\n        if (result && result.rows) {\n            for (let i = 0; i < result.rows.length; i++) {\n                const row = result.rows[i];\n                if (row.f && row.f.length === 2) {\n                    metadata[row.f[0].v] = row.f[1].v;\n                }\n            }\n        }\n\n        return metadata;\n    }\n\n    async fetchTiles (tiles, dataset, tileset, tilesetMetadata) {\n        if (!_partitioner) {\n            const params = JSON.parse(tilesetMetadata.carto_quadkey_zoom);\n            _partitioner = initializePartitioner(params);\n        }\n\n        const parentQuadkeys = getParentQuadkeysFromTiles(tiles);\n        const parentQuadkeysFilter = parentQuadkeys.length ? `carto_quadkey IN (${parentQuadkeys})` : 'TRUE';\n        const tilesFilter = tiles.map((tile) => tileFilter(tile)).join(' OR ');\n        const sqlQuery = `\n            SELECT zoom_level, tile_column, tile_row, tile_data\n            FROM \\`${dataset}.${tileset}\\`\n            WHERE (${parentQuadkeysFilter}) AND (${tilesFilter})`;\n\n        const result = await this._execute(sqlQuery);\n\n        let mvts = [];\n        let missedTiles = Object.assign(tiles, {});\n        if (result && result.rows) {\n            for (let i = 0; i < result.rows.length; i++) {\n                const row = result.rows[i];\n                if (row.f && row.f.length === 4) {\n                    const z = parseInt(row.f[0].v);\n                    const x = parseInt(row.f[1].v);\n                    const y = parseInt(row.f[2].v);\n                    const mvt = tilesetMetadata.compression === 'gzip'\n                        ? Object(pako__WEBPACK_IMPORTED_MODULE_3__[\"inflate\"])(atob(row.f[3].v))\n                        : Object(base64_arraybuffer__WEBPACK_IMPORTED_MODULE_2__[\"decode\"])(row.f[3].v);\n                    mvts.push({ z, x, y, buffer: mvt });\n                    missedTiles = missedTiles.filter((t) => !(t.z === z && t.x === x && t.y === y));\n                }\n            }\n\n            console.log(`${mvts.length}/${result.totalRows}`);\n\n            if (result.totalRows > mvts.length) {\n                const missedmvts = await this.fetchTiles(missedTiles, dataset, tileset, tilesetMetadata);\n                mvts = mvts.concat(missedmvts);\n            }\n        }\n\n        return mvts;\n    }\n\n    async _execute (sqlQuery) {\n        console.log('>');\n\n        const begin = (new Date()).getTime();\n        const result = await this._client.execute(sqlQuery);\n        const end = (new Date()).getTime();\n\n        console.log('<', end - begin);\n\n        return result;\n    }\n}\n\nfunction initializePartitioner (parameters) {\n    if (parameters.version !== 1) {\n        throw new Error('Unknown quadkey version');\n    }\n    const zRange = {\n        zmin: parameters.zmin,\n        zmax: parameters.zmax,\n        zstep: parameters.zstep\n    };\n    const zmaxBBox = {\n        xmin: parameters.xmin,\n        xmax: parameters.xmax,\n        ymin: parameters.ymin,\n        ymax: parameters.ymax\n    };\n    const partitions = parameters.partitions;\n    return new _BQQuadkey__WEBPACK_IMPORTED_MODULE_1__[\"default\"](partitions, zRange, zmaxBBox);\n}\n\nfunction getParentQuadkeysFromTiles (tiles) {\n    let result = new Set();\n    for (let tile of tiles) {\n        result.add(_partitioner.getPartition({ z: tile.z, x: tile.x, y: tile.y }));\n    }\n    return [...result].filter(x => x !== null);\n}\n\nfunction tileFilter (tile) {\n    return `(zoom_level = ${tile.z} AND tile_column = ${tile.x} AND tile_row = ${tile.y})`;\n}\n\n\n/***/ }),\n\n/***/ \"./src/sources/bigquery/BQTilesetWorker.js\":\n/*!*************************************************!*\\\n  !*** ./src/sources/bigquery/BQTilesetWorker.js ***!\n  \\*************************************************/\n/*! exports provided: BigQueryTilesetWorker */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BigQueryTilesetWorker\", function() { return BigQueryTilesetWorker; });\n/* harmony import */ var _mapbox_vector_tile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mapbox/vector-tile */ \"./node_modules/@mapbox/vector-tile/index.js\");\n/* harmony import */ var _mapbox_vector_tile__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_mapbox_vector_tile__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var pbf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pbf */ \"./node_modules/pbf/index.js\");\n/* harmony import */ var pbf__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(pbf__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _client_rsys__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../client/rsys */ \"./src/client/rsys.js\");\n/* harmony import */ var _client_mvt_feature_decoder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../client/mvt/feature-decoder */ \"./src/client/mvt/feature-decoder.js\");\n/* harmony import */ var _MVTMetadata__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../MVTMetadata */ \"./src/sources/MVTMetadata.js\");\n/* harmony import */ var _renderer_dataframe_DummyDataframe__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../renderer/dataframe/DummyDataframe */ \"./src/renderer/dataframe/DummyDataframe.js\");\n/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../errors/carto-validation-error */ \"./src/errors/carto-validation-error.js\");\n/* harmony import */ var _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../errors/carto-runtime-error */ \"./src/errors/carto-runtime-error.js\");\n/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../../utils/geometry */ \"./src/utils/geometry.js\");\n/* harmony import */ var _BQTilesetClient__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./BQTilesetClient */ \"./src/sources/bigquery/BQTilesetClient.js\");\n\n\n\n\n\n\n\n\n\n\n\n// TODO import correctly\nconst RTT_WIDTH = 1024;\n\n// Constants for '@mapbox/vector-tile' geometry types, from https://github.com/mapbox/vector-tile-js/blob/v1.3.0/lib/vectortilefeature.js#L39\nconst mvtDecoderGeomTypes = { point: 1, line: 2, polygon: 3 };\n\nconst MVT_TO_CARTO_TYPES = {\n    1: _utils_geometry__WEBPACK_IMPORTED_MODULE_8__[\"GEOMETRY_TYPE\"].POINT,\n    2: _utils_geometry__WEBPACK_IMPORTED_MODULE_8__[\"GEOMETRY_TYPE\"].LINE,\n    3: _utils_geometry__WEBPACK_IMPORTED_MODULE_8__[\"GEOMETRY_TYPE\"].POLYGON\n};\n\nconst DEFAULT_ID_PROPERTY = '___id';\n\nclass BigQueryTilesetWorker {\n    // Worker API\n    onmessage (event) {\n        this.processEvent(event).then(postMessage);\n    }\n\n    async processEvent (event) {\n        const params = event.data;\n        if (params.metadata) {\n            this.castMetadata(params.metadata);\n            this.metadata = params.metadata;\n        }\n        const dataframes = await this._requestDataframes(params.tiles, params.tilesetData, params.tilesetMetadata, this.metadata);\n        return {\n            mID: params.mID,\n            dataframes\n        };\n    }\n\n    castMetadata (metadata) {\n        Object.setPrototypeOf(metadata, _MVTMetadata__WEBPACK_IMPORTED_MODULE_4__[\"default\"].prototype);\n        metadata.setCodecs();\n    }\n\n    async _requestDataframes (tiles, tilesetData, tilesetMetadata, metadata) {\n        const client = new _BQTilesetClient__WEBPACK_IMPORTED_MODULE_9__[\"default\"](tilesetData.project, tilesetData.token);\n        const responseTiles = await client.fetchTiles(tiles, tilesetData.dataset, tilesetData.tileset, tilesetMetadata);\n        const dataframes = await Promise.all(tiles.map((t) => {\n            const responseTile = responseTiles && responseTiles.find((rt) => (rt.x === t.x && rt.y === t.y && rt.z === t.z));\n            if (responseTile) {\n                return this.responseToDataframeTransformer(responseTile, metadata);\n            } else {\n                return { x: t.x, y: t.y, z: t.z, empty: true };\n            }\n        }));\n        return dataframes;\n    }\n\n    responseToDataframeTransformer ({ x, y, z, buffer }, metadata) {\n        return new Promise((resolve) => {\n            const MVT_EXTENT = metadata.extent;\n            if (buffer.byteLength === 0) {\n                return resolve({ x, y, z, empty: true });\n            }\n            const tile = new _mapbox_vector_tile__WEBPACK_IMPORTED_MODULE_0__[\"VectorTile\"](new pbf__WEBPACK_IMPORTED_MODULE_1__(buffer));\n\n            if (Object.keys(tile.layers).length > 1) {\n                throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__[\"default\"](\n                    `LayerID parameter wasn't specified and the MVT tile contains multiple layers: ${JSON.stringify(Object.keys(tile.layers))}.`,\n                    _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__[\"CartoValidationErrorTypes\"].MISSING_REQUIRED\n                );\n            }\n\n            const mvtLayer = tile.layers[Object.keys(tile.layers)[0]];\n\n            if (!mvtLayer) {\n                return resolve({ empty: true });\n            }\n\n            const { geometries, properties, propertiesArrayBuffer, numFeatures } = this._decodeMVTLayer(mvtLayer, metadata, MVT_EXTENT);\n            const rs = _client_rsys__WEBPACK_IMPORTED_MODULE_2__[\"getRsysFromTile\"](x, y, z);\n            resolve(this._generateDataFrame(rs, geometries, properties, propertiesArrayBuffer, numFeatures, metadata.geomType, metadata, x, y, z));\n        });\n    }\n\n    _decodeMVTLayer (mvtLayer, metadata, mvtExtent) {\n        if (!mvtLayer.length) {\n            return { properties: [], geometries: {}, propertiesArrayBuffer: [], numFeatures: 0 };\n        }\n        if (!metadata.geomType) {\n            metadata.geomType = this._autoDiscoverType(mvtLayer);\n        }\n        switch (metadata.geomType) {\n            case _utils_geometry__WEBPACK_IMPORTED_MODULE_8__[\"GEOMETRY_TYPE\"].POINT:\n                const arrayBuffer = new ArrayBuffer(mvtLayer.length * 2 * 3 * 4);// SIZEOF\n                return this._decode(mvtLayer, metadata, mvtExtent, arrayBuffer);\n            case _utils_geometry__WEBPACK_IMPORTED_MODULE_8__[\"GEOMETRY_TYPE\"].LINE:\n                return this._decode(mvtLayer, metadata, mvtExtent, [], _client_mvt_feature_decoder__WEBPACK_IMPORTED_MODULE_3__[\"decodeLines\"]);\n            case _utils_geometry__WEBPACK_IMPORTED_MODULE_8__[\"GEOMETRY_TYPE\"].POLYGON:\n                return this._decode(mvtLayer, metadata, mvtExtent, [], _client_mvt_feature_decoder__WEBPACK_IMPORTED_MODULE_3__[\"decodePolygons\"]);\n            default:\n                throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__[\"default\"](`MVT: invalid geometry type '${metadata.geomType}'`, _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__[\"CartoValidationErrorTypes\"].INCORRECT_TYPE);\n        }\n    }\n\n    _autoDiscoverType (mvtLayer) {\n        const type = mvtLayer.feature(0).type;\n        switch (type) {\n            case mvtDecoderGeomTypes.point:\n                return _utils_geometry__WEBPACK_IMPORTED_MODULE_8__[\"GEOMETRY_TYPE\"].POINT;\n            case mvtDecoderGeomTypes.line:\n                return _utils_geometry__WEBPACK_IMPORTED_MODULE_8__[\"GEOMETRY_TYPE\"].LINE;\n            case mvtDecoderGeomTypes.polygon:\n                return _utils_geometry__WEBPACK_IMPORTED_MODULE_8__[\"GEOMETRY_TYPE\"].POLYGON;\n            default:\n                throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__[\"default\"](`MVT: invalid geometry type '${type}'`, _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_6__[\"CartoValidationErrorTypes\"].INCORRECT_TYPE);\n        }\n    }\n\n    _decode (mvtLayer, metadata, mvtExtent, geometries, decodeFn) {\n        let numFeatures = 0;\n        let pointGeometries;\n        if (geometries) {\n            pointGeometries = new Float32Array(geometries);\n        }\n        const { properties, propertiesArrayBuffer } = this._initializePropertyArrays(metadata, mvtLayer.length);\n        const scalarPropertyCodecs = this._scalarPropertyCodecs(metadata);\n        const rangePropertyCodecs = this._rangePropertyCodecs(metadata);\n        for (let i = 0; i < mvtLayer.length; i++) {\n            const feature = mvtLayer.feature(i);\n            this._checkType(feature, metadata.geomType);\n            const geom = feature.loadGeometry();\n            if (decodeFn) {\n                const decodedPolygons = decodeFn(geom, mvtExtent);\n                geometries.push(decodedPolygons);\n            } else {\n                // TODO refactor\n                const x = 2 * (geom[0][0].x) / mvtExtent - 1.0;\n                const y = 2 * (1.0 - (geom[0][0].y) / mvtExtent) - 1.0;\n                // Tiles may contain points in the border;\n                // we'll avoid here duplicated points between tiles by excluding the 1-edge\n                if (x < -1 || x >= 1 || y < -1 || y >= 1) {\n                    continue;\n                }\n                pointGeometries[6 * numFeatures + 0] = x;\n                pointGeometries[6 * numFeatures + 1] = y;\n                pointGeometries[6 * numFeatures + 2] = x;\n                pointGeometries[6 * numFeatures + 3] = y;\n                pointGeometries[6 * numFeatures + 4] = x;\n                pointGeometries[6 * numFeatures + 5] = y;\n            }\n            this._decodeProperties(metadata, scalarPropertyCodecs, rangePropertyCodecs, properties, feature, numFeatures);\n            numFeatures++;\n        }\n\n        return { properties, propertiesArrayBuffer, geometries, numFeatures };\n    }\n\n    // Currently only mvtLayers with the same type in every feature are supported\n    _checkType (feature, expected) {\n        const type = feature.type;\n        const actual = MVT_TO_CARTO_TYPES[type];\n        if (actual !== expected) {\n            throw new _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_7__[\"default\"](\n                `MVT: mixed geometry types in the same layer. Layer has type: ${expected} but feature was ${actual}`,\n                _errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_7__[\"CartoRuntimeErrorTypes\"].MVT\n            );\n        }\n    }\n\n    _initializePropertyArrays (metadata, length) {\n        const propertyNames = this._getPropertyNamesFrom(metadata);\n        const { properties, propertiesArrayBuffer } = this._getPropertiesFor(propertyNames, length);\n        return { propertyNames, properties, propertiesArrayBuffer };\n    }\n\n    _getSourcePropertyNamesFrom (metadata) {\n        return metadata.propertyKeys.filter(name => metadata.properties[metadata.baseName(name)].type !== 'geometry');\n    }\n\n    _getPropertyNamesFrom (metadata) {\n        const propertyNames = [];\n        this._getSourcePropertyNamesFrom(metadata).forEach(sourceName => {\n            metadata.decodedProperties(sourceName).forEach(propertyName => {\n                propertyNames.push(propertyName);\n            });\n        });\n        return propertyNames;\n    }\n\n    _getPropertiesFor (propertyNames, length) {\n        const properties = {};\n        const size = Math.ceil(length / RTT_WIDTH) * RTT_WIDTH;\n\n        const arrayBuffer = new ArrayBuffer(4 * size * propertyNames.length);\n        const propertiesArrayBuffer = arrayBuffer;\n        for (let i = 0; i < propertyNames.length; i++) {\n            const propertyName = propertyNames[i];\n            properties[propertyName] = new Float32Array(arrayBuffer, i * 4 * size, size);\n        }\n\n        return { properties, propertiesArrayBuffer };\n    }\n\n    _scalarPropertyCodecs (metadata) {\n        return this._getSourcePropertyNamesFrom(metadata)\n            .map(prop => [prop, metadata.codec(prop)])\n            .filter(([_, codec]) => !codec.isRange());\n    }\n\n    _rangePropertyCodecs (metadata) {\n        return this._getSourcePropertyNamesFrom(metadata)\n            .map(prop => [prop, metadata.decodedProperties(prop), metadata.codec(prop)])\n            .filter(([_prop, _dprop, codec]) => codec.isRange());\n    }\n\n    _decodeProperties (metadata, scalarPropertyCodecs, rangePropertyCodecs, properties, feature, i) {\n        let length = scalarPropertyCodecs.length;\n        for (let j = 0; j < length; j++) {\n            const [propertyName, codec] = scalarPropertyCodecs[j];\n            const propertyValue = (propertyName === DEFAULT_ID_PROPERTY)\n                ? feature.id\n                : feature.properties[propertyName];\n            properties[propertyName][i] = codec.sourceToInternal(metadata, propertyValue);\n        }\n\n        length = rangePropertyCodecs.length;\n        for (let j = 0; j < length; j++) {\n            const [propertyName, [loPropertyName, hiPropertyName], codec] = rangePropertyCodecs[j];\n            const propertyValue = feature.properties[propertyName];\n            const [loValue, hiValue] = codec.sourceToInternal(metadata, propertyValue);\n            properties[loPropertyName][i] = loValue;\n            properties[hiPropertyName][i] = hiValue;\n        }\n    }\n\n    _generateDataFrame (rs, geometry, properties, propertiesArrayBuffer, size, type, metadata, x, y, z) {\n        return new _renderer_dataframe_DummyDataframe__WEBPACK_IMPORTED_MODULE_5__[\"default\"]({\n            active: false,\n            center: rs.center,\n            geom: geometry,\n            properties: properties,\n            propertiesArrayBuffer: propertiesArrayBuffer,\n            scale: rs.scale,\n            size: size,\n            type: type,\n            metadata,\n            x,\n            y,\n            z\n        });\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/utils/geometry.js\":\n/*!*******************************!*\\\n  !*** ./src/utils/geometry.js ***!\n  \\*******************************/\n/*! exports provided: GEOMETRY_TYPE, intersect, sub, dot, perpendicular, getLineNormal, getJoinNormal, neg, pointInTriangle, halfPlaneSign, equalPoints, pointInCircle, pointInRectangle, computeAABB, computeCentroids, triangleArea, unproject, default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GEOMETRY_TYPE\", function() { return GEOMETRY_TYPE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"intersect\", function() { return intersect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"sub\", function() { return sub; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dot\", function() { return dot; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"perpendicular\", function() { return perpendicular; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLineNormal\", function() { return getLineNormal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getJoinNormal\", function() { return getJoinNormal; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"neg\", function() { return neg; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pointInTriangle\", function() { return pointInTriangle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"halfPlaneSign\", function() { return halfPlaneSign; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equalPoints\", function() { return equalPoints; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pointInCircle\", function() { return pointInCircle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pointInRectangle\", function() { return pointInRectangle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeAABB\", function() { return computeAABB; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeCentroids\", function() { return computeCentroids; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"triangleArea\", function() { return triangleArea; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unproject\", function() { return unproject; });\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/lib/gl-matrix.js\");\n/* harmony import */ var _renderer_viz_expressions_stats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/viz/expressions/stats */ \"./src/renderer/viz/expressions/stats.js\");\n/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors/carto-validation-error */ \"./src/errors/carto-validation-error.js\");\n\n\n\n\nconst GEOMETRY_TYPE = {\n    UNKNOWN: 'unknown',\n    POINT: 'point',\n    LINE: 'line',\n    POLYGON: 'polygon'\n};\n\n// If AB intersects CD => return intersection point\n// Intersection method from Real Time Rendering, Third Edition, page 780\nfunction intersect (a, b, c, d) {\n    const o1 = a;\n    const o2 = c;\n    const d1 = sub(b, a);\n    const d2 = sub(d, c);\n    const d1t = perpendicular(d1);\n    const d2t = perpendicular(d2);\n\n    const s = dot(sub(o2, o1), d2t) / dot(d1, d2t);\n    const t = dot(sub(o1, o2), d1t) / dot(d2, d1t);\n\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n        return [o1[0] + s * d1[0], o1[1] + s * d1[1]];\n    }\n}\n\nfunction sub ([ax, ay], [bx, by]) {\n    return ([ax - bx, ay - by]);\n}\n\nfunction dot ([ax, ay], [bx, by]) {\n    return (ax * bx + ay * by);\n}\n\nfunction perpendicular ([x, y]) {\n    return [-y, x];\n}\n\n/**\n * Compute the normal of a line AB.\n * By definition it is the unitary vector from B to A, rotated +90 degrees counter-clockwise\n */\nfunction getLineNormal (a, b) {\n    const u = normalize(a[0] - b[0], a[1] - b[1]);\n    return [-u[1], u[0]];\n}\n\n/**\n * Compute the normal of the join from the lines' normals.\n * By definition this is the sum of the unitary vectors `u` (from B to A) and `v` (from B to C)\n * multiplied by a factor of `1/sin(theta)` to reach the intersection of the wide lines.\n * Theta is the angle between the vectors `v` and `u`. But instead of computing the angle,\n * the `sin(theta)` (with sign) is obtained directly from the vectorial product of `v` and `u`\n */\nfunction getJoinNormal (prevNormal, nextNormal) {\n    const u = [prevNormal[1], -prevNormal[0]];\n    const v = [-nextNormal[1], nextNormal[0]];\n    const sin = v[0] * u[1] - v[1] * u[0];\n    const cos = v[0] * u[0] + v[1] * u[1];\n    const factor = Math.abs(sin);\n    const miterJoin = !(factor < 0.866 && cos > 0.5); // 60 deg\n    return {\n        turnLeft: sin > 0,\n        joinNormal: miterJoin && neg([\n            (u[0] + v[0]) / factor,\n            (u[1] + v[1]) / factor\n        ])\n    };\n}\n\n/**\n * Return the negative of the provided vector\n */\nfunction neg (v) {\n    return [-v[0], -v[1]];\n}\n\n/**\n * Return the vector scaled to length 1\n */\nfunction normalize (x, y) {\n    const s = Math.hypot(x, y);\n    return [x / s, y / s];\n}\n\n// Returns true if p is inside the triangle or on a triangle's edge, false otherwise\n// Parameters in {x: 0, y:0} form\nfunction pointInTriangle (p, v1, v2, v3) {\n    // https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle\n    // contains an explanation of both this algorithm and one based on barycentric coordinates,\n    // which could be faster, but, nevertheless, it is quite similar in terms of required arithmetic operations\n\n    if (equalPoints(v1, v2) || equalPoints(v2, v3) || equalPoints(v3, v1)) {\n        // Avoid zero area triangle\n        return false;\n    }\n\n    // A point is inside a triangle or in one of the triangles edges\n    // if the point is in the three half-plane defined by the 3 edges\n    const b1 = halfPlaneSign(p, v1, v2) < 0;\n    const b2 = halfPlaneSign(p, v2, v3) < 0;\n    const b3 = halfPlaneSign(p, v3, v1) < 0;\n\n    return (b1 === b2) && (b2 === b3);\n}\n\n// Tests if a point `p` is in the half plane defined by the line with points `a` and `b`\n// Returns a negative number if the result is INSIDE, returns 0 if the result is ON_LINE,\n// returns >0 if the point is OUTSIDE\n// Parameters in {x: 0, y:0} form\nfunction halfPlaneSign (p, a, b) {\n    // We use the cross product of `PB x AB` to get `sin(angle(PB, AB))`\n    // The result's sign is the half plane test result\n    return (p.x - b.x) * (a.y - b.y) - (a.x - b.x) * (p.y - b.y);\n}\n\nfunction equalPoints (a, b) {\n    return (a.x === b.x) && (a.y === b.y);\n}\n\nfunction pointInCircle (p, center, radius) {\n    const diff = {\n        x: p.x - center.x,\n        y: p.y - center.y\n    };\n    const lengthSquared = diff.x * diff.x + diff.y * diff.y;\n    return lengthSquared <= radius * radius;\n}\n\nfunction pointInRectangle (point, bbox) {\n    if (bbox === null) {\n        return false;\n    }\n    const p = {\n        x: point.x.toFixed(2),\n        y: point.y.toFixed(2)\n    };\n\n    return ((bbox.minx <= p.x) && (p.x <= bbox.maxx) && (bbox.miny <= p.y) && (p.y <= bbox.maxy));\n}\n\n/**\n * Axis-Aligned Bounding Box (AABB). This creates a wrapping box around the geometry, without rotation.\n * This allows the use of a common technique to detect collision between features (using their corresponding AABBs).\n */\nfunction computeAABB (geometry, type) {\n    switch (type) {\n        case GEOMETRY_TYPE.POINT:\n            return [];\n        case GEOMETRY_TYPE.LINE:\n        case GEOMETRY_TYPE.POLYGON:\n            const aabbList = [];\n\n            for (let i = 0; i < geometry.length; i++) {\n                const feature = geometry[i];\n\n                let aabb = {\n                    minx: Number.POSITIVE_INFINITY,\n                    miny: Number.POSITIVE_INFINITY,\n                    maxx: Number.NEGATIVE_INFINITY,\n                    maxy: Number.NEGATIVE_INFINITY\n                };\n\n                for (let j = 0; j < feature.length; j++) {\n                    aabb = _updateAABBForGeometry(feature[j], aabb, type);\n                }\n\n                if (aabb.minx === Number.POSITIVE_INFINITY) {\n                    aabb = null;\n                }\n\n                aabbList.push(aabb);\n            }\n\n            return aabbList;\n    }\n}\n\nfunction computeCentroids (decodedGeometry, type) {\n    switch (type) {\n        case GEOMETRY_TYPE.POINT:\n            return _computeCentroidsForPoints(decodedGeometry);\n        case GEOMETRY_TYPE.LINE:\n        case GEOMETRY_TYPE.POLYGON:\n            return _computeCentroidsForLinesOrPolygons(decodedGeometry, type);\n        default:\n            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__[\"default\"](\n                'Invalid type argument, decoded geometry must have a point, line or polygon type.',\n                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__[\"CartoValidationErrorTypes\"].INCORRECT_VALUE\n            );\n    }\n}\n\nfunction _computeCentroidsForPoints (decodedGeometry) {\n    const centroids = [];\n\n    // 'Compute' centroids for points is just getting one exemplar from the 3 repeated points\n    const STEP = 6;\n    for (let i = 0; i < decodedGeometry.vertices.length / STEP; i++) {\n        const start = i * STEP;\n        const end = start + STEP;\n        const [, , , , x, y] = decodedGeometry.vertices.slice(start, end);\n        centroids.push({ x, y });\n    }\n    return centroids;\n}\n\nfunction _computeCentroidsForLinesOrPolygons (decodedGeometry, type) {\n    const centroids = [];\n\n    let startVertex = 0;\n    decodedGeometry.breakpoints.forEach((breakpoint) => {\n        const vertices = decodedGeometry.vertices.slice(startVertex, breakpoint);\n        let centroid = null;\n        if (type === GEOMETRY_TYPE.LINE) {\n            centroid = _centroidForLines(vertices);\n        } else {\n            centroid = _centroidForPolygons(vertices);\n        }\n        centroids.push(centroid);\n        startVertex = breakpoint;\n    });\n\n    return centroids;\n}\n\nfunction _centroidForLines (vertices) {\n    // Triangles don't have any area in this case, so just average coordinates are calculated\n    const Xs = [];\n    const Ys = [];\n    const STEP = 6;\n    for (let i = 0; i < vertices.length / STEP; i++) {\n        const start = i * STEP;\n        const end = start + STEP;\n        const [xA, yA, xB, yB, xC, yC] = vertices.slice(start, end);\n\n        const AequalB = (xA === xB && yA === yB);\n        const BequalC = (xB === xC && yB === yC);\n\n        if (AequalB && BequalC) {\n            continue; // spurious triangles (useful for rendering strokes with normals, not here)\n        }\n\n        const firstPoint = [xA, yA];\n        const secondPoint = !AequalB ? [xB, yB] : [xC, yC];\n\n        Xs.push(firstPoint[0]);\n        Xs.push(secondPoint[0]);\n\n        Ys.push(firstPoint[1]);\n        Ys.push(secondPoint[1]);\n    }\n\n    let centroid = {\n        x: Object(_renderer_viz_expressions_stats__WEBPACK_IMPORTED_MODULE_1__[\"average\"])(Xs),\n        y: Object(_renderer_viz_expressions_stats__WEBPACK_IMPORTED_MODULE_1__[\"average\"])(Ys)\n    };\n    return centroid;\n}\n\nfunction _centroidForPolygons (vertices) {\n    // Triangles average coordinates, ponderated by their area\n    const weightedXs = [];\n    const weightedYs = [];\n    const areas = [];\n\n    const STEP = 6;\n    for (let i = 0; i < vertices.length / STEP; i++) {\n        const start = i * STEP;\n        const end = start + STEP;\n        const [xA, yA, xB, yB, xC, yC] = vertices.slice(start, end);\n        const triangle = [[xA, yA], [xB, yB], [xC, yC]];\n        const area = triangleArea(triangle);\n        if (area > 0) {\n            const averageX = Object(_renderer_viz_expressions_stats__WEBPACK_IMPORTED_MODULE_1__[\"average\"])([xA, xB, xC]);\n            const averageY = Object(_renderer_viz_expressions_stats__WEBPACK_IMPORTED_MODULE_1__[\"average\"])([yA, yB, yC]);\n\n            weightedXs.push(averageX * area);\n            weightedYs.push(averageY * area);\n            areas.push(area);\n        }\n    }\n    const totalWeight = _sumArray(areas);\n\n    let centroid = {\n        x: _sumArray(weightedXs) / totalWeight,\n        y: _sumArray(weightedYs) / totalWeight\n    };\n    return centroid;\n}\n\nfunction _sumArray (array) {\n    return array.reduce((p, c) => p + c, 0);\n}\n\n/*\n* Calculate the area of a triangle using its coordinates.\n* From https://en.wikipedia.org/wiki/Triangle#Computing_the_area_of_a_triangle\n*/\nfunction triangleArea (threeVerticesArray) {\n    let [xA, yA] = threeVerticesArray[0];\n    let [xB, yB] = threeVerticesArray[1];\n    let [xC, yC] = threeVerticesArray[2];\n\n    const area = Math.abs((xA - xC) * (yB - yA) - (xA - xB) * (yC - yA)) / 2.0;\n    return area;\n}\n\n// Compute the WebMercator position at projected (x,y) NDC (Normalized Device Coordinates) reversing the projection of the point\nfunction unproject (inv, x, y) {\n    // To unproject a point we need the 3 coordinates (x,y,z)\n    // The `z` coordinate can be computed by knowing that the unprojected `z` is equal to `0` (since the map is a 2D plane)\n    // defined at `z=0`\n\n    // Since a matrix-vector multiplication is a linear transform we know that\n    //      z = m * projectedZ + k\n    // Being `m` and `k` constants for a particular value of projected `x` and `y` coordinates\n\n    // With that equation and the inverse matrix of the projection we can establish an equation system of the form:\n    //      v1 = m * v2 + k\n    //      v3 = m * v4 + k\n    // Where `v2` and `v4` can be arbitrary values (but not equal to each other) and\n    // `v1` and `v3` can be computed by using the inverse matrix knowing that:\n    //      (_, _, v1,_) = inverse(projectionMatrix) * (projectedX, projectedY, v2, 1)\n    //      (_, _, v3,_) = inverse(projectionMatrix) * (projectedX, projectedY, v4, 1)\n\n    // By resolving the the equation system above computing `m` and `k` values\n    // we can compute the projected Z coordinate at the (x,y) NDC (projected) point\n\n    // With (projectedX, projectedY, projectedZ) we can compute the unprojected point by multiplying by the inverse matrix\n\n    // *** Implementation ***\n\n    // compute m, k for: [z = m*projectedZ + k]\n    const v2 = 1;\n    const v4 = 2;\n\n    const v1 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"vec4\"].transformMat4([], [x, y, v2, 1], inv)[2];\n    const v3 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"vec4\"].transformMat4([], [x, y, v4, 1], inv)[2];\n\n    // Solve the equation system by using the elimination method (subtraction of the equations)\n    //      (v1-v3) = (v2-v4)*m\n    //      m = (v1 - v3) / (v2 - v4)\n    const m = (v1 - v3) / (v2 - v4);\n    // Substituting in the first equation `m` and solving for `k`\n    const k = v1 - m * v2;\n\n    // compute projectedZ by solving `z = m * projectedZ + k` knwoing `z`, `m` and `k`\n    const projectedZ = -k / m;\n\n    // Inverse the projection and normalize by `p.w`\n    return gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"vec4\"].transformMat4([], [x, y, projectedZ, 1], inv).map((v, _, point) => v / point[3]);\n}\n\nfunction _updateAABBForGeometry (feature, aabb, geometryType) {\n    switch (geometryType) {\n        case GEOMETRY_TYPE.LINE:\n            return _updateAABBLine(feature, aabb);\n        case GEOMETRY_TYPE.POLYGON:\n            return _updateAABBPolygon(feature, aabb);\n    }\n}\n\nfunction _updateAABBLine (line, aabb) {\n    const vertices = line;\n    const numVertices = line.length;\n\n    for (let i = 0; i < numVertices; i += 2) {\n        aabb.minx = Math.min(aabb.minx, vertices[i + 0]);\n        aabb.miny = Math.min(aabb.miny, vertices[i + 1]);\n        aabb.maxx = Math.max(aabb.maxx, vertices[i + 0]);\n        aabb.maxy = Math.max(aabb.maxy, vertices[i + 1]);\n    }\n\n    return aabb;\n}\n\nfunction _updateAABBPolygon (polygon, aabb) {\n    const [vertices, numVertices] = [polygon.flat, polygon.holes[0] || polygon.flat.length / 2];\n\n    for (let i = 0; i < numVertices; i++) {\n        aabb.minx = Math.min(aabb.minx, vertices[2 * i + 0]);\n        aabb.miny = Math.min(aabb.miny, vertices[2 * i + 1]);\n        aabb.maxx = Math.max(aabb.maxx, vertices[2 * i + 0]);\n        aabb.maxy = Math.max(aabb.maxy, vertices[2 * i + 1]);\n    }\n\n    return aabb;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    intersect,\n    sub,\n    dot,\n    perpendicular,\n    getLineNormal,\n    getJoinNormal,\n    neg,\n    halfPlaneSign,\n    pointInTriangle,\n    equalPoints,\n    pointInCircle,\n    pointInRectangle\n});\n\n\n/***/ }),\n\n/***/ \"./src/utils/time/TimeRange.js\":\n/*!*************************************!*\\\n  !*** ./src/utils/time/TimeRange.js ***!\n  \\*************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return TimeRange; });\n/* harmony import */ var _periodISO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./periodISO */ \"./src/utils/time/periodISO.js\");\n/* harmony import */ var _parseISO__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parseISO */ \"./src/utils/time/parseISO.js\");\n/* harmony import */ var _TimeZoneDate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TimeZoneDate */ \"./src/utils/time/TimeZoneDate.js\");\n\n\n\n\n/**\n * Class TimeRange represents an interval of time between to instants.\n *\n * Only single unit-of-time intervals such as a calender year, month, day, hour, etc.\n * are supported, arbitrary intervals are not.\n *\n * A TimeRange can be defined and accessed either by its start and end instants\n * or by an abbreviated ISO-formatted textual representation.\n * For the text format, since general intervals are not supported, the ISO interval\n * format is not used, but simply the abbreviated form of the time unit.\n * For example, to represent March 2018, `2018-03` is used instead of the\n * ISO-formatted interval `018-03-01T00:00:00/2018-04-01T00:00:00`.\n *\n * A TimeRange includes its start instant and excludes the end instant:\n * it represents the semi-open interval start <= t < end.\n *\n * @param {String} timezone - Time zone of the range; informational only.\n * @param {String} text - text representation of the range\n * @param {Number} startValue - start of the range as elapsed milliseconds since a timezone-specific epoch\n * @param {Number} endValue - end of the range as elapsed milliseconds since a timezone-specific epoch\n *\n * @constructor Layer\n * @name carto.TimeRange\n * @api\n * */\nclass TimeRange {\n    constructor (timeZone, iso, startValue, endValue) {\n        this._startValue = startValue;\n        this._endValue = endValue;\n\n        if (startValue && endValue) {\n            this._iso = Object(_periodISO__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(startValue, endValue);\n        } else if (!startValue && !endValue && iso) {\n            const startEndValues = _startEndTimeValues(iso);\n\n            this._iso = iso;\n            this._startValue = startEndValues[0];\n            this._endValue = startEndValues[1];\n        }\n\n        // The timezone of a TimeRange is merely informative.\n        // No time zone conversion is ever performed, e.g. when\n        // several ranges are used in the same linear expression.\n        // In same cases (e.g. defining a time range from a text constant)\n        // it may not be available.\n        this._timeZone = timeZone;\n    }\n\n    get timeZone () {\n        return this._timeZone;\n    }\n\n    get iso () {\n        return this._iso;\n    }\n\n    get startValue () {\n        return this._startValue;\n    }\n\n    get endValue () {\n        return this._endValue;\n    }\n\n    get startDate () {\n        return _TimeZoneDate__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fromValue(this._startValue, this._timeZone);\n    }\n\n    get endDate () {\n        return _TimeZoneDate__WEBPACK_IMPORTED_MODULE_2__[\"default\"].fromValue(this._endValue, this._timeZone);\n    }\n}\n\nfunction _timeValue (parsed) {\n    return Date.UTC(\n        parsed.year,\n        parsed.month - 1,\n        parsed.day,\n        parsed.hour,\n        parsed.minute,\n        parsed.second\n    );\n}\n\nfunction _startEndTimeValues (iso) {\n    return Object(_parseISO__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(iso).map(_timeValue);\n}\n\n\n/***/ }),\n\n/***/ \"./src/utils/time/TimeZoneDate.js\":\n/*!****************************************!*\\\n  !*** ./src/utils/time/TimeZoneDate.js ***!\n  \\****************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return TimeZoneDate; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./src/utils/util.js\");\n/* harmony import */ var _periodISO__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./periodISO */ \"./src/utils/time/periodISO.js\");\n\n\n\n// Time-zone neutral date\n// TODO: name: TimeZoneLessDate, NeutralDate, DateWithoutTimeZone, ...\n// it has an optional informational time zone string to declare the\n// original TZ\n// The idea is that this represent a date, just like a Date object,\n// but in relation ot some externally defined time zone\n// (the time zone specified in a clusterTime expression),\n// so we want to avoid the time zone handling that Date does.\n// (this dates cannot be converted from the tz they're specified in,\n// not even to UTC)\nclass TimeZoneDate {\n    constructor (milliseconds, tz) {\n        this._value = milliseconds;\n        this._date = Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"msToDate\"])(milliseconds);\n        this._timeZone = tz; // informational\n    }\n\n    static fromValue (milliseconds, tz) {\n        return new TimeZoneDate(milliseconds, tz);\n    }\n\n    static from (year, month, day, hour, minute, second, tz) {\n        return this.fromValue(Date.UTC(year, (month || 1) - 1, day, hour, minute, second), tz);\n    }\n\n    get year () {\n        return this._date.getUTCFullYear();\n    }\n    get month () {\n        return this._date.getUTCMonth() + 1;\n    }\n    get day () {\n        return this._date.getUTCDate();\n    }\n    get hour () {\n        return this._date.getUTCHours();\n    }\n    get minute () {\n        return this._date.getUTCMinutes();\n    }\n    get second () {\n        return this._date.getUTCSeconds();\n    }\n    get text () {\n        return Object(_periodISO__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this._date.getTime(), this._date.getTime() + 1000);\n    }\n    get timeZone () {\n        return this._timeZone;\n    }\n}\n\n\n/***/ }),\n\n/***/ \"./src/utils/time/parseISO.js\":\n/*!************************************!*\\\n  !*** ./src/utils/time/parseISO.js ***!\n  \\************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return parseISO; });\n/* harmony import */ var _errors_carto_parsing_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../errors/carto-parsing-error */ \"./src/errors/carto-parsing-error.js\");\n\n\nclass IsoParser {\n    constructor (format) {\n        this._format = format;\n    }\n    check (iso) {\n        return iso.match(this._format);\n    }\n}\n\nfunction fieldDefault (value, defaultValue) {\n    return (value === undefined) ? defaultValue : Number(value);\n}\n\nfunction dateFields (fields) {\n    return {\n        year: fieldDefault(fields.year, 1),\n        month: fieldDefault(fields.month, 1),\n        day: fieldDefault(fields.day, 1),\n        hour: fieldDefault(fields.hour, 0),\n        minute: fieldDefault(fields.minute, 0),\n        second: fieldDefault(fields.second, 0)\n    };\n}\n\nfunction fieldsFromMatch (match) {\n    return dateFields({\n        year: match[1],\n        month: match[2],\n        day: match[3],\n        hour: match[4],\n        minute: match[5],\n        second: match[6]\n    });\n}\n\nclass YMDHMSParser extends IsoParser {\n    constructor () {\n        super(/^(\\d\\d\\d\\d)(?:\\-?(\\d\\d)(?:\\-?(\\d\\d)(?:[T\\s]?(\\d\\d)(?:\\:(\\d\\d)(?:\\:(\\d\\d))?)?)?)?)?$/);\n    }\n    parse (iso) {\n        const start = this.check(iso) || [];\n        const end = start.slice();\n        const i = [1, 2, 3, 4, 5, 6].find(i => end[i] === undefined) || 7;\n        if (i === 1) {\n            end[1] = 2;\n        } else {\n            end[i - 1] = Number(end[i - 1]) + 1;\n        }\n        return [ fieldsFromMatch(start), fieldsFromMatch(end) ];\n    }\n}\n\nclass MillenniumParser extends IsoParser {\n    constructor () {\n        super(/^M(\\d+)$/);\n    }\n    parse (iso) {\n        const match = this.check(iso);\n        const m = Number(match[1]);\n        const year = m => (m - 1) * 1000 + 1;\n        return [\n            dateFields({ year: year(m) }),\n            dateFields({ year: year(m + 1) })\n        ];\n    }\n}\n\nclass CenturyParser extends IsoParser {\n    constructor () {\n        super(/^C(\\d+)$/);\n    }\n    parse (iso) {\n        const match = this.check(iso);\n        const c = Number(match[1]);\n        const year = c => (c - 1) * 100 + 1;\n        return [\n            dateFields({ year: year(c) }),\n            dateFields({ year: year(c + 1) })\n        ];\n    }\n}\n\nclass DecadeParser extends IsoParser {\n    constructor () {\n        super(/^D(\\d+)$/);\n    }\n    parse (iso) {\n        const match = this.check(iso);\n        const d = Number(match[1]);\n        const year = d => d * 10;\n        return [\n            dateFields({ year: year(d) }),\n            dateFields({ year: year(d + 1) })\n        ];\n    }\n}\n\nclass SemesterParser extends IsoParser {\n    constructor () {\n        super(/^(\\d\\d\\d\\d)S(\\d)$/);\n    }\n    parse (iso) {\n        const match = this.check(iso);\n        const year = Number(match[1]);\n        const s = Number(match[2]);\n        const month = s => (s - 1) * 6 + 1;\n        return [\n            dateFields({ year, month: month(s) }),\n            dateFields({ year, month: month(s + 1) })\n        ];\n    }\n}\n\nclass TrimesterParser extends IsoParser {\n    constructor () {\n        super(/^(\\d\\d\\d\\d)t(\\d)$/);\n    }\n    parse (iso) {\n        const match = this.check(iso);\n        const year = Number(match[1]);\n        const t = Number(match[2]);\n        const month = t => (t - 1) * 4 + 1;\n        return [\n            dateFields({ year, month: month(t) }),\n            dateFields({ year, month: month(t + 1) })\n        ];\n    }\n}\n\nclass QuarterParser extends IsoParser {\n    constructor () {\n        super(/^(\\d\\d\\d\\d)\\-?Q(\\d)$/);\n    }\n    parse (iso) {\n        const match = this.check(iso);\n        const year = Number(match[1]);\n        const q = Number(match[2]);\n        const month = q => (q - 1) * 3 + 1;\n        return [\n            dateFields({ year, month: month(q) }),\n            dateFields({ year, month: month(q + 1) })\n        ];\n    }\n}\n\nfunction isoDow (y, m, d) {\n    const dow = (new Date(y, m - 1, d)).getDay();\n    return dow === 0 ? 7 : dow;\n}\n\nfunction addDays (date, days) {\n    const newDate = new Date(date.valueOf());\n    newDate.setDate(newDate.getDate() + days);\n    return newDate;\n}\n\n// compute start date of yWw\nfunction startOfIsoWeek (y, w) {\n    const dow = isoDow(y, 1, 1);\n    const startDay = dow > 4 ? 9 - dow : 2 - dow;\n    const startDate = new Date(y, 0, startDay);\n    return addDays(startDate, (w - 1) * 7);\n}\n\nclass WeekParser extends IsoParser {\n    constructor () {\n        super(/^(\\d\\d\\d\\d)\\-?W(\\d\\d)$/);\n    }\n    parse (iso) {\n        const match = this.check(iso);\n        const year = Number(match[1]);\n        const week = Number(match[2]);\n        const start = startOfIsoWeek(year, week);\n        const end = startOfIsoWeek(year, week + 1);\n        const fields = date => ({\n            year: date.getFullYear(),\n            month: date.getMonth() + 1,\n            day: date.getDate()\n        });\n        return [\n            dateFields(fields(start)),\n            dateFields(fields(end))\n        ];\n    }\n}\n\nconst isoFormats = [\n    new MillenniumParser(),\n    new CenturyParser(),\n    new DecadeParser(),\n    new SemesterParser(),\n    new TrimesterParser(),\n    new QuarterParser(),\n    new WeekParser(),\n    new YMDHMSParser()\n];\n\nfunction findParser (iso) {\n    return isoFormats.find(parser => parser.check(iso));\n}\n\nfunction parseISO (iso) {\n    iso = iso || '';\n    const parser = findParser(iso);\n    if (!parser) {\n        throw new _errors_carto_parsing_error__WEBPACK_IMPORTED_MODULE_0__[\"default\"](`No date parser found for ${iso}`);\n    }\n    return parser.parse(iso);\n}\n\n\n/***/ }),\n\n/***/ \"./src/utils/time/periodISO.js\":\n/*!*************************************!*\\\n  !*** ./src/utils/time/periodISO.js ***!\n  \\*************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return periodISO; });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ \"./src/utils/util.js\");\n\n\nconst TIME_LEVELS = ['year', 'month', 'day', 'hour', 'minute', 'second'];\nconst TIME_STARTS = [1, 1, 1, 0, 0, 0];\nconst YEAR_LEVEL = 0;\nconst MONTH_LEVEL = 1;\nconst DAY_LEVEL = 2;\nconst HOUR_LEVEL = 3;\nconst MINUTE_LEVEL = 4;\nconst SECOND_LEVEL = 5;\n\nconst MS_PER_DAY = 86400000;\nconst MS_PER_HOUR = 3600000;\nconst MS_PER_MINUTE = 60000;\nconst MS_PER_S = 1000;\n\nfunction startLevel (parsed) {\n    let i = TIME_LEVELS.length - 1;\n    while (i > 0 && parsed[TIME_LEVELS[i]] === TIME_STARTS[i]) {\n        --i;\n    }\n    return i;\n}\n\nfunction pad (x, n) {\n    return x.toString().padStart(n, '0');\n}\n\nfunction parsedValue (dateValue) {\n    const date = Object(_util__WEBPACK_IMPORTED_MODULE_0__[\"msToDate\"])(dateValue);\n    return {\n        year: date.getUTCFullYear(),\n        month: date.getUTCMonth() + 1,\n        day: date.getUTCDate(),\n        hour: date.getUTCHours(),\n        minute: date.getUTCMinutes(),\n        second: date.getUTCSeconds()\n    };\n}\n\nfunction isoDow (y, m, d) {\n    const dow = (new Date(y, m - 1, d)).getDay();\n    return dow === 0 ? 7 : dow;\n}\n\nfunction invalidPeriod (period, invalid) {\n    throw new Error(`Invalid period of ${invalid} between ${period.v1} and ${period.v2}`);\n}\n\n// Return year and week number given year and day number\nfunction yearWeek (y, yd) {\n    const dow = isoDow(y, 1, 1);\n    const start = dow > 4 ? 9 - dow : 2 - dow;\n    if ((Math.abs(yd - start) % 7) !== 0) {\n        // y yd is not the start of any week\n        return [];\n    }\n    if (yd < start) {\n        // The week starts before the first week of the year => go back one year\n        yd += Math.round((Date.UTC(y, 0, 1) - Date.UTC(y - 1, 0, 1)) / MS_PER_DAY);\n        return yearWeek(y - 1, yd);\n    } else if (Date.UTC(y, 0, 1) + (yd - 1 + 3) * MS_PER_DAY >= Date.UTC(y + 1, 0, 1)) {\n        // The Wednesday (start of week + 3) lies in the next year => advance one year\n        yd -= Math.round((Date.UTC(y + 1, 0, 1) - Date.UTC(y, 0, 1)) / MS_PER_DAY);\n        return yearWeek(y + 1, yd);\n    }\n    return [y, 1 + Math.round((yd - start) / 7)];\n}\n\nfunction yearsPeriod (period) {\n    const d = period.t2['year'] - period.t1['year'];\n    if (d === 1000 && ((period.t1['year'] - 1) % 1000) === 0) {\n        // millennium\n        return `M${1 + (period.t1['year'] - 1) / 1000}`;\n    } else if (d === 100 && ((period.t1['year'] - 1) % 100) === 0) {\n        // century\n        return `C${1 + (period.t1['year'] - 1) / 100}`;\n    } else if (d === 10 && (period.t1['year'] % 10) === 0) {\n        // decade\n        return `D${period.t1['year'] / 10}`;\n    } else if (d === 1) {\n        // year\n        return pad(period.t1['year'], 4);\n    } else {\n        invalidPeriod(`${d} years`);\n    }\n}\n\nfunction monthsPeriod (period) {\n    const d = 12 * period.t2['year'] + period.t2['month'] - 12 * period.t1['year'] - period.t1['month'];\n    if (d === 6 && ((period.t1['month'] - 1) % 6) === 0) {\n        // semester\n        return `${pad(period.t1['year'], 4)}S${1 + (period.t1['month'] - 1) / 6}`;\n    } else if (d === 4) {\n        // trimester\n        return `${pad(period.t1['year'], 4)}t${1 + (period.t1['month'] - 1) / 4}`;\n    } else if (d === 3) {\n        // quarter\n        return `${pad(period.t1['year'], 4)}-Q${1 + (period.t1['month'] - 1) / 3}`;\n    } else if (d === 1) {\n        // month\n        return `${pad(period.t1['year'], 4)}-${pad(period.t1['month'], 2)}`;\n    } else {\n        invalidPeriod(`${d} months`);\n    }\n}\n\nfunction daysPeriod (period) {\n    const d = Math.round((period.v2 - period.v1) / MS_PER_DAY);\n    if (d === 1) {\n        // day\n        return `${pad(period.t1['year'], 4)}-${pad(period.t1['month'], 2)}-${pad(period.t1['day'], 2)}`;\n    } else if (d === 7) {\n        // week\n        let y = period.t1['year'];\n        const v0 = Date.UTC(y, 0, 1);\n        let yd = 1 + Math.round((period.v1 - v0) / MS_PER_DAY);\n        const [iy, w] = yearWeek(y, yd);\n        if (iy && w) {\n            return `${pad(iy, 4)}-W${pad(w, 2)}`;\n        }\n        invalidPeriod('7 days');\n    } else {\n        invalidPeriod(`${d} days`);\n    }\n}\n\nfunction hoursPeriod (period) {\n    const d = Math.round((period.v2 - period.v1) / MS_PER_HOUR);\n    if (d === 1) {\n        // hour\n        return `${pad(period.t1['year'], 4)}-${pad(period.t1['month'], 2)}-${pad(period.t1['day'], 2)}T${pad(period.t1['hour'], 2)}`;\n    } else {\n        invalidPeriod(`${d} hours`);\n    }\n}\n\nfunction minutesPeriod (period) {\n    const d = Math.round((period.v2 - period.v1) / MS_PER_MINUTE);\n    if (d === 1) {\n        // minute\n        return `${pad(period.t1['year'], 4)}-${pad(period.t1['month'], 2)}-${pad(period.t1['day'], 2)}T${pad(period.t1['hour'], 2)}:${pad(period.t1['minute'], 2)}`;\n    } else {\n        invalidPeriod(`${d} minutes`);\n    }\n}\n\nfunction secondsPeriod (period) {\n    const d = Math.round((period.v2 - period.v1) / MS_PER_S);\n    if (d === 1) {\n        // second\n        return `${pad(period.t1['year'], 4)}-${pad(period.t1['month'], 2)}-${pad(period.t1['day'], 2)}T${pad(period.t1['hour'], 2)}:${pad(period.t1['minute'], 2)}:${pad(period.t1['second'], 2)}`;\n    } else {\n        invalidPeriod(`${d} seconds`);\n    }\n}\n\nfunction periodISO (v1, v2) {\n    const t1 = parsedValue(v1);\n    const t2 = parsedValue(v2);\n    const l1 = startLevel(t1);\n    const l2 = startLevel(t2);\n    const period = { v1, v2, t1, t2 };\n\n    if (Math.max(l1, l2) === YEAR_LEVEL) {\n        return yearsPeriod(period);\n    } else if (Math.max(l1, l2) === MONTH_LEVEL) {\n        return monthsPeriod(period);\n    } else if (Math.max(l1, l2) === DAY_LEVEL) {\n        return daysPeriod(period);\n    } else if (Math.max(l1, l2) === HOUR_LEVEL) {\n        return hoursPeriod(period);\n    } else if (Math.max(l1, l2) === MINUTE_LEVEL) {\n        return minutesPeriod(period);\n    } else if (Math.max(l1, l2) === SECOND_LEVEL) {\n        return secondsPeriod(period);\n    }\n    invalidPeriod(period, 'fractional seconds');\n}\n\n\n/***/ }),\n\n/***/ \"./src/utils/util.js\":\n/*!***************************!*\\\n  !*** ./src/utils/util.js ***!\n  \\***************************/\n/*! exports provided: WM_R, WM_2R, isUndefined, isString, isNumber, isObject, regExpThatContains, castDate, msToDate, isSetsEqual, equalArrays, projectToWebMercator, computeMatrixZoom, computeMatrixCenter, computeViewportFromCameraMatrix, default, castTimeRange, timeRange, isTimeRange */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WM_R\", function() { return WM_R; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WM_2R\", function() { return WM_2R; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isUndefined\", function() { return isUndefined; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isString\", function() { return isString; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNumber\", function() { return isNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isObject\", function() { return isObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"regExpThatContains\", function() { return regExpThatContains; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"castDate\", function() { return castDate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"msToDate\", function() { return msToDate; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isSetsEqual\", function() { return isSetsEqual; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"equalArrays\", function() { return equalArrays; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"projectToWebMercator\", function() { return projectToWebMercator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeMatrixZoom\", function() { return computeMatrixZoom; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeMatrixCenter\", function() { return computeMatrixCenter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"computeViewportFromCameraMatrix\", function() { return computeViewportFromCameraMatrix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"castTimeRange\", function() { return castTimeRange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"timeRange\", function() { return timeRange; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isTimeRange\", function() { return isTimeRange; });\n/* harmony import */ var _time_TimeRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time/TimeRange */ \"./src/utils/time/TimeRange.js\");\n/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ \"./node_modules/gl-matrix/lib/gl-matrix.js\");\n/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geometry */ \"./src/utils/geometry.js\");\n/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors/carto-validation-error */ \"./src/errors/carto-validation-error.js\");\n\n\n\n\n/**\n * Export util functions\n */\n\n\nconst DEG2RAD = Math.PI / 180;\nconst EARTH_RADIUS = 6378137;\nconst WM_R = EARTH_RADIUS * Math.PI; // Webmercator *radius*: half length Earth's circumference\nconst WM_2R = WM_R * 2; // Webmercator coordinate range (Earth's circumference)\n\nfunction isUndefined (value) {\n    return value === undefined;\n}\n\nfunction isString (value) {\n    return typeof value === 'string';\n}\n\nfunction isNumber (value) {\n    return typeof value === 'number';\n}\n\nfunction isObject (value) {\n    const type = typeof value;\n    return value !== null && (type === 'object' || type === 'function');\n}\n\nfunction regExpThatContains (text) {\n    const escaped = text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // in case it has special symbols\n    return new RegExp(escaped);\n}\n\n/**\n * Transform the given parameter into a Date object.\n * When a number is given as a parameter is assumed to be a milliseconds epoch (UTC).\n * The result is a local Date.\n * @param {Date|number|string} date\n */\nfunction castDate (date) {\n    if (date instanceof Date) {\n        return date;\n    }\n\n    if (typeof (date) === 'number') {\n        return msToDate(date);\n    }\n\n    if (isString(date)) {\n        return new Date(date);\n    } else {\n        throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__[\"default\"](\n            'Invalid Date type',\n            _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__[\"CartoValidationErrorTypes\"].INCORRECT_TYPE\n        );\n    }\n}\n\nfunction msToDate (msEpoch) {\n    return new Date(msEpoch);\n}\n\nfunction isSetsEqual (a, b) {\n    return a.size === b.size && [...a].every(value => b.has(value));\n}\n\nfunction equalArrays (a, b) {\n    if (a && b && a.length === b.length) {\n        for (let i = 0; i < a.length; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\nfunction projectToWebMercator (latLng) {\n    let lat = latLng.lat * DEG2RAD;\n    let lng = latLng.lng * DEG2RAD;\n    return {\n        x: lng * EARTH_RADIUS,\n        y: Math.log(Math.tan(lat / 2 + Math.PI / 4)) * EARTH_RADIUS\n    };\n}\n\nfunction computeMatrixZoom (matrix) {\n    // The matrix projects spherical mercator coordinates to gl coordinates\n    return -(2 * matrix[15] / matrix[5]);\n}\n\nfunction computeMatrixCenter (matrix) {\n    // The matrix projects spherical mercator coordinates to gl coordinates\n    return {\n        x: -(1 + 2 * matrix[12] / matrix[0]),\n        y: +(1 + 2 * matrix[13] / matrix[5])\n    };\n}\n\nfunction computeViewportFromCameraMatrix (matrix) {\n    const inv = gl_matrix__WEBPACK_IMPORTED_MODULE_1__[\"mat4\"].invert([], matrix);\n\n    const corners = [\n        [-1, -1],\n        [-1, 1],\n        [1, -1],\n        [1, 1]\n    ].map(NDC =>\n        Object(_geometry__WEBPACK_IMPORTED_MODULE_2__[\"unproject\"])(inv, ...NDC)\n    ).map(c =>\n        // Our API works on the [-1,1] range, convert from [0,1] range to  [-1, 1] range\n        c.map(x => x * 2 - 1)\n    );\n\n    // Rotation no longer guarantees that corners[0] will be the minimum point of the AABB and corners[3] the maximum,\n    // we need to compute the AABB min/max by iterating\n    const min = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];\n    const max = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];\n    corners.forEach(corner => {\n        min[0] = Math.min(min[0], corner[0]);\n        min[1] = Math.min(min[1], corner[1]);\n        max[0] = Math.max(max[0], corner[0]);\n        max[1] = Math.max(max[1], corner[1]);\n    });\n\n    // Our API flips the `y` coordinate, we need to convert the values accordingly\n    min[1] = -min[1];\n    max[1] = -max[1];\n    const temp = min[1];\n    min[1] = max[1];\n    max[1] = temp;\n\n    return [...min, ...max];\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    WM_R,\n    WM_2R,\n    isUndefined,\n    isString,\n    isNumber,\n    isObject,\n    castDate,\n    isSetsEqual,\n    equalArrays,\n    projectToWebMercator,\n    computeMatrixZoom,\n    computeMatrixCenter,\n    computeViewportFromCameraMatrix\n});\n\nfunction castTimeRange (value, timeZone = null) {\n    if (value === undefined || isTimeRange(value)) {\n        if (value && timeZone) {\n            return timeRange({ iso: value._iso, timeZone });\n        }\n        return value;\n    }\n\n    if (typeof value === 'string') {\n        return timeRange({ iso: value, timeZone });\n    }\n}\n\nfunction timeRange (parameters) {\n    const { start, end, iso, timeZone } = parameters;\n\n    return new _time_TimeRange__WEBPACK_IMPORTED_MODULE_0__[\"default\"](timeZone, iso, start, end);\n}\n\nfunction isTimeRange (t) {\n    return t instanceof _time_TimeRange__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n}\n\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=carto-vl-91ee0cafd1e8f2199af1.worker.js.map", "/dist/" + "carto-vl-91ee0cafd1e8f2199af1.worker.js");
};

/***/ }),

/***/ "./src/sources/bigquery/BQClient.js":
/*!******************************************!*\
  !*** ./src/sources/bigquery/BQClient.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BigQueryClient; });
const ENDPOINT_URL = 'https://bigquery.googleapis.com/bigquery/v2';
const QUERY_TIMEOUT = 5 * 1000;
const POLLING_TIMEOUT = 2 * 60 * 1000;

class BigQueryClient {
    constructor (projectId, token) {
        this._projectId = projectId;
        this._token = token;
        this._activeJobs = {};
    }

    async list () {
        return this.fetch('GET', 'jobs');
    }

    async insert () {
        return this.fetch('POST', 'jobs');
    }

    async get (jobId) {
        return this.fetch('GET', `jobs/${jobId}`);
    }

    async cancel (jobId) {
        return this.fetch('POST', `jobs/${jobId}/cancel`);
    }

    async query (sqlQuery) {
        return this.fetch('POST', 'queries', {
            kind: 'bigquery#queryRequest',
            query: sqlQuery,
            useLegacySql: false,
            timeoutMs: QUERY_TIMEOUT,
            useQueryCache: true
        });
    }

    async getQueryResults (jobId) {
        return this.fetch('GET', `queries/${jobId}?timeoutMs=${QUERY_TIMEOUT}`);
    }

    async execute (sqlQuery) {
        const result = await this.query(sqlQuery);
        if (result.error) {
            throw Error(`[${result.error.status}] ${result.error.message}`);
        }
        return this._pollingQuery(result);
    }

    async _pollingQuery (result) {
        return new Promise((resolve, reject) => {
            if (result.jobComplete) {
                resolve(result);
            } else {
                const jobId = result.jobReference.jobId;
                this._updateJobTime(jobId);
                if (this._jobTimeout(jobId)) {
                    this._cancelJob(jobId, reject);
                } else {
                    this._getJobResult(jobId, resolve);
                }
            }
        });
    }

    _jobTimeout (jobId) {
        return this._activeJobs[jobId] >= POLLING_TIMEOUT;
    }

    _updateJobTime (jobId) {
        if (jobId in this._activeJobs) {
            this._activeJobs[jobId] += QUERY_TIMEOUT;
        } else {
            this._activeJobs[jobId] = QUERY_TIMEOUT;
        }
    }

    async _cancelJob (jobId, reject) {
        const result = await this.cancel(jobId);
        delete this._activeJobs[jobId];
        reject(result);
    }

    async _getJobResult (jobId, resolve) {
        const result = await this.getQueryResults(jobId);
        if (result.jobComplete) {
            resolve(result);
        } else {
            resolve(this._pollingQuery(result));
        }
    }

    async fetch (method, url, body) {
        const response = await fetch(`${ENDPOINT_URL}/projects/${this._projectId}/${url}`, {
            method,
            headers: {
                'Authorization': `Bearer ${this._token}`,
                'Content-Type': 'application/json'
            },
            body: body && JSON.stringify(body)
        });
        return response.json();
    }
}


/***/ }),

/***/ "./src/sources/bigquery/BQQuadkey.js":
/*!*******************************************!*\
  !*** ./src/sources/bigquery/BQQuadkey.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GilbertPartition; });
/* eslint-disable */


const PARTITION_UNPARTITIONED = 0;

/**
 * Assigns partitions to zoom levels given the number of partitions and zoom ranges available
 * Partitions always start at 1 (0 is used for outside levels) and end at the **partitions** parameter
 *
 * On the default situation (zmin = 0) we assign to the max zoom level, 3/4ths of the available partitions
 * since approximately 75% of the tiles are always found in the highest zoom. Then, we assign 75%
 * of the **remaining** space to the zoom level right below it, 75%(75%(75%)) to the next one, and so on.
 *
 * When (zmin != 0) we divide the "saved" partition space in the same proportion as the full partition table
 *
 * When (zstep != 1) we assign those partitions to the next valid zoom level
 */
function partition_range_by_zoom(partition_count, param = { z, zmin, zmax, zstep }) {

    if (param.z < 0 || param.zmin < 0 || param.zmax < 0 || param.zstep < 1 ||
        param.z < param.zmin || param.z > param.zmax || param.partition_count < 1 ||
        (param.z != param.zmin && ((param.z - param.zmin) % param.zstep) !== 0)) {
        return { min: PARTITION_UNPARTITIONED, max: PARTITION_UNPARTITIONED };
    }

    /* Adapt levels to always start from 0 */
    const zstep = param.zstep;
    const zmin = 0;
    let zmax = param.zmax - param.zmin;
    zmax = zmax - (zmax % zstep);
    let z = param.z - param.zmin;
    let range_initial_z = z - zstep + 1;

    const global_start = 1;
    const global_end = partition_count;

    if (zmin == zmax || global_start == global_end) {
        return { min: global_start, max: global_end };
    }

    /* Note that the z0 level gets special treatment since it gets the whole 100% of its remaining space */
    let z_partitions = 0;
    let partition_start;
    if (z == 0) {
        z_partitions = 4 * global_end / Math.pow(4, zmax + 1);
        partition_start = 0;
    } else {
        for (let acc = range_initial_z; acc <= z; acc++) {
            z_partitions += 3 * global_end / Math.pow(4, zmax - acc + 1);
        }
        partition_start = global_end / Math.pow(4, zmax - range_initial_z + 1);
    }
    const partition_end = partition_start + z_partitions;
    /* We round the start (instead of using floor) to give the lower zoom levels more partitions as 
     * they tend to be overcrowded, especially in rectangles with a great difference between height and width
     */
    partition_start = Math.round(partition_start);
    return {
        min: partition_start + global_start,
        max: Math.min(global_end, Math.max(Math.floor(partition_end), partition_start) + global_start)
    };
}

/* Finds the position of `target` inside the Gilbert curve defined by the rectangle:
 * cursor: Current position (start)
 * vector_main: Main direction of movement.
 *              It should move only on one axis, and it can be positive or negative.
 * vector_sec: Secondary direction of movement. Orthogonal to and smaller than vector_main.
 *
 * This is currently recursive, so the value is being add up inside target.counter
 */
function gilbert2d(cursor = { x, y },
    vector_main = { x, y },
    vector_sec = { x, y },
    target = { counter, x, y }) {
    /* Vector direction of movement (-1, 0 or +1) */
    const main_dirx = Math.sign(vector_main.x);
    const main_diry = Math.sign(vector_main.y);
    const sec_dirx = Math.sign(vector_sec.x);
    const sec_diry = Math.sign(vector_sec.y);

    const xmin = Math.min(cursor.x, cursor.x + vector_main.x - main_dirx + vector_sec.x - sec_dirx);
    const xmax = Math.max(cursor.x, cursor.x + vector_main.x - main_dirx + vector_sec.x - sec_dirx);
    const ymin = Math.min(cursor.y, cursor.y + vector_main.y - main_diry + vector_sec.y - sec_diry);
    const ymax = Math.max(cursor.y, cursor.y + vector_main.y - main_diry + vector_sec.y - sec_diry);
    if (target.x < xmin || target.x > xmax || target.y < ymin || target.y > ymax) {
        /* The tile we are looking for is not insde this rectangle. Add up its size and do a fast exit */
        target.counter += (xmax - xmin + 1) * (ymax - ymin + 1);
        return -1;
    }

    /* We can calculate the magnitude of the vectors this way because one of the coordinates
     * will always be 0 */
    const vector_main_magnitude = Math.abs(vector_main.x + vector_main.y);
    const vector_sec_magnitude = Math.abs(vector_sec.x + vector_sec.y);

    if (vector_main_magnitude == 1 || vector_sec_magnitude == 1) {
        /* We have either one row or one column. Either way, the position is the distance between
         * the current point and the target */
        target.counter += Math.abs((cursor.x - target.x) + (cursor.y - target.y));
        return target.counter;
    }

    const vector_main_half = {
        x: Math.floor(vector_main.x / 2),
        y: Math.floor(vector_main.y / 2)
    };

    if (2 * vector_main_magnitude > 3 * vector_sec_magnitude) {
        const vector_main_half_magnitude = Math.abs(vector_main_half.x + vector_main_half.y);
        if ((vector_main_half_magnitude % 2) && (vector_main_magnitude > 2)) {
            /* Prefer even steps */
            vector_main_half.x += main_dirx;
            vector_main_half.y += main_diry;
        }

        /* We split the main vector into 2 parts */
        const first = gilbert2d({ x: cursor.x, y: cursor.y },
            vector_main_half,
            vector_sec,
            target);
        if (first !== -1)
            return first;
        return gilbert2d({ x: cursor.x + vector_main_half.x, y: cursor.y + vector_main_half.y },
            { x: vector_main.x - vector_main_half.x, y: vector_main.y - vector_main_half.y },
            vector_sec,
            target);
    } else {
        const vector_sec_half = {
            x: Math.floor(vector_sec.x / 2),
            y: Math.floor(vector_sec.y / 2)
        };
        const vector_sec_half_magnitude = Math.abs(vector_sec_half.x + vector_sec_half.y);
        if ((vector_sec_half_magnitude % 2) && (vector_sec_magnitude > 2)) {
            /* Prefer even steps */
            vector_sec_half.x += sec_dirx;
            vector_sec_half.y += sec_diry;
        }

        /* We split the whole rectangle into 3 parts */

        /* Bottom half left (flipped so it finishes on top of the starting point) */
        const first = gilbert2d({ x: cursor.x, y: cursor.y },
            vector_sec_half,
            vector_main_half,
            target);
        if (first !== -1)
            return first;

        /* Top (left to right) */
        const second = gilbert2d({ x: cursor.x + vector_sec_half.x, y: cursor.y + vector_sec_half.y },
            vector_main,
            { x: vector_sec.x - vector_sec_half.x, y: vector_sec.y - vector_sec_half.y },
            target);
        if (second !== -1)
            return second;

        /* Bottom half right */
        return gilbert2d({
            x: cursor.x + (vector_main.x - main_dirx) + (vector_sec_half.x - sec_dirx),
            y: cursor.y + (vector_main.y - main_diry) + (vector_sec_half.y - sec_diry)
        },
            { x: - vector_sec_half.x, y: - vector_sec_half.y },
            { x: - (vector_main.x - vector_main_half.x), y: - (vector_main.y - vector_main_half.y) },
            target);
    }
}

/**
 * Given a rectangle coordinate (x : [0, width) ^ y : [ 0 .. height)) and its height and width,
 * it returns the position of the given coordinate in the Gilbert curve filling the rectangle
 * The result will be an integer number n : [0, (width * height) - 1]
 */
function gilbert2d_tile(target_tile = { x, y }, width, height) {
    if (width < 1 || height < 1)
        throw `Invalid Gilbert rectangle. Got: Width (${width}). Height: (${height})`;
    const tile = { x: target_tile.x, y: target_tile.y, counter: 0 };
    const start_point = { x: 0, y: 0 };

    let main_vector = { x: 0, y: height };
    let secondary_vector = { x: width, y: 0 };
    if (width > height) {
        main_vector = { x: width, y: 0 };
        secondary_vector = { x: 0, y: height };
    }
    return gilbert2d(start_point, main_vector, secondary_vector, tile);
}

class GilbertPartition {
    /**
     * partition_count: Number of partitions assigned for the whole dataset
     * z_range: Range of accepted zoom levels (e.g: { zmin: 0, zmax: 15 })
     * zmax_bbox: Bounding box of the dataset for the maximum accepted zoom level (i.e. z_range.zmax)
     *            These are tile coordinates (x, y) not geography coordinates
     */
    constructor(partition_count,
        z_range = { zmin, zmax, zstep },
        zmax_bbox = { xmin, xmax, ymin, ymax }) {
        this.partition_count = parseInt(partition_count);
        this.z_range = {
            zmin: parseInt(z_range.zmin),
            zmax: parseInt(z_range.zmax),
            zstep: parseInt(z_range.zstep)
        };
        this.zmax_bbox = {
            xmin: parseInt(zmax_bbox.xmin),
            xmax: parseInt(zmax_bbox.xmax),
            ymin: parseInt(zmax_bbox.ymin),
            ymax: parseInt(zmax_bbox.ymax)
        };

        if (!partition_count || partition_count < 1)
            throw `Unexpected partition count. Expected a positive integer. Got ${partition_count}`;
        if (!this.z_range)
            throw `Missing z_range`;
        if (isNaN(this.z_range.zmin) || isNaN(this.z_range.zmax) || isNaN(this.z_range.zstep))
            throw `Invalid z_range. Both zmin, zmax and zstep need to be defined. Got ${JSON.stringify(z_range)}`;
        if (this.z_range.zmin > this.z_range.zmax || this.z_range.zmin < 0 || this.zstep < 1)
            throw `Invalid z_range received. Got (${JSON.stringify(z_range)})`;
        if (!this.zmax_bbox)
            throw `Missing zmax_bbox`;
        if (isNaN(this.zmax_bbox.xmin) || isNaN(this.zmax_bbox.xmax) ||
            isNaN(this.zmax_bbox.ymin) || isNaN(this.zmax_bbox.ymax))
            throw `Invalid zmax_bbox. All xmin, xmax, ymin and ymax need to be defined. Got (${JSON.stringify(zmax_bbox)})`;
        if (this.zmax_bbox.xmin > this.zmax_bbox.xmax || this.zmax_bbox.xmin < 0 ||
            this.zmax_bbox.ymin > this.zmax_bbox.ymax || this.zmax_bbox.ymin < 0)
            throw `Invalid bbox received. Got (${JSON.stringify(zmax_bbox)})`;
    }

    getPartition(tile = { z: 0, x: 0, y: 0 }) {
        const rxmin = this.zmax_bbox.xmin >> (this.z_range.zmax - tile.z);
        const rxmax = this.zmax_bbox.xmax >> (this.z_range.zmax - tile.z);
        const rymin = this.zmax_bbox.ymin >> (this.z_range.zmax - tile.z);
        const rymax = this.zmax_bbox.ymax >> (this.z_range.zmax - tile.z);
        if (tile.z < this.z_range.zmin || tile.z > this.z_range.zmax ||
            tile.x < rxmin || tile.x > rxmax ||
            tile.y < rymin || tile.y > rymax) {
            return PARTITION_UNPARTITIONED;
        }

        const partition_range = partition_range_by_zoom(this.partition_count,
            { z: tile.z, zmin: this.z_range.zmin, zmax: this.z_range.zmax, zstep: this.z_range.zstep });
        const usable_partitions = partition_range.max - partition_range.min + 1;
        if (usable_partitions == 1) {
            return partition_range.min;
        }

        /* We switch to a rectangle starting at 0, 0 so it's easier to reason about it
         * The rectangle goes from (0, 0) to (rwidth - 1, rheight - 1)
         */
        const x = tile.x - rxmin;
        const y = tile.y - rymin;
        const rwidth = rxmax - rxmin + 1;
        const rheight = rymax - rymin + 1;
        const rectangle_size = rwidth * rheight;

        /* We need to divide this **rectangle** into equal sized areas, so what we do is to create a
         * Hilbert curve and then divide this 1d line into the necessary parts.
         *
         * If this was a perfect square, we would interleave bits from x and y, but in a rectangle
         * that would leave many empty spaces, so the partitions would be irregular (or some even empty)
         *
         * Instead we use a Generalized Hilbert curve based on https://github.com/jakubcerveny/gilbert
         * by Jakub erven
         *
         */
        const gilbert_position = gilbert2d_tile({ x: x, y: y }, rwidth, rheight);
        if (gilbert_position === -1 || gilbert_position >= rwidth * rheight) {
            throw `Unexpected gilbert partition (${gilbert_position}) for tile ${tile.z}/${tile.x}/${tile.y} ` +
            `=> ${x}/${y} : ${rwidth}, ${rheight})`;
        }

        /* The gilbert_position goes from 0 to rectangle_size - 1 */
        return partition_range.min + Math.floor(usable_partitions * gilbert_position / rectangle_size);
    }
}


/***/ }),

/***/ "./src/sources/bigquery/BQTileCache.js":
/*!*********************************************!*\
  !*** ./src/sources/bigquery/BQTileCache.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BigQueryTileCache; });
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lru-cache */ "./node_modules/lru-cache/index.js");
/* harmony import */ var lru_cache__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lru_cache__WEBPACK_IMPORTED_MODULE_0__);


class BigQueryTileCache {
    constructor () {
        const lruOptions = {
            max: 512,
            length: () => 1,
            maxAge: 1000 * 60 * 60,
            dispose: (uid, dataframe) => {
                if (dataframe.empty === false) {
                    dataframe.free();
                }
            }
        };
        this._cache = lru_cache__WEBPACK_IMPORTED_MODULE_0__(lruOptions);
    }

    get (uid) {
        return this._cache.get(uid);
    }

    set (uid, dataframe) {
        this._cache.set(uid, dataframe);
    }

    free () {
        this._cache.reset();
    }
}


/***/ }),

/***/ "./src/sources/bigquery/BQTileClient.js":
/*!**********************************************!*\
  !*** ./src/sources/bigquery/BQTileClient.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BigQueryTileClient; });
/* harmony import */ var _BQTileCache__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BQTileCache */ "./src/sources/bigquery/BQTileCache.js");
/* harmony import */ var _client_rsys__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../client/rsys */ "./src/client/rsys.js");
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/util */ "./src/utils/util.js");




class BigQueryTileClient {
    constructor () {
        this._nextGroupID = 0;
        this._currentRequestGroupID = 0;
        this._oldDataframes = [];
        this._cache = new _BQTileCache__WEBPACK_IMPORTED_MODULE_0__["default"]();
    }

    bindLayer (addDataframe) {
        this._addDataframe = addDataframe;
    }

    requestData (zoom, viewport, requestDataframes, viewportZoomToSourceZoom = Math.ceil, bounds) {
        const extend = 0; // tile ring around the viewport
        viewport = this._filterViewport(viewport, bounds);
        const tiles = Object(_client_rsys__WEBPACK_IMPORTED_MODULE_1__["rTiles"])(zoom, viewport, viewportZoomToSourceZoom, extend);
        return this._getTiles(tiles, requestDataframes);
    }

    free () {
        this._cache.free();
        this._cache = new _BQTileCache__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this._oldDataframes = [];
    }

    async _getTiles (tiles, requestDataframes) {
        this._nextGroupID++;
        const requestGroupID = this._nextGroupID;

        // Extract non-cached tiles
        const nonCachedTiles = tiles.filter(({ x, y, z }) => !this._cache.get(`${x},${y},${z}`));

        // Cache tiles with empty Dataframe to avoid multiple requests
        nonCachedTiles.map(({ x, y, z }) => this._cache.set(`${x},${y},${z}`, { }));

        // Request all tiles at the same time
        if (nonCachedTiles.length) {
            await this._requestDataframes(nonCachedTiles, requestDataframes);
        }

        const completedDataframes = tiles.map(({ x, y, z }) => this._cache.get(`${x},${y},${z}`));

        if (requestGroupID < this._currentRequestGroupID) {
            return true;
        }
        this._currentRequestGroupID = requestGroupID;

        this._oldDataframes.forEach(d => {
            d.active = false;
        });
        completedDataframes.forEach(d => {
            d.active = true;
        });
        const dataframesChanged = !Object(_utils_util__WEBPACK_IMPORTED_MODULE_2__["isSetsEqual"])(new Set(completedDataframes), new Set(this._oldDataframes));
        this._oldDataframes = completedDataframes;
        return dataframesChanged;
    }

    async _requestDataframes (tiles, requestDataframes) {
        const dataframes = await requestDataframes(tiles);
        for (let i = 0; i < dataframes.length; i++) {
            const dataframe = dataframes[i];
            const { x, y, z } = dataframe;
            dataframes[i].orderID = x + y / 1000;
            if (!dataframe.empty) {
                this._addDataframe(dataframe);
            }
            this._cache.set(`${x},${y},${z}`, dataframe);
        }
    }

    _filterViewport (viewport, bounds) {
        if (bounds) {
            const localBounds = this._localBounds(bounds);
            return [
                Math.max(viewport[0], localBounds[0]),
                Math.max(viewport[1], localBounds[1]),
                Math.min(viewport[2], localBounds[2]),
                Math.min(viewport[3], localBounds[3])
            ];
        }
        return viewport;
    }

    _localBounds (bounds) {
        const sw = Object(_utils_util__WEBPACK_IMPORTED_MODULE_2__["projectToWebMercator"])({
            lng: bounds[0],
            lat: bounds[1]
        });
        const ne = Object(_utils_util__WEBPACK_IMPORTED_MODULE_2__["projectToWebMercator"])({
            lng: bounds[2],
            lat: bounds[3]
        });
        return [sw.x / _utils_util__WEBPACK_IMPORTED_MODULE_2__["WM_R"], sw.y / _utils_util__WEBPACK_IMPORTED_MODULE_2__["WM_R"], ne.x / _utils_util__WEBPACK_IMPORTED_MODULE_2__["WM_R"], ne.y / _utils_util__WEBPACK_IMPORTED_MODULE_2__["WM_R"]];
    }
}


/***/ }),

/***/ "./src/sources/bigquery/BQTileset.js":
/*!*******************************************!*\
  !*** ./src/sources/bigquery/BQTileset.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BigQueryTileset; });
/* harmony import */ var _renderer_dataframe_Dataframe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../renderer/dataframe/Dataframe */ "./src/renderer/dataframe/Dataframe.js");
/* harmony import */ var _MVTMetadata__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../MVTMetadata */ "./src/sources/MVTMetadata.js");
/* harmony import */ var _Base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Base */ "./src/sources/Base.js");
/* harmony import */ var _BQTileClient__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./BQTileClient */ "./src/sources/bigquery/BQTileClient.js");
/* harmony import */ var _BQTilesetClient__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BQTilesetClient */ "./src/sources/bigquery/BQTilesetClient.js");
/* harmony import */ var _Workers_worker__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Workers.worker */ "./src/sources/Workers.worker.js");
/* harmony import */ var _Workers_worker__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_Workers_worker__WEBPACK_IMPORTED_MODULE_5__);








const DEFAULT_ID_PROPERTY = '___id';

/**
 * BigQueryTileset source: PoC based on the MVT source to fetch tiles directly from a tileset in BigQuery.
 *
 * @param {object} data - BigQuery data to reference the tileset:
 * @param {string} data.project - The name of the BigQuery project.
 * @param {string} data.dataset - The name of the BigQuery dataset.
 * @param {string} data.tileset - The name of the BigQuery tileset table.
 * @param {string} data.token   - The token to authorize requests to the BigQuery project.
 *
 * @param {object} [metadata] - Optional attributes to overwrite tileset metadata:
 * @param {object} [metadata.properties]  - The information about available columns and types in the MVT ('{"prop": "String", ...').
 * @param {string} [metadata.maxzoom]     - The maximum zoom with tiles data ('14').
 * @param {string} [metadata.minzoom]     - The minimum zoom with tiles data ('4').
 * @param {string} [metadata.center]      - The initial position and zoom of the map ('-76.124268,38.933775,14')
 * @param {string} [metadata.bounds]      - The global bounds with tiles data available ('78.178689,0.000000,0.000000,39.719731').
 * @param {string} [metadata.compression] - The type of tile compression ('gzip').
 * @param {string} [metadata.tile_extent] - The size and resolution of the tile ('4096').
 * @param {string} [metadata.carto_quadkey_zoom] - The quadkey optimization params ('{"version":1,"partitions":4000,"zmin":0,"zmax":14,"xmin":4634,"xmax":4747,"ymin":6219,"ymax":6322}').
 * @param {string} [metadata.extend_maxzoom_tiles] - A flag to use the max zoom tiles for bigger zoom values. Default is false.
 */
class BigQueryTileset extends _Base__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor (data, metadata = {}) {
        super();

        this._tilesetData = data;
        this._tilesetMetadata = metadata;
        this._tileClient = new _BQTileClient__WEBPACK_IMPORTED_MODULE_3__["default"]();

        this._mID = 0;
        this._workerDispatch = {};
        this._workerName = 'BigQueryTileset';
    }

    _initMetadata (metadata) {
        metadata = new _MVTMetadata__WEBPACK_IMPORTED_MODULE_1__["default"](metadata);
        metadata.setCodecs();
        this._metadata = metadata;
    }

    _initOptions (options) {
        this._options = options;
    }

    get _worker () {
        if (!this._workerInstance) {
            this._workerInstance = new _Workers_worker__WEBPACK_IMPORTED_MODULE_5___default.a();
            this._workerInstance.onmessage = this._receiveMessageFromWorker.bind(this);
        }
        return this._workerInstance;
    }

    _receiveMessageFromWorker (event) {
        const { mID, dataframes } = event.data;
        for (let i = 0; i < dataframes.length; i++) {
            const dataframe = dataframes[i];
            if (!dataframe.empty) {
                this._updateMetadataWith(dataframe);
            }
        }
        this._workerDispatch[mID](dataframes);
    }

    _updateMetadataWith (dataframe) {
        Object.setPrototypeOf(dataframe, _renderer_dataframe_Dataframe__WEBPACK_IMPORTED_MODULE_0__["default"].prototype);
        const metadata = dataframe.metadata;

        this._metadata.numCategories = metadata.numCategories;
        this._metadata.categoryToID = metadata.categoryToID;
        this._metadata.IDToCategory = metadata.IDToCategory;
        this._metadata.geomType = metadata.geomType;

        dataframe.metadata = this._metadata;
    }

    _clone () {
        return this;
    }

    bindLayer (addDataframe) {
        this._tileClient.bindLayer(addDataframe);
    }

    async requestMetadata () {
        if (!this._metadata) {
            await this.initMetadata();
        }
        return this._metadata;
    }

    async initMetadata () {
        const client = new _BQTilesetClient__WEBPACK_IMPORTED_MODULE_4__["default"](this._tilesetData.project, this._tilesetData.token);
        const tilesetMetadata = await client.fetchMetadata(this._tilesetData.dataset, this._tilesetData.tileset);

        this._tilesetMetadata = { ...tilesetMetadata, ...this._tilesetMetadata };

        const properties = {};
        const tilesetProps = JSON.parse(this._tilesetMetadata.json).vector_layers[0].fields;

        for (let key in tilesetProps) {
            const type = tilesetProps[key] === 'String' ? 'category' : 'number';
            properties[key] = { type };
        }
        properties[DEFAULT_ID_PROPERTY] = { type: 'number' };

        const metadata = {
            idProperty: DEFAULT_ID_PROPERTY,
            properties,
            extent: parseInt(this._tilesetMetadata.tile_extent)
        };

        const minZoom = parseInt(this._tilesetMetadata.minzoom);
        const maxZoom = parseInt(this._tilesetMetadata.maxzoom);
        const options = {
            viewportZoomToSourceZoom: (zoom) => {
                if (zoom > maxZoom) {
                    return this._tilesetMetadata.extend_maxzoom_tiles ? maxZoom : null;
                }
                if (zoom < minZoom) {
                    return null;
                }
                return Math.ceil(zoom);
            }
        };

        if (this._tilesetMetadata.center) {
            const rawCenter = this._tilesetMetadata.center.split(',');
            this._tilesetMetadata.center = {
                longitude: parseFloat(rawCenter[0]),
                latitude: parseFloat(rawCenter[1]),
                zoom: parseInt(rawCenter[2])
            };
        }

        if (this._tilesetMetadata.bounds) {
            const rawBounds = this._tilesetMetadata.bounds.split(',');
            // [xmin, ymin, xmax, ymax]
            this._tilesetMetadata.bounds = [
                parseFloat(rawBounds[0]),
                parseFloat(rawBounds[1]),
                parseFloat(rawBounds[2]),
                parseFloat(rawBounds[3])
            ];
        }

        this._initMetadata(metadata);
        this._initOptions(options);
    }

    requestData (zoom, viewport) {
        const requestDataframes = this._requestDataframes.bind(this);
        const viewportZoomToSourceZoom = this._viewportZoomToSourceZoom.bind(this);

        return this._tileClient.requestData(zoom, viewport,
            requestDataframes, viewportZoomToSourceZoom, this._tilesetMetadata.bounds
        );
    }

    async _requestDataframes (tiles) {
        return new Promise(resolve => {
            this._postMessageToWorker(tiles);

            this._metadataSent = true;
            this._workerDispatch[this._mID] = resolve;
            this._mID++;
        });
    }

    _postMessageToWorker (tiles) {
        this._worker.postMessage({
            tiles,
            tilesetData: this._tilesetData,
            tilesetMetadata: this._tilesetMetadata,
            metadata: this._metadataSent ? undefined : this._metadata,
            mID: this._mID,
            workerName: this._workerName
        });
    }

    _viewportZoomToSourceZoom (zoom) {
        return this._options.viewportZoomToSourceZoom(zoom);
    }

    free () {
        this._tileClient.free();
    }
}


/***/ }),

/***/ "./src/sources/bigquery/BQTilesetClient.js":
/*!*************************************************!*\
  !*** ./src/sources/bigquery/BQTilesetClient.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BigQueryTilesetClient; });
/* harmony import */ var _BQClient__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BQClient */ "./src/sources/bigquery/BQClient.js");
/* harmony import */ var _BQQuadkey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BQQuadkey */ "./src/sources/bigquery/BQQuadkey.js");
/* harmony import */ var base64_arraybuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! base64-arraybuffer */ "./node_modules/base64-arraybuffer/lib/base64-arraybuffer.js");
/* harmony import */ var base64_arraybuffer__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(base64_arraybuffer__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! pako */ "./node_modules/pako/index.js");
/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(pako__WEBPACK_IMPORTED_MODULE_3__);





// Singleton
let _partitioner = null;

class BigQueryTilesetClient {
    constructor (projectId, token) {
        this._client = new _BQClient__WEBPACK_IMPORTED_MODULE_0__["default"](projectId, token);
    }

    async fetchMetadata (dataset, tileset) {
        const sqlQuery = `
            SELECT name, value
            FROM \`${dataset}.metadata\`
            WHERE table_name = '${tileset}'`;

        const result = await this._execute(sqlQuery);

        const metadata = {};

        if (result && result.rows) {
            for (let i = 0; i < result.rows.length; i++) {
                const row = result.rows[i];
                if (row.f && row.f.length === 2) {
                    metadata[row.f[0].v] = row.f[1].v;
                }
            }
        }

        return metadata;
    }

    async fetchTiles (tiles, dataset, tileset, tilesetMetadata) {
        if (!_partitioner) {
            const params = JSON.parse(tilesetMetadata.carto_quadkey_zoom);
            _partitioner = initializePartitioner(params);
        }

        const parentQuadkeys = getParentQuadkeysFromTiles(tiles);
        const parentQuadkeysFilter = parentQuadkeys.length ? `carto_quadkey IN (${parentQuadkeys})` : 'TRUE';
        const tilesFilter = tiles.map((tile) => tileFilter(tile)).join(' OR ');
        const sqlQuery = `
            SELECT zoom_level, tile_column, tile_row, tile_data
            FROM \`${dataset}.${tileset}\`
            WHERE (${parentQuadkeysFilter}) AND (${tilesFilter})`;

        const result = await this._execute(sqlQuery);

        let mvts = [];
        let missedTiles = Object.assign(tiles, {});
        if (result && result.rows) {
            for (let i = 0; i < result.rows.length; i++) {
                const row = result.rows[i];
                if (row.f && row.f.length === 4) {
                    const z = parseInt(row.f[0].v);
                    const x = parseInt(row.f[1].v);
                    const y = parseInt(row.f[2].v);
                    const mvt = tilesetMetadata.compression === 'gzip'
                        ? Object(pako__WEBPACK_IMPORTED_MODULE_3__["inflate"])(atob(row.f[3].v))
                        : Object(base64_arraybuffer__WEBPACK_IMPORTED_MODULE_2__["decode"])(row.f[3].v);
                    mvts.push({ z, x, y, buffer: mvt });
                    missedTiles = missedTiles.filter((t) => !(t.z === z && t.x === x && t.y === y));
                }
            }

            console.log(`${mvts.length}/${result.totalRows}`);

            if (result.totalRows > mvts.length) {
                const missedmvts = await this.fetchTiles(missedTiles, dataset, tileset, tilesetMetadata);
                mvts = mvts.concat(missedmvts);
            }
        }

        return mvts;
    }

    async _execute (sqlQuery) {
        console.log('>');

        const begin = (new Date()).getTime();
        const result = await this._client.execute(sqlQuery);
        const end = (new Date()).getTime();

        console.log('<', end - begin);

        return result;
    }
}

function initializePartitioner (parameters) {
    if (parameters.version !== 1) {
        throw new Error('Unknown quadkey version');
    }
    const zRange = {
        zmin: parameters.zmin,
        zmax: parameters.zmax,
        zstep: parameters.zstep
    };
    const zmaxBBox = {
        xmin: parameters.xmin,
        xmax: parameters.xmax,
        ymin: parameters.ymin,
        ymax: parameters.ymax
    };
    const partitions = parameters.partitions;
    return new _BQQuadkey__WEBPACK_IMPORTED_MODULE_1__["default"](partitions, zRange, zmaxBBox);
}

function getParentQuadkeysFromTiles (tiles) {
    let result = new Set();
    for (let tile of tiles) {
        result.add(_partitioner.getPartition({ z: tile.z, x: tile.x, y: tile.y }));
    }
    return [...result].filter(x => x !== null);
}

function tileFilter (tile) {
    return `(zoom_level = ${tile.z} AND tile_column = ${tile.x} AND tile_row = ${tile.y})`;
}


/***/ }),

/***/ "./src/sources/geojson/GeoJSOMetadataBuilder.js":
/*!******************************************************!*\
  !*** ./src/sources/geojson/GeoJSOMetadataBuilder.js ***!
  \******************************************************/
/*! exports provided: GeoJSONMetadataBuilder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeoJSONMetadataBuilder", function() { return GeoJSONMetadataBuilder; });
/* harmony import */ var _renderer_Metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../renderer/Metadata */ "./src/renderer/Metadata.js");
/* harmony import */ var _renderer_schema__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../renderer/schema */ "./src/renderer/schema.js");
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/util */ "./src/utils/util.js");
/* harmony import */ var _src_errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../src/errors/carto-runtime-error */ "./src/errors/carto-runtime-error.js");
/* harmony import */ var _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../src/errors/carto-validation-error */ "./src/errors/carto-validation-error.js");
/* harmony import */ var _GeoJSONMetadata__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./GeoJSONMetadata */ "./src/sources/geojson/GeoJSONMetadata.js");
/* harmony import */ var _GeoJSONGeometryType__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./GeoJSONGeometryType */ "./src/sources/geojson/GeoJSONGeometryType.js");












const SAMPLE_TARGET_SIZE = 1000;

class GeoJSONMetadataBuilder {
    constructor (providedDateColumns, boundColumns) {
        this._providedDateColumns = providedDateColumns;
        this._boundColumns = boundColumns;

        this._numFields = new Set();
        this._catFields = new Set();
        this._dateFields = new Set();

        this._properties = {};
    }

    /**
     * Build a Metadata instance, including the columns required by the viz (and using
     * a sample of SAMPLE_TARGET_SIZE if required) to calculate the properties stats
     */
    buildFrom (viz, features) {
        this._addNumericColumnField(_renderer_Metadata__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_ID_PROPERTY"]);

        const sample = [];
        const requiredColumns = this._requiredColumnsIn(viz);
        for (let i = 0; i < features.length; i++) {
            const featureProperties = features[i].properties;
            this._addPropertiesToMetadata(featureProperties, requiredColumns);
            this._sampleFeatureOnMetadata(featureProperties, sample, features.length);
        }

        this._calculateAvgForNumericFields();

        const metadata = new _GeoJSONMetadata__WEBPACK_IMPORTED_MODULE_5__["default"]({
            properties: this._properties,
            featureCount: features.length,
            sample,
            geomType: this._dataframeGeomTypeFrom(features),
            idProperty: _renderer_Metadata__WEBPACK_IMPORTED_MODULE_0__["DEFAULT_ID_PROPERTY"]
        });
        metadata.setCodecs();

        return metadata;
    }

    /**
     * Return a list with the current numFields + catFields + dateFields
     */
    getCurrentFields () {
        const allFields = [...this._numFields].concat([...this._catFields]).concat([...this._dateFields]);
        return allFields;
    }

    _requiredColumnsIn (viz) {
        return new Set(Object.keys(_renderer_schema__WEBPACK_IMPORTED_MODULE_1__["default"].simplify(viz.getMinimumNeededSchema())));
    }

    _addPropertiesToMetadata (featureProperties, requiredColumns) {
        const keys = Object.keys(featureProperties);
        for (let j = 0, len = keys.length; j < len; j++) {
            const name = keys[j];
            if (!requiredColumns.has(name) || this._boundColumns.has(name)) {
                continue;
            }
            const value = featureProperties[name];
            this._addPropertyToMetadata(name, value);
        }
    }

    _calculateAvgForNumericFields () {
        this._numFields.forEach(name => {
            const property = this._properties[name];
            property.avg = property.sum / property.count;
        });
    }

    _dataframeGeomTypeFrom (features) {
        let geomType = '';
        if (features.length > 0) {
            // Set the geomType of the first feature to the metadata
            geomType = Object(_GeoJSONGeometryType__WEBPACK_IMPORTED_MODULE_6__["dataframeGeometryType"])(features[0].geometry.type);
        }
        return geomType;
    }
    _sampleFeatureOnMetadata (featureProperties, sample, featureCount) {
        if (featureCount > SAMPLE_TARGET_SIZE) {
            const sampling = SAMPLE_TARGET_SIZE / featureCount;
            if (Math.random() > sampling) {
                return;
            }
        }
        sample.push(featureProperties);
    }

    _addNumericPropertyToMetadata (propertyName, value) {
        if (this._catFields.has(propertyName) || this._dateFields.has(propertyName)) {
            throw new _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_4__["default"](
                `Unsupported GeoJSON: the property '${propertyName}' has different types in different features.`,
                _src_errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_4__["CartoValidationErrorTypes"].INCORRECT_TYPE
            );
        }

        this._addNumericColumnField(propertyName);
        const property = this._properties[propertyName];
        property.min = Math.min(property.min, value);
        property.max = Math.max(property.max, value);
        property.sum += value;
    }

    _addNumericColumnField (propertyName) {
        if (!this._numFields.has(propertyName)) {
            this._numFields.add(propertyName);
            this._properties[propertyName] = {
                type: 'number',
                min: Number.POSITIVE_INFINITY,
                max: Number.NEGATIVE_INFINITY,
                avg: Number.NaN,
                sum: 0,
                count: 0
            };
        }
    }

    _addDatePropertyToMetadata (propertyName, value) {
        if (this._catFields.has(propertyName) || this._numFields.has(propertyName)) {
            throw new _src_errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_3__["default"](
                `Unsupported GeoJSON: the property '${propertyName}' has different types in different features.`,
                _src_errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_3__["CartoRuntimeErrorTypes"].NOT_SUPPORTED
            );
        }
        this._addDateColumnField(propertyName);
        const column = this._properties[propertyName];
        const dateValue = _utils_util__WEBPACK_IMPORTED_MODULE_2__["default"].castDate(value);
        column.min = column.min ? _utils_util__WEBPACK_IMPORTED_MODULE_2__["default"].castDate(Math.min(column.min, dateValue)) : dateValue;
        column.max = column.max ? _utils_util__WEBPACK_IMPORTED_MODULE_2__["default"].castDate(Math.max(column.max, dateValue)) : dateValue;
        column.sum += value;
        column.count++;
    }

    _addDateColumnField (propertyName) {
        if (!this._dateFields.has(propertyName)) {
            this._dateFields.add(propertyName);
            this._properties[propertyName] = {
                type: 'date',
                min: null,
                max: null,
                avg: null,
                sum: 0,
                count: 0
            };
        }
    }

    _addPropertyToMetadata (propertyName, value) {
        if (this._providedDateColumns.has(propertyName)) {
            return this._addDatePropertyToMetadata(propertyName, value);
        }
        if (Number.isFinite(value)) {
            return this._addNumericPropertyToMetadata(propertyName, value);
        }
        if (value === null) {
            return;
        }
        this._addCategoryPropertyToMetadata(propertyName, value);
    }

    _addCategoryPropertyToMetadata (propertyName, value) {
        if (this._numFields.has(propertyName) || this._dateFields.has(propertyName)) {
            throw new _src_errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_3__["default"](
                `Unsupported GeoJSON: the property '${propertyName}' has different types in different features.`,
                _src_errors_carto_runtime_error__WEBPACK_IMPORTED_MODULE_3__["CartoRuntimeErrorTypes"].NOT_SUPPORTED
            );
        }
        if (!this._catFields.has(propertyName)) {
            this._catFields.add(propertyName);
            this._properties[propertyName] = {
                type: 'category',
                categories: []
            };
        }
        const property = this._properties[propertyName];
        const cat = property.categories.find(cat => cat.name === value);
        if (cat) {
            cat.frequency++;
        } else {
            property.categories.push({ name: value, frequency: 1 });
        }
    }
}


/***/ }),

/***/ "./src/sources/geojson/GeoJSONGeometryTransformer.js":
/*!***********************************************************!*\
  !*** ./src/sources/geojson/GeoJSONGeometryTransformer.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GeoJSONGeometryTransformer; });
/* harmony import */ var _client_rsys__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../client/rsys */ "./src/client/rsys.js");
/* harmony import */ var _utils_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/util */ "./src/utils/util.js");



/**
 * Helper class to transform geometry coordinates from a GeoJSON.
 * It converts the original coordinates (Lng, Lat) to a rSys coords
 * (local reference system), using the 'center' parameter.
 *
 * RSys coords are in the range: -1 <= x <= +1; -1 <= y <= +1
 */
class GeoJSONGeometryTransformer {
    constructor (center) {
        this._center = center;
    }

    computePoint (data) {
        const lat = data[1];
        const lng = data[0];
        const wm = _utils_util__WEBPACK_IMPORTED_MODULE_1__["default"].projectToWebMercator({ lat, lng });

        const targetReferenceSystem = {
            scale: _utils_util__WEBPACK_IMPORTED_MODULE_1__["default"].WM_R,
            center: this._center /* */
        };

        return _client_rsys__WEBPACK_IMPORTED_MODULE_0__["wToR"](wm.x, wm.y, targetReferenceSystem);
    }

    computeLineString (data, reverse) {
        let line = [];
        for (let i = 0; i < data.length; i++) {
            const point = this.computePoint(
                data[reverse ? (data.length - i - 1) : i]
            );
            line.push(point.x, point.y);
        }
        return line;
    }

    computeMultiLineString (data) {
        let multiline = [];
        for (let i = 0; i < data.length; i++) {
            let line = this.computeLineString(data[i]);
            if (line.length > 0) {
                multiline.push(line);
            }
        }
        return multiline;
    }

    computePolygon (data) {
        let polygon = {
            flat: [],
            holes: [],
            clipped: []
        };
        let holeIndex = 0;
        let firstReverse = false;

        if (data.length) {
            firstReverse = this._isReversed(data[0]);
            const flat = this.computeLineString(data[0], firstReverse);
            polygon.flat = polygon.flat.concat(flat);
        }

        for (let i = 1; i < data.length; i++) {
            if (firstReverse !== this._isReversed(data[i])) {
                holeIndex += data[i - 1].length;
                polygon.holes.push(holeIndex);
            }
            const flat = this.computeLineString(data[i], firstReverse);
            polygon.flat = polygon.flat.concat(flat);
        }

        return polygon;
    }

    computeMultiPolygon (data) {
        let multipolygon = [];
        for (let i = 0; i < data.length; i++) {
            let polygon = this.computePolygon(data[i]);
            if (polygon.flat.length > 0) {
                multipolygon.push(polygon);
            }
        }
        return multipolygon;
    }

    _isReversed (vertices) {
        let total = 0;
        let pt1 = vertices[0];
        let pt2;
        for (let i = 0; i < vertices.length - 1; i++) {
            pt2 = vertices[i + 1];
            total += (pt2[1] - pt1[1]) * (pt2[0] + pt1[0]);
            pt1 = pt2;
        }
        // When total is positive it means that vertices are oriented clock wise
        // and, since positive orientation is counter-clock wise, it is reversed.
        return total >= 0;
    }
}


/***/ }),

/***/ "./src/sources/geojson/GeoJSONGeometryType.js":
/*!****************************************************!*\
  !*** ./src/sources/geojson/GeoJSONGeometryType.js ***!
  \****************************************************/
/*! exports provided: GeoJSONGeometryType, dataframeGeometryType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeoJSONGeometryType", function() { return GeoJSONGeometryType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dataframeGeometryType", function() { return dataframeGeometryType; });
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/geometry */ "./src/utils/geometry.js");


/**
 * Geometry types available at GeoJSON format
 */
const GeoJSONGeometryType = Object.freeze({
    POINT: 'Point',
    LINE_STRING: 'LineString',
    MULTI_LINE_STRING: 'MultiLineString',
    POLYGON: 'Polygon',
    MULTI_POLYGON: 'MultiPolygon'
});

/**
 * Dataframe geometry type corresponding to every GeoJSON geometry type
 */
function dataframeGeometryType (geojsonGeometryType) {
    switch (geojsonGeometryType) {
        case GeoJSONGeometryType.POINT:
            return _utils_geometry__WEBPACK_IMPORTED_MODULE_0__["GEOMETRY_TYPE"].POINT;
        case GeoJSONGeometryType.LINE_STRING:
        case GeoJSONGeometryType.MULTI_LINE_STRING:
            return _utils_geometry__WEBPACK_IMPORTED_MODULE_0__["GEOMETRY_TYPE"].LINE;
        case GeoJSONGeometryType.POLYGON:
        case GeoJSONGeometryType.MULTI_POLYGON:
            return _utils_geometry__WEBPACK_IMPORTED_MODULE_0__["GEOMETRY_TYPE"].POLYGON;
        default:
            return '';
    }
}




/***/ }),

/***/ "./src/sources/geojson/GeoJSONMetadata.js":
/*!************************************************!*\
  !*** ./src/sources/geojson/GeoJSONMetadata.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GeoJSONMetadata; });
/* harmony import */ var _renderer_Metadata__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../renderer/Metadata */ "./src/renderer/Metadata.js");
/* harmony import */ var _codecs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../codecs */ "./src/codecs/index.js");



class GeoJSONMetadata extends _renderer_Metadata__WEBPACK_IMPORTED_MODULE_0__["default"] {
    setCodecs () {
        Object.keys(this.properties).forEach(propertyName => {
            const property = this.properties[propertyName];
            const type = property.type;
            if (type !== 'geometry') {
                property.codec = Object(_codecs__WEBPACK_IMPORTED_MODULE_1__["default"])(this, type, propertyName);
            }
        });
    }
}


/***/ }),

/***/ "./src/utils/collision.js":
/*!********************************!*\
  !*** ./src/utils/collision.js ***!
  \********************************/
/*! exports provided: triangleCollides */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "triangleCollides", function() { return triangleCollides; });
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometry */ "./src/utils/geometry.js");
/* harmony import */ var lineclip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lineclip */ "./node_modules/lineclip/index.js");
/* harmony import */ var lineclip__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lineclip__WEBPACK_IMPORTED_MODULE_1__);



const SEPARATING_LINE_FOUND = 'separatingLineFound';
const SEPARATING_LINE_NOT_FOUND = 'separatingLineNotFound';

function triangleCollides (triangle, viewportAABB) {
    if (_noArea(triangle)) {
        return _noAreaTriangleCollides(triangle, viewportAABB);
    }

    /*
     * TODO
     *
     * Optimize triangle collision:
     *
     * if (_isAnyTriangleVertexInViewport(triangle, viewportAABB)) {
     *   return true;
     * }
     *
     * if (_isAnyViewportVertexInTriangle(triangle, viewport)) {
     *   return true;
     * }
     */

    if (_viewportLineSeparatesTriangle(viewportAABB, triangle) === SEPARATING_LINE_FOUND) {
        return false;
    }

    const viewport = [
        { x: viewportAABB.minx, y: viewportAABB.miny },
        { x: viewportAABB.minx, y: viewportAABB.maxy },
        { x: viewportAABB.maxx, y: viewportAABB.miny },
        { x: viewportAABB.maxx, y: viewportAABB.maxy }
    ];
    if (_triangleLineSeparatesViewport(triangle, viewport) === SEPARATING_LINE_FOUND) {
        return false;
    }

    return true;
}

/**
 * When dealing with some triangles (such as line's triangles), repeated vertices are generated.
 * Those are not strictly triangles, as they don't have any area.
 */
function _noArea (triangle) {
    const [v1, v2, v3] = triangle;
    return (Object(_geometry__WEBPACK_IMPORTED_MODULE_0__["equalPoints"])(v1, v2) || Object(_geometry__WEBPACK_IMPORTED_MODULE_0__["equalPoints"])(v2, v3));
}

/**
 * Calculates the collision for the special case of a no area triangle.
 * Having 2 repeated vertices, the triangle can be simplified to a line and calculate the collision using `lineclip`.
 * This algorithm also solves the issue when line vertices are completely outside the viewport and the
 * line wasn't considered an intersecting one (by the 'separating line' algorithm).
 */
function _noAreaTriangleCollides (triangle, viewportAABB) {
    const [v1, v2, v3] = triangle;
    const a = v1;
    const b = Object(_geometry__WEBPACK_IMPORTED_MODULE_0__["equalPoints"])(v2, a) ? v3 : v2;
    const bbox = [viewportAABB.minx, viewportAABB.miny, viewportAABB.maxx, viewportAABB.maxy];
    const collides = lineclip__WEBPACK_IMPORTED_MODULE_1__([[a.x, a.y], [b.x, b.y]], bbox);
    return (collides.length > 0);
}

/*
 * TODO
 *
 * Optimize triangle collision:
 *
 * function _isAnyViewportVertexInTriangle (triangle, viewport) {
 *     for (let i = 0; i < viewport.length; i++) {
 *         if (pointInTriangle(viewport[i], triangle[0], triangle[1], triangle[2])) {
 *             return true;
 *         }
 *     }
 *
 *     return false;
 * }
 * function _isAnyTriangleVertexInViewport (triangle, viewportAABB) {
 *  for (let i = 0; i < 3; i++) {
 *       if (pointInRectangle(triangle[i], viewportAABB)) {
 *           return true;
 *       }
 *   }
 *   return false;
 * }
 */

function _viewportLineSeparatesTriangle (viewportAABB, triangle) {
    if (triangle[0].x < viewportAABB.minx &&
        triangle[1].x < viewportAABB.minx &&
        triangle[2].x < viewportAABB.minx) {
        return SEPARATING_LINE_FOUND;
    }

    if (triangle[0].y < viewportAABB.miny &&
        triangle[1].y < viewportAABB.miny &&
        triangle[2].y < viewportAABB.miny) {
        return SEPARATING_LINE_FOUND;
    }

    if (triangle[0].x > viewportAABB.maxx &&
        triangle[1].x > viewportAABB.maxx &&
        triangle[2].x > viewportAABB.maxx) {
        return SEPARATING_LINE_FOUND;
    }

    if (triangle[0].y > viewportAABB.maxy &&
        triangle[1].y > viewportAABB.maxy &&
        triangle[2].y > viewportAABB.maxy) {
        return SEPARATING_LINE_FOUND;
    }

    return SEPARATING_LINE_NOT_FOUND;
}

function _triangleLineSeparatesViewport (triangle, viewport) {
    const TRIANGLE_VERTICES = 3;

    for (let i = 0; i < TRIANGLE_VERTICES; i++) {
        for (let j = 0; j < viewport.length; j++) {
            const position = Object(_geometry__WEBPACK_IMPORTED_MODULE_0__["halfPlaneSign"])(viewport[j], triangle[i], triangle[(i + 1) % TRIANGLE_VERTICES]);

            if (position > 0) {
                break;
            }

            if (j === TRIANGLE_VERTICES) {
                return SEPARATING_LINE_FOUND;
            }
        }
    }

    return SEPARATING_LINE_NOT_FOUND;
}


/***/ }),

/***/ "./src/utils/events.js":
/*!*****************************!*\
  !*** ./src/utils/events.js ***!
  \*****************************/
/*! exports provided: on, off */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "on", function() { return on; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "off", function() { return off; });
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");


let registeredHandlers = [];

/**
 * Register an event handler for the given event name and for the given list of layers. Valid names are: `loaded`, `updated`.
 *
 * The 'loaded' event will be fired when all the layers are loaded (and their 'loaded' events are fired).
 *
 * The 'updated' event will be fired whenever one of the layers fired an 'updated' event,
 * but throttled by requestAnimationFrame to return a maximum of one event per frame.
 *
 * @param {String} eventName - Supported event names are 'loaded' and 'updated'
 * @param {carto.Layer[]} layerList - List of layers
 *
 * @memberof carto
 * @api
 */
function on (eventName, layerList, callback) {
    let internalCallbacks = [];
    if (eventName === 'loaded') {
        const waitingGroup = new Set(layerList);
        layerList.forEach(layer => {
            const internalCallback = () => {
                waitingGroup.delete(layer);
                if (waitingGroup.size === 0) {
                    callback();
                }
            };
            layer.on('loaded', internalCallback);
            internalCallbacks.push(internalCallback);
        });
    } else if (eventName === 'updated') {
        let scheduledRAF = false;
        layerList.forEach(layer => {
            const internalCallback = () => {
                if (!scheduledRAF) {
                    window.requestAnimationFrame(() => {
                        scheduledRAF = false;
                        callback();
                    });
                }
            };
            layer.on('updated', internalCallback);
            internalCallbacks.push(internalCallback);
        });
    } else {
        throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_0__["default"](
            `Event name '${eventName}' is not supported by "carto.on". Supported event names are: 'loaded' and 'updated'.`,
            _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_0__["CartoValidationErrorTypes"].INCORRECT_VALUE
        );
    }
    registeredHandlers.push({
        eventName,
        layerList,
        callback,
        internalCallbacks
    });
}

/**
* Remove an event handler for the given event name, layer list and callback.
*
* @param {String} eventName - event
* @param {carto.Layer} layerList - List of layers
* @param {function} callback - Handler function to unregister
*
* @memberof carto
* @api
*/
function off (eventName, layerList, callback) {
    registeredHandlers.forEach(register => {
        if (register.eventName === eventName &&
            register.layerList.every(registeredLayer => layerList.includes(registeredLayer)) &&
            register.callback === callback) {
            register.layerList.forEach(layer => {
                register.internalCallbacks.forEach(internalCallback => {
                    layer.off(eventName, internalCallback);
                });
            });
        }
    });
    registeredHandlers = registeredHandlers.filter(register =>
        !(
            register.eventName === eventName &&
            register.layerList.every(registeredLayer => layerList.includes(registeredLayer)) &&
            register.callback === callback
        )
    );
}


/***/ }),

/***/ "./src/utils/geometry.js":
/*!*******************************!*\
  !*** ./src/utils/geometry.js ***!
  \*******************************/
/*! exports provided: GEOMETRY_TYPE, intersect, sub, dot, perpendicular, getLineNormal, getJoinNormal, neg, pointInTriangle, halfPlaneSign, equalPoints, pointInCircle, pointInRectangle, computeAABB, computeCentroids, triangleArea, unproject, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GEOMETRY_TYPE", function() { return GEOMETRY_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "intersect", function() { return intersect; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perpendicular", function() { return perpendicular; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getLineNormal", function() { return getLineNormal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getJoinNormal", function() { return getJoinNormal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "neg", function() { return neg; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointInTriangle", function() { return pointInTriangle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "halfPlaneSign", function() { return halfPlaneSign; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equalPoints", function() { return equalPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointInCircle", function() { return pointInCircle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pointInRectangle", function() { return pointInRectangle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeAABB", function() { return computeAABB; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeCentroids", function() { return computeCentroids; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "triangleArea", function() { return triangleArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unproject", function() { return unproject; });
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/lib/gl-matrix.js");
/* harmony import */ var _renderer_viz_expressions_stats__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../renderer/viz/expressions/stats */ "./src/renderer/viz/expressions/stats.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");




const GEOMETRY_TYPE = {
    UNKNOWN: 'unknown',
    POINT: 'point',
    LINE: 'line',
    POLYGON: 'polygon'
};

// If AB intersects CD => return intersection point
// Intersection method from Real Time Rendering, Third Edition, page 780
function intersect (a, b, c, d) {
    const o1 = a;
    const o2 = c;
    const d1 = sub(b, a);
    const d2 = sub(d, c);
    const d1t = perpendicular(d1);
    const d2t = perpendicular(d2);

    const s = dot(sub(o2, o1), d2t) / dot(d1, d2t);
    const t = dot(sub(o1, o2), d1t) / dot(d2, d1t);

    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
        return [o1[0] + s * d1[0], o1[1] + s * d1[1]];
    }
}

function sub ([ax, ay], [bx, by]) {
    return ([ax - bx, ay - by]);
}

function dot ([ax, ay], [bx, by]) {
    return (ax * bx + ay * by);
}

function perpendicular ([x, y]) {
    return [-y, x];
}

/**
 * Compute the normal of a line AB.
 * By definition it is the unitary vector from B to A, rotated +90 degrees counter-clockwise
 */
function getLineNormal (a, b) {
    const u = normalize(a[0] - b[0], a[1] - b[1]);
    return [-u[1], u[0]];
}

/**
 * Compute the normal of the join from the lines' normals.
 * By definition this is the sum of the unitary vectors `u` (from B to A) and `v` (from B to C)
 * multiplied by a factor of `1/sin(theta)` to reach the intersection of the wide lines.
 * Theta is the angle between the vectors `v` and `u`. But instead of computing the angle,
 * the `sin(theta)` (with sign) is obtained directly from the vectorial product of `v` and `u`
 */
function getJoinNormal (prevNormal, nextNormal) {
    const u = [prevNormal[1], -prevNormal[0]];
    const v = [-nextNormal[1], nextNormal[0]];
    const sin = v[0] * u[1] - v[1] * u[0];
    const cos = v[0] * u[0] + v[1] * u[1];
    const factor = Math.abs(sin);
    const miterJoin = !(factor < 0.866 && cos > 0.5); // 60 deg
    return {
        turnLeft: sin > 0,
        joinNormal: miterJoin && neg([
            (u[0] + v[0]) / factor,
            (u[1] + v[1]) / factor
        ])
    };
}

/**
 * Return the negative of the provided vector
 */
function neg (v) {
    return [-v[0], -v[1]];
}

/**
 * Return the vector scaled to length 1
 */
function normalize (x, y) {
    const s = Math.hypot(x, y);
    return [x / s, y / s];
}

// Returns true if p is inside the triangle or on a triangle's edge, false otherwise
// Parameters in {x: 0, y:0} form
function pointInTriangle (p, v1, v2, v3) {
    // https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle
    // contains an explanation of both this algorithm and one based on barycentric coordinates,
    // which could be faster, but, nevertheless, it is quite similar in terms of required arithmetic operations

    if (equalPoints(v1, v2) || equalPoints(v2, v3) || equalPoints(v3, v1)) {
        // Avoid zero area triangle
        return false;
    }

    // A point is inside a triangle or in one of the triangles edges
    // if the point is in the three half-plane defined by the 3 edges
    const b1 = halfPlaneSign(p, v1, v2) < 0;
    const b2 = halfPlaneSign(p, v2, v3) < 0;
    const b3 = halfPlaneSign(p, v3, v1) < 0;

    return (b1 === b2) && (b2 === b3);
}

// Tests if a point `p` is in the half plane defined by the line with points `a` and `b`
// Returns a negative number if the result is INSIDE, returns 0 if the result is ON_LINE,
// returns >0 if the point is OUTSIDE
// Parameters in {x: 0, y:0} form
function halfPlaneSign (p, a, b) {
    // We use the cross product of `PB x AB` to get `sin(angle(PB, AB))`
    // The result's sign is the half plane test result
    return (p.x - b.x) * (a.y - b.y) - (a.x - b.x) * (p.y - b.y);
}

function equalPoints (a, b) {
    return (a.x === b.x) && (a.y === b.y);
}

function pointInCircle (p, center, radius) {
    const diff = {
        x: p.x - center.x,
        y: p.y - center.y
    };
    const lengthSquared = diff.x * diff.x + diff.y * diff.y;
    return lengthSquared <= radius * radius;
}

function pointInRectangle (point, bbox) {
    if (bbox === null) {
        return false;
    }
    const p = {
        x: point.x.toFixed(2),
        y: point.y.toFixed(2)
    };

    return ((bbox.minx <= p.x) && (p.x <= bbox.maxx) && (bbox.miny <= p.y) && (p.y <= bbox.maxy));
}

/**
 * Axis-Aligned Bounding Box (AABB). This creates a wrapping box around the geometry, without rotation.
 * This allows the use of a common technique to detect collision between features (using their corresponding AABBs).
 */
function computeAABB (geometry, type) {
    switch (type) {
        case GEOMETRY_TYPE.POINT:
            return [];
        case GEOMETRY_TYPE.LINE:
        case GEOMETRY_TYPE.POLYGON:
            const aabbList = [];

            for (let i = 0; i < geometry.length; i++) {
                const feature = geometry[i];

                let aabb = {
                    minx: Number.POSITIVE_INFINITY,
                    miny: Number.POSITIVE_INFINITY,
                    maxx: Number.NEGATIVE_INFINITY,
                    maxy: Number.NEGATIVE_INFINITY
                };

                for (let j = 0; j < feature.length; j++) {
                    aabb = _updateAABBForGeometry(feature[j], aabb, type);
                }

                if (aabb.minx === Number.POSITIVE_INFINITY) {
                    aabb = null;
                }

                aabbList.push(aabb);
            }

            return aabbList;
    }
}

function computeCentroids (decodedGeometry, type) {
    switch (type) {
        case GEOMETRY_TYPE.POINT:
            return _computeCentroidsForPoints(decodedGeometry);
        case GEOMETRY_TYPE.LINE:
        case GEOMETRY_TYPE.POLYGON:
            return _computeCentroidsForLinesOrPolygons(decodedGeometry, type);
        default:
            throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["default"](
                'Invalid type argument, decoded geometry must have a point, line or polygon type.',
                _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_2__["CartoValidationErrorTypes"].INCORRECT_VALUE
            );
    }
}

function _computeCentroidsForPoints (decodedGeometry) {
    const centroids = [];

    // 'Compute' centroids for points is just getting one exemplar from the 3 repeated points
    const STEP = 6;
    for (let i = 0; i < decodedGeometry.vertices.length / STEP; i++) {
        const start = i * STEP;
        const end = start + STEP;
        const [, , , , x, y] = decodedGeometry.vertices.slice(start, end);
        centroids.push({ x, y });
    }
    return centroids;
}

function _computeCentroidsForLinesOrPolygons (decodedGeometry, type) {
    const centroids = [];

    let startVertex = 0;
    decodedGeometry.breakpoints.forEach((breakpoint) => {
        const vertices = decodedGeometry.vertices.slice(startVertex, breakpoint);
        let centroid = null;
        if (type === GEOMETRY_TYPE.LINE) {
            centroid = _centroidForLines(vertices);
        } else {
            centroid = _centroidForPolygons(vertices);
        }
        centroids.push(centroid);
        startVertex = breakpoint;
    });

    return centroids;
}

function _centroidForLines (vertices) {
    // Triangles don't have any area in this case, so just average coordinates are calculated
    const Xs = [];
    const Ys = [];
    const STEP = 6;
    for (let i = 0; i < vertices.length / STEP; i++) {
        const start = i * STEP;
        const end = start + STEP;
        const [xA, yA, xB, yB, xC, yC] = vertices.slice(start, end);

        const AequalB = (xA === xB && yA === yB);
        const BequalC = (xB === xC && yB === yC);

        if (AequalB && BequalC) {
            continue; // spurious triangles (useful for rendering strokes with normals, not here)
        }

        const firstPoint = [xA, yA];
        const secondPoint = !AequalB ? [xB, yB] : [xC, yC];

        Xs.push(firstPoint[0]);
        Xs.push(secondPoint[0]);

        Ys.push(firstPoint[1]);
        Ys.push(secondPoint[1]);
    }

    let centroid = {
        x: Object(_renderer_viz_expressions_stats__WEBPACK_IMPORTED_MODULE_1__["average"])(Xs),
        y: Object(_renderer_viz_expressions_stats__WEBPACK_IMPORTED_MODULE_1__["average"])(Ys)
    };
    return centroid;
}

function _centroidForPolygons (vertices) {
    // Triangles average coordinates, ponderated by their area
    const weightedXs = [];
    const weightedYs = [];
    const areas = [];

    const STEP = 6;
    for (let i = 0; i < vertices.length / STEP; i++) {
        const start = i * STEP;
        const end = start + STEP;
        const [xA, yA, xB, yB, xC, yC] = vertices.slice(start, end);
        const triangle = [[xA, yA], [xB, yB], [xC, yC]];
        const area = triangleArea(triangle);
        if (area > 0) {
            const averageX = Object(_renderer_viz_expressions_stats__WEBPACK_IMPORTED_MODULE_1__["average"])([xA, xB, xC]);
            const averageY = Object(_renderer_viz_expressions_stats__WEBPACK_IMPORTED_MODULE_1__["average"])([yA, yB, yC]);

            weightedXs.push(averageX * area);
            weightedYs.push(averageY * area);
            areas.push(area);
        }
    }
    const totalWeight = _sumArray(areas);

    let centroid = {
        x: _sumArray(weightedXs) / totalWeight,
        y: _sumArray(weightedYs) / totalWeight
    };
    return centroid;
}

function _sumArray (array) {
    return array.reduce((p, c) => p + c, 0);
}

/*
* Calculate the area of a triangle using its coordinates.
* From https://en.wikipedia.org/wiki/Triangle#Computing_the_area_of_a_triangle
*/
function triangleArea (threeVerticesArray) {
    let [xA, yA] = threeVerticesArray[0];
    let [xB, yB] = threeVerticesArray[1];
    let [xC, yC] = threeVerticesArray[2];

    const area = Math.abs((xA - xC) * (yB - yA) - (xA - xB) * (yC - yA)) / 2.0;
    return area;
}

// Compute the WebMercator position at projected (x,y) NDC (Normalized Device Coordinates) reversing the projection of the point
function unproject (inv, x, y) {
    // To unproject a point we need the 3 coordinates (x,y,z)
    // The `z` coordinate can be computed by knowing that the unprojected `z` is equal to `0` (since the map is a 2D plane)
    // defined at `z=0`

    // Since a matrix-vector multiplication is a linear transform we know that
    //      z = m * projectedZ + k
    // Being `m` and `k` constants for a particular value of projected `x` and `y` coordinates

    // With that equation and the inverse matrix of the projection we can establish an equation system of the form:
    //      v1 = m * v2 + k
    //      v3 = m * v4 + k
    // Where `v2` and `v4` can be arbitrary values (but not equal to each other) and
    // `v1` and `v3` can be computed by using the inverse matrix knowing that:
    //      (_, _, v1,_) = inverse(projectionMatrix) * (projectedX, projectedY, v2, 1)
    //      (_, _, v3,_) = inverse(projectionMatrix) * (projectedX, projectedY, v4, 1)

    // By resolving the the equation system above computing `m` and `k` values
    // we can compute the projected Z coordinate at the (x,y) NDC (projected) point

    // With (projectedX, projectedY, projectedZ) we can compute the unprojected point by multiplying by the inverse matrix

    // *** Implementation ***

    // compute m, k for: [z = m*projectedZ + k]
    const v2 = 1;
    const v4 = 2;

    const v1 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].transformMat4([], [x, y, v2, 1], inv)[2];
    const v3 = gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].transformMat4([], [x, y, v4, 1], inv)[2];

    // Solve the equation system by using the elimination method (subtraction of the equations)
    //      (v1-v3) = (v2-v4)*m
    //      m = (v1 - v3) / (v2 - v4)
    const m = (v1 - v3) / (v2 - v4);
    // Substituting in the first equation `m` and solving for `k`
    const k = v1 - m * v2;

    // compute projectedZ by solving `z = m * projectedZ + k` knwoing `z`, `m` and `k`
    const projectedZ = -k / m;

    // Inverse the projection and normalize by `p.w`
    return gl_matrix__WEBPACK_IMPORTED_MODULE_0__["vec4"].transformMat4([], [x, y, projectedZ, 1], inv).map((v, _, point) => v / point[3]);
}

function _updateAABBForGeometry (feature, aabb, geometryType) {
    switch (geometryType) {
        case GEOMETRY_TYPE.LINE:
            return _updateAABBLine(feature, aabb);
        case GEOMETRY_TYPE.POLYGON:
            return _updateAABBPolygon(feature, aabb);
    }
}

function _updateAABBLine (line, aabb) {
    const vertices = line;
    const numVertices = line.length;

    for (let i = 0; i < numVertices; i += 2) {
        aabb.minx = Math.min(aabb.minx, vertices[i + 0]);
        aabb.miny = Math.min(aabb.miny, vertices[i + 1]);
        aabb.maxx = Math.max(aabb.maxx, vertices[i + 0]);
        aabb.maxy = Math.max(aabb.maxy, vertices[i + 1]);
    }

    return aabb;
}

function _updateAABBPolygon (polygon, aabb) {
    const [vertices, numVertices] = [polygon.flat, polygon.holes[0] || polygon.flat.length / 2];

    for (let i = 0; i < numVertices; i++) {
        aabb.minx = Math.min(aabb.minx, vertices[2 * i + 0]);
        aabb.miny = Math.min(aabb.miny, vertices[2 * i + 1]);
        aabb.maxx = Math.max(aabb.maxx, vertices[2 * i + 0]);
        aabb.maxy = Math.max(aabb.maxy, vertices[2 * i + 1]);
    }

    return aabb;
}

/* harmony default export */ __webpack_exports__["default"] = ({
    intersect,
    sub,
    dot,
    perpendicular,
    getLineNormal,
    getJoinNormal,
    neg,
    halfPlaneSign,
    pointInTriangle,
    equalPoints,
    pointInCircle,
    pointInRectangle
});


/***/ }),

/***/ "./src/utils/time/TimeRange.js":
/*!*************************************!*\
  !*** ./src/utils/time/TimeRange.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TimeRange; });
/* harmony import */ var _periodISO__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./periodISO */ "./src/utils/time/periodISO.js");
/* harmony import */ var _parseISO__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parseISO */ "./src/utils/time/parseISO.js");
/* harmony import */ var _TimeZoneDate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TimeZoneDate */ "./src/utils/time/TimeZoneDate.js");




/**
 * Class TimeRange represents an interval of time between to instants.
 *
 * Only single unit-of-time intervals such as a calender year, month, day, hour, etc.
 * are supported, arbitrary intervals are not.
 *
 * A TimeRange can be defined and accessed either by its start and end instants
 * or by an abbreviated ISO-formatted textual representation.
 * For the text format, since general intervals are not supported, the ISO interval
 * format is not used, but simply the abbreviated form of the time unit.
 * For example, to represent March 2018, `2018-03` is used instead of the
 * ISO-formatted interval `018-03-01T00:00:00/2018-04-01T00:00:00`.
 *
 * A TimeRange includes its start instant and excludes the end instant:
 * it represents the semi-open interval start <= t < end.
 *
 * @param {String} timezone - Time zone of the range; informational only.
 * @param {String} text - text representation of the range
 * @param {Number} startValue - start of the range as elapsed milliseconds since a timezone-specific epoch
 * @param {Number} endValue - end of the range as elapsed milliseconds since a timezone-specific epoch
 *
 * @constructor Layer
 * @name carto.TimeRange
 * @api
 * */
class TimeRange {
    constructor (timeZone, iso, startValue, endValue) {
        this._startValue = startValue;
        this._endValue = endValue;

        if (startValue && endValue) {
            this._iso = Object(_periodISO__WEBPACK_IMPORTED_MODULE_0__["default"])(startValue, endValue);
        } else if (!startValue && !endValue && iso) {
            const startEndValues = _startEndTimeValues(iso);

            this._iso = iso;
            this._startValue = startEndValues[0];
            this._endValue = startEndValues[1];
        }

        // The timezone of a TimeRange is merely informative.
        // No time zone conversion is ever performed, e.g. when
        // several ranges are used in the same linear expression.
        // In same cases (e.g. defining a time range from a text constant)
        // it may not be available.
        this._timeZone = timeZone;
    }

    get timeZone () {
        return this._timeZone;
    }

    get iso () {
        return this._iso;
    }

    get startValue () {
        return this._startValue;
    }

    get endValue () {
        return this._endValue;
    }

    get startDate () {
        return _TimeZoneDate__WEBPACK_IMPORTED_MODULE_2__["default"].fromValue(this._startValue, this._timeZone);
    }

    get endDate () {
        return _TimeZoneDate__WEBPACK_IMPORTED_MODULE_2__["default"].fromValue(this._endValue, this._timeZone);
    }
}

function _timeValue (parsed) {
    return Date.UTC(
        parsed.year,
        parsed.month - 1,
        parsed.day,
        parsed.hour,
        parsed.minute,
        parsed.second
    );
}

function _startEndTimeValues (iso) {
    return Object(_parseISO__WEBPACK_IMPORTED_MODULE_1__["default"])(iso).map(_timeValue);
}


/***/ }),

/***/ "./src/utils/time/TimeZoneDate.js":
/*!****************************************!*\
  !*** ./src/utils/time/TimeZoneDate.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TimeZoneDate; });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./src/utils/util.js");
/* harmony import */ var _periodISO__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./periodISO */ "./src/utils/time/periodISO.js");



// Time-zone neutral date
// TODO: name: TimeZoneLessDate, NeutralDate, DateWithoutTimeZone, ...
// it has an optional informational time zone string to declare the
// original TZ
// The idea is that this represent a date, just like a Date object,
// but in relation ot some externally defined time zone
// (the time zone specified in a clusterTime expression),
// so we want to avoid the time zone handling that Date does.
// (this dates cannot be converted from the tz they're specified in,
// not even to UTC)
class TimeZoneDate {
    constructor (milliseconds, tz) {
        this._value = milliseconds;
        this._date = Object(_util__WEBPACK_IMPORTED_MODULE_0__["msToDate"])(milliseconds);
        this._timeZone = tz; // informational
    }

    static fromValue (milliseconds, tz) {
        return new TimeZoneDate(milliseconds, tz);
    }

    static from (year, month, day, hour, minute, second, tz) {
        return this.fromValue(Date.UTC(year, (month || 1) - 1, day, hour, minute, second), tz);
    }

    get year () {
        return this._date.getUTCFullYear();
    }
    get month () {
        return this._date.getUTCMonth() + 1;
    }
    get day () {
        return this._date.getUTCDate();
    }
    get hour () {
        return this._date.getUTCHours();
    }
    get minute () {
        return this._date.getUTCMinutes();
    }
    get second () {
        return this._date.getUTCSeconds();
    }
    get text () {
        return Object(_periodISO__WEBPACK_IMPORTED_MODULE_1__["default"])(this._date.getTime(), this._date.getTime() + 1000);
    }
    get timeZone () {
        return this._timeZone;
    }
}


/***/ }),

/***/ "./src/utils/time/parseISO.js":
/*!************************************!*\
  !*** ./src/utils/time/parseISO.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseISO; });
/* harmony import */ var _errors_carto_parsing_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../errors/carto-parsing-error */ "./src/errors/carto-parsing-error.js");


class IsoParser {
    constructor (format) {
        this._format = format;
    }
    check (iso) {
        return iso.match(this._format);
    }
}

function fieldDefault (value, defaultValue) {
    return (value === undefined) ? defaultValue : Number(value);
}

function dateFields (fields) {
    return {
        year: fieldDefault(fields.year, 1),
        month: fieldDefault(fields.month, 1),
        day: fieldDefault(fields.day, 1),
        hour: fieldDefault(fields.hour, 0),
        minute: fieldDefault(fields.minute, 0),
        second: fieldDefault(fields.second, 0)
    };
}

function fieldsFromMatch (match) {
    return dateFields({
        year: match[1],
        month: match[2],
        day: match[3],
        hour: match[4],
        minute: match[5],
        second: match[6]
    });
}

class YMDHMSParser extends IsoParser {
    constructor () {
        super(/^(\d\d\d\d)(?:\-?(\d\d)(?:\-?(\d\d)(?:[T\s]?(\d\d)(?:\:(\d\d)(?:\:(\d\d))?)?)?)?)?$/);
    }
    parse (iso) {
        const start = this.check(iso) || [];
        const end = start.slice();
        const i = [1, 2, 3, 4, 5, 6].find(i => end[i] === undefined) || 7;
        if (i === 1) {
            end[1] = 2;
        } else {
            end[i - 1] = Number(end[i - 1]) + 1;
        }
        return [ fieldsFromMatch(start), fieldsFromMatch(end) ];
    }
}

class MillenniumParser extends IsoParser {
    constructor () {
        super(/^M(\d+)$/);
    }
    parse (iso) {
        const match = this.check(iso);
        const m = Number(match[1]);
        const year = m => (m - 1) * 1000 + 1;
        return [
            dateFields({ year: year(m) }),
            dateFields({ year: year(m + 1) })
        ];
    }
}

class CenturyParser extends IsoParser {
    constructor () {
        super(/^C(\d+)$/);
    }
    parse (iso) {
        const match = this.check(iso);
        const c = Number(match[1]);
        const year = c => (c - 1) * 100 + 1;
        return [
            dateFields({ year: year(c) }),
            dateFields({ year: year(c + 1) })
        ];
    }
}

class DecadeParser extends IsoParser {
    constructor () {
        super(/^D(\d+)$/);
    }
    parse (iso) {
        const match = this.check(iso);
        const d = Number(match[1]);
        const year = d => d * 10;
        return [
            dateFields({ year: year(d) }),
            dateFields({ year: year(d + 1) })
        ];
    }
}

class SemesterParser extends IsoParser {
    constructor () {
        super(/^(\d\d\d\d)S(\d)$/);
    }
    parse (iso) {
        const match = this.check(iso);
        const year = Number(match[1]);
        const s = Number(match[2]);
        const month = s => (s - 1) * 6 + 1;
        return [
            dateFields({ year, month: month(s) }),
            dateFields({ year, month: month(s + 1) })
        ];
    }
}

class TrimesterParser extends IsoParser {
    constructor () {
        super(/^(\d\d\d\d)t(\d)$/);
    }
    parse (iso) {
        const match = this.check(iso);
        const year = Number(match[1]);
        const t = Number(match[2]);
        const month = t => (t - 1) * 4 + 1;
        return [
            dateFields({ year, month: month(t) }),
            dateFields({ year, month: month(t + 1) })
        ];
    }
}

class QuarterParser extends IsoParser {
    constructor () {
        super(/^(\d\d\d\d)\-?Q(\d)$/);
    }
    parse (iso) {
        const match = this.check(iso);
        const year = Number(match[1]);
        const q = Number(match[2]);
        const month = q => (q - 1) * 3 + 1;
        return [
            dateFields({ year, month: month(q) }),
            dateFields({ year, month: month(q + 1) })
        ];
    }
}

function isoDow (y, m, d) {
    const dow = (new Date(y, m - 1, d)).getDay();
    return dow === 0 ? 7 : dow;
}

function addDays (date, days) {
    const newDate = new Date(date.valueOf());
    newDate.setDate(newDate.getDate() + days);
    return newDate;
}

// compute start date of yWw
function startOfIsoWeek (y, w) {
    const dow = isoDow(y, 1, 1);
    const startDay = dow > 4 ? 9 - dow : 2 - dow;
    const startDate = new Date(y, 0, startDay);
    return addDays(startDate, (w - 1) * 7);
}

class WeekParser extends IsoParser {
    constructor () {
        super(/^(\d\d\d\d)\-?W(\d\d)$/);
    }
    parse (iso) {
        const match = this.check(iso);
        const year = Number(match[1]);
        const week = Number(match[2]);
        const start = startOfIsoWeek(year, week);
        const end = startOfIsoWeek(year, week + 1);
        const fields = date => ({
            year: date.getFullYear(),
            month: date.getMonth() + 1,
            day: date.getDate()
        });
        return [
            dateFields(fields(start)),
            dateFields(fields(end))
        ];
    }
}

const isoFormats = [
    new MillenniumParser(),
    new CenturyParser(),
    new DecadeParser(),
    new SemesterParser(),
    new TrimesterParser(),
    new QuarterParser(),
    new WeekParser(),
    new YMDHMSParser()
];

function findParser (iso) {
    return isoFormats.find(parser => parser.check(iso));
}

function parseISO (iso) {
    iso = iso || '';
    const parser = findParser(iso);
    if (!parser) {
        throw new _errors_carto_parsing_error__WEBPACK_IMPORTED_MODULE_0__["default"](`No date parser found for ${iso}`);
    }
    return parser.parse(iso);
}


/***/ }),

/***/ "./src/utils/time/periodISO.js":
/*!*************************************!*\
  !*** ./src/utils/time/periodISO.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return periodISO; });
/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util */ "./src/utils/util.js");


const TIME_LEVELS = ['year', 'month', 'day', 'hour', 'minute', 'second'];
const TIME_STARTS = [1, 1, 1, 0, 0, 0];
const YEAR_LEVEL = 0;
const MONTH_LEVEL = 1;
const DAY_LEVEL = 2;
const HOUR_LEVEL = 3;
const MINUTE_LEVEL = 4;
const SECOND_LEVEL = 5;

const MS_PER_DAY = 86400000;
const MS_PER_HOUR = 3600000;
const MS_PER_MINUTE = 60000;
const MS_PER_S = 1000;

function startLevel (parsed) {
    let i = TIME_LEVELS.length - 1;
    while (i > 0 && parsed[TIME_LEVELS[i]] === TIME_STARTS[i]) {
        --i;
    }
    return i;
}

function pad (x, n) {
    return x.toString().padStart(n, '0');
}

function parsedValue (dateValue) {
    const date = Object(_util__WEBPACK_IMPORTED_MODULE_0__["msToDate"])(dateValue);
    return {
        year: date.getUTCFullYear(),
        month: date.getUTCMonth() + 1,
        day: date.getUTCDate(),
        hour: date.getUTCHours(),
        minute: date.getUTCMinutes(),
        second: date.getUTCSeconds()
    };
}

function isoDow (y, m, d) {
    const dow = (new Date(y, m - 1, d)).getDay();
    return dow === 0 ? 7 : dow;
}

function invalidPeriod (period, invalid) {
    throw new Error(`Invalid period of ${invalid} between ${period.v1} and ${period.v2}`);
}

// Return year and week number given year and day number
function yearWeek (y, yd) {
    const dow = isoDow(y, 1, 1);
    const start = dow > 4 ? 9 - dow : 2 - dow;
    if ((Math.abs(yd - start) % 7) !== 0) {
        // y yd is not the start of any week
        return [];
    }
    if (yd < start) {
        // The week starts before the first week of the year => go back one year
        yd += Math.round((Date.UTC(y, 0, 1) - Date.UTC(y - 1, 0, 1)) / MS_PER_DAY);
        return yearWeek(y - 1, yd);
    } else if (Date.UTC(y, 0, 1) + (yd - 1 + 3) * MS_PER_DAY >= Date.UTC(y + 1, 0, 1)) {
        // The Wednesday (start of week + 3) lies in the next year => advance one year
        yd -= Math.round((Date.UTC(y + 1, 0, 1) - Date.UTC(y, 0, 1)) / MS_PER_DAY);
        return yearWeek(y + 1, yd);
    }
    return [y, 1 + Math.round((yd - start) / 7)];
}

function yearsPeriod (period) {
    const d = period.t2['year'] - period.t1['year'];
    if (d === 1000 && ((period.t1['year'] - 1) % 1000) === 0) {
        // millennium
        return `M${1 + (period.t1['year'] - 1) / 1000}`;
    } else if (d === 100 && ((period.t1['year'] - 1) % 100) === 0) {
        // century
        return `C${1 + (period.t1['year'] - 1) / 100}`;
    } else if (d === 10 && (period.t1['year'] % 10) === 0) {
        // decade
        return `D${period.t1['year'] / 10}`;
    } else if (d === 1) {
        // year
        return pad(period.t1['year'], 4);
    } else {
        invalidPeriod(`${d} years`);
    }
}

function monthsPeriod (period) {
    const d = 12 * period.t2['year'] + period.t2['month'] - 12 * period.t1['year'] - period.t1['month'];
    if (d === 6 && ((period.t1['month'] - 1) % 6) === 0) {
        // semester
        return `${pad(period.t1['year'], 4)}S${1 + (period.t1['month'] - 1) / 6}`;
    } else if (d === 4) {
        // trimester
        return `${pad(period.t1['year'], 4)}t${1 + (period.t1['month'] - 1) / 4}`;
    } else if (d === 3) {
        // quarter
        return `${pad(period.t1['year'], 4)}-Q${1 + (period.t1['month'] - 1) / 3}`;
    } else if (d === 1) {
        // month
        return `${pad(period.t1['year'], 4)}-${pad(period.t1['month'], 2)}`;
    } else {
        invalidPeriod(`${d} months`);
    }
}

function daysPeriod (period) {
    const d = Math.round((period.v2 - period.v1) / MS_PER_DAY);
    if (d === 1) {
        // day
        return `${pad(period.t1['year'], 4)}-${pad(period.t1['month'], 2)}-${pad(period.t1['day'], 2)}`;
    } else if (d === 7) {
        // week
        let y = period.t1['year'];
        const v0 = Date.UTC(y, 0, 1);
        let yd = 1 + Math.round((period.v1 - v0) / MS_PER_DAY);
        const [iy, w] = yearWeek(y, yd);
        if (iy && w) {
            return `${pad(iy, 4)}-W${pad(w, 2)}`;
        }
        invalidPeriod('7 days');
    } else {
        invalidPeriod(`${d} days`);
    }
}

function hoursPeriod (period) {
    const d = Math.round((period.v2 - period.v1) / MS_PER_HOUR);
    if (d === 1) {
        // hour
        return `${pad(period.t1['year'], 4)}-${pad(period.t1['month'], 2)}-${pad(period.t1['day'], 2)}T${pad(period.t1['hour'], 2)}`;
    } else {
        invalidPeriod(`${d} hours`);
    }
}

function minutesPeriod (period) {
    const d = Math.round((period.v2 - period.v1) / MS_PER_MINUTE);
    if (d === 1) {
        // minute
        return `${pad(period.t1['year'], 4)}-${pad(period.t1['month'], 2)}-${pad(period.t1['day'], 2)}T${pad(period.t1['hour'], 2)}:${pad(period.t1['minute'], 2)}`;
    } else {
        invalidPeriod(`${d} minutes`);
    }
}

function secondsPeriod (period) {
    const d = Math.round((period.v2 - period.v1) / MS_PER_S);
    if (d === 1) {
        // second
        return `${pad(period.t1['year'], 4)}-${pad(period.t1['month'], 2)}-${pad(period.t1['day'], 2)}T${pad(period.t1['hour'], 2)}:${pad(period.t1['minute'], 2)}:${pad(period.t1['second'], 2)}`;
    } else {
        invalidPeriod(`${d} seconds`);
    }
}

function periodISO (v1, v2) {
    const t1 = parsedValue(v1);
    const t2 = parsedValue(v2);
    const l1 = startLevel(t1);
    const l2 = startLevel(t2);
    const period = { v1, v2, t1, t2 };

    if (Math.max(l1, l2) === YEAR_LEVEL) {
        return yearsPeriod(period);
    } else if (Math.max(l1, l2) === MONTH_LEVEL) {
        return monthsPeriod(period);
    } else if (Math.max(l1, l2) === DAY_LEVEL) {
        return daysPeriod(period);
    } else if (Math.max(l1, l2) === HOUR_LEVEL) {
        return hoursPeriod(period);
    } else if (Math.max(l1, l2) === MINUTE_LEVEL) {
        return minutesPeriod(period);
    } else if (Math.max(l1, l2) === SECOND_LEVEL) {
        return secondsPeriod(period);
    }
    invalidPeriod(period, 'fractional seconds');
}


/***/ }),

/***/ "./src/utils/util.js":
/*!***************************!*\
  !*** ./src/utils/util.js ***!
  \***************************/
/*! exports provided: WM_R, WM_2R, isUndefined, isString, isNumber, isObject, regExpThatContains, castDate, msToDate, isSetsEqual, equalArrays, projectToWebMercator, computeMatrixZoom, computeMatrixCenter, computeViewportFromCameraMatrix, default, castTimeRange, timeRange, isTimeRange */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WM_R", function() { return WM_R; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WM_2R", function() { return WM_2R; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isUndefined", function() { return isUndefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isString", function() { return isString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNumber", function() { return isNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return isObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "regExpThatContains", function() { return regExpThatContains; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "castDate", function() { return castDate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "msToDate", function() { return msToDate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSetsEqual", function() { return isSetsEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equalArrays", function() { return equalArrays; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projectToWebMercator", function() { return projectToWebMercator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeMatrixZoom", function() { return computeMatrixZoom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeMatrixCenter", function() { return computeMatrixCenter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeViewportFromCameraMatrix", function() { return computeViewportFromCameraMatrix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "castTimeRange", function() { return castTimeRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "timeRange", function() { return timeRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTimeRange", function() { return isTimeRange; });
/* harmony import */ var _time_TimeRange__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time/TimeRange */ "./src/utils/time/TimeRange.js");
/* harmony import */ var gl_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! gl-matrix */ "./node_modules/gl-matrix/lib/gl-matrix.js");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geometry */ "./src/utils/geometry.js");
/* harmony import */ var _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors/carto-validation-error */ "./src/errors/carto-validation-error.js");




/**
 * Export util functions
 */


const DEG2RAD = Math.PI / 180;
const EARTH_RADIUS = 6378137;
const WM_R = EARTH_RADIUS * Math.PI; // Webmercator *radius*: half length Earth's circumference
const WM_2R = WM_R * 2; // Webmercator coordinate range (Earth's circumference)

function isUndefined (value) {
    return value === undefined;
}

function isString (value) {
    return typeof value === 'string';
}

function isNumber (value) {
    return typeof value === 'number';
}

function isObject (value) {
    const type = typeof value;
    return value !== null && (type === 'object' || type === 'function');
}

function regExpThatContains (text) {
    const escaped = text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // in case it has special symbols
    return new RegExp(escaped);
}

/**
 * Transform the given parameter into a Date object.
 * When a number is given as a parameter is assumed to be a milliseconds epoch (UTC).
 * The result is a local Date.
 * @param {Date|number|string} date
 */
function castDate (date) {
    if (date instanceof Date) {
        return date;
    }

    if (typeof (date) === 'number') {
        return msToDate(date);
    }

    if (isString(date)) {
        return new Date(date);
    } else {
        throw new _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["default"](
            'Invalid Date type',
            _errors_carto_validation_error__WEBPACK_IMPORTED_MODULE_3__["CartoValidationErrorTypes"].INCORRECT_TYPE
        );
    }
}

function msToDate (msEpoch) {
    return new Date(msEpoch);
}

function isSetsEqual (a, b) {
    return a.size === b.size && [...a].every(value => b.has(value));
}

function equalArrays (a, b) {
    if (a && b && a.length === b.length) {
        for (let i = 0; i < a.length; i++) {
            if (a[i] !== b[i]) {
                return false;
            }
        }
        return true;
    }
}

function projectToWebMercator (latLng) {
    let lat = latLng.lat * DEG2RAD;
    let lng = latLng.lng * DEG2RAD;
    return {
        x: lng * EARTH_RADIUS,
        y: Math.log(Math.tan(lat / 2 + Math.PI / 4)) * EARTH_RADIUS
    };
}

function computeMatrixZoom (matrix) {
    // The matrix projects spherical mercator coordinates to gl coordinates
    return -(2 * matrix[15] / matrix[5]);
}

function computeMatrixCenter (matrix) {
    // The matrix projects spherical mercator coordinates to gl coordinates
    return {
        x: -(1 + 2 * matrix[12] / matrix[0]),
        y: +(1 + 2 * matrix[13] / matrix[5])
    };
}

function computeViewportFromCameraMatrix (matrix) {
    const inv = gl_matrix__WEBPACK_IMPORTED_MODULE_1__["mat4"].invert([], matrix);

    const corners = [
        [-1, -1],
        [-1, 1],
        [1, -1],
        [1, 1]
    ].map(NDC =>
        Object(_geometry__WEBPACK_IMPORTED_MODULE_2__["unproject"])(inv, ...NDC)
    ).map(c =>
        // Our API works on the [-1,1] range, convert from [0,1] range to  [-1, 1] range
        c.map(x => x * 2 - 1)
    );

    // Rotation no longer guarantees that corners[0] will be the minimum point of the AABB and corners[3] the maximum,
    // we need to compute the AABB min/max by iterating
    const min = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];
    const max = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
    corners.forEach(corner => {
        min[0] = Math.min(min[0], corner[0]);
        min[1] = Math.min(min[1], corner[1]);
        max[0] = Math.max(max[0], corner[0]);
        max[1] = Math.max(max[1], corner[1]);
    });

    // Our API flips the `y` coordinate, we need to convert the values accordingly
    min[1] = -min[1];
    max[1] = -max[1];
    const temp = min[1];
    min[1] = max[1];
    max[1] = temp;

    return [...min, ...max];
}

/* harmony default export */ __webpack_exports__["default"] = ({
    WM_R,
    WM_2R,
    isUndefined,
    isString,
    isNumber,
    isObject,
    castDate,
    isSetsEqual,
    equalArrays,
    projectToWebMercator,
    computeMatrixZoom,
    computeMatrixCenter,
    computeViewportFromCameraMatrix
});

function castTimeRange (value, timeZone = null) {
    if (value === undefined || isTimeRange(value)) {
        if (value && timeZone) {
            return timeRange({ iso: value._iso, timeZone });
        }
        return value;
    }

    if (typeof value === 'string') {
        return timeRange({ iso: value, timeZone });
    }
}

function timeRange (parameters) {
    const { start, end, iso, timeZone } = parameters;

    return new _time_TimeRange__WEBPACK_IMPORTED_MODULE_0__["default"](timeZone, iso, start, end);
}

function isTimeRange (t) {
    return t instanceof _time_TimeRange__WEBPACK_IMPORTED_MODULE_0__["default"];
}


/***/ })

/******/ });
});
//# sourceMappingURL=carto-vl.js.map