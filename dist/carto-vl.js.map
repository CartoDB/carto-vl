{"version":3,"sources":["webpack://carto/webpack/universalModuleDefinition","webpack://carto/webpack/bootstrap","webpack://carto/./node_modules/@mapbox/point-geometry/index.js","webpack://carto/./node_modules/@mapbox/vector-tile/index.js","webpack://carto/./node_modules/@mapbox/vector-tile/lib/vectortile.js","webpack://carto/./node_modules/@mapbox/vector-tile/lib/vectortilefeature.js","webpack://carto/./node_modules/@mapbox/vector-tile/lib/vectortilelayer.js","webpack://carto/./node_modules/cartocolor/cartocolor.js","webpack://carto/./node_modules/cartocolor/index.js","webpack://carto/./node_modules/colorbrewer/colorbrewer.js","webpack://carto/./node_modules/colorbrewer/index.js","webpack://carto/./node_modules/earcut/src/earcut.js","webpack://carto/./node_modules/ieee754/index.js","webpack://carto/./node_modules/inherits/inherits_browser.js","webpack://carto/./node_modules/jsep/build/jsep.js","webpack://carto/./node_modules/lru-cache/index.js","webpack://carto/./node_modules/lru-cache/node_modules/yallist/yallist.js","webpack://carto/./node_modules/mitt/dist/mitt.es.js","webpack://carto/./node_modules/pbf/index.js","webpack://carto/./node_modules/process/browser.js","webpack://carto/./node_modules/pseudomap/map.js","webpack://carto/./node_modules/pseudomap/pseudomap.js","webpack://carto/./node_modules/util/support/isBufferBrowser.js","webpack://carto/./node_modules/util/util.js","webpack://carto/(webpack)/buildin/global.js","webpack://carto/./src/Layer.js","webpack://carto/./src/Viz.js","webpack://carto/./src/apiUtils.js","webpack://carto/./src/client/mvt/feature-decoder.js","webpack://carto/./src/client/rsys.js","webpack://carto/./src/client/windshaft-filtering.js","webpack://carto/./src/client/windshaft.js","webpack://carto/./src/constants/layer.js","webpack://carto/./src/errors/carto-error.js","webpack://carto/./src/errors/carto-validation-error.js","webpack://carto/./src/errors/error-list.js","webpack://carto/./src/index.js","webpack://carto/./src/integrator/Map.js","webpack://carto/./src/integrator/carto.js","webpack://carto/./src/integrator/mapbox-gl.js","webpack://carto/./src/interactivity/Interactivity.js","webpack://carto/./src/interactivity/feature.js","webpack://carto/./src/interactivity/featureVizProperty.js","webpack://carto/./src/renderer/Dataframe.js","webpack://carto/./src/renderer/Metadata.js","webpack://carto/./src/renderer/RenderLayer.js","webpack://carto/./src/renderer/Renderer.js","webpack://carto/./src/renderer/decoder/index.js","webpack://carto/./src/renderer/decoder/lineDecoder.js","webpack://carto/./src/renderer/decoder/pointDecoder.js","webpack://carto/./src/renderer/decoder/polygonDecoder.js","webpack://carto/./src/renderer/schema.js","webpack://carto/./src/renderer/shaders/Cache.js","webpack://carto/./src/renderer/shaders/common/antialiasing/AntiAliasingShader.js","webpack://carto/./src/renderer/shaders/common/antialiasing/antialiasingFragmentShader.glsl","webpack://carto/./src/renderer/shaders/common/antialiasing/antialiasingVertexShader.glsl","webpack://carto/./src/renderer/shaders/geometry/line/LineShader.js","webpack://carto/./src/renderer/shaders/geometry/line/lineFragmentShader.glsl","webpack://carto/./src/renderer/shaders/geometry/line/lineVertexShader.glsl","webpack://carto/./src/renderer/shaders/geometry/point/PointShader.js","webpack://carto/./src/renderer/shaders/geometry/point/pointFragmentShader.glsl","webpack://carto/./src/renderer/shaders/geometry/point/pointVertexShader.glsl","webpack://carto/./src/renderer/shaders/geometry/triangle/TriangleShader.js","webpack://carto/./src/renderer/shaders/geometry/triangle/triangleFragmentShader.glsl","webpack://carto/./src/renderer/shaders/geometry/triangle/triangleVertexShader.glsl","webpack://carto/./src/renderer/shaders/index.js","webpack://carto/./src/renderer/shaders/shaderCompiler.js","webpack://carto/./src/renderer/shaders/styler/stylerEncodeWidth.glsl","webpack://carto/./src/renderer/shaders/styler/stylerFragmentShader.glsl","webpack://carto/./src/renderer/shaders/styler/stylerShaders.js","webpack://carto/./src/renderer/shaders/styler/stylerVertexShader.glsl","webpack://carto/./src/renderer/shaders/symbolizer/symbolizerFragmentShader.glsl","webpack://carto/./src/renderer/shaders/symbolizer/symbolizerShaders.js","webpack://carto/./src/renderer/shaders/symbolizer/symbolizerVertexShader.glsl","webpack://carto/./src/renderer/shaders/utils.js","webpack://carto/./src/renderer/viz/colorspaces.js","webpack://carto/./src/renderer/viz/defaultSVGs.js","webpack://carto/./src/renderer/viz/expressions.js","webpack://carto/./src/renderer/viz/expressions/Animation.js","webpack://carto/./src/renderer/viz/expressions/Fade.js","webpack://carto/./src/renderer/viz/expressions/Image.js","webpack://carto/./src/renderer/viz/expressions/ImageList.js","webpack://carto/./src/renderer/viz/expressions/SVG.js","webpack://carto/./src/renderer/viz/expressions/aggregation/cluster/ClusterAggregation.js","webpack://carto/./src/renderer/viz/expressions/aggregation/cluster/ClusterAvg.js","webpack://carto/./src/renderer/viz/expressions/aggregation/cluster/ClusterMax.js","webpack://carto/./src/renderer/viz/expressions/aggregation/cluster/ClusterMin.js","webpack://carto/./src/renderer/viz/expressions/aggregation/cluster/ClusterMode.js","webpack://carto/./src/renderer/viz/expressions/aggregation/cluster/ClusterSum.js","webpack://carto/./src/renderer/viz/expressions/aggregation/global/GlobalAggregation.js","webpack://carto/./src/renderer/viz/expressions/aggregation/global/GlobalAvg.js","webpack://carto/./src/renderer/viz/expressions/aggregation/global/GlobalCount.js","webpack://carto/./src/renderer/viz/expressions/aggregation/global/GlobalMax.js","webpack://carto/./src/renderer/viz/expressions/aggregation/global/GlobalMin.js","webpack://carto/./src/renderer/viz/expressions/aggregation/global/GlobalPercentile.js","webpack://carto/./src/renderer/viz/expressions/aggregation/global/GlobalSum.js","webpack://carto/./src/renderer/viz/expressions/aggregation/viewport/ViewportAggregation.js","webpack://carto/./src/renderer/viz/expressions/aggregation/viewport/ViewportAvg.js","webpack://carto/./src/renderer/viz/expressions/aggregation/viewport/ViewportCount.js","webpack://carto/./src/renderer/viz/expressions/aggregation/viewport/ViewportHistogram.js","webpack://carto/./src/renderer/viz/expressions/aggregation/viewport/ViewportMax.js","webpack://carto/./src/renderer/viz/expressions/aggregation/viewport/ViewportMin.js","webpack://carto/./src/renderer/viz/expressions/aggregation/viewport/ViewportPercentile.js","webpack://carto/./src/renderer/viz/expressions/aggregation/viewport/ViewportSum.js","webpack://carto/./src/renderer/viz/expressions/base.js","webpack://carto/./src/renderer/viz/expressions/basic/array.js","webpack://carto/./src/renderer/viz/expressions/basic/category.js","webpack://carto/./src/renderer/viz/expressions/basic/constant.js","webpack://carto/./src/renderer/viz/expressions/basic/number.js","webpack://carto/./src/renderer/viz/expressions/basic/property.js","webpack://carto/./src/renderer/viz/expressions/basic/variable.js","webpack://carto/./src/renderer/viz/expressions/belongs.js","webpack://carto/./src/renderer/viz/expressions/between.js","webpack://carto/./src/renderer/viz/expressions/binary.js","webpack://carto/./src/renderer/viz/expressions/blend.js","webpack://carto/./src/renderer/viz/expressions/buckets.js","webpack://carto/./src/renderer/viz/expressions/classification/Classifier.js","webpack://carto/./src/renderer/viz/expressions/classification/GlobalEqIntervals.js","webpack://carto/./src/renderer/viz/expressions/classification/GlobalQuantiles.js","webpack://carto/./src/renderer/viz/expressions/classification/ViewportEqIntervals.js","webpack://carto/./src/renderer/viz/expressions/classification/ViewportQuantiles.js","webpack://carto/./src/renderer/viz/expressions/color/CIELab.js","webpack://carto/./src/renderer/viz/expressions/color/NamedColor.js","webpack://carto/./src/renderer/viz/expressions/color/cssColorNames.js","webpack://carto/./src/renderer/viz/expressions/color/hex.js","webpack://carto/./src/renderer/viz/expressions/color/hsl.js","webpack://carto/./src/renderer/viz/expressions/color/hsv.js","webpack://carto/./src/renderer/viz/expressions/color/opacity.js","webpack://carto/./src/renderer/viz/expressions/color/palettes.js","webpack://carto/./src/renderer/viz/expressions/color/palettes/Palette.js","webpack://carto/./src/renderer/viz/expressions/color/palettes/Reverse.js","webpack://carto/./src/renderer/viz/expressions/color/rgb.js","webpack://carto/./src/renderer/viz/expressions/interpolators.js","webpack://carto/./src/renderer/viz/expressions/linear.js","webpack://carto/./src/renderer/viz/expressions/now.js","webpack://carto/./src/renderer/viz/expressions/ordering.js","webpack://carto/./src/renderer/viz/expressions/placement.js","webpack://carto/./src/renderer/viz/expressions/ramp.js","webpack://carto/./src/renderer/viz/expressions/time.js","webpack://carto/./src/renderer/viz/expressions/top.js","webpack://carto/./src/renderer/viz/expressions/transition.js","webpack://carto/./src/renderer/viz/expressions/unary.js","webpack://carto/./src/renderer/viz/expressions/utils.js","webpack://carto/./src/renderer/viz/expressions/viewportFeatures.js","webpack://carto/./src/renderer/viz/expressions/xyz.js","webpack://carto/./src/renderer/viz/expressions/zoom.js","webpack://carto/./src/renderer/viz/parser.js","webpack://carto/./src/renderer/viz/svgs/bicycle.svg","webpack://carto/./src/renderer/viz/svgs/building.svg","webpack://carto/./src/renderer/viz/svgs/bus.svg","webpack://carto/./src/renderer/viz/svgs/car.svg","webpack://carto/./src/renderer/viz/svgs/circle.svg","webpack://carto/./src/renderer/viz/svgs/circleOutline.svg","webpack://carto/./src/renderer/viz/svgs/cross.svg","webpack://carto/./src/renderer/viz/svgs/flag.svg","webpack://carto/./src/renderer/viz/svgs/house.svg","webpack://carto/./src/renderer/viz/svgs/marker.svg","webpack://carto/./src/renderer/viz/svgs/markerOutline.svg","webpack://carto/./src/renderer/viz/svgs/plus.svg","webpack://carto/./src/renderer/viz/svgs/square.svg","webpack://carto/./src/renderer/viz/svgs/squareOutline.svg","webpack://carto/./src/renderer/viz/svgs/star.svg","webpack://carto/./src/renderer/viz/svgs/starOutline.svg","webpack://carto/./src/renderer/viz/svgs/triangle.svg","webpack://carto/./src/renderer/viz/svgs/triangleOutline.svg","webpack://carto/./src/setup/auth-service.js","webpack://carto/./src/setup/config-service.js","webpack://carto/./src/sources/Base.js","webpack://carto/./src/sources/BaseWindshaft.js","webpack://carto/./src/sources/DataframeCache.js","webpack://carto/./src/sources/Dataset.js","webpack://carto/./src/sources/GeoJSON.js","webpack://carto/./src/sources/MVT.js","webpack://carto/./src/sources/SQL.js","webpack://carto/./src/sources/TileClient.js","webpack://carto/./src/utils/collision.js","webpack://carto/./src/utils/geometry.js","webpack://carto/./src/utils/util.js"],"names":[],"mappings":";;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA,uBAAuB,kCAAkC,EAAE;;AAE3D;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,MAAM;AACtB;AACA,0BAA0B,6BAA6B,EAAE;;AAEzD;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,MAAM;AACtB;AACA,0BAA0B,6BAA6B,EAAE;;AAEzD;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,MAAM;AACtB;AACA,iCAAiC,qCAAqC,EAAE;;AAExE;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,MAAM;AACtB;AACA,iCAAiC,oCAAoC,EAAE;;AAEvE;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,MAAM;AACtB;AACA,0BAA0B,8BAA8B,EAAE;;AAE1D;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,MAAM;AACtB;AACA,0BAA0B,6BAA6B,EAAE;;AAEzD;AACA;AACA;AACA,eAAe,OAAO;AACtB,gBAAgB,MAAM;AACtB;AACA,0BAA0B,gCAAgC,EAAE;;AAE5D;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,MAAM;AACrB,gBAAgB,MAAM;AACtB;AACA,kCAAkC,wCAAwC,EAAE;;AAE5E;AACA;AACA,eAAe,cAAc;AAC7B,gBAAgB,MAAM;AACtB;AACA,0BAA0B,iCAAiC,EAAE;;AAE7D;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA,yBAAyB,6BAA6B,EAAE;;AAExD;AACA;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA,yBAAyB,6BAA6B,EAAE;;AAExD;AACA;AACA;AACA,gBAAgB,MAAM;AACtB;AACA,yBAAyB,8BAA8B,EAAE;;AAEzD;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,QAAQ;AACxB;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,eAAe,MAAM;AACrB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,YAAY,MAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvTA;AACA;AACA;;;;;;;;;;;;;ACFA;;AAEA;;AAEA;;AAEA;AACA,6CAA6C;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACfA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,4BAA4B;AAC5B;AACA;AACA;;AAEA;;AAEA,SAAS;;AAET;AACA;AACA,2CAA2C;AAC3C;;AAEA,SAAS;AACT;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,mBAAmB;AACtC,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2DAA2D,SAAS;AACpE;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxOA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;;;;;;;;;;AC5DA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,YAAY,2BAA2B;AACvC,WAAW,wBAAwB;AACnC,YAAY,2BAA2B;AACvC,WAAW,wBAAwB;AACnC,WAAW,wBAAwB;AACnC,cAAc,2BAA2B;AACzC,aAAa,wBAAwB;AACrC,eAAe,wBAAwB;AACvC,aAAa,2BAA2B;AACxC,WAAW,2BAA2B;AACtC,aAAa,2BAA2B;AACxC,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA,CAAC,QAID;;AAEA,CAAC;;;;;;;;;;;;ACn1DD;;;;;;;;;;;;ACAA;AACA;AACA;;AAEA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA,CAAC,QAID;;AAEA,CAAC;;;;;;;;;;;;AC1TD;;;;;;;;;;;;;ACAA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,0EAA0E;AAC1E;AACA;AACA;;AAEA,yBAAyB,cAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,SAAS;AAChC,KAAK;AACL,2BAA2B,YAAY;AACvC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yCAAyC;;AAEzC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC;;AAEzC,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA,iCAAiC,+BAA+B;;AAEhE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,kDAAkD;;AAElD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,SAAS;AAC1D;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC,SAAS;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,yCAAyC;AAC3D;;AAEA,mBAAmB,iBAAiB;AACpC,uBAAuB,oBAAoB;AAC3C,2BAA2B,SAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,QAAQ,WAAW;;AAEnB;AACA;AACA,QAAQ,UAAU;;AAElB;AACA;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,iCAAiC;AACjC,GAAG;AACH;AACA;AACA;AACA;AACA,2EAA2E;AAC3E,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,2EAA2E;AAC3E,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,iCAAiC,EAAE;AAC5D,6BAA6B,qCAAqC,EAAE;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB;;AAElB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD;AACxD;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC;AACnC;AACA;AACA,oCAAoC;AACpC;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,8BAA8B;AAC9B,gCAAgC;AAChC;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,cAAc;AACd,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,OAAO,gCAAgC;AACvC;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,+DAA+D;;AAE5F;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,wCAAwC;AACxC;;AAEA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,EAAE;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6BAWE;AACF;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;AC1sBD;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;;AAEzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,GAAG;AACH,oBAAoB,iCAAiC;AACrD;AACA,CAAC;;AAED;AACA,oBAAoB,sBAAsB;AAC1C;AACA,CAAC;;AAED;AACA,oBAAoB,+BAA+B;AACnD;AACA,CAAC;;AAED;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wCAAwC,iBAAiB;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,WAAW;;AAEX;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,QAAQ;AACtC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACldA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH,yCAAyC,OAAO;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA,uCAAuC,OAAO;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,0BAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,0BAA0B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,iBAAiB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;;AAEA,+BAA+B,iBAAiB;AAChD;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qCAAqC,iBAAiB;AACtD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,6BAA6B;AAClE;AACA;AACA,QAAQ,2BAA2B;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2BAA2B;AAC1E;AACA;AACA,QAAQ,6BAA6B;AACrC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,iBAAiB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;;;ACjXA;AAAA;AACA;AACA;;;;AAIA;;;AAGA;;;;;;AAMA;AACA;AACA,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,aAAa,OAAO;AACpB,aAAa,IAAI;AACjB;AACA;AACA;AACA,qDAAqD,cAAc,EAAE;AACrE,oDAAoD,oBAAoB,EAAE;AAC1E;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;AC/DA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;;AAEhB;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,4BAA4B,kBAAkB;AAC9C,4BAA4B,wBAAwB;AACpD,4BAA4B,yBAAyB;AACrD,4BAA4B,yBAAyB;AACrD,0BAA0B;;AAE1B;AACA,KAAK;;AAEL,8BAA8B;AAC9B;AACA,KAAK;;AAEL;AACA;AACA,wDAAwD;AACxD,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,uCAAuC;;AAEvC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,+EAA+E;AAC/E,+EAA+E;AAC/E,+EAA+E;AAC/E;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA,mBAAmB;;AAEnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC,KAAK;;AAEL;AACA,mBAAmB;;AAEnB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL,6CAA6C,gDAAgD,IAAI;AACjG,6CAA6C,iDAAiD,GAAG;AACjG,6CAA6C,iDAAiD,GAAG;AACjG,6CAA6C,+CAA+C,KAAK;AACjG,6CAA6C,gDAAgD,IAAI;AACjG,6CAA6C,iDAAiD,GAAG;AACjG,6CAA6C,kDAAkD,EAAE;AACjG,6CAA6C,iDAAiD,GAAG;AACjG,6CAA6C,kDAAkD,EAAE;;AAEjG;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,sBAAsB;AAC3C,qBAAqB,sBAAsB;AAC3C,qBAAqB,uBAAuB;AAC5C,qBAAqB,uBAAuB;AAC5C,qBAAqB,uBAAuB;AAC5C,qBAAqB,uBAAuB;;AAE5C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA,2CAA2C;AAC3C,2CAA2C;AAC3C,2CAA2C;AAC3C,2CAA2C;AAC3C;AACA;;AAEA;AACA;;AAEA,mEAAmE;AACnE,mEAAmE;AACnE,mEAAmE;AACnE,mEAAmE;AACnE,mEAAmE;AACnE;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,eAAe;AAC5C;;AAEA,wCAAwC,gBAAgB,gBAAgB,8BAA8B;AACtG,wCAAwC,gBAAgB,gBAAgB,+BAA+B;AACvG,wCAAwC,gBAAgB,gBAAgB,6BAA6B;AACrG,wCAAwC,gBAAgB,gBAAgB,8BAA8B;AACtG,wCAAwC,gBAAgB,gBAAgB,+BAA+B;AACvG,wCAAwC,gBAAgB,gBAAgB,+BAA+B;AACvG,wCAAwC,gBAAgB,gBAAgB,gCAAgC;AACxG,wCAAwC,gBAAgB,gBAAgB,+BAA+B;AACvG,wCAAwC,gBAAgB,gBAAgB,gCAAgC;;AAExG;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,4BAA4B,gBAAgB;AAC5C,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa;AACb;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzmBA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;;;;;ACvLtC;AACA;AACA;;AAEA;AACA;AACA,CAAC;AACD;AACA;;;;;;;;;;;;;ACRA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,GAAG;AACH,sBAAsB;AACtB;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AChHA;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,uBAAuB,SAAS;AAChC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,KAAK;;AAEjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;AAGA;AACA;AACA,yDAAyD;AACzD;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB;AACA,WAAW,SAAS;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;ACzkBA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACgB;AAChB;AACA;AAC0B;AAC1B;;AAEA;AACA;AACA,oCAAoC,wBAAwB;AAC5D;AACA,aAAa,OAAO;AACpB;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,+BAA+B,MAAM,oBAAoB;AAChF;AACA,SAAS,+BAA+B;AACxC,SAAS,oBAAoB;AAC7B;AACA,UAAU,OAAO,+CAA+C,kBAAkB;AAClF,UAAU,kBAAkB;AAC5B,UAAU,UAAU;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,aAAa;AAC5B,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,YAAY;AAC/C,mCAAmC,YAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,UAAU;AACzB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,eAAe,UAAU;AACzB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AClhBA;AACA;AACwB;AACxB;AACA;AACuB;AACM;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,8EAAsB,sBAAsB,aAAa;AAClG;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,MAAM;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,MAAM;AACvB,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB,iBAAiB,MAAM;AACvB,iBAAiB,UAAU;AAC3B,uBAAuB,MAAM;AAC7B,iBAAiB,OAAO;AACxB,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,gDAAgD;AAChD;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,+MAA8E,oBAAoB;AAClG,+MAA8E,oBAAoB;AAClG,qNAAoF,0BAA0B;AAC9G,qNAAoF,0BAA0B;AAC9G,iNAAgF,sBAAsB;;AAEtG;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,cAAc;AAC9B,gBAAgB;AAChB;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD,oBAAoB;AACrE,gEAAgE;AAChE,qBAAqB,OAAO;AAC5B,sBAAsB,MAAM;AAC5B,sBAAsB,OAAO;AAC7B,sBAAsB,MAAM;AAC5B,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B,sBAAsB,MAAM;AAC5B,sBAAsB,UAAU;AAChC,4BAA4B,MAAM;AAClC,sBAAsB,OAAO;AAC7B,sBAAsB,OAAO;AAC7B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0HAAwE,eAAe;AACvF;AACA;AACA,wHAAsE,eAAe;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,IAAI;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzdA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,cAAc;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,SAAS;AACT,KAAK;AACL,uCAAuC,UAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,UAAU,OAAO;AACjB,UAAU,YAAY;AACtB,UAAU,SAAS;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,KAAK;AACL;AACA,oBAAoB;AACpB;AACA;AACA,KAAK;AACL;AACA,qBAAqB;AACrB;AACA;AACA,KAAK;AACL;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,mBAAmB;AACtC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,mCAAmC;AAC1D;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA,cAAc,EAAE;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7RA;AAAA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,WAAW,KAAK;AAChB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,YAAY,OAAO;AACnB;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA,YAAY,0BAA0B,yDAAyD;AAC/F;;AAEA;AACA;AACA;AACA,WAAW,KAAK;AAChB,YAAY,MAAM,sBAAsB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,MAAM;AACjB,YAAY,MAAM,sBAAsB;AACxC;AACA;AACA;AACA,uBAAuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC,2BAA2B,YAAY;AACvC,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,WAAW,EAAE;AACb,WAAW,EAAE;AACb,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA,gEAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClIqF;AACnF;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,+BAA+B;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C;;AAEA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,kBAAkB,WAAW,cAAc,OAAO,cAAc;AACvF,kBAAkB,kBAAkB,OAAO,yBAAyB;AACpE,qBAAqB,kBAAkB,WAAW,yBAAyB;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,EAAE;AACb,aAAa;AACb;AACA,wCAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,UAAU;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AC5dkB;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,kGAAgE,6BAA6B;AAC7F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kGAAgE,6BAA6B;AAC7F;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,iHAAiH,SAAS;AAC1H;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qEAAqE,uBAAuB;AAC5F;AACA;AACA;AACA;;AAEA,0BAA0B,OAAO;;AAEjC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,aAAa,gBAAgB;AAC7B;;AAEA,gBAAgB;AAChB;;AAEA,qCAAqC,kDAAkD;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qGAAqG,qBAAqB;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA;AACA;AACA,4EAA4E;AAC5E;;AAEA;AACA;AACA,mDAAmD,oBAAoB;AACvE;AACA,yBAAyB,QAAQ,QAAQ,SAAS,GAAG,UAAU;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,2CAA2C;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,2BAA2B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,qCAAqC;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;;AAET;;AAEA,yFAAuC,sGAAsG;AAC7I;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,KAAK;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,mDAAmD,iDAAQ;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,8BAA8B,iBAAiB,GAAG,cAAc,cAAc,wBAAwB,GAAG,WAAW,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;AAChI;AACA,oDAAoD,wBAAwB,GAAG,WAAW,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;AACtG;;AAEA;AACA,cAAc,KAAK,GAAG,0BAA0B;AAChD;;AAEA;AACA,cAAc,IAAI,GAAG,qBAAqB;AAC1C;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/cA;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;;;;ACHD;;AAEA;AACA;;AAEA;AACA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,WAAW;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mDAAmD,IAAI;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEQ;;;;;;;;;;;;;;;;AC/Ea;;AAErB;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;ACfA;AAAA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEQ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvKR;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN,MAAM;AACN;;AAEyB;AACE;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACkB;;AAElB;AACA;AACA;AACA,SAAS,OAAO;AAChB;AACA;AACA;AACA;AACkB;;AAElB;;AAEA,gBAAgB;;AAER;;;;;;;;;;;;;;;;AChDkB;AAC1B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,OAAO;AACvB,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,kBAAkB;AAChE,aAAa;AACb;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;;AAEA,sCAAsC,WAAW;AACjD,uCAAuC,YAAY;AACnD;AACA;;;;;;;;;;;;;;;;AC9JA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3BA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,2CAA2C;AAC3C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uCAAuC,MAAM;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvIA;AACA;AACqC;AACtB;;AAEf;AACA;AACA,sCAAsC,wCAAwC;AAC9E;AACA,aAAa,OAAO;AACpB,cAAc,OAAO,uCAAuC,WAAW;AACvE,cAAc,OAAO,kCAAkC,OAAO;AAC9D,cAAc,UAAU,sBAAsB;AAC9C;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oDAAoD,kBAAkB;AACtE;AACA;AACA;AACA,cAAc,0BAA0B,cAAc,kBAAkB,cAAc,kBAAkB;AACxG,cAAc,OAAO,YAAY;AACjC,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0BAA0B;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS,yFAAyF;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4FAAuC,mEAAuB,aAAa,EAAE;AAC7E;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C,UAAU,sBAAsB,kBAAkB;AACjG;AACA;;;;;;;;;;;;;;;;AC/RA;;AAEA;AACA;AACA,oCAAoC,mBAAmB;AACvD;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,mBAAmB;AACjC,cAAc,mBAAmB;AACjC,cAAc,mBAAmB;AACjC,cAAc,mBAAmB;AACjC,cAAc,qBAAqB;AACnC,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,uHAA8E,QAAQ;AACtF,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACzCiD;AACpB;;AAE7B;AACA;AACA,uDAAuD,cAAc;AACrE;AACA,aAAa,OAAO;AACpB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC/DqB;AACN;AAC4C;AAChC;;AAE3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,gEAAgE;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,qBAAqB;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mCAAmC,oBAAoB;AACvD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;;AAET;;AAEA;AACA;AACA;AACA;;AAEA;AACA,eAAe,yBAAyB;AACxC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,uCAAuC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC;AACrC;AACA,uBAAuB,uCAAuC;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;AChiBA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,uEAAuE,IAAI,eAAe,EAAE;AAC9G;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7CA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACrEA;AACoB;AACe;;AAEnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oGAAoG,aAAa,KAAK,UAAU;AAChI;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe;AACf;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B,2BAA2B;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,6BAA6B;;AAE5C;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,sBAAsB;AACzD,mCAAmC,sBAAsB;AACzD,KAAK;AACL,mCAAmC,sBAAsB;AACzD,mCAAmC,sBAAsB;AACzD;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACrfsB;AACD;AACG;;AAExB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,SAAS;AACtE;AACA;;;;;;;;;;;;;;;;;ACfmC;AACS;;AAE5C;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;;AAEA,mBAAmB,qBAAqB;AACxC;AACA,uBAAuB,oBAAoB;AAC3C;AACA;AACA;;AAEA;AACA,eAAe;AACf,eAAe,sFAAsF;;AAErG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qBAAqB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7GA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACPA;AACmC;AACN;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA,yBAAyB;AACzB;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;AACA;;AAEA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;;AAEA,2BAA2B,qBAAqB;AAChD;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2BAA2B,0BAA0B;AACrD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe;AACf,eAAe,sFAAsF;;AAErG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjHA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,kBAAkB,WAAW,EAAE,MAAM,GAAG,KAAK;AAC7C;AACA;;AAEA,gEAAgB;;;;;;;;;;;;;;AC3DhB;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AChCyB;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACVA,wCAAwC,qBAAqB,4BAA4B,qBAAqB,qCAAqC,wBAAwB,GAAG,G;;;;;;;;;;;ACA9K,wCAAwC,wBAAwB,qBAAqB,qBAAqB,gCAAgC,0CAA0C,GAAG,G;;;;;;;;;;;;;;;;;;;ACA9J;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACjBA,wCAAwC,4BAA4B,qBAAqB,2BAA2B,GAAG,G;;;;;;;;;;;ACAvH,wCAAwC,kCAAkC,2BAA2B,wBAAwB,6BAA6B,4BAA4B,2BAA2B,+BAA+B,6BAA6B,8BAA8B,4BAA4B,gGAAgG,cAAc,mCAAmC,sCAAsC,qBAAqB,iCAAiC,yCAAyC,OAAO,MAAM,2BAA2B,OAAO,eAAe,GAAG,qBAAqB,6CAA6C,0DAA0D,2BAA2B,2BAA2B,iEAAiE,sMAAsM,kDAAkD,gGAAgG,mCAAmC,qBAAqB,OAAO,uBAAuB,GAAG,G;;;;;;;;;;;;;;;;;;;ACAzyC;AACzB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpBA,wCAAwC,4BAA4B,2BAA2B,yBAAyB,qCAAqC,gCAAgC,kCAAkC,oCAAoC,oEAAoE,GAAG,uBAAuB,0DAA0D,qBAAqB,wBAAwB,8CAA8C,iBAAiB,oCAAoC,mDAAmD,iBAAiB,uBAAuB,yBAAyB,GAAG,G;;;;;;;;;;;ACAlqB,wCAAwC,kCAAkC,2BAA2B,6BAA6B,4BAA4B,8BAA8B,8BAA8B,iCAAiC,+BAA+B,6BAA6B,mCAAmC,mCAAmC,8BAA8B,0DAA0D,4BAA4B,yBAAyB,qCAAqC,gCAAgC,kCAAkC,iGAAiG,YAAY,kCAAkC,kCAAkC,mBAAmB,mCAAmC,wCAAwC,KAAK,OAAO,0BAA0B,KAAK,aAAa,GAAG,qBAAqB,2CAA2C,kDAAkD,wDAAwD,yBAAyB,0BAA0B,iEAAiE,0BAA0B,2EAA2E,uBAAuB,gCAAgC,6DAA6D,mCAAmC,oBAAoB,KAAK,sBAAsB,kBAAkB,KAAK,gDAAgD,2BAA2B,0CAA0C,0EAA0E,2GAA2G,mBAAmB,KAAK,oBAAoB,GAAG,G;;;;;;;;;;;;;;;;;;;ACA31D;AACzB;AACA;;AAEA;AACA;AACA,iGAAkD,kEAAqB,MAAM,oEAAuB;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClBA,uCAAuC,4BAA4B,qBAAqB,2BAA2B,GAAG,G;;;;;;;;;;;ACAtH,0CAA0C,kCAAkC,2BAA2B,wBAAwB,6BAA6B,4BAA4B,2BAA2B,+BAA+B,mCAAmC,mCAAmC,8BAA8B,4BAA4B,gGAAgG,cAAc,mCAAmC,sCAAsC,qBAAqB,iCAAiC,yCAAyC,OAAO,MAAM,2BAA2B,OAAO,eAAe,GAAG,qBAAqB,aAAa,8BAA8B,6CAA6C,OAAO,KAAK,mDAAmD,OAAO,0DAA0D,uBAAuB,uEAAuE,kGAAkG,qBAAqB,qBAAqB,OAAO,mCAAmC,uBAAuB,GAAG,G;;;;;;;;;;;;;;;;;;;;;;;ACApuC;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEQ;;AAER;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACtBmC;;AAEnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,UAAU;AACjD;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL,yFAAyF,WAAW;;AAEpG;;AAEA;AACA,wEAAwE,UAAU;AAClF,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;;ACxDA,+GAA+G,iBAAiB,mBAAmB,OAAO,gBAAgB,0BAA0B,OAAO,KAAK,iCAAiC,OAAO,sBAAsB,GAAG,qB;;;;;;;;;;;ACAjR,wCAAwC,oBAAoB,yDAAyD,0BAA0B,mCAAmC,GAAG,G;;;;;;;;;;;;;;;;;;;;;;ACArL;AACA;AACA;;AAEA;AACA,qBAAqB,gEAAmB;AACxC,uBAAuB,kEAAqB;AAC5C;AACA;AACA;;AAEA;AACA,qBAAqB,gEAAmB;AACxC,uBAAuB,kEAAqB;AAC5C;AACA;AACA;;AAEA;AACA,qBAAqB,gEAAmB;AACxC,uBAAuB,kEAAqB;AAC5C;AACA,sCAAsC,+DAAkB;AACxD;;;;;;;;;;;;ACvBA,wCAAwC,wBAAwB,qBAAqB,qBAAqB,gCAAgC,0CAA0C,GAAG,G;;;;;;;;;;;ACAvL,wCAAwC,oCAAoC,2BAA2B,+BAA+B,0DAA0D,oCAAoC,sCAAsC,wCAAwC,eAAe,yBAAyB,mDAAmD,OAAO,KAAK,0BAA0B,OAAO,4CAA4C,GAAG,G;;;;;;;;;;;;;;;;;;ACAze;AACA;;AAEA;AACA,qBAAqB,oEAAuB;AAC5C,uBAAuB,sEAAyB;AAChD;;;;;;;;;;;;ACNA,wCAAwC,kCAAkC,2BAA2B,6BAA6B,4BAA4B,8BAA8B,8BAA8B,iCAAiC,0BAA0B,+BAA+B,6BAA6B,8BAA8B,iEAAiE,2BAA2B,gGAAgG,cAAc,mBAAmB,wBAAwB,OAAO,iBAAiB,6BAA6B,OAAO,KAAK,iCAAiC,OAAO,GAAG,mEAAmE,+BAA+B,6CAA6C,0DAA0D,2BAA2B,mEAAmE,4BAA4B,uBAAuB,sBAAsB,OAAO,6CAA6C,wEAAwE,gEAAgE,gFAAgF,qBAAqB,OAAO,uBAAuB,GAAG,G;;;;;;;;;;;;;;;;ACAl4C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;AC3FgB;;AAEhB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,gdAAgd,+BAA+B;AAC/e;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,aAAa;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,aAAa;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,aAAa;AACpC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,4BAA4B,aAAa;AACzC;;AAEA;AACA,uBAAuB,iBAAiB;AACxC;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACtCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,4DAA4D;AACpF;AACA,cAAc;AACd;AACA;;AAEA;;AAEA;;AAEa;AACC;;AAEd;;AAEc;AACA;AACA;AACA;AACA;AACA;AACQ;AACS;AACZ;AACS;AACX;AACG;AACP;AACC;;AAEd;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEc;AACC;;AAED;AACC;;AAEC;AACE;;AAElB;;AAEA;;AAEA;;AAEA;;AAEA;;AAEc;AACC;AACG;AACF;;AAEhB;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEc;AACC;;AAEf;;AAEA;;AAEe;AACK;;AAEN;AACC;AACD;AACA;AACA;AACC;AACM;AACP;AACE;AACD;;AAEf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACQ;;AAER;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACQ;;AAER;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACQ;;AAER;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACQ;;AAER;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEQ;;;;;;;;;;;;;;;;;;;;;AClaR;AACe;AACmE;AACnC;AAC/C;AACmB;;AAEnB;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,KAAK;AAChB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,eAAe,0CAA0C;AACzD;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,yBAAyB,cAAc,IAAI,gBAAgB,IAAI,gBAAgB,IAAI,eAAe,IAAI,gBAAgB;AACtH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,OAAO;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oHAAoH,SAAS;AAC7H;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC5TA;AACuC;;AAEvC;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,eAAe,kBAAkB;;AAEjC;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;AC3EA;AACsB;;AAEtB;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qEAAqE,WAAW;AAChF,0CAA0C,UAAU;AACpD;AACA;;AAEA;AACA,uFAAuF,UAAU;AACjG;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;;;;;;;;;;;;;;;AC9GA;AACqC;;AAErC;AACA;AACA;AACA;AACA;AACA,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gIAAiF,EAAE;;AAEnF;;AAEA;AACA,6BAA6B,EAAE;AAC/B,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;;AAEzC,4BAA4B,UAAU;AACtC,4CAA4C,UAAU;AACtD;AACA;AACA,4BAA4B,UAAU;AACtC;AACA;;AAEA;AACA,kFAAkF,UAAU;AAC5F;;AAEA;AACA;AACA,uBAAuB,oBAAoB;AAC3C,uCAAuC,EAAE;AACzC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,oBAAoB;AAC/C,2CAA2C,EAAE;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC1GA;;AAEA;AACA;AACA,oCAAoC,wBAAwB;AAC5D;AACA;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACmC;AACnC;;AAEA;AACA,kBAAkB,6CAA6C;AAC/D;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,uBAAuB,gHAA+E;AACtG;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA,8CAA8C,oDAAoD;AAClG;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4EAA4E;AAC3F;AACA;;;;;;;;;;;;;;;;AC9BA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C,oDAAoD;AAClG;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4EAA4E;AAC3F;AACA;;;;;;;;;;;;;;;;AC/BA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C,oDAAoD;AAClG;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4EAA4E;AAC3F;AACA;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oDAAoD;AACnG;AACA,WAAW,SAAS;AACpB,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,gFAAgF;AAC/F;AACA;;;;;;;;;;;;;;;;AC9BA;;AAEA;AACA;AACA;AACA;AACA,8CAA8C,oDAAoD;AAClG;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4EAA4E;AAC3F;AACA;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACiB;AACM;;AAEvB;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA,kBAAkB,uBAAuB;AACzC,eAAe,yEAAoB;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wCAAwC,WAAW,gBAAgB,mBAAmB;AACtF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AClDA;;AAEA;AACA;AACA;AACA,6CAA6C,oDAAoD;AACjG;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wCAAwC;AACvD;AACA;;;;;;;;;;;;;;;;AChCA;;AAEA;AACA;AACA;AACA,+CAA+C,oDAAoD;AACnG;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,0CAA0C;AACzD;AACA;;;;;;;;;;;;;;;;AChCA;;AAEA;AACA;AACA;AACA,6CAA6C,oDAAoD;AACjG;AACA,WAAW,YAAY;AACvB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wCAAwC;AACvD;AACA;;;;;;;;;;;;;;;;AChCA;AACA;AACA;AACA;AACA,6CAA6C,oDAAoD;AACjG;AACA,WAAW,YAAY;AACvB,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wCAAwC;AACvD;AACA;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACiB;;AAEjB;AACA;AACA;AACA;AACA;AACA,eAAe,yEAAoB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC7CA;;AAEA;AACA;AACA;AACA,6CAA6C,oDAAoD;AACjG;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA;;;;;;;;;;;;;;;;;;AChCA;AACuB;AACN;;AAEjB;AACA;AACA,eAAe,EAAE;AACjB;AACA,kBAAkB,WAAW;AAC7B,eAAe,6JAAyD;AACxE;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AChCA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtDA;AACiB;;AAEjB;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2EAAsB;AACrC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AChDA;AACuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kBAAkB,GAAG,kBAAkB;AAC/C;AACA;AACA;AACA,QAAQ,kBAAkB,GAAG,kBAAkB,GAAG,kBAAkB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iJAAmD;;AAElE;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;ACvIA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACnDA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnDA;AACiB;AACa;;AAE9B;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA,eAAe,sFAAiC;;AAEhD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;ACjFA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACnDuB;AACK;AAC5B;;AAEA;AACA;AACA;AACA,+BAA+B,wBAAwB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,8BAA8B;AACjD;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B,cAAc;AACd;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,EAAE;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,WAAW;AAC1B,eAAe,WAAW;AAC1B,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtNA;AAC6D;;AAE7D;AACA;AACA;AACA,WAAW,mCAAmC;AAC9C,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,KAAK;AACtE;AACA;AACA,4FAA6C,MAAM;AACnD;AACA,oDAAoD,8EAA+B;AACnF;AACA,SAAS;AACT,gBAAgB;AAChB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iEAAiE,KAAK;AACtE;AACA;AACA,4FAA6C,MAAM;AACnD;AACA,oDAAoD,0EAA2B;AAC/E;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;ACzEA;AACsB;;AAEtB;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,2DAA2D,WAAW;AACtE,0BAA0B,UAAU;AACpC;AACA;;AAEA;AACA,yFAAyF,UAAU;AACnG;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACtDA;AACsB;;AAEtB;AACA,2DAA2D,iDAAiD;AAC5G;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA,qCAAqC,cAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACvCA;AACsB;;AAEtB;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,WAAW;AACzE,6BAA6B,UAAU;AACvC;AACA;AACA;AACA,4FAA4F,UAAU;AACtG;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrDA;AACsB;;AAEtB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC,UAAU;AACnD;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpFA;AACsB;;AAEtB;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,gDAAgD,KAAK;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC1FmE;AACnE;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,WAAW;AACtB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,6BAA6B,aAAa,MAAM,aAAa,MAAM,GAAG,iBAAiB;AAChH;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,WAAW;AACtB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,6BAA6B,aAAa,MAAM,aAAa,MAAM,GAAG,iBAAiB;AAChH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,4BAA4B;AAC5B;AACA,+BAA+B,MAAM;AACrC,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACjGA;AACkD;;AAElD;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,gCAAgC;AAC/C;AACA,0CAA0C,aAAa,MAAM,kBAAkB,OAAO,aAAa,MAAM,kBAAkB;AAC3H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxDiB;AACM;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,EAAE,KAAK,EAAE;AAC3B;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,EAAE,KAAK,EAAE;AAC3B;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,EAAE,KAAK,EAAE;AAC3B;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,EAAE,KAAK,EAAE;AAC3B;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,EAAE,IAAI,EAAE;AAC7B;;AAEA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,EAAE,IAAI,EAAE;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,EAAE,GAAG,EAAE;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,EAAE,IAAI,EAAE;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,EAAE,GAAG,EAAE;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,EAAE,IAAI,EAAE;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,EAAE,IAAI,EAAE;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,EAAE,IAAI,EAAE;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,EAAE,KAAK,EAAE;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,EAAE,KAAK,EAAE;AAC9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,KAAK,4CAA4C,OAAO,iBAAiB,OAAO;AACvH;AACA;;AAEA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC,KAAK,4CAA4C,OAAO,iBAAiB,OAAO;AACnH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACviB+E;AAC/E;AACA;;AAEA;AACA;AACA;AACA,WAAW,aAAa;AACxB,WAAW,aAAa;AACxB,WAAW,OAAO;AAClB,aAAa,aAAa;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,YAAY;AAC3B;;AAEA;AACA;AACA;AACA,4CAA4C,SAAS,IAAI,SAAS,UAAU,WAAW;AACvF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6EAA6E,OAAO,oBAAoB,OAAO;AAC/G;AACA;;;;;;;;;;;;;;;;;AC9FA;AAC4C;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,kCAAkC;AAC3C,SAAS,8CAA8C;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,oBAAoB;AAC/B,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,+FAA+F,WAAW;AAC1G;AACA;AACA;;AAEA;AACA;AACA;AACA,0DAA0D,8EAA+B;AACzF,iDAAiD,UAAU,sBAAsB,UAAU;AAC3F,iBAAiB;AACjB,0DAA0D,8EAA+B,8BAA8B,UAAU;AACjI;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA,2BAA2B,MAAM;AACjC,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,4BAA4B;AACnD;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,2FAA2F,gBAAgB;AAC3G;;AAEA;AACA;AACA,sDAAsD,8EAA+B;AACrF,6CAA6C,gBAAgB,sBAAsB,UAAU;AAC7F,aAAa;AACb,sDAAsD,8EAA+B,8BAA8B,UAAU;AAC7H;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,mCAAmC,UAAU;AAC7C;AACA;AACA,eAAe,wBAAwB,QAAQ,IAAI,GAAG,mBAAmB,MAAM,GAAG;AAClF,yBAAyB,MAAM;AAC/B,aAAa;AACb;AACA,iCAAiC,SAAS;AAC1C,cAAc;AACd,qBAAqB,uBAAuB;AAC5C,SAAS;;AAET;AACA;AACA,uBAAuB,SAAS,GAAG,mBAAmB;AACtD;AACA;AACA;;;;;;;;;;;;;;;;;;ACvKA;AACiB;AACjB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sCAAsC,mBAAmB;AACzD;AACA,eAAe,wBAAwB,UAAU,mBAAmB,MAAM,GAAG;AAC7E,yBAAyB;AACzB,aAAa;AACb;AACA,iCAAiC,SAAS;AAC1C,cAAc;AACd,qBAAqB;AACrB,SAAS;AACT;AACA;AACA,uBAAuB,SAAS,GAAG,mBAAmB;AACtD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,iBAAiB;AACpC,uBAAuB,EAAE;AACzB,wCAAwC,EAAE;AAC1C;;AAEA;AACA;;;;;;;;;;;;;;;;;;ACjFA;AACA;AACiE;;AAEjE;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,QAAQ;AACvB;;AAEA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;ACjDA;AACA;AACiE;;AAEjE;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;AClDA;AACmC;AACF;;AAEjC;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;;ACnDA;AACiC;AACL;;AAE5B;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B;AAC1B;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,0CAA0C,IAAI;AAC9C;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;;;;;;;;;;;;;;;;ACtEA;AACmE;;AAEnE;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,UAAU;AACzB;;AAEA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC,4BAA4B,SAAS;AACrC,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpGA;AAC6C;AACnB;;AAE1B;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4JAA6G,UAAU;AACvH;AACA,gBAAgB;AAChB;AACA;AACA;AACA,yCAAyC,gCAAgC,IAAI,gCAAgC,IAAI,gCAAgC,IAAI,eAAe;AACpK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB;;AAEnB;AACA;AACA;;;;;;;;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACrJA;AACuD;;AAEvD;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,yCAAyC,gCAAgC,IAAI,gCAAgC,IAAI,gCAAgC,IAAI,0BAA0B;AAC/K;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC3CA;AAC0E;;AAE1E;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA8B;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B,oDAAoD;AACnF;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS,EAAE,wBAAwB;AACzD,4BAA4B,SAAS,EAAE,kBAAkB;AACzD,4BAA4B,SAAS,EAAE,kBAAkB;AACzD,sBAAsB,iBAAiB,SAAS,kBAAkB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,KAAK,2BAA2B,cAAc,cAAc,eAAe;AAC1G;AACA;AACA;;;;;;;;;;;;;;;;;;AC3JA;AAC0E;;AAE1E;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,oDAAoD;AACnF;AACA;AACA;AACA;AACA;AACA,sBAAsB,SAAS,EAAE,wBAAwB;AACzD,4BAA4B,SAAS,EAAE,kBAAkB;AACzD,4BAA4B,SAAS,EAAE,kBAAkB;AACzD,sBAAsB,iBAAiB,SAAS,iBAAiB;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,KAAK,2BAA2B,cAAc,cAAc,eAAe;AAC1G;AACA;AACA;;;;;;;;;;;;;;;;;;ACxJA;AACiB;AACmB;;AAEpC;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA,8CAA8C,aAAa,SAAS,aAAa;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACxDA;AACA;;AAEA;;AAEA;AACA,gBAAgB,mBAAmB;AACnC,CAAC;;AAED;;;;;;;;;;;;;;;;;ACVA;AACmB;;AAEnB;AACA;AACA;AACA,6CAA6C,kDAAkD,MAAM,2DAA2D;AAChK,oBAAoB;AACpB;AACA,0DAA0D,4DAA4D;AACtH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACpEA;;AAEA;AACA;AACA;AACA,WAAW,QAAQ;AACnB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACtDA;AACkD;;AAElD;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,SAAS,SAAS,SAAS,SAAS,SAAS,SAAS,wBAAwB;AAC/H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChGuB;AACvB;;AAEA;;AAEA,kFAAyF;;AAEzF;AACA,+BAA+B,MAAM;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,6BAA6B,MAAM;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA,mBAAmB,IAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,YAAY;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChFA;AACmE;AACpC;;AAE/B;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB,UAAU,YAAY;AACtB,UAAU,YAAY;AACtB,WAAW;AACX;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,eAAe,kBAAkB;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,gDAAgD,aAAa,IAAI,iBAAiB,MAAM,0BAA0B;AAClH,SAAS;AACT;AACA;AACA;;AAEA,gDAAgD,aAAa,GAAG,WAAW,KAAK,WAAW,GAAG,WAAW;AACzG;AACA;AACA;;;;;;;;;;;;;;;;;ACpGA;AACiB;;AAEjB;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sEAAiB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;ACvCA;AACwB;;AAExB;AACA;AACA;AACA,WAAW,wBAAwB;AACnC,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,wBAAwB;AACnC,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;;;;;;;;;;;;;;;;;ACrHA;AACkD;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,6CAA6C,SAAS,IAAI,SAAS;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACrDA;AACyF;;AAEvD;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,gBAAgB;AAC1B,UAAU,yBAAyB;AACnC,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2BAA2B,cAAc,YAAY,aAAa;AAClE;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C,sCAAsC;AACtC,wCAAwC,WAAW;AACnD;;AAEA;AACA,uCAAuC,UAAU,UAAU,aAAa,SAAS,UAAU,YAAY,UAAU;AACjH,sCAAsC,UAAU,UAAU,aAAa,SAAS,UAAU,YAAY,UAAU;AAChH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oFAAoF,UAAU;AAC9F,sFAAsF,UAAU;AAChG,0FAA0F,UAAU;AACpG;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;AACA,oGAA+C,6DAA6D,GAAG,6DAA6D;;AAE5K;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,wBAAwB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;ACvbA;AACA;;AAEA;AACA;AACA;AACA,WAAW,YAAY;AACvB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AC1CA;AAC0F;AAC1F;AACiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B,uBAAuB,qBAAqB;AAC5C,4BAA4B,EAAE;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,gBAAgB,gBAAgB,KAAK;AACtG,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,0EAA0E,EAAE;AACxH;AACA;AACA,uBAAuB,UAAU;AACjC;AACA,sBAAsB,0BAA0B;AAChD;AACA,iBAAiB,YAAY,0BAA0B;AACvD;AACA,iBAAiB,YAAY,0BAA0B;AACvD;AACA,iBAAiB,YAAY,0BAA0B;AACvD;AACA,iBAAiB,YAAY,0BAA0B;AACvD;AACA,iBAAiB,YAAY,0BAA0B;AACvD;AACA,iBAAiB,YAAY,0BAA0B;AACvD;AACA,iBAAiB,YAAY,0BAA0B;AACvD;AACA,iBAAiB,YAAY,0BAA0B;AACvD;AACA,iBAAiB,YAAY,0BAA0B;AACvD;AACA,iBAAiB,YAAY,2BAA2B;AACxD;AACA,iBAAiB,YAAY,2BAA2B;AACxD;AACA,iBAAiB,YAAY,2BAA2B;AACxD;AACA,iBAAiB,YAAY,2BAA2B;AACxD;AACA,iBAAiB,YAAY,2BAA2B;AACxD;AACA,iBAAiB,YAAY,2BAA2B;AACxD;AACA;AACA;AACA,aAAa;AACb,0BAA0B,UAAU,GAAG,6BAA6B;AACpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,uBAAuB,qBAAqB;AAC5C,wBAAwB,EAAE;AAC1B;;AAEA;AACA;AACA,4BAA4B,EAAE;AAC9B;AACA,SAAS;AACT;AACA;AACA;;;;;;;;;;;;;;;;;ACxJA;AAC6C;;AAE7C;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,WAAW;AACvE,2BAA2B,UAAU;AACrC;AACA;AACA;AACA,0FAA0F,UAAU;AACpG;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrDkD;AAClD;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAAmE,EAAE;;AAErE;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAuE,EAAE;;AAEzE;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAAmE,EAAE;;AAErE;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAAmE,EAAE;;AAErE;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAAmE,EAAE;;AAErE;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAuE,EAAE;;AAEzE;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAAmE,EAAE;;AAErE;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,0EAAiF,EAAE,oBAAoB,EAAE;;AAEzG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAgE,EAAE;;AAElE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAA2E,EAAE;;AAE7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY;AACZ;AACA;AACA;AACA;AACA,wBAAwB;AACxB,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAuE,EAAE;;AAEzE;AACA;AACA;AACA;AACA;AACA,mBAAmB,IAAI;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2EAA2E,YAAY;AACvF;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvSkC;AAClC;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8BAA8B,EAAE,UAAU,EAAE,UAAU,EAAE;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,EAAE,UAAU,EAAE,UAAU,EAAE;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,eAAe,cAAc,wCAAwC,cAAc,cAAc;AAC/G;AACA;AACA,uBAAuB;AACvB,qBAAqB,aAAa,sBAAsB,WAAW;AACnE;;AAEA;AACA,uBAAuB;AACvB,OAAO,eAAe,2BAA2B,mBAAmB;AACpE;;AAEA;AACA,uBAAuB;AACvB,eAAe,OAAO,OAAO,cAAc;AAC3C;;AAEA;AACA,uBAAuB;AACvB,OAAO,MAAM;AACb;;AAEA;AACA,uBAAuB;AACvB,OAAO,IAAI;AACX;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B;AAC3B,WAAW,UAAU;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,uCAAuC,oBAAoB,qBAAqB,eAAe;AAC/F;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;ACtMA;AACA;AACuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,YAAY;AACvB,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;;ACxGA;AACuB;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,SAAS;AACrC,4BAA4B,SAAS;AACrC,4BAA4B,SAAS;AACrC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACxEA;AACiB;;AAEjB;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uEAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACpCA;AACA;AACuB;AACG;AAC1B;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAkB,gGAAgE,EAAE;AACpF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,iBAAiB;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,cAAc;AACtE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,cAAc;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL,+CAA+C,qBAAqB;AACpE;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA,2CAA2C,qBAAqB;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mCAAmC,OAAO;AAC1C;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AC/RA,s0B;;;;;;;;;;;ACAA,uN;;;;;;;;;;;ACAA,2a;;;;;;;;;;;ACAA,yX;;;;;;;;;;;ACAA,2K;;;;;;;;;;;ACAA,yO;;;;;;;;;;;ACAA,8Z;;;;;;;;;;;ACAA,4b;;;;;;;;;;;ACAA,qW;;;;;;;;;;;ACAA,0P;;;;;;;;;;;ACAA,6b;;;;;;;;;;;ACAA,2R;;;;;;;;;;;ACAA,sM;;;;;;;;;;;ACAA,gO;;;;;;;;;;;ACAA,oL;;;;;;;;;;;ACAA,2U;;;;;;;;;;;ACAA,4T;;;;;;;;;;;ACAA,sS;;;;;;;;;;;;;;;;;;;ACAA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEQ;;;;;;;;;;;;;;;;;;;;AC5ER;AACA;;AAEA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO,4BAA4B,KAAK;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEQ;;;;;;;;;;;;;;;ACtDR;AACA;AACA;AACA;AACA,kCAAkC,wBAAwB;AAC1D;AACA,qDAAqD,6BAA6B;AAClF;AACA,QAAQ,wBAAwB,kCAAkC,2BAA2B,GAAG,uBAAuB,KAAK,2BAA2B;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AChBA;AACA;AACoC;AACI;;AAExC,8CAA8C,KAAK;;AAEnD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B,KAAK;AACjC;AACA;AACA;;;;;;;;;;;;;;;;;AChDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACpCA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,wCAAwC;AAClG;AACA;AACA,yBAAyB,oDAAoD;AAC7E;AACA;AACA,2HAA2H,wDAAwD;AACnL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO,6BAA6B,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,cAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;AACA;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,wCAAwC,qDAAqD;AAC7F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,2BAA2B;AAClD;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;;AAEA,yFAAuC,2EAA2E;;AAElH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kEAAkE,aAAa;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kEAAkE,aAAa;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kEAAkE,aAAa;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,sCAAsC,4BAA4B;AAClE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA,uBAAuB,2BAA2B;AAClD;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC;AACvC;AACA;AACA;;AAEA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC;AACrC;AACA;AACA;AACA,mIAAiF,WAAW,IAAI,KAAK;AACrG;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA,6FAA8C,WAAW;AACzD,8EAAsC,wFAAyC;AAC/E;;AAEA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB,iBAAiB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA,uGAAwD,2CAA2C;AACnG;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA,wBAAwB;AACxB,mHAA2E,2EAA4B,aAAa,EAAE;AACtH;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;ACveqB;AACrB;AACsC;AACtC;AACA;AACA;AACoB;AACpB;AACA;;AAEA;AACA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,OAAO;AACpB,cAAc,OAAO;AACrB,cAAc,SAAS,+GAA+G,EAAE;AACxI,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,WAAW;AAC1B;AACA;AACA,wDAAwD,mCAAmC;AAC3F,sCAAsC,OAAO,EAAE,EAAE,EAAE,EAAE,EAAE,EAAE;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sHAAoE,8EAA8E;AAClJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;;AAEA;AACA,6GAA6G,yCAAyC;AACtJ;;AAEA;;AAEA;AACA,wCAAwC,sBAAsB;AAC9D;;AAEA,eAAe,sCAAsC;AACrD;AACA;;AAEA;AACA;;AAEA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,4BAA4B;AAC3C,uBAAuB,qBAAqB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,0BAA0B;AACpG;AACA;AACA;AACA;;AAEA,gBAAgB;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA,4FAA4F,SAAS,mBAAmB,OAAO;AAC/H;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,kCAAkC;AACzD;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,uBAAuB,0BAA0B;AACjD;AACA;AACA;;AAEA,gBAAgB;AAChB;;AAEA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0EAA0E,aAAa,gBAAgB,6CAA6C,mEAAmE,cAAc;AACrO;AACA;AACA,SAAS;AACT;AACA,0EAA0E,aAAa,gBAAgB,6CAA6C,mEAAmE,cAAc;AACrO;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,mFAAmF,qBAAqB;AACxG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AC5QA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,qCAAqC,gDAAgD;AACrF;AACA;AACA,yBAAyB,oDAAoD;AAC7E;AACA;AACA,2HAA2H,wDAAwD;AACnL;AACA;AACA,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO;AACtB,eAAe,OAAO,6BAA6B,KAAK;AACxD;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AC1EA;AACiB;;AAEjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAwB,UAAU;AAClC,+BAA+B,EAAE,GAAG,EAAE,GAAG,EAAE;AAC3C;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA,iBAAiB;AACjB,SAAS;AACT;;AAEA;AACA;AACA,4DAA4D,EAAE,gBAAgB,EAAE,gBAAgB,EAAE;AAClG;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5EwB;;AAExB;AACA;;AAEA;AACA;AACA,SAAS,6CAA6C;AACtD,SAAS,6CAA6C;AACtD,SAAS,6CAA6C;AACtD,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,OAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C,uBAAuB,qBAAqB;AAC5C;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AC5GA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,UAAU;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;ACvJA;AAAA;AACA;AACA;;AAEA;AACA;AACA,oCAA2C;AAC3C,uBAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,YAAY;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,mBAAmB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"carto-vl.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"carto\"] = factory();\n\telse\n\t\troot[\"carto\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","'use strict';\n\nmodule.exports = Point;\n\n/**\n * A standalone point geometry with useful accessor, comparison, and\n * modification methods.\n *\n * @class Point\n * @param {Number} x the x-coordinate. this could be longitude or screen\n * pixels, or any other sort of unit.\n * @param {Number} y the y-coordinate. this could be latitude or screen\n * pixels, or any other sort of unit.\n * @example\n * var point = new Point(-77, 38);\n */\nfunction Point(x, y) {\n    this.x = x;\n    this.y = y;\n}\n\nPoint.prototype = {\n\n    /**\n     * Clone this point, returning a new point that can be modified\n     * without affecting the old one.\n     * @return {Point} the clone\n     */\n    clone: function() { return new Point(this.x, this.y); },\n\n    /**\n     * Add this point's x & y coordinates to another point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    add:     function(p) { return this.clone()._add(p); },\n\n    /**\n     * Subtract this point's x & y coordinates to from point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    sub:     function(p) { return this.clone()._sub(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    multByPoint:    function(p) { return this.clone()._multByPoint(p); },\n\n    /**\n     * Divide this point's x & y coordinates by point,\n     * yielding a new point.\n     * @param {Point} p the other point\n     * @return {Point} output point\n     */\n    divByPoint:     function(p) { return this.clone()._divByPoint(p); },\n\n    /**\n     * Multiply this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {Point} k factor\n     * @return {Point} output point\n     */\n    mult:    function(k) { return this.clone()._mult(k); },\n\n    /**\n     * Divide this point's x & y coordinates by a factor,\n     * yielding a new point.\n     * @param {Point} k factor\n     * @return {Point} output point\n     */\n    div:     function(k) { return this.clone()._div(k); },\n\n    /**\n     * Rotate this point around the 0, 0 origin by an angle a,\n     * given in radians\n     * @param {Number} a angle to rotate around, in radians\n     * @return {Point} output point\n     */\n    rotate:  function(a) { return this.clone()._rotate(a); },\n\n    /**\n     * Rotate this point around p point by an angle a,\n     * given in radians\n     * @param {Number} a angle to rotate around, in radians\n     * @param {Point} p Point to rotate around\n     * @return {Point} output point\n     */\n    rotateAround:  function(a,p) { return this.clone()._rotateAround(a,p); },\n\n    /**\n     * Multiply this point by a 4x1 transformation matrix\n     * @param {Array<Number>} m transformation matrix\n     * @return {Point} output point\n     */\n    matMult: function(m) { return this.clone()._matMult(m); },\n\n    /**\n     * Calculate this point but as a unit vector from 0, 0, meaning\n     * that the distance from the resulting point to the 0, 0\n     * coordinate will be equal to 1 and the angle from the resulting\n     * point to the 0, 0 coordinate will be the same as before.\n     * @return {Point} unit vector point\n     */\n    unit:    function() { return this.clone()._unit(); },\n\n    /**\n     * Compute a perpendicular point, where the new y coordinate\n     * is the old x coordinate and the new x coordinate is the old y\n     * coordinate multiplied by -1\n     * @return {Point} perpendicular point\n     */\n    perp:    function() { return this.clone()._perp(); },\n\n    /**\n     * Return a version of this point with the x & y coordinates\n     * rounded to integers.\n     * @return {Point} rounded point\n     */\n    round:   function() { return this.clone()._round(); },\n\n    /**\n     * Return the magitude of this point: this is the Euclidean\n     * distance from the 0, 0 coordinate to this point's x and y\n     * coordinates.\n     * @return {Number} magnitude\n     */\n    mag: function() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    },\n\n    /**\n     * Judge whether this point is equal to another point, returning\n     * true or false.\n     * @param {Point} other the other point\n     * @return {boolean} whether the points are equal\n     */\n    equals: function(other) {\n        return this.x === other.x &&\n               this.y === other.y;\n    },\n\n    /**\n     * Calculate the distance from this point to another point\n     * @param {Point} p the other point\n     * @return {Number} distance\n     */\n    dist: function(p) {\n        return Math.sqrt(this.distSqr(p));\n    },\n\n    /**\n     * Calculate the distance from this point to another point,\n     * without the square root step. Useful if you're comparing\n     * relative distances.\n     * @param {Point} p the other point\n     * @return {Number} distance\n     */\n    distSqr: function(p) {\n        var dx = p.x - this.x,\n            dy = p.y - this.y;\n        return dx * dx + dy * dy;\n    },\n\n    /**\n     * Get the angle from the 0, 0 coordinate to this point, in radians\n     * coordinates.\n     * @return {Number} angle\n     */\n    angle: function() {\n        return Math.atan2(this.y, this.x);\n    },\n\n    /**\n     * Get the angle from this point to another point, in radians\n     * @param {Point} b the other point\n     * @return {Number} angle\n     */\n    angleTo: function(b) {\n        return Math.atan2(this.y - b.y, this.x - b.x);\n    },\n\n    /**\n     * Get the angle between this point and another point, in radians\n     * @param {Point} b the other point\n     * @return {Number} angle\n     */\n    angleWith: function(b) {\n        return this.angleWithSep(b.x, b.y);\n    },\n\n    /*\n     * Find the angle of the two vectors, solving the formula for\n     * the cross product a x b = |a||b|sin() for .\n     * @param {Number} x the x-coordinate\n     * @param {Number} y the y-coordinate\n     * @return {Number} the angle in radians\n     */\n    angleWithSep: function(x, y) {\n        return Math.atan2(\n            this.x * y - this.y * x,\n            this.x * x + this.y * y);\n    },\n\n    _matMult: function(m) {\n        var x = m[0] * this.x + m[1] * this.y,\n            y = m[2] * this.x + m[3] * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _add: function(p) {\n        this.x += p.x;\n        this.y += p.y;\n        return this;\n    },\n\n    _sub: function(p) {\n        this.x -= p.x;\n        this.y -= p.y;\n        return this;\n    },\n\n    _mult: function(k) {\n        this.x *= k;\n        this.y *= k;\n        return this;\n    },\n\n    _div: function(k) {\n        this.x /= k;\n        this.y /= k;\n        return this;\n    },\n\n    _multByPoint: function(p) {\n        this.x *= p.x;\n        this.y *= p.y;\n        return this;\n    },\n\n    _divByPoint: function(p) {\n        this.x /= p.x;\n        this.y /= p.y;\n        return this;\n    },\n\n    _unit: function() {\n        this._div(this.mag());\n        return this;\n    },\n\n    _perp: function() {\n        var y = this.y;\n        this.y = this.x;\n        this.x = -y;\n        return this;\n    },\n\n    _rotate: function(angle) {\n        var cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = cos * this.x - sin * this.y,\n            y = sin * this.x + cos * this.y;\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _rotateAround: function(angle, p) {\n        var cos = Math.cos(angle),\n            sin = Math.sin(angle),\n            x = p.x + cos * (this.x - p.x) - sin * (this.y - p.y),\n            y = p.y + sin * (this.x - p.x) + cos * (this.y - p.y);\n        this.x = x;\n        this.y = y;\n        return this;\n    },\n\n    _round: function() {\n        this.x = Math.round(this.x);\n        this.y = Math.round(this.y);\n        return this;\n    }\n};\n\n/**\n * Construct a point from an array if necessary, otherwise if the input\n * is already a Point, or an unknown type, return it unchanged\n * @param {Array<Number>|Point|*} a any kind of input value\n * @return {Point} constructed point, or passed-through value.\n * @example\n * // this\n * var point = Point.convert([0, 1]);\n * // is equivalent to\n * var point = new Point(0, 1);\n */\nPoint.convert = function (a) {\n    if (a instanceof Point) {\n        return a;\n    }\n    if (Array.isArray(a)) {\n        return new Point(a[0], a[1]);\n    }\n    return a;\n};\n","module.exports.VectorTile = require('./lib/vectortile.js');\nmodule.exports.VectorTileFeature = require('./lib/vectortilefeature.js');\nmodule.exports.VectorTileLayer = require('./lib/vectortilelayer.js');\n","'use strict';\n\nvar VectorTileLayer = require('./vectortilelayer');\n\nmodule.exports = VectorTile;\n\nfunction VectorTile(pbf, end) {\n    this.layers = pbf.readFields(readTile, {}, end);\n}\n\nfunction readTile(tag, layers, pbf) {\n    if (tag === 3) {\n        var layer = new VectorTileLayer(pbf, pbf.readVarint() + pbf.pos);\n        if (layer.length) layers[layer.name] = layer;\n    }\n}\n\n","'use strict';\n\nvar Point = require('@mapbox/point-geometry');\n\nmodule.exports = VectorTileFeature;\n\nfunction VectorTileFeature(pbf, end, extent, keys, values) {\n    // Public\n    this.properties = {};\n    this.extent = extent;\n    this.type = 0;\n\n    // Private\n    this._pbf = pbf;\n    this._geometry = -1;\n    this._keys = keys;\n    this._values = values;\n\n    pbf.readFields(readFeature, this, end);\n}\n\nfunction readFeature(tag, feature, pbf) {\n    if (tag == 1) feature.id = pbf.readVarint();\n    else if (tag == 2) readTag(pbf, feature);\n    else if (tag == 3) feature.type = pbf.readVarint();\n    else if (tag == 4) feature._geometry = pbf.pos;\n}\n\nfunction readTag(pbf, feature) {\n    var end = pbf.readVarint() + pbf.pos;\n\n    while (pbf.pos < end) {\n        var key = feature._keys[pbf.readVarint()],\n            value = feature._values[pbf.readVarint()];\n        feature.properties[key] = value;\n    }\n}\n\nVectorTileFeature.types = ['Unknown', 'Point', 'LineString', 'Polygon'];\n\nVectorTileFeature.prototype.loadGeometry = function() {\n    var pbf = this._pbf;\n    pbf.pos = this._geometry;\n\n    var end = pbf.readVarint() + pbf.pos,\n        cmd = 1,\n        length = 0,\n        x = 0,\n        y = 0,\n        lines = [],\n        line;\n\n    while (pbf.pos < end) {\n        if (length <= 0) {\n            var cmdLen = pbf.readVarint();\n            cmd = cmdLen & 0x7;\n            length = cmdLen >> 3;\n        }\n\n        length--;\n\n        if (cmd === 1 || cmd === 2) {\n            x += pbf.readSVarint();\n            y += pbf.readSVarint();\n\n            if (cmd === 1) { // moveTo\n                if (line) lines.push(line);\n                line = [];\n            }\n\n            line.push(new Point(x, y));\n\n        } else if (cmd === 7) {\n\n            // Workaround for https://github.com/mapbox/mapnik-vector-tile/issues/90\n            if (line) {\n                line.push(line[0].clone()); // closePolygon\n            }\n\n        } else {\n            throw new Error('unknown command ' + cmd);\n        }\n    }\n\n    if (line) lines.push(line);\n\n    return lines;\n};\n\nVectorTileFeature.prototype.bbox = function() {\n    var pbf = this._pbf;\n    pbf.pos = this._geometry;\n\n    var end = pbf.readVarint() + pbf.pos,\n        cmd = 1,\n        length = 0,\n        x = 0,\n        y = 0,\n        x1 = Infinity,\n        x2 = -Infinity,\n        y1 = Infinity,\n        y2 = -Infinity;\n\n    while (pbf.pos < end) {\n        if (length <= 0) {\n            var cmdLen = pbf.readVarint();\n            cmd = cmdLen & 0x7;\n            length = cmdLen >> 3;\n        }\n\n        length--;\n\n        if (cmd === 1 || cmd === 2) {\n            x += pbf.readSVarint();\n            y += pbf.readSVarint();\n            if (x < x1) x1 = x;\n            if (x > x2) x2 = x;\n            if (y < y1) y1 = y;\n            if (y > y2) y2 = y;\n\n        } else if (cmd !== 7) {\n            throw new Error('unknown command ' + cmd);\n        }\n    }\n\n    return [x1, y1, x2, y2];\n};\n\nVectorTileFeature.prototype.toGeoJSON = function(x, y, z) {\n    var size = this.extent * Math.pow(2, z),\n        x0 = this.extent * x,\n        y0 = this.extent * y,\n        coords = this.loadGeometry(),\n        type = VectorTileFeature.types[this.type],\n        i, j;\n\n    function project(line) {\n        for (var j = 0; j < line.length; j++) {\n            var p = line[j], y2 = 180 - (p.y + y0) * 360 / size;\n            line[j] = [\n                (p.x + x0) * 360 / size - 180,\n                360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90\n            ];\n        }\n    }\n\n    switch (this.type) {\n    case 1:\n        var points = [];\n        for (i = 0; i < coords.length; i++) {\n            points[i] = coords[i][0];\n        }\n        coords = points;\n        project(coords);\n        break;\n\n    case 2:\n        for (i = 0; i < coords.length; i++) {\n            project(coords[i]);\n        }\n        break;\n\n    case 3:\n        coords = classifyRings(coords);\n        for (i = 0; i < coords.length; i++) {\n            for (j = 0; j < coords[i].length; j++) {\n                project(coords[i][j]);\n            }\n        }\n        break;\n    }\n\n    if (coords.length === 1) {\n        coords = coords[0];\n    } else {\n        type = 'Multi' + type;\n    }\n\n    var result = {\n        type: \"Feature\",\n        geometry: {\n            type: type,\n            coordinates: coords\n        },\n        properties: this.properties\n    };\n\n    if ('id' in this) {\n        result.id = this.id;\n    }\n\n    return result;\n};\n\n// classifies an array of rings into polygons with outer rings and holes\n\nfunction classifyRings(rings) {\n    var len = rings.length;\n\n    if (len <= 1) return [rings];\n\n    var polygons = [],\n        polygon,\n        ccw;\n\n    for (var i = 0; i < len; i++) {\n        var area = signedArea(rings[i]);\n        if (area === 0) continue;\n\n        if (ccw === undefined) ccw = area < 0;\n\n        if (ccw === area < 0) {\n            if (polygon) polygons.push(polygon);\n            polygon = [rings[i]];\n\n        } else {\n            polygon.push(rings[i]);\n        }\n    }\n    if (polygon) polygons.push(polygon);\n\n    return polygons;\n}\n\nfunction signedArea(ring) {\n    var sum = 0;\n    for (var i = 0, len = ring.length, j = len - 1, p1, p2; i < len; j = i++) {\n        p1 = ring[i];\n        p2 = ring[j];\n        sum += (p2.x - p1.x) * (p1.y + p2.y);\n    }\n    return sum;\n}\n","'use strict';\n\nvar VectorTileFeature = require('./vectortilefeature.js');\n\nmodule.exports = VectorTileLayer;\n\nfunction VectorTileLayer(pbf, end) {\n    // Public\n    this.version = 1;\n    this.name = null;\n    this.extent = 4096;\n    this.length = 0;\n\n    // Private\n    this._pbf = pbf;\n    this._keys = [];\n    this._values = [];\n    this._features = [];\n\n    pbf.readFields(readLayer, this, end);\n\n    this.length = this._features.length;\n}\n\nfunction readLayer(tag, layer, pbf) {\n    if (tag === 15) layer.version = pbf.readVarint();\n    else if (tag === 1) layer.name = pbf.readString();\n    else if (tag === 5) layer.extent = pbf.readVarint();\n    else if (tag === 2) layer._features.push(pbf.pos);\n    else if (tag === 3) layer._keys.push(pbf.readString());\n    else if (tag === 4) layer._values.push(readValueMessage(pbf));\n}\n\nfunction readValueMessage(pbf) {\n    var value = null,\n        end = pbf.readVarint() + pbf.pos;\n\n    while (pbf.pos < end) {\n        var tag = pbf.readVarint() >> 3;\n\n        value = tag === 1 ? pbf.readString() :\n            tag === 2 ? pbf.readFloat() :\n            tag === 3 ? pbf.readDouble() :\n            tag === 4 ? pbf.readVarint64() :\n            tag === 5 ? pbf.readVarint() :\n            tag === 6 ? pbf.readSVarint() :\n            tag === 7 ? pbf.readBoolean() : null;\n    }\n\n    return value;\n}\n\n// return feature `i` from this layer as a `VectorTileFeature`\nVectorTileLayer.prototype.feature = function(i) {\n    if (i < 0 || i >= this._features.length) throw new Error('feature index out of bounds');\n\n    this._pbf.pos = this._features[i];\n\n    var end = this._pbf.readVarint() + this._pbf.pos;\n    return new VectorTileFeature(this._pbf, end, this.extent, this._keys, this._values);\n};\n","!function() {\n\nvar cartocolor = {\n    \"Burg\": {\n        \"2\": [\n            \"#ffc6c4\",\n            \"#672044\"\n        ],\n        \"3\": [\n            \"#ffc6c4\",\n            \"#cc607d\",\n            \"#672044\"\n        ],\n        \"4\": [\n            \"#ffc6c4\",\n            \"#e38191\",\n            \"#ad466c\",\n            \"#672044\"\n        ],\n        \"5\": [\n            \"#ffc6c4\",\n            \"#ee919b\",\n            \"#cc607d\",\n            \"#9e3963\",\n            \"#672044\"\n        ],\n        \"6\": [\n            \"#ffc6c4\",\n            \"#f29ca3\",\n            \"#da7489\",\n            \"#b95073\",\n            \"#93345d\",\n            \"#672044\"\n        ],\n        \"7\": [\n            \"#ffc6c4\",\n            \"#f4a3a8\",\n            \"#e38191\",\n            \"#cc607d\",\n            \"#ad466c\",\n            \"#8b3058\",\n            \"#672044\"\n        ],\n        \"tags\": [\n            \"quantitative\"\n        ]\n    },\n    \"BurgYl\": {\n        \"2\": [\n            \"#fbe6c5\",\n            \"#70284a\"\n        ],\n        \"3\": [\n            \"#fbe6c5\",\n            \"#dc7176\",\n            \"#70284a\"\n        ],\n        \"4\": [\n            \"#fbe6c5\",\n            \"#ee8a82\",\n            \"#c8586c\",\n            \"#70284a\"\n        ],\n        \"5\": [\n            \"#fbe6c5\",\n            \"#f2a28a\",\n            \"#dc7176\",\n            \"#b24b65\",\n            \"#70284a\"\n        ],\n        \"6\": [\n            \"#fbe6c5\",\n            \"#f4b191\",\n            \"#e7807d\",\n            \"#d06270\",\n            \"#a44360\",\n            \"#70284a\"\n        ],\n        \"7\": [\n            \"#fbe6c5\",\n            \"#f5ba98\",\n            \"#ee8a82\",\n            \"#dc7176\",\n            \"#c8586c\",\n            \"#9c3f5d\",\n            \"#70284a\"\n        ],\n        \"tags\": [\n            \"quantitative\"\n        ]\n    },\n    \"RedOr\": {\n        \"2\": [\n            \"#f6d2a9\",\n            \"#b13f64\"\n        ],\n        \"3\": [\n            \"#f6d2a9\",\n            \"#ea8171\",\n            \"#b13f64\"\n        ],\n        \"4\": [\n            \"#f6d2a9\",\n            \"#f19c7c\",\n            \"#dd686c\",\n            \"#b13f64\"\n        ],\n        \"5\": [\n            \"#f6d2a9\",\n            \"#f3aa84\",\n            \"#ea8171\",\n            \"#d55d6a\",\n            \"#b13f64\"\n        ],\n        \"6\": [\n            \"#f6d2a9\",\n            \"#f4b28a\",\n            \"#ef9177\",\n            \"#e3726d\",\n            \"#cf5669\",\n            \"#b13f64\"\n        ],\n        \"7\": [\n            \"#f6d2a9\",\n            \"#f5b78e\",\n            \"#f19c7c\",\n            \"#ea8171\",\n            \"#dd686c\",\n            \"#ca5268\",\n            \"#b13f64\"\n        ],\n        \"tags\": [\n            \"quantitative\"\n        ]\n    },\n    \"OrYel\": {\n        \"2\": [\n            \"#ecda9a\",\n            \"#ee4d5a\"\n        ],\n        \"3\": [\n            \"#ecda9a\",\n            \"#f7945d\",\n            \"#ee4d5a\"\n        ],\n        \"4\": [\n            \"#ecda9a\",\n            \"#f3ad6a\",\n            \"#f97b57\",\n            \"#ee4d5a\"\n        ],\n        \"5\": [\n            \"#ecda9a\",\n            \"#f1b973\",\n            \"#f7945d\",\n            \"#f86f56\",\n            \"#ee4d5a\"\n        ],\n        \"6\": [\n            \"#ecda9a\",\n            \"#f0c079\",\n            \"#f5a363\",\n            \"#f98558\",\n            \"#f76856\",\n            \"#ee4d5a\"\n        ],\n        \"7\": [\n            \"#ecda9a\",\n            \"#efc47e\",\n            \"#f3ad6a\",\n            \"#f7945d\",\n            \"#f97b57\",\n            \"#f66356\",\n            \"#ee4d5a\"\n        ],\n        \"tags\": [\n            \"quantitative\"\n        ]\n    },\n    \"Peach\": {\n        \"2\": [\n            \"#fde0c5\",\n            \"#eb4a40\"\n        ],\n        \"3\": [\n            \"#fde0c5\",\n            \"#f59e72\",\n            \"#eb4a40\"\n        ],\n        \"4\": [\n            \"#fde0c5\",\n            \"#f8b58b\",\n            \"#f2855d\",\n            \"#eb4a40\"\n        ],\n        \"5\": [\n            \"#fde0c5\",\n            \"#f9c098\",\n            \"#f59e72\",\n            \"#f17854\",\n            \"#eb4a40\"\n        ],\n        \"6\": [\n            \"#fde0c5\",\n            \"#fac7a1\",\n            \"#f7ac80\",\n            \"#f38f65\",\n            \"#f0704f\",\n            \"#eb4a40\"\n        ],\n        \"7\": [\n            \"#fde0c5\",\n            \"#facba6\",\n            \"#f8b58b\",\n            \"#f59e72\",\n            \"#f2855d\",\n            \"#ef6a4c\",\n            \"#eb4a40\"\n        ],\n        \"tags\": [\n            \"quantitative\"\n        ]\n    },\n    \"PinkYl\": {\n        \"2\": [\n            \"#fef6b5\",\n            \"#e15383\"\n        ],\n        \"3\": [\n            \"#fef6b5\",\n            \"#ffa679\",\n            \"#e15383\"\n        ],\n        \"4\": [\n            \"#fef6b5\",\n            \"#ffc285\",\n            \"#fa8a76\",\n            \"#e15383\"\n        ],\n        \"5\": [\n            \"#fef6b5\",\n            \"#ffd08e\",\n            \"#ffa679\",\n            \"#f67b77\",\n            \"#e15383\"\n        ],\n        \"6\": [\n            \"#fef6b5\",\n            \"#ffd795\",\n            \"#ffb77f\",\n            \"#fd9576\",\n            \"#f37378\",\n            \"#e15383\"\n        ],\n        \"7\": [\n            \"#fef6b5\",\n            \"#ffdd9a\",\n            \"#ffc285\",\n            \"#ffa679\",\n            \"#fa8a76\",\n            \"#f16d7a\",\n            \"#e15383\"\n        ],\n        \"tags\": [\n            \"quantitative\"\n        ]\n    },\n    \"Mint\": {\n        \"2\": [\n            \"#e4f1e1\",\n            \"#0d585f\"\n        ],\n        \"3\": [\n            \"#e4f1e1\",\n            \"#63a6a0\",\n            \"#0d585f\"\n        ],\n        \"4\": [\n            \"#e4f1e1\",\n            \"#89c0b6\",\n            \"#448c8a\",\n            \"#0d585f\"\n        ],\n        \"5\": [\n            \"#E4F1E1\",\n            \"#9CCDC1\",\n            \"#63A6A0\",\n            \"#337F7F\",\n            \"#0D585F\"\n        ],\n        \"6\": [\n            \"#e4f1e1\",\n            \"#abd4c7\",\n            \"#7ab5ad\",\n            \"#509693\",\n            \"#2c7778\",\n            \"#0d585f\"\n        ],\n        \"7\": [\n            \"#e4f1e1\",\n            \"#b4d9cc\",\n            \"#89c0b6\",\n            \"#63a6a0\",\n            \"#448c8a\",\n            \"#287274\",\n            \"#0d585f\"\n        ],\n        \"tags\": [\n            \"quantitative\"\n        ]\n    },\n    \"BluGrn\": {\n        \"2\": [\n            \"#c4e6c3\",\n            \"#1d4f60\"\n        ],\n        \"3\": [\n            \"#c4e6c3\",\n            \"#4da284\",\n            \"#1d4f60\"\n        ],\n        \"4\": [\n            \"#c4e6c3\",\n            \"#6dbc90\",\n            \"#36877a\",\n            \"#1d4f60\"\n        ],\n        \"5\": [\n            \"#c4e6c3\",\n            \"#80c799\",\n            \"#4da284\",\n            \"#2d7974\",\n            \"#1d4f60\"\n        ],\n        \"6\": [\n            \"#c4e6c3\",\n            \"#8dce9f\",\n            \"#5fb28b\",\n            \"#3e927e\",\n            \"#297071\",\n            \"#1d4f60\"\n        ],\n        \"7\": [\n            \"#c4e6c3\",\n            \"#96d2a4\",\n            \"#6dbc90\",\n            \"#4da284\",\n            \"#36877a\",\n            \"#266b6e\",\n            \"#1d4f60\"\n        ],\n        \"tags\": [\n            \"quantitative\"\n        ]\n    },\n    \"DarkMint\": {\n        \"2\": [\n            \"#d2fbd4\",\n            \"#123f5a\"\n        ],\n        \"3\": [\n            \"#d2fbd4\",\n            \"#559c9e\",\n            \"#123f5a\"\n        ],\n        \"4\": [\n            \"#d2fbd4\",\n            \"#7bbcb0\",\n            \"#3a7c89\",\n            \"#123f5a\"\n        ],\n        \"5\": [\n            \"#d2fbd4\",\n            \"#8eccb9\",\n            \"#559c9e\",\n            \"#2b6c7f\",\n            \"#123f5a\"\n        ],\n        \"6\": [\n            \"#d2fbd4\",\n            \"#9cd5be\",\n            \"#6cafa9\",\n            \"#458892\",\n            \"#266377\",\n            \"#123f5a\"\n        ],\n        \"7\": [\n            \"#d2fbd4\",\n            \"#a5dbc2\",\n            \"#7bbcb0\",\n            \"#559c9e\",\n            \"#3a7c89\",\n            \"#235d72\",\n            \"#123f5a\"\n        ],\n        \"tags\": [\n            \"quantitative\"\n        ]\n    },\n    \"Emrld\": {\n        \"2\": [\n            \"#d3f2a3\",\n            \"#074050\"\n        ],\n        \"3\": [\n            \"#d3f2a3\",\n            \"#4c9b82\",\n            \"#074050\"\n        ],\n        \"4\": [\n            \"#d3f2a3\",\n            \"#6cc08b\",\n            \"#217a79\",\n            \"#074050\"\n        ],\n        \"5\": [\n            \"#d3f2a3\",\n            \"#82d091\",\n            \"#4c9b82\",\n            \"#19696f\",\n            \"#074050\"\n        ],\n        \"6\": [\n            \"#d3f2a3\",\n            \"#8fda94\",\n            \"#60b187\",\n            \"#35877d\",\n            \"#145f69\",\n            \"#074050\"\n        ],\n        \"7\": [\n            \"#d3f2a3\",\n            \"#97e196\",\n            \"#6cc08b\",\n            \"#4c9b82\",\n            \"#217a79\",\n            \"#105965\",\n            \"#074050\"\n        ],\n        \"tags\": [\n            \"quantitative\"\n        ]\n    },\n    \"ag_GrnYl\": {\n        \"2\": [\n            \"#245668\",\n            \"#EDEF5D\"\n        ],\n        \"3\": [\n            \"#245668\",\n            \"#39AB7E\",\n            \"#EDEF5D\"\n        ],\n        \"4\": [\n            \"#245668\",\n            \"#0D8F81\",\n            \"#6EC574\",\n            \"#EDEF5D\"\n        ],\n        \"5\": [\n            \"#245668\",\n            \"#04817E\",\n            \"#39AB7E\",\n            \"#8BD16D\",\n            \"#EDEF5D\"\n        ],\n        \"6\": [\n            \"#245668\",\n            \"#09787C\",\n            \"#1D9A81\",\n            \"#58BB79\",\n            \"#9DD869\",\n            \"#EDEF5D\"\n        ],\n        \"7\": [\n            \"#245668\",\n            \"#0F7279\",\n            \"#0D8F81\",\n            \"#39AB7E\",\n            \"#6EC574\",\n            \"#A9DC67\",\n            \"#EDEF5D\"\n        ],\n        \"tags\": [\n            \"aggregation\"\n        ]\n    },\n    \"BluYl\": {\n        \"2\": [\n            \"#f7feae\",\n            \"#045275\"\n        ],\n        \"3\": [\n            \"#f7feae\",\n            \"#46aea0\",\n            \"#045275\"\n        ],\n        \"4\": [\n            \"#f7feae\",\n            \"#7ccba2\",\n            \"#089099\",\n            \"#045275\"\n        ],\n        \"5\": [\n            \"#f7feae\",\n            \"#9bd8a4\",\n            \"#46aea0\",\n            \"#058092\",\n            \"#045275\"\n        ],\n        \"6\": [\n            \"#f7feae\",\n            \"#ace1a4\",\n            \"#68bfa1\",\n            \"#2a9c9c\",\n            \"#02778e\",\n            \"#045275\"\n        ],\n        \"7\": [\n            \"#f7feae\",\n            \"#b7e6a5\",\n            \"#7ccba2\",\n            \"#46aea0\",\n            \"#089099\",\n            \"#00718b\",\n            \"#045275\"\n        ],\n        \"tags\": [\n            \"quantitative\"\n        ]\n    },\n    \"Teal\": {\n        \"2\": [\n            \"#d1eeea\",\n            \"#2a5674\"\n        ],\n        \"3\": [\n            \"#d1eeea\",\n            \"#68abb8\",\n            \"#2a5674\"\n        ],\n        \"4\": [\n            \"#d1eeea\",\n            \"#85c4c9\",\n            \"#4f90a6\",\n            \"#2a5674\"\n        ],\n        \"5\": [\n            \"#d1eeea\",\n            \"#96d0d1\",\n            \"#68abb8\",\n            \"#45829b\",\n            \"#2a5674\"\n        ],\n        \"6\": [\n            \"#d1eeea\",\n            \"#a1d7d6\",\n            \"#79bbc3\",\n            \"#599bae\",\n            \"#3f7994\",\n            \"#2a5674\"\n        ],\n        \"7\": [\n            \"#d1eeea\",\n            \"#a8dbd9\",\n            \"#85c4c9\",\n            \"#68abb8\",\n            \"#4f90a6\",\n            \"#3b738f\",\n            \"#2a5674\"\n        ],\n        \"tags\": [\n            \"quantitative\"\n        ]\n    },\n    \"TealGrn\": {\n        \"2\": [\n            \"#b0f2bc\",\n            \"#257d98\"\n        ],\n        \"3\": [\n            \"#b0f2bc\",\n            \"#4cc8a3\",\n            \"#257d98\"\n        ],\n        \"4\": [\n            \"#b0f2bc\",\n            \"#67dba5\",\n            \"#38b2a3\",\n            \"#257d98\"\n        ],\n        \"5\": [\n            \"#b0f2bc\",\n            \"#77e2a8\",\n            \"#4cc8a3\",\n            \"#31a6a2\",\n            \"#257d98\"\n        ],\n        \"6\": [\n            \"#b0f2bc\",\n            \"#82e6aa\",\n            \"#5bd4a4\",\n            \"#3fbba3\",\n            \"#2e9ea1\",\n            \"#257d98\"\n        ],\n        \"7\": [\n            \"#b0f2bc\",\n            \"#89e8ac\",\n            \"#67dba5\",\n            \"#4cc8a3\",\n            \"#38b2a3\",\n            \"#2c98a0\",\n            \"#257d98\"\n        ],\n        \"tags\": [\n            \"quantitative\"\n        ]\n    },\n    \"Purp\": {\n        \"2\": [\n            \"#f3e0f7\",\n            \"#63589f\"\n        ],\n        \"3\": [\n            \"#f3e0f7\",\n            \"#b998dd\",\n            \"#63589f\"\n        ],\n        \"4\": [\n            \"#f3e0f7\",\n            \"#d1afe8\",\n            \"#9f82ce\",\n            \"#63589f\"\n        ],\n        \"5\": [\n            \"#f3e0f7\",\n            \"#dbbaed\",\n            \"#b998dd\",\n            \"#9178c4\",\n            \"#63589f\"\n        ],\n        \"6\": [\n            \"#f3e0f7\",\n            \"#e0c2ef\",\n            \"#c8a5e4\",\n            \"#aa8bd4\",\n            \"#8871be\",\n            \"#63589f\"\n        ],\n        \"7\": [\n            \"#f3e0f7\",\n            \"#e4c7f1\",\n            \"#d1afe8\",\n            \"#b998dd\",\n            \"#9f82ce\",\n            \"#826dba\",\n            \"#63589f\"\n        ],\n        \"tags\": [\n            \"quantitative\"\n        ]\n    },\n    \"PurpOr\": {\n        \"3\": [\n            \"#f9ddda\",\n            \"#ce78b3\",\n            \"#573b88\"\n        ],\n        \"4\": [\n            \"#f9ddda\",\n            \"#e597b9\",\n            \"#ad5fad\",\n            \"#573b88\"\n        ],\n        \"5\": [\n            \"#f9ddda\",\n            \"#eda8bd\",\n            \"#ce78b3\",\n            \"#9955a8\",\n            \"#573b88\"\n        ],\n        \"6\": [\n            \"#f9ddda\",\n            \"#f0b2c1\",\n            \"#dd8ab6\",\n            \"#bb69b0\",\n            \"#8c4fa4\",\n            \"#573b88\"\n        ],\n        \"7\": [\n            \"#f9ddda\",\n            \"#f2b9c4\",\n            \"#e597b9\",\n            \"#ce78b3\",\n            \"#ad5fad\",\n            \"#834ba0\",\n            \"#573b88\"\n        ],\n        \"tags\": [\n            \"quantitative\"\n        ]\n    },\n    \"Sunset\": {\n        \"2\": [\n            \"#f3e79b\",\n            \"#5c53a5\"\n        ],\n        \"3\": [\n            \"#f3e79b\",\n            \"#eb7f86\",\n            \"#5c53a5\"\n        ],\n        \"4\": [\n            \"#f3e79b\",\n            \"#f8a07e\",\n            \"#ce6693\",\n            \"#5c53a5\"\n        ],\n        \"5\": [\n            \"#f3e79b\",\n            \"#fab27f\",\n            \"#eb7f86\",\n            \"#b95e9a\",\n            \"#5c53a5\"\n        ],\n        \"6\": [\n            \"#f3e79b\",\n            \"#fabc82\",\n            \"#f59280\",\n            \"#dc6f8e\",\n            \"#ab5b9e\",\n            \"#5c53a5\"\n        ],\n        \"7\": [\n            \"#f3e79b\",\n            \"#fac484\",\n            \"#f8a07e\",\n            \"#eb7f86\",\n            \"#ce6693\",\n            \"#a059a0\",\n            \"#5c53a5\"\n        ],\n        \"tags\": [\n            \"quantitative\"\n        ]\n    },\n    \"Magenta\": {\n        \"2\": [\n            \"#f3cbd3\",\n            \"#6c2167\"\n        ],\n        \"3\": [\n            \"#f3cbd3\",\n            \"#ca699d\",\n            \"#6c2167\"\n        ],\n        \"4\": [\n            \"#f3cbd3\",\n            \"#dd88ac\",\n            \"#b14d8e\",\n            \"#6c2167\"\n        ],\n        \"5\": [\n            \"#f3cbd3\",\n            \"#e498b4\",\n            \"#ca699d\",\n            \"#a24186\",\n            \"#6c2167\"\n        ],\n        \"6\": [\n            \"#f3cbd3\",\n            \"#e7a2b9\",\n            \"#d67ba5\",\n            \"#bc5894\",\n            \"#983a81\",\n            \"#6c2167\"\n        ],\n        \"7\": [\n            \"#f3cbd3\",\n            \"#eaa9bd\",\n            \"#dd88ac\",\n            \"#ca699d\",\n            \"#b14d8e\",\n            \"#91357d\",\n            \"#6c2167\"\n        ],\n        \"tags\": [\n            \"quantitative\"\n        ]\n    },\n    \"SunsetDark\": {\n        \"2\": [\n            \"#fcde9c\",\n            \"#7c1d6f\"\n        ],\n        \"3\": [\n            \"#fcde9c\",\n            \"#e34f6f\",\n            \"#7c1d6f\"\n        ],\n        \"4\": [\n            \"#fcde9c\",\n            \"#f0746e\",\n            \"#dc3977\",\n            \"#7c1d6f\"\n        ],\n        \"5\": [\n            \"#fcde9c\",\n            \"#f58670\",\n            \"#e34f6f\",\n            \"#d72d7c\",\n            \"#7c1d6f\"\n        ],\n        \"6\": [\n            \"#fcde9c\",\n            \"#f89872\",\n            \"#ec666d\",\n            \"#df4273\",\n            \"#c5287b\",\n            \"#7c1d6f\"\n        ],\n        \"7\": [\n            \"#fcde9c\",\n            \"#faa476\",\n            \"#f0746e\",\n            \"#e34f6f\",\n            \"#dc3977\",\n            \"#b9257a\",\n            \"#7c1d6f\"\n        ],\n        \"tags\": [\n            \"quantitative\"\n        ]\n    },\n    \"ag_Sunset\": {\n        \"2\": [\n            \"#4b2991\",\n            \"#edd9a3\"\n        ],\n        \"3\": [\n            \"#4b2991\",\n            \"#ea4f88\",\n            \"#edd9a3\"\n        ],\n        \"4\": [\n            \"#4b2991\",\n            \"#c0369d\",\n            \"#fa7876\",\n            \"#edd9a3\"\n        ],\n        \"5\": [\n            \"#4b2991\",\n            \"#a52fa2\",\n            \"#ea4f88\",\n            \"#fa9074\",\n            \"#edd9a3\"\n        ],\n        \"6\": [\n            \"#4b2991\",\n            \"#932da3\",\n            \"#d43f96\",\n            \"#f7667c\",\n            \"#f89f77\",\n            \"#edd9a3\"\n        ],\n        \"7\": [\n            \"#4b2991\",\n            \"#872ca2\",\n            \"#c0369d\",\n            \"#ea4f88\",\n            \"#fa7876\",\n            \"#f6a97a\",\n            \"#edd9a3\"\n        ],\n        \"tags\": [\n            \"aggregation\"\n        ]\n    },\n    \"BrwnYl\": {\n        \"2\": [\n            \"#ede5cf\",\n            \"#541f3f\"\n        ],\n        \"3\": [\n            \"#ede5cf\",\n            \"#c1766f\",\n            \"#541f3f\"\n        ],\n        \"4\": [\n            \"#ede5cf\",\n            \"#d39c83\",\n            \"#a65461\",\n            \"#541f3f\"\n        ],\n        \"5\": [\n            \"#ede5cf\",\n            \"#daaf91\",\n            \"#c1766f\",\n            \"#95455a\",\n            \"#541f3f\"\n        ],\n        \"6\": [\n            \"#ede5cf\",\n            \"#ddba9b\",\n            \"#cd8c7a\",\n            \"#b26166\",\n            \"#8a3c56\",\n            \"#541f3f\"\n        ],\n        \"7\": [\n            \"#ede5cf\",\n            \"#e0c2a2\",\n            \"#d39c83\",\n            \"#c1766f\",\n            \"#a65461\",\n            \"#813753\",\n            \"#541f3f\"\n        ],\n        \"tags\": [\n            \"quantitative\"\n        ]\n    },\n    \"ArmyRose\": {\n        \"2\": [\n            \"#929b4f\",\n            \"#db8195\"\n        ],\n        \"3\": [\n            \"#a3ad62\",\n            \"#fdfbe4\",\n            \"#df91a3\"\n        ],\n        \"4\": [\n            \"#929b4f\",\n            \"#d9dbaf\",\n            \"#f3d1ca\",\n            \"#db8195\"\n        ],\n        \"5\": [\n            \"#879043\",\n            \"#c1c68c\",\n            \"#fdfbe4\",\n            \"#ebb4b8\",\n            \"#d8758b\"\n        ],\n        \"6\": [\n            \"#7f883b\",\n            \"#b0b874\",\n            \"#e3e4be\",\n            \"#f6ddd1\",\n            \"#e4a0ac\",\n            \"#d66d85\"\n        ],\n        \"7\": [\n            \"#798234\",\n            \"#a3ad62\",\n            \"#d0d3a2\",\n            \"#fdfbe4\",\n            \"#f0c6c3\",\n            \"#df91a3\",\n            \"#d46780\"\n        ],\n        \"tags\": [\n            \"diverging\"\n        ]\n    },\n    \"Fall\": {\n        \"2\": [\n            \"#3d5941\",\n            \"#ca562c\"\n        ],\n        \"3\": [\n            \"#3d5941\",\n            \"#f6edbd\",\n            \"#ca562c\"\n        ],\n        \"4\": [\n            \"#3d5941\",\n            \"#b5b991\",\n            \"#edbb8a\",\n            \"#ca562c\"\n        ],\n        \"5\": [\n            \"#3d5941\",\n            \"#96a07c\",\n            \"#f6edbd\",\n            \"#e6a272\",\n            \"#ca562c\"\n        ],\n        \"6\": [\n            \"#3d5941\",\n            \"#839170\",\n            \"#cecea2\",\n            \"#f1cf9e\",\n            \"#e19464\",\n            \"#ca562c\"\n        ],\n        \"7\": [\n            \"#3d5941\",\n            \"#778868\",\n            \"#b5b991\",\n            \"#f6edbd\",\n            \"#edbb8a\",\n            \"#de8a5a\",\n            \"#ca562c\"\n        ],\n        \"tags\": [\n            \"diverging\"\n        ]\n    },\n    \"Geyser\": {\n        \"2\": [\n            \"#008080\",\n            \"#ca562c\"\n        ],\n        \"3\": [\n            \"#008080\",\n            \"#f6edbd\",\n            \"#ca562c\"\n        ],\n        \"4\": [\n            \"#008080\",\n            \"#b4c8a8\",\n            \"#edbb8a\",\n            \"#ca562c\"\n        ],\n        \"5\": [\n            \"#008080\",\n            \"#92b69e\",\n            \"#f6edbd\",\n            \"#e6a272\",\n            \"#ca562c\"\n        ],\n        \"6\": [\n            \"#008080\",\n            \"#7eab98\",\n            \"#ced7b1\",\n            \"#f1cf9e\",\n            \"#e19464\",\n            \"#ca562c\"\n        ],\n        \"7\": [\n            \"#008080\",\n            \"#70a494\",\n            \"#b4c8a8\",\n            \"#f6edbd\",\n            \"#edbb8a\",\n            \"#de8a5a\",\n            \"#ca562c\"\n        ],\n        \"tags\": [\n            \"diverging\"\n        ]\n    },\n    \"Temps\": {\n        \"2\": [\n            \"#009392\",\n            \"#cf597e\"\n        ],\n        \"3\": [\n            \"#009392\",\n            \"#e9e29c\",\n            \"#cf597e\"\n        ],\n        \"4\": [\n            \"#009392\",\n            \"#9ccb86\",\n            \"#eeb479\",\n            \"#cf597e\"\n        ],\n        \"5\": [\n            \"#009392\",\n            \"#71be83\",\n            \"#e9e29c\",\n            \"#ed9c72\",\n            \"#cf597e\"\n        ],\n        \"6\": [\n            \"#009392\",\n            \"#52b684\",\n            \"#bcd48c\",\n            \"#edc783\",\n            \"#eb8d71\",\n            \"#cf597e\"\n        ],\n        \"7\": [\n            \"#009392\",\n            \"#39b185\",\n            \"#9ccb86\",\n            \"#e9e29c\",\n            \"#eeb479\",\n            \"#e88471\",\n            \"#cf597e\"\n        ],\n        \"tags\": [\n            \"diverging\"\n        ]\n    },\n    \"TealRose\": {\n        \"2\": [\n            \"#009392\",\n            \"#d0587e\"\n        ],\n        \"3\": [\n            \"#009392\",\n            \"#f1eac8\",\n            \"#d0587e\"\n        ],\n        \"4\": [\n            \"#009392\",\n            \"#91b8aa\",\n            \"#f1eac8\",\n            \"#dfa0a0\",\n            \"#d0587e\"\n        ],\n        \"5\": [\n            \"#009392\",\n            \"#91b8aa\",\n            \"#f1eac8\",\n            \"#dfa0a0\",\n            \"#d0587e\"\n        ],\n        \"6\": [\n            \"#009392\",\n            \"#72aaa1\",\n            \"#b1c7b3\",\n            \"#e5b9ad\",\n            \"#d98994\",\n            \"#d0587e\"\n        ],\n        \"7\": [\n            \"#009392\",\n            \"#72aaa1\",\n            \"#b1c7b3\",\n            \"#f1eac8\",\n            \"#e5b9ad\",\n            \"#d98994\",\n            \"#d0587e\"\n        ],\n        \"tags\": [\n            \"diverging\"\n        ]\n    },\n    \"Tropic\": {\n        \"2\": [\n            \"#009B9E\",\n            \"#C75DAB\"\n        ],\n        \"3\": [\n            \"#009B9E\",\n            \"#F1F1F1\",\n            \"#C75DAB\"\n        ],\n        \"4\": [\n            \"#009B9E\",\n            \"#A7D3D4\",\n            \"#E4C1D9\",\n            \"#C75DAB\"\n        ],\n        \"5\": [\n            \"#009B9E\",\n            \"#7CC5C6\",\n            \"#F1F1F1\",\n            \"#DDA9CD\",\n            \"#C75DAB\"\n        ],\n        \"6\": [\n            \"#009B9E\",\n            \"#5DBCBE\",\n            \"#C6DFDF\",\n            \"#E9D4E2\",\n            \"#D99BC6\",\n            \"#C75DAB\"\n        ],\n        \"7\": [\n            \"#009B9E\",\n            \"#42B7B9\",\n            \"#A7D3D4\",\n            \"#F1F1F1\",\n            \"#E4C1D9\",\n            \"#D691C1\",\n            \"#C75DAB\"\n        ],\n        \"tags\": [\n            \"diverging\"\n        ]\n    },\n    \"Earth\": {\n        \"2\": [\n            \"#A16928\",\n            \"#2887a1\"\n        ],\n        \"3\": [\n            \"#A16928\",\n            \"#edeac2\",\n            \"#2887a1\"\n        ],\n        \"4\": [\n            \"#A16928\",\n            \"#d6bd8d\",\n            \"#b5c8b8\",\n            \"#2887a1\"\n        ],\n        \"5\": [\n            \"#A16928\",\n            \"#caa873\",\n            \"#edeac2\",\n            \"#98b7b2\",\n            \"#2887a1\"\n        ],\n        \"6\": [\n            \"#A16928\",\n            \"#c29b64\",\n            \"#e0cfa2\",\n            \"#cbd5bc\",\n            \"#85adaf\",\n            \"#2887a1\"\n        ],\n        \"7\": [\n            \"#A16928\",\n            \"#bd925a\",\n            \"#d6bd8d\",\n            \"#edeac2\",\n            \"#b5c8b8\",\n            \"#79a7ac\",\n            \"#2887a1\"\n        ],\n        \"tags\": [\n            \"diverging\"\n        ]\n    },\n    \"Antique\": {\n        \"2\": [\n            \"#855C75\",\n            \"#D9AF6B\",\n            \"#7C7C7C\"\n        ],\n        \"3\": [\n            \"#855C75\",\n            \"#D9AF6B\",\n            \"#AF6458\",\n            \"#7C7C7C\"\n        ],\n        \"4\": [\n            \"#855C75\",\n            \"#D9AF6B\",\n            \"#AF6458\",\n            \"#736F4C\",\n            \"#7C7C7C\"\n        ],\n        \"5\": [\n            \"#855C75\",\n            \"#D9AF6B\",\n            \"#AF6458\",\n            \"#736F4C\",\n            \"#526A83\",\n            \"#7C7C7C\"\n        ],\n        \"6\": [\n            \"#855C75\",\n            \"#D9AF6B\",\n            \"#AF6458\",\n            \"#736F4C\",\n            \"#526A83\",\n            \"#625377\",\n            \"#7C7C7C\"\n        ],\n        \"7\": [\n            \"#855C75\",\n            \"#D9AF6B\",\n            \"#AF6458\",\n            \"#736F4C\",\n            \"#526A83\",\n            \"#625377\",\n            \"#68855C\",\n            \"#7C7C7C\"\n        ],\n        \"8\": [\n            \"#855C75\",\n            \"#D9AF6B\",\n            \"#AF6458\",\n            \"#736F4C\",\n            \"#526A83\",\n            \"#625377\",\n            \"#68855C\",\n            \"#9C9C5E\",\n            \"#7C7C7C\"\n        ],\n        \"9\": [\n            \"#855C75\",\n            \"#D9AF6B\",\n            \"#AF6458\",\n            \"#736F4C\",\n            \"#526A83\",\n            \"#625377\",\n            \"#68855C\",\n            \"#9C9C5E\",\n            \"#A06177\",\n            \"#7C7C7C\"\n        ],\n        \"10\": [\n            \"#855C75\",\n            \"#D9AF6B\",\n            \"#AF6458\",\n            \"#736F4C\",\n            \"#526A83\",\n            \"#625377\",\n            \"#68855C\",\n            \"#9C9C5E\",\n            \"#A06177\",\n            \"#8C785D\",\n            \"#7C7C7C\"\n        ],\n        \"11\": [\n            \"#855C75\",\n            \"#D9AF6B\",\n            \"#AF6458\",\n            \"#736F4C\",\n            \"#526A83\",\n            \"#625377\",\n            \"#68855C\",\n            \"#9C9C5E\",\n            \"#A06177\",\n            \"#8C785D\",\n            \"#467378\",\n            \"#7C7C7C\"\n        ],\n        \"tags\": [\n            \"qualitative\"\n        ]\n    },\n    \"Bold\": {\n        \"2\": [\n            \"#7F3C8D\",\n            \"#11A579\",\n            \"#A5AA99\"\n        ],\n        \"3\": [\n            \"#7F3C8D\",\n            \"#11A579\",\n            \"#3969AC\",\n            \"#A5AA99\"\n        ],\n        \"4\": [\n            \"#7F3C8D\",\n            \"#11A579\",\n            \"#3969AC\",\n            \"#F2B701\",\n            \"#A5AA99\"\n        ],\n        \"5\": [\n            \"#7F3C8D\",\n            \"#11A579\",\n            \"#3969AC\",\n            \"#F2B701\",\n            \"#E73F74\",\n            \"#A5AA99\"\n        ],\n        \"6\": [\n            \"#7F3C8D\",\n            \"#11A579\",\n            \"#3969AC\",\n            \"#F2B701\",\n            \"#E73F74\",\n            \"#80BA5A\",\n            \"#A5AA99\"\n        ],\n        \"7\": [\n            \"#7F3C8D\",\n            \"#11A579\",\n            \"#3969AC\",\n            \"#F2B701\",\n            \"#E73F74\",\n            \"#80BA5A\",\n            \"#E68310\",\n            \"#A5AA99\"\n        ],\n        \"8\": [\n            \"#7F3C8D\",\n            \"#11A579\",\n            \"#3969AC\",\n            \"#F2B701\",\n            \"#E73F74\",\n            \"#80BA5A\",\n            \"#E68310\",\n            \"#008695\",\n            \"#A5AA99\"\n        ],\n        \"9\": [\n            \"#7F3C8D\",\n            \"#11A579\",\n            \"#3969AC\",\n            \"#F2B701\",\n            \"#E73F74\",\n            \"#80BA5A\",\n            \"#E68310\",\n            \"#008695\",\n            \"#CF1C90\",\n            \"#A5AA99\"\n        ],\n        \"10\": [\n            \"#7F3C8D\",\n            \"#11A579\",\n            \"#3969AC\",\n            \"#F2B701\",\n            \"#E73F74\",\n            \"#80BA5A\",\n            \"#E68310\",\n            \"#008695\",\n            \"#CF1C90\",\n            \"#f97b72\",\n            \"#A5AA99\"\n        ],\n        \"11\": [\n            \"#7F3C8D\",\n            \"#11A579\",\n            \"#3969AC\",\n            \"#F2B701\",\n            \"#E73F74\",\n            \"#80BA5A\",\n            \"#E68310\",\n            \"#008695\",\n            \"#CF1C90\",\n            \"#f97b72\",\n            \"#4b4b8f\",\n            \"#A5AA99\"\n        ],\n        \"tags\": [\n            \"qualitative\"\n        ]\n    },\n    \"Pastel\": {\n        \"2\": [\n            \"#66C5CC\",\n            \"#F6CF71\",\n            \"#B3B3B3\"\n        ],\n        \"3\": [\n            \"#66C5CC\",\n            \"#F6CF71\",\n            \"#F89C74\",\n            \"#B3B3B3\"\n        ],\n        \"4\": [\n            \"#66C5CC\",\n            \"#F6CF71\",\n            \"#F89C74\",\n            \"#DCB0F2\",\n            \"#B3B3B3\"\n        ],\n        \"5\": [\n            \"#66C5CC\",\n            \"#F6CF71\",\n            \"#F89C74\",\n            \"#DCB0F2\",\n            \"#87C55F\",\n            \"#B3B3B3\"\n        ],\n        \"6\": [\n            \"#66C5CC\",\n            \"#F6CF71\",\n            \"#F89C74\",\n            \"#DCB0F2\",\n            \"#87C55F\",\n            \"#9EB9F3\",\n            \"#B3B3B3\"\n        ],\n        \"7\": [\n            \"#66C5CC\",\n            \"#F6CF71\",\n            \"#F89C74\",\n            \"#DCB0F2\",\n            \"#87C55F\",\n            \"#9EB9F3\",\n            \"#FE88B1\",\n            \"#B3B3B3\"\n        ],\n        \"8\": [\n            \"#66C5CC\",\n            \"#F6CF71\",\n            \"#F89C74\",\n            \"#DCB0F2\",\n            \"#87C55F\",\n            \"#9EB9F3\",\n            \"#FE88B1\",\n            \"#C9DB74\",\n            \"#B3B3B3\"\n        ],\n        \"9\": [\n            \"#66C5CC\",\n            \"#F6CF71\",\n            \"#F89C74\",\n            \"#DCB0F2\",\n            \"#87C55F\",\n            \"#9EB9F3\",\n            \"#FE88B1\",\n            \"#C9DB74\",\n            \"#8BE0A4\",\n            \"#B3B3B3\"\n        ],\n        \"10\": [\n            \"#66C5CC\",\n            \"#F6CF71\",\n            \"#F89C74\",\n            \"#DCB0F2\",\n            \"#87C55F\",\n            \"#9EB9F3\",\n            \"#FE88B1\",\n            \"#C9DB74\",\n            \"#8BE0A4\",\n            \"#B497E7\",\n            \"#B3B3B3\"\n        ],\n        \"11\": [\n            \"#66C5CC\",\n            \"#F6CF71\",\n            \"#F89C74\",\n            \"#DCB0F2\",\n            \"#87C55F\",\n            \"#9EB9F3\",\n            \"#FE88B1\",\n            \"#C9DB74\",\n            \"#8BE0A4\",\n            \"#B497E7\",\n            \"#D3B484\",\n            \"#B3B3B3\"\n        ],\n        \"tags\": [\n            \"qualitative\"\n        ]\n    },\n    \"Prism\": {\n        \"2\": [\n            \"#5F4690\",\n            \"#1D6996\",\n            \"#666666\"\n        ],\n        \"3\": [\n            \"#5F4690\",\n            \"#1D6996\",\n            \"#38A6A5\",\n            \"#666666\"\n        ],\n        \"4\": [\n            \"#5F4690\",\n            \"#1D6996\",\n            \"#38A6A5\",\n            \"#0F8554\",\n            \"#666666\"\n        ],\n        \"5\": [\n            \"#5F4690\",\n            \"#1D6996\",\n            \"#38A6A5\",\n            \"#0F8554\",\n            \"#73AF48\",\n            \"#666666\"\n        ],\n        \"6\": [\n            \"#5F4690\",\n            \"#1D6996\",\n            \"#38A6A5\",\n            \"#0F8554\",\n            \"#73AF48\",\n            \"#EDAD08\",\n            \"#666666\"\n        ],\n        \"7\": [\n            \"#5F4690\",\n            \"#1D6996\",\n            \"#38A6A5\",\n            \"#0F8554\",\n            \"#73AF48\",\n            \"#EDAD08\",\n            \"#E17C05\",\n            \"#666666\"\n        ],\n        \"8\": [\n            \"#5F4690\",\n            \"#1D6996\",\n            \"#38A6A5\",\n            \"#0F8554\",\n            \"#73AF48\",\n            \"#EDAD08\",\n            \"#E17C05\",\n            \"#CC503E\",\n            \"#666666\"\n        ],\n        \"9\": [\n            \"#5F4690\",\n            \"#1D6996\",\n            \"#38A6A5\",\n            \"#0F8554\",\n            \"#73AF48\",\n            \"#EDAD08\",\n            \"#E17C05\",\n            \"#CC503E\",\n            \"#94346E\",\n            \"#666666\"\n        ],\n        \"10\": [\n            \"#5F4690\",\n            \"#1D6996\",\n            \"#38A6A5\",\n            \"#0F8554\",\n            \"#73AF48\",\n            \"#EDAD08\",\n            \"#E17C05\",\n            \"#CC503E\",\n            \"#94346E\",\n            \"#6F4070\",\n            \"#666666\"\n        ],\n        \"11\": [\n            \"#5F4690\",\n            \"#1D6996\",\n            \"#38A6A5\",\n            \"#0F8554\",\n            \"#73AF48\",\n            \"#EDAD08\",\n            \"#E17C05\",\n            \"#CC503E\",\n            \"#94346E\",\n            \"#6F4070\",\n            \"#994E95\",\n            \"#666666\"\n        ],\n        \"tags\": [\n            \"qualitative\"\n        ]\n    },\n    \"Safe\": {\n        \"2\": [\n            \"#88CCEE\",\n            \"#CC6677\",\n            \"#888888\"\n        ],\n        \"3\": [\n            \"#88CCEE\",\n            \"#CC6677\",\n            \"#DDCC77\",\n            \"#888888\"\n        ],\n        \"4\": [\n            \"#88CCEE\",\n            \"#CC6677\",\n            \"#DDCC77\",\n            \"#117733\",\n            \"#888888\"\n        ],\n        \"5\": [\n            \"#88CCEE\",\n            \"#CC6677\",\n            \"#DDCC77\",\n            \"#117733\",\n            \"#332288\",\n            \"#888888\"\n        ],\n        \"6\": [\n            \"#88CCEE\",\n            \"#CC6677\",\n            \"#DDCC77\",\n            \"#117733\",\n            \"#332288\",\n            \"#AA4499\",\n            \"#888888\"\n        ],\n        \"7\": [\n            \"#88CCEE\",\n            \"#CC6677\",\n            \"#DDCC77\",\n            \"#117733\",\n            \"#332288\",\n            \"#AA4499\",\n            \"#44AA99\",\n            \"#888888\"\n        ],\n        \"8\": [\n            \"#88CCEE\",\n            \"#CC6677\",\n            \"#DDCC77\",\n            \"#117733\",\n            \"#332288\",\n            \"#AA4499\",\n            \"#44AA99\",\n            \"#999933\",\n            \"#888888\"\n        ],\n        \"9\": [\n            \"#88CCEE\",\n            \"#CC6677\",\n            \"#DDCC77\",\n            \"#117733\",\n            \"#332288\",\n            \"#AA4499\",\n            \"#44AA99\",\n            \"#999933\",\n            \"#882255\",\n            \"#888888\"\n        ],\n        \"10\": [\n            \"#88CCEE\",\n            \"#CC6677\",\n            \"#DDCC77\",\n            \"#117733\",\n            \"#332288\",\n            \"#AA4499\",\n            \"#44AA99\",\n            \"#999933\",\n            \"#882255\",\n            \"#661100\",\n            \"#888888\"\n        ],\n        \"11\": [\n            \"#88CCEE\",\n            \"#CC6677\",\n            \"#DDCC77\",\n            \"#117733\",\n            \"#332288\",\n            \"#AA4499\",\n            \"#44AA99\",\n            \"#999933\",\n            \"#882255\",\n            \"#661100\",\n            \"#6699CC\",\n            \"#888888\"\n        ],\n        \"tags\": [\n            \"qualitative\",\n            \"colorblind\"\n        ]\n    },\n    \"Vivid\": {\n        \"2\": [\n            \"#E58606\",\n            \"#5D69B1\",\n            \"#A5AA99\"\n        ],\n        \"3\": [\n            \"#E58606\",\n            \"#5D69B1\",\n            \"#52BCA3\",\n            \"#A5AA99\"\n        ],\n        \"4\": [\n            \"#E58606\",\n            \"#5D69B1\",\n            \"#52BCA3\",\n            \"#99C945\",\n            \"#A5AA99\"\n        ],\n        \"5\": [\n            \"#E58606\",\n            \"#5D69B1\",\n            \"#52BCA3\",\n            \"#99C945\",\n            \"#CC61B0\",\n            \"#A5AA99\"\n        ],\n        \"6\": [\n            \"#E58606\",\n            \"#5D69B1\",\n            \"#52BCA3\",\n            \"#99C945\",\n            \"#CC61B0\",\n            \"#24796C\",\n            \"#A5AA99\"\n        ],\n        \"7\": [\n            \"#E58606\",\n            \"#5D69B1\",\n            \"#52BCA3\",\n            \"#99C945\",\n            \"#CC61B0\",\n            \"#24796C\",\n            \"#DAA51B\",\n            \"#A5AA99\"\n        ],\n        \"8\": [\n            \"#E58606\",\n            \"#5D69B1\",\n            \"#52BCA3\",\n            \"#99C945\",\n            \"#CC61B0\",\n            \"#24796C\",\n            \"#DAA51B\",\n            \"#2F8AC4\",\n            \"#A5AA99\"\n        ],\n        \"9\": [\n            \"#E58606\",\n            \"#5D69B1\",\n            \"#52BCA3\",\n            \"#99C945\",\n            \"#CC61B0\",\n            \"#24796C\",\n            \"#DAA51B\",\n            \"#2F8AC4\",\n            \"#764E9F\",\n            \"#A5AA99\"\n        ],\n        \"10\": [\n            \"#E58606\",\n            \"#5D69B1\",\n            \"#52BCA3\",\n            \"#99C945\",\n            \"#CC61B0\",\n            \"#24796C\",\n            \"#DAA51B\",\n            \"#2F8AC4\",\n            \"#764E9F\",\n            \"#ED645A\",\n            \"#A5AA99\"\n        ],\n        \"11\": [\n            \"#E58606\",\n            \"#5D69B1\",\n            \"#52BCA3\",\n            \"#99C945\",\n            \"#CC61B0\",\n            \"#24796C\",\n            \"#DAA51B\",\n            \"#2F8AC4\",\n            \"#764E9F\",\n            \"#ED645A\",\n            \"#CC3A8E\",\n            \"#A5AA99\"\n        ],\n        \"tags\": [\n            \"qualitative\"\n        ]\n    }\n};\n\nvar colorbrewer_tags = {\n  \"Blues\": { \"tags\": [\"quantitative\"] },\n  \"BrBG\": { \"tags\": [\"diverging\"] },\n  \"Greys\": { \"tags\": [\"quantitative\"] },\n  \"PiYG\": { \"tags\": [\"diverging\"] },\n  \"PRGn\": { \"tags\": [\"diverging\"] },\n  \"Purples\": { \"tags\": [\"quantitative\"] },\n  \"RdYlGn\": { \"tags\": [\"diverging\"] },\n  \"Spectral\": { \"tags\": [\"diverging\"] },\n  \"YlOrBr\": { \"tags\": [\"quantitative\"] },\n  \"YlGn\": { \"tags\": [\"quantitative\"] },\n  \"YlGnBu\": { \"tags\": [\"quantitative\"] },\n  \"YlOrRd\": { \"tags\": [\"quantitative\"] }\n}\n\nvar colorbrewer = require('colorbrewer');\n\n// augment colorbrewer with tags\nfor (var r in colorbrewer) {\n  var ramps = colorbrewer[r];\n  var augmentedRamps = {};\n  for (var i in ramps) {\n    augmentedRamps[i] = ramps[i];\n  }\n\n  if (r in colorbrewer_tags) {\n    augmentedRamps.tags = colorbrewer_tags[r].tags;\n  }\n\n  cartocolor['cb_' + r] = augmentedRamps;\n}\n\nif (typeof define === \"function\" && define.amd) {\n    define(cartocolor);\n} else if (typeof module === \"object\" && module.exports) {\n    module.exports = cartocolor;\n} else {\n    this.colorbrewer = cartocolor;\n}\n\n}();\n","module.exports = require('./cartocolor');\n","// This product includes color specifications and designs developed by Cynthia Brewer (http://colorbrewer.org/).\n// JavaScript specs as packaged in the D3 library (d3js.org). Please see license at http://colorbrewer.org/export/LICENSE.txt\n!function() {\n\nvar colorbrewer = {YlGn: {\n3: [\"#f7fcb9\",\"#addd8e\",\"#31a354\"],\n4: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#238443\"],\n5: [\"#ffffcc\",\"#c2e699\",\"#78c679\",\"#31a354\",\"#006837\"],\n6: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#31a354\",\"#006837\"],\n7: [\"#ffffcc\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n8: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#005a32\"],\n9: [\"#ffffe5\",\"#f7fcb9\",\"#d9f0a3\",\"#addd8e\",\"#78c679\",\"#41ab5d\",\"#238443\",\"#006837\",\"#004529\"]\n},YlGnBu: {\n3: [\"#edf8b1\",\"#7fcdbb\",\"#2c7fb8\"],\n4: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#225ea8\"],\n5: [\"#ffffcc\",\"#a1dab4\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n6: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#2c7fb8\",\"#253494\"],\n7: [\"#ffffcc\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n8: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#0c2c84\"],\n9: [\"#ffffd9\",\"#edf8b1\",\"#c7e9b4\",\"#7fcdbb\",\"#41b6c4\",\"#1d91c0\",\"#225ea8\",\"#253494\",\"#081d58\"]\n},GnBu: {\n3: [\"#e0f3db\",\"#a8ddb5\",\"#43a2ca\"],\n4: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#2b8cbe\"],\n5: [\"#f0f9e8\",\"#bae4bc\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n6: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#43a2ca\",\"#0868ac\"],\n7: [\"#f0f9e8\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n8: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#08589e\"],\n9: [\"#f7fcf0\",\"#e0f3db\",\"#ccebc5\",\"#a8ddb5\",\"#7bccc4\",\"#4eb3d3\",\"#2b8cbe\",\"#0868ac\",\"#084081\"]\n},BuGn: {\n3: [\"#e5f5f9\",\"#99d8c9\",\"#2ca25f\"],\n4: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#238b45\"],\n5: [\"#edf8fb\",\"#b2e2e2\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n6: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#2ca25f\",\"#006d2c\"],\n7: [\"#edf8fb\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n8: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#005824\"],\n9: [\"#f7fcfd\",\"#e5f5f9\",\"#ccece6\",\"#99d8c9\",\"#66c2a4\",\"#41ae76\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},PuBuGn: {\n3: [\"#ece2f0\",\"#a6bddb\",\"#1c9099\"],\n4: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#02818a\"],\n5: [\"#f6eff7\",\"#bdc9e1\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n6: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#1c9099\",\"#016c59\"],\n7: [\"#f6eff7\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n8: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016450\"],\n9: [\"#fff7fb\",\"#ece2f0\",\"#d0d1e6\",\"#a6bddb\",\"#67a9cf\",\"#3690c0\",\"#02818a\",\"#016c59\",\"#014636\"]\n},PuBu: {\n3: [\"#ece7f2\",\"#a6bddb\",\"#2b8cbe\"],\n4: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#0570b0\"],\n5: [\"#f1eef6\",\"#bdc9e1\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n6: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#2b8cbe\",\"#045a8d\"],\n7: [\"#f1eef6\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n8: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#034e7b\"],\n9: [\"#fff7fb\",\"#ece7f2\",\"#d0d1e6\",\"#a6bddb\",\"#74a9cf\",\"#3690c0\",\"#0570b0\",\"#045a8d\",\"#023858\"]\n},BuPu: {\n3: [\"#e0ecf4\",\"#9ebcda\",\"#8856a7\"],\n4: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#88419d\"],\n5: [\"#edf8fb\",\"#b3cde3\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n6: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8856a7\",\"#810f7c\"],\n7: [\"#edf8fb\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n8: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#6e016b\"],\n9: [\"#f7fcfd\",\"#e0ecf4\",\"#bfd3e6\",\"#9ebcda\",\"#8c96c6\",\"#8c6bb1\",\"#88419d\",\"#810f7c\",\"#4d004b\"]\n},RdPu: {\n3: [\"#fde0dd\",\"#fa9fb5\",\"#c51b8a\"],\n4: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#ae017e\"],\n5: [\"#feebe2\",\"#fbb4b9\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n6: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#c51b8a\",\"#7a0177\"],\n7: [\"#feebe2\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n8: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\"],\n9: [\"#fff7f3\",\"#fde0dd\",\"#fcc5c0\",\"#fa9fb5\",\"#f768a1\",\"#dd3497\",\"#ae017e\",\"#7a0177\",\"#49006a\"]\n},PuRd: {\n3: [\"#e7e1ef\",\"#c994c7\",\"#dd1c77\"],\n4: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#ce1256\"],\n5: [\"#f1eef6\",\"#d7b5d8\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n6: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#dd1c77\",\"#980043\"],\n7: [\"#f1eef6\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n8: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#91003f\"],\n9: [\"#f7f4f9\",\"#e7e1ef\",\"#d4b9da\",\"#c994c7\",\"#df65b0\",\"#e7298a\",\"#ce1256\",\"#980043\",\"#67001f\"]\n},OrRd: {\n3: [\"#fee8c8\",\"#fdbb84\",\"#e34a33\"],\n4: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#d7301f\"],\n5: [\"#fef0d9\",\"#fdcc8a\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n6: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#e34a33\",\"#b30000\"],\n7: [\"#fef0d9\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n8: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#990000\"],\n9: [\"#fff7ec\",\"#fee8c8\",\"#fdd49e\",\"#fdbb84\",\"#fc8d59\",\"#ef6548\",\"#d7301f\",\"#b30000\",\"#7f0000\"]\n},YlOrRd: {\n3: [\"#ffeda0\",\"#feb24c\",\"#f03b20\"],\n4: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#e31a1c\"],\n5: [\"#ffffb2\",\"#fecc5c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n6: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#f03b20\",\"#bd0026\"],\n7: [\"#ffffb2\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n8: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#b10026\"],\n9: [\"#ffffcc\",\"#ffeda0\",\"#fed976\",\"#feb24c\",\"#fd8d3c\",\"#fc4e2a\",\"#e31a1c\",\"#bd0026\",\"#800026\"]\n},YlOrBr: {\n3: [\"#fff7bc\",\"#fec44f\",\"#d95f0e\"],\n4: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#cc4c02\"],\n5: [\"#ffffd4\",\"#fed98e\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n6: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#d95f0e\",\"#993404\"],\n7: [\"#ffffd4\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n8: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#8c2d04\"],\n9: [\"#ffffe5\",\"#fff7bc\",\"#fee391\",\"#fec44f\",\"#fe9929\",\"#ec7014\",\"#cc4c02\",\"#993404\",\"#662506\"]\n},Purples: {\n3: [\"#efedf5\",\"#bcbddc\",\"#756bb1\"],\n4: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#6a51a3\"],\n5: [\"#f2f0f7\",\"#cbc9e2\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n6: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#756bb1\",\"#54278f\"],\n7: [\"#f2f0f7\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n8: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#4a1486\"],\n9: [\"#fcfbfd\",\"#efedf5\",\"#dadaeb\",\"#bcbddc\",\"#9e9ac8\",\"#807dba\",\"#6a51a3\",\"#54278f\",\"#3f007d\"]\n},Blues: {\n3: [\"#deebf7\",\"#9ecae1\",\"#3182bd\"],\n4: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#2171b5\"],\n5: [\"#eff3ff\",\"#bdd7e7\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n6: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#3182bd\",\"#08519c\"],\n7: [\"#eff3ff\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n8: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#084594\"],\n9: [\"#f7fbff\",\"#deebf7\",\"#c6dbef\",\"#9ecae1\",\"#6baed6\",\"#4292c6\",\"#2171b5\",\"#08519c\",\"#08306b\"]\n},Greens: {\n3: [\"#e5f5e0\",\"#a1d99b\",\"#31a354\"],\n4: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#238b45\"],\n5: [\"#edf8e9\",\"#bae4b3\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n6: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#31a354\",\"#006d2c\"],\n7: [\"#edf8e9\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n8: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#005a32\"],\n9: [\"#f7fcf5\",\"#e5f5e0\",\"#c7e9c0\",\"#a1d99b\",\"#74c476\",\"#41ab5d\",\"#238b45\",\"#006d2c\",\"#00441b\"]\n},Oranges: {\n3: [\"#fee6ce\",\"#fdae6b\",\"#e6550d\"],\n4: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#d94701\"],\n5: [\"#feedde\",\"#fdbe85\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n6: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#e6550d\",\"#a63603\"],\n7: [\"#feedde\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n8: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#8c2d04\"],\n9: [\"#fff5eb\",\"#fee6ce\",\"#fdd0a2\",\"#fdae6b\",\"#fd8d3c\",\"#f16913\",\"#d94801\",\"#a63603\",\"#7f2704\"]\n},Reds: {\n3: [\"#fee0d2\",\"#fc9272\",\"#de2d26\"],\n4: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#cb181d\"],\n5: [\"#fee5d9\",\"#fcae91\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n6: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#de2d26\",\"#a50f15\"],\n7: [\"#fee5d9\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n8: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#99000d\"],\n9: [\"#fff5f0\",\"#fee0d2\",\"#fcbba1\",\"#fc9272\",\"#fb6a4a\",\"#ef3b2c\",\"#cb181d\",\"#a50f15\",\"#67000d\"]\n},Greys: {\n3: [\"#f0f0f0\",\"#bdbdbd\",\"#636363\"],\n4: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#525252\"],\n5: [\"#f7f7f7\",\"#cccccc\",\"#969696\",\"#636363\",\"#252525\"],\n6: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#636363\",\"#252525\"],\n7: [\"#f7f7f7\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n8: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\"],\n9: [\"#ffffff\",\"#f0f0f0\",\"#d9d9d9\",\"#bdbdbd\",\"#969696\",\"#737373\",\"#525252\",\"#252525\",\"#000000\"]\n},PuOr: {\n3: [\"#f1a340\",\"#f7f7f7\",\"#998ec3\"],\n4: [\"#e66101\",\"#fdb863\",\"#b2abd2\",\"#5e3c99\"],\n5: [\"#e66101\",\"#fdb863\",\"#f7f7f7\",\"#b2abd2\",\"#5e3c99\"],\n6: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n7: [\"#b35806\",\"#f1a340\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#998ec3\",\"#542788\"],\n8: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n9: [\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\"],\n10: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"],\n11: [\"#7f3b08\",\"#b35806\",\"#e08214\",\"#fdb863\",\"#fee0b6\",\"#f7f7f7\",\"#d8daeb\",\"#b2abd2\",\"#8073ac\",\"#542788\",\"#2d004b\"]\n},BrBG: {\n3: [\"#d8b365\",\"#f5f5f5\",\"#5ab4ac\"],\n4: [\"#a6611a\",\"#dfc27d\",\"#80cdc1\",\"#018571\"],\n5: [\"#a6611a\",\"#dfc27d\",\"#f5f5f5\",\"#80cdc1\",\"#018571\"],\n6: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n7: [\"#8c510a\",\"#d8b365\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#5ab4ac\",\"#01665e\"],\n8: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n9: [\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\"],\n10: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"],\n11: [\"#543005\",\"#8c510a\",\"#bf812d\",\"#dfc27d\",\"#f6e8c3\",\"#f5f5f5\",\"#c7eae5\",\"#80cdc1\",\"#35978f\",\"#01665e\",\"#003c30\"]\n},PRGn: {\n3: [\"#af8dc3\",\"#f7f7f7\",\"#7fbf7b\"],\n4: [\"#7b3294\",\"#c2a5cf\",\"#a6dba0\",\"#008837\"],\n5: [\"#7b3294\",\"#c2a5cf\",\"#f7f7f7\",\"#a6dba0\",\"#008837\"],\n6: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n7: [\"#762a83\",\"#af8dc3\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#7fbf7b\",\"#1b7837\"],\n8: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n9: [\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\"],\n10: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"],\n11: [\"#40004b\",\"#762a83\",\"#9970ab\",\"#c2a5cf\",\"#e7d4e8\",\"#f7f7f7\",\"#d9f0d3\",\"#a6dba0\",\"#5aae61\",\"#1b7837\",\"#00441b\"]\n},PiYG: {\n3: [\"#e9a3c9\",\"#f7f7f7\",\"#a1d76a\"],\n4: [\"#d01c8b\",\"#f1b6da\",\"#b8e186\",\"#4dac26\"],\n5: [\"#d01c8b\",\"#f1b6da\",\"#f7f7f7\",\"#b8e186\",\"#4dac26\"],\n6: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n7: [\"#c51b7d\",\"#e9a3c9\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#a1d76a\",\"#4d9221\"],\n8: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n9: [\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\"],\n10: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"],\n11: [\"#8e0152\",\"#c51b7d\",\"#de77ae\",\"#f1b6da\",\"#fde0ef\",\"#f7f7f7\",\"#e6f5d0\",\"#b8e186\",\"#7fbc41\",\"#4d9221\",\"#276419\"]\n},RdBu: {\n3: [\"#ef8a62\",\"#f7f7f7\",\"#67a9cf\"],\n4: [\"#ca0020\",\"#f4a582\",\"#92c5de\",\"#0571b0\"],\n5: [\"#ca0020\",\"#f4a582\",\"#f7f7f7\",\"#92c5de\",\"#0571b0\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#67a9cf\",\"#2166ac\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#f7f7f7\",\"#d1e5f0\",\"#92c5de\",\"#4393c3\",\"#2166ac\",\"#053061\"]\n},RdGy: {\n3: [\"#ef8a62\",\"#ffffff\",\"#999999\"],\n4: [\"#ca0020\",\"#f4a582\",\"#bababa\",\"#404040\"],\n5: [\"#ca0020\",\"#f4a582\",\"#ffffff\",\"#bababa\",\"#404040\"],\n6: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n7: [\"#b2182b\",\"#ef8a62\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#999999\",\"#4d4d4d\"],\n8: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n9: [\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\"],\n10: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"],\n11: [\"#67001f\",\"#b2182b\",\"#d6604d\",\"#f4a582\",\"#fddbc7\",\"#ffffff\",\"#e0e0e0\",\"#bababa\",\"#878787\",\"#4d4d4d\",\"#1a1a1a\"]\n},RdYlBu: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91bfdb\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abd9e9\",\"#2c7bb6\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abd9e9\",\"#2c7bb6\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#91bfdb\",\"#4575b4\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee090\",\"#ffffbf\",\"#e0f3f8\",\"#abd9e9\",\"#74add1\",\"#4575b4\",\"#313695\"]\n},Spectral: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#99d594\"],\n4: [\"#d7191c\",\"#fdae61\",\"#abdda4\",\"#2b83ba\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#abdda4\",\"#2b83ba\"],\n6: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n7: [\"#d53e4f\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#99d594\",\"#3288bd\"],\n8: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n9: [\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\"],\n10: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"],\n11: [\"#9e0142\",\"#d53e4f\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#e6f598\",\"#abdda4\",\"#66c2a5\",\"#3288bd\",\"#5e4fa2\"]\n},RdYlGn: {\n3: [\"#fc8d59\",\"#ffffbf\",\"#91cf60\"],\n4: [\"#d7191c\",\"#fdae61\",\"#a6d96a\",\"#1a9641\"],\n5: [\"#d7191c\",\"#fdae61\",\"#ffffbf\",\"#a6d96a\",\"#1a9641\"],\n6: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n7: [\"#d73027\",\"#fc8d59\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#91cf60\",\"#1a9850\"],\n8: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n9: [\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\"],\n10: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"],\n11: [\"#a50026\",\"#d73027\",\"#f46d43\",\"#fdae61\",\"#fee08b\",\"#ffffbf\",\"#d9ef8b\",\"#a6d96a\",\"#66bd63\",\"#1a9850\",\"#006837\"]\n},Accent: {\n3: [\"#7fc97f\",\"#beaed4\",\"#fdc086\"],\n4: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\"],\n5: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\"],\n6: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\"],\n7: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\"],\n8: [\"#7fc97f\",\"#beaed4\",\"#fdc086\",\"#ffff99\",\"#386cb0\",\"#f0027f\",\"#bf5b17\",\"#666666\"]\n},Dark2: {\n3: [\"#1b9e77\",\"#d95f02\",\"#7570b3\"],\n4: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\"],\n5: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\"],\n6: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\"],\n7: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\"],\n8: [\"#1b9e77\",\"#d95f02\",\"#7570b3\",\"#e7298a\",\"#66a61e\",\"#e6ab02\",\"#a6761d\",\"#666666\"]\n},Paired: {\n3: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\"],\n4: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\"],\n5: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\"],\n6: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\"],\n7: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\"],\n8: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\"],\n9: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\"],\n10: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\"],\n11: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\"],\n12: [\"#a6cee3\",\"#1f78b4\",\"#b2df8a\",\"#33a02c\",\"#fb9a99\",\"#e31a1c\",\"#fdbf6f\",\"#ff7f00\",\"#cab2d6\",\"#6a3d9a\",\"#ffff99\",\"#b15928\"]\n},Pastel1: {\n3: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\"],\n4: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\"],\n5: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\"],\n6: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\"],\n7: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\"],\n8: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\"],\n9: [\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\"#fddaec\",\"#f2f2f2\"]\n},Pastel2: {\n3: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\"],\n4: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\"],\n5: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\"],\n6: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\"],\n7: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\"],\n8: [\"#b3e2cd\",\"#fdcdac\",\"#cbd5e8\",\"#f4cae4\",\"#e6f5c9\",\"#fff2ae\",\"#f1e2cc\",\"#cccccc\"]\n},Set1: {\n3: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\"],\n4: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\"],\n5: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\"],\n6: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\"],\n7: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\"],\n8: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\"],\n9: [\"#e41a1c\",\"#377eb8\",\"#4daf4a\",\"#984ea3\",\"#ff7f00\",\"#ffff33\",\"#a65628\",\"#f781bf\",\"#999999\"]\n},Set2: {\n3: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\"],\n4: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\"],\n5: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\"],\n6: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\"],\n7: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\"],\n8: [\"#66c2a5\",\"#fc8d62\",\"#8da0cb\",\"#e78ac3\",\"#a6d854\",\"#ffd92f\",\"#e5c494\",\"#b3b3b3\"]\n},Set3: {\n3: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\"],\n4: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\"],\n5: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\"],\n6: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\"],\n7: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\"],\n8: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\"],\n9: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\"],\n10: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\"],\n11: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\"],\n12: [\"#8dd3c7\",\"#ffffb3\",\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#d9d9d9\",\"#bc80bd\",\"#ccebc5\",\"#ffed6f\"]\n}};\n\nif (typeof define === \"function\" && define.amd) {\n    define(colorbrewer);\n} else if (typeof module === \"object\" && module.exports) {\n    module.exports = colorbrewer;\n} else {\n    this.colorbrewer = colorbrewer;\n}\n\n}();\n","module.exports = require('./colorbrewer.js');\n","'use strict';\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertice leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(ear, triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, invSize),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return p;\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize);\n                earcutLinked(c, triangles, dim, minX, minY, invSize);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m.next;\n\n    while (p !== stop) {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    }\n\n    return m;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) * invSize;\n    y = 32767 * (y - minY) * invSize;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&\n           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    if ((equals(p1, q1) && equals(p2, q2)) ||\n        (equals(p1, q2) && equals(p2, q1))) return true;\n    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&\n           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertice index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertice nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","//     JavaScript Expression Parser (JSEP) 0.3.4\n//     JSEP may be freely distributed under the MIT License\n//     http://jsep.from.so/\n\n/*global module: true, exports: true, console: true */\n(function (root) {\n\t'use strict';\n\t// Node Types\n\t// ----------\n\n\t// This is the full set of types that any JSEP node can be.\n\t// Store them here to save space when minified\n\tvar COMPOUND = 'Compound',\n\t\tIDENTIFIER = 'Identifier',\n\t\tMEMBER_EXP = 'MemberExpression',\n\t\tLITERAL = 'Literal',\n\t\tTHIS_EXP = 'ThisExpression',\n\t\tCALL_EXP = 'CallExpression',\n\t\tUNARY_EXP = 'UnaryExpression',\n\t\tBINARY_EXP = 'BinaryExpression',\n\t\tLOGICAL_EXP = 'LogicalExpression',\n\t\tCONDITIONAL_EXP = 'ConditionalExpression',\n\t\tARRAY_EXP = 'ArrayExpression',\n\n\t\tPERIOD_CODE = 46, // '.'\n\t\tCOMMA_CODE  = 44, // ','\n\t\tSQUOTE_CODE = 39, // single quote\n\t\tDQUOTE_CODE = 34, // double quotes\n\t\tOPAREN_CODE = 40, // (\n\t\tCPAREN_CODE = 41, // )\n\t\tOBRACK_CODE = 91, // [\n\t\tCBRACK_CODE = 93, // ]\n\t\tQUMARK_CODE = 63, // ?\n\t\tSEMCOL_CODE = 59, // ;\n\t\tCOLON_CODE  = 58, // :\n\n\t\tthrowError = function(message, index) {\n\t\t\tvar error = new Error(message + ' at character ' + index);\n\t\t\terror.index = index;\n\t\t\terror.description = message;\n\t\t\tthrow error;\n\t\t},\n\n\t// Operations\n\t// ----------\n\n\t// Set `t` to `true` to save space (when minified, not gzipped)\n\t\tt = true,\n\t// Use a quickly-accessible map to store all of the unary operators\n\t// Values are set to `true` (it really doesn't matter)\n\t\tunary_ops = {'-': t, '!': t, '~': t, '+': t},\n\t// Also use a map for the binary operations but set their values to their\n\t// binary precedence for quick reference:\n\t// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)\n\t\tbinary_ops = {\n\t\t\t'||': 1, '&&': 2, '|': 3,  '^': 4,  '&': 5,\n\t\t\t'==': 6, '!=': 6, '===': 6, '!==': 6,\n\t\t\t'<': 7,  '>': 7,  '<=': 7,  '>=': 7,\n\t\t\t'<<':8,  '>>': 8, '>>>': 8,\n\t\t\t'+': 9, '-': 9,\n\t\t\t'*': 10, '/': 10, '%': 10\n\t\t},\n\t// Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)\n\t\tadditional_identifier_chars = {'$': t, '_': t},\n\t// Get return the longest key length of any object\n\t\tgetMaxKeyLen = function(obj) {\n\t\t\tvar max_len = 0, len;\n\t\t\tfor(var key in obj) {\n\t\t\t\tif((len = key.length) > max_len && obj.hasOwnProperty(key)) {\n\t\t\t\t\tmax_len = len;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn max_len;\n\t\t},\n\t\tmax_unop_len = getMaxKeyLen(unary_ops),\n\t\tmax_binop_len = getMaxKeyLen(binary_ops),\n\t// Literals\n\t// ----------\n\t// Store the values to return for the various literals we may encounter\n\t\tliterals = {\n\t\t\t'true': true,\n\t\t\t'false': false,\n\t\t\t'null': null\n\t\t},\n\t// Except for `this`, which is special. This could be changed to something like `'self'` as well\n\t\tthis_str = 'this',\n\t// Returns the precedence of a binary operator or `0` if it isn't a binary operator\n\t\tbinaryPrecedence = function(op_val) {\n\t\t\treturn binary_ops[op_val] || 0;\n\t\t},\n\t// Utility function (gets called from multiple places)\n\t// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions\n\t\tcreateBinaryExpression = function (operator, left, right) {\n\t\t\tvar type = (operator === '||' || operator === '&&') ? LOGICAL_EXP : BINARY_EXP;\n\t\t\treturn {\n\t\t\t\ttype: type,\n\t\t\t\toperator: operator,\n\t\t\t\tleft: left,\n\t\t\t\tright: right\n\t\t\t};\n\t\t},\n\t\t// `ch` is a character code in the next three functions\n\t\tisDecimalDigit = function(ch) {\n\t\t\treturn (ch >= 48 && ch <= 57); // 0...9\n\t\t},\n\t\tisIdentifierStart = function(ch) {\n\t\t\treturn  (ch >= 65 && ch <= 90) || // A...Z\n\t\t\t\t\t(ch >= 97 && ch <= 122) || // a...z\n\t\t\t\t\t(ch >= 128 && !binary_ops[String.fromCharCode(ch)]) || // any non-ASCII that is not an operator\n\t\t\t\t\t(additional_identifier_chars.hasOwnProperty(String.fromCharCode(ch))); // additional characters\n\t\t},\n\t\tisIdentifierPart = function(ch) {\n\t\t\treturn \t(ch >= 65 && ch <= 90) || // A...Z\n\t\t\t\t\t(ch >= 97 && ch <= 122) || // a...z\n\t\t\t\t\t(ch >= 48 && ch <= 57) || // 0...9\n\t\t\t\t\t(ch >= 128 && !binary_ops[String.fromCharCode(ch)])|| // any non-ASCII that is not an operator\n\t\t\t\t\t(additional_identifier_chars.hasOwnProperty(String.fromCharCode(ch))); // additional characters\n\t\t},\n\n\t\t// Parsing\n\t\t// -------\n\t\t// `expr` is a string with the passed in expression\n\t\tjsep = function(expr) {\n\t\t\t// `index` stores the character number we are currently at while `length` is a constant\n\t\t\t// All of the gobbles below will modify `index` as we move along\n\t\t\tvar index = 0,\n\t\t\t\tcharAtFunc = expr.charAt,\n\t\t\t\tcharCodeAtFunc = expr.charCodeAt,\n\t\t\t\texprI = function(i) { return charAtFunc.call(expr, i); },\n\t\t\t\texprICode = function(i) { return charCodeAtFunc.call(expr, i); },\n\t\t\t\tlength = expr.length,\n\n\t\t\t\t// Push `index` up to the next non-space character\n\t\t\t\tgobbleSpaces = function() {\n\t\t\t\t\tvar ch = exprICode(index);\n\t\t\t\t\t// space or tab\n\t\t\t\t\twhile(ch === 32 || ch === 9 || ch === 10 || ch === 13) {\n\t\t\t\t\t\tch = exprICode(++index);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// The main parsing function. Much of this code is dedicated to ternary expressions\n\t\t\t\tgobbleExpression = function() {\n\t\t\t\t\tvar test = gobbleBinaryExpression(),\n\t\t\t\t\t\tconsequent, alternate;\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tif(exprICode(index) === QUMARK_CODE) {\n\t\t\t\t\t\t// Ternary expression: test ? consequent : alternate\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tconsequent = gobbleExpression();\n\t\t\t\t\t\tif(!consequent) {\n\t\t\t\t\t\t\tthrowError('Expected expression', index);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\tif(exprICode(index) === COLON_CODE) {\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\talternate = gobbleExpression();\n\t\t\t\t\t\t\tif(!alternate) {\n\t\t\t\t\t\t\t\tthrowError('Expected expression', index);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\ttype: CONDITIONAL_EXP,\n\t\t\t\t\t\t\t\ttest: test,\n\t\t\t\t\t\t\t\tconsequent: consequent,\n\t\t\t\t\t\t\t\talternate: alternate\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrowError('Expected :', index);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn test;\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Search for the operation portion of the string (e.g. `+`, `===`)\n\t\t\t\t// Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)\n\t\t\t\t// and move down from 3 to 2 to 1 character until a matching binary operation is found\n\t\t\t\t// then, return that binary operation\n\t\t\t\tgobbleBinaryOp = function() {\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tvar biop, to_check = expr.substr(index, max_binop_len), tc_len = to_check.length;\n\t\t\t\t\twhile(tc_len > 0) {\n\t\t\t\t\t\t// Don't accept a binary op when it is an identifier.\n\t\t\t\t\t\t// Binary ops that start with a identifier-valid character must be followed\n\t\t\t\t\t\t// by a non identifier-part valid character\n\t\t\t\t\t\tif(binary_ops.hasOwnProperty(to_check) && (\n\t\t\t\t\t\t\t!isIdentifierStart(exprICode(index)) ||\n\t\t\t\t\t\t\t(index+to_check.length< expr.length && !isIdentifierPart(exprICode(index+to_check.length)))\n\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\tindex += tc_len;\n\t\t\t\t\t\t\treturn to_check;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tto_check = to_check.substr(0, --tc_len);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\n\t\t\t\t// This function is responsible for gobbling an individual expression,\n\t\t\t\t// e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`\n\t\t\t\tgobbleBinaryExpression = function() {\n\t\t\t\t\tvar ch_i, node, biop, prec, stack, biop_info, left, right, i;\n\n\t\t\t\t\t// First, try to get the leftmost thing\n\t\t\t\t\t// Then, check to see if there's a binary operator operating on that leftmost thing\n\t\t\t\t\tleft = gobbleToken();\n\t\t\t\t\tbiop = gobbleBinaryOp();\n\n\t\t\t\t\t// If there wasn't a binary operator, just return the leftmost node\n\t\t\t\t\tif(!biop) {\n\t\t\t\t\t\treturn left;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Otherwise, we need to start a stack to properly place the binary operations in their\n\t\t\t\t\t// precedence structure\n\t\t\t\t\tbiop_info = { value: biop, prec: binaryPrecedence(biop)};\n\n\t\t\t\t\tright = gobbleToken();\n\t\t\t\t\tif(!right) {\n\t\t\t\t\t\tthrowError(\"Expected expression after \" + biop, index);\n\t\t\t\t\t}\n\t\t\t\t\tstack = [left, biop_info, right];\n\n\t\t\t\t\t// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)\n\t\t\t\t\twhile((biop = gobbleBinaryOp())) {\n\t\t\t\t\t\tprec = binaryPrecedence(biop);\n\n\t\t\t\t\t\tif(prec === 0) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbiop_info = { value: biop, prec: prec };\n\n\t\t\t\t\t\t// Reduce: make a binary expression from the three topmost entries.\n\t\t\t\t\t\twhile ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n\t\t\t\t\t\t\tright = stack.pop();\n\t\t\t\t\t\t\tbiop = stack.pop().value;\n\t\t\t\t\t\t\tleft = stack.pop();\n\t\t\t\t\t\t\tnode = createBinaryExpression(biop, left, right);\n\t\t\t\t\t\t\tstack.push(node);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnode = gobbleToken();\n\t\t\t\t\t\tif(!node) {\n\t\t\t\t\t\t\tthrowError(\"Expected expression after \" + biop, index);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack.push(biop_info, node);\n\t\t\t\t\t}\n\n\t\t\t\t\ti = stack.length - 1;\n\t\t\t\t\tnode = stack[i];\n\t\t\t\t\twhile(i > 1) {\n\t\t\t\t\t\tnode = createBinaryExpression(stack[i - 1].value, stack[i - 2], node);\n\t\t\t\t\t\ti -= 2;\n\t\t\t\t\t}\n\t\t\t\t\treturn node;\n\t\t\t\t},\n\n\t\t\t\t// An individual part of a binary expression:\n\t\t\t\t// e.g. `foo.bar(baz)`, `1`, `\"abc\"`, `(a % 2)` (because it's in parenthesis)\n\t\t\t\tgobbleToken = function() {\n\t\t\t\t\tvar ch, to_check, tc_len;\n\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tch = exprICode(index);\n\n\t\t\t\t\tif(isDecimalDigit(ch) || ch === PERIOD_CODE) {\n\t\t\t\t\t\t// Char code 46 is a dot `.` which can start off a numeric literal\n\t\t\t\t\t\treturn gobbleNumericLiteral();\n\t\t\t\t\t} else if(ch === SQUOTE_CODE || ch === DQUOTE_CODE) {\n\t\t\t\t\t\t// Single or double quotes\n\t\t\t\t\t\treturn gobbleStringLiteral();\n\t\t\t\t\t} else if (ch === OBRACK_CODE) {\n\t\t\t\t\t\treturn gobbleArray();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tto_check = expr.substr(index, max_unop_len);\n\t\t\t\t\t\ttc_len = to_check.length;\n\t\t\t\t\t\twhile(tc_len > 0) {\n\t\t\t\t\t\t// Don't accept an unary op when it is an identifier.\n\t\t\t\t\t\t// Unary ops that start with a identifier-valid character must be followed\n\t\t\t\t\t\t// by a non identifier-part valid character\n\t\t\t\t\t\t\tif(unary_ops.hasOwnProperty(to_check) && (\n\t\t\t\t\t\t\t\t!isIdentifierStart(exprICode(index)) ||\n\t\t\t\t\t\t\t\t(index+to_check.length < expr.length && !isIdentifierPart(exprICode(index+to_check.length)))\n\t\t\t\t\t\t\t)) {\n\t\t\t\t\t\t\t\tindex += tc_len;\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\ttype: UNARY_EXP,\n\t\t\t\t\t\t\t\t\toperator: to_check,\n\t\t\t\t\t\t\t\t\targument: gobbleToken(),\n\t\t\t\t\t\t\t\t\tprefix: true\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tto_check = to_check.substr(0, --tc_len);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (isIdentifierStart(ch) || ch === OPAREN_CODE) { // open parenthesis\n\t\t\t\t\t\t\t// `foo`, `bar.baz`\n\t\t\t\t\t\t\treturn gobbleVariable();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn false;\n\t\t\t\t},\n\t\t\t\t// Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to\n\t\t\t\t// keep track of everything in the numeric literal and then calling `parseFloat` on that string\n\t\t\t\tgobbleNumericLiteral = function() {\n\t\t\t\t\tvar number = '', ch, chCode;\n\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) {\n\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t}\n\n\t\t\t\t\tif(exprICode(index) === PERIOD_CODE) { // can start with a decimal marker\n\t\t\t\t\t\tnumber += exprI(index++);\n\n\t\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) {\n\t\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tch = exprI(index);\n\t\t\t\t\tif(ch === 'e' || ch === 'E') { // exponent marker\n\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t\tch = exprI(index);\n\t\t\t\t\t\tif(ch === '+' || ch === '-') { // exponent sign\n\t\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile(isDecimalDigit(exprICode(index))) { //exponent itself\n\t\t\t\t\t\t\tnumber += exprI(index++);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!isDecimalDigit(exprICode(index-1)) ) {\n\t\t\t\t\t\t\tthrowError('Expected exponent (' + number + exprI(index) + ')', index);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t\tchCode = exprICode(index);\n\t\t\t\t\t// Check to make sure this isn't a variable name that start with a number (123abc)\n\t\t\t\t\tif(isIdentifierStart(chCode)) {\n\t\t\t\t\t\tthrowError('Variable names cannot start with a number (' +\n\t\t\t\t\t\t\t\t\tnumber + exprI(index) + ')', index);\n\t\t\t\t\t} else if(chCode === PERIOD_CODE) {\n\t\t\t\t\t\tthrowError('Unexpected period', index);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: LITERAL,\n\t\t\t\t\t\tvalue: parseFloat(number),\n\t\t\t\t\t\traw: number\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t// Parses a string literal, staring with single or double quotes with basic support for escape codes\n\t\t\t\t// e.g. `\"hello world\"`, `'this is\\nJSEP'`\n\t\t\t\tgobbleStringLiteral = function() {\n\t\t\t\t\tvar str = '', quote = exprI(index++), closed = false, ch;\n\n\t\t\t\t\twhile(index < length) {\n\t\t\t\t\t\tch = exprI(index++);\n\t\t\t\t\t\tif(ch === quote) {\n\t\t\t\t\t\t\tclosed = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if(ch === '\\\\') {\n\t\t\t\t\t\t\t// Check for all of the common escape codes\n\t\t\t\t\t\t\tch = exprI(index++);\n\t\t\t\t\t\t\tswitch(ch) {\n\t\t\t\t\t\t\t\tcase 'n': str += '\\n'; break;\n\t\t\t\t\t\t\t\tcase 'r': str += '\\r'; break;\n\t\t\t\t\t\t\t\tcase 't': str += '\\t'; break;\n\t\t\t\t\t\t\t\tcase 'b': str += '\\b'; break;\n\t\t\t\t\t\t\t\tcase 'f': str += '\\f'; break;\n\t\t\t\t\t\t\t\tcase 'v': str += '\\x0B'; break;\n\t\t\t\t\t\t\t\tdefault : str += ch;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tstr += ch;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!closed) {\n\t\t\t\t\t\tthrowError('Unclosed quote after \"'+str+'\"', index);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: LITERAL,\n\t\t\t\t\t\tvalue: str,\n\t\t\t\t\t\traw: quote + str + quote\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\t// Gobbles only identifiers\n\t\t\t\t// e.g.: `foo`, `_value`, `$x1`\n\t\t\t\t// Also, this function checks if that identifier is a literal:\n\t\t\t\t// (e.g. `true`, `false`, `null`) or `this`\n\t\t\t\tgobbleIdentifier = function() {\n\t\t\t\t\tvar ch = exprICode(index), start = index, identifier;\n\n\t\t\t\t\tif(isIdentifierStart(ch)) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrowError('Unexpected ' + exprI(index), index);\n\t\t\t\t\t}\n\n\t\t\t\t\twhile(index < length) {\n\t\t\t\t\t\tch = exprICode(index);\n\t\t\t\t\t\tif(isIdentifierPart(ch)) {\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tidentifier = expr.slice(start, index);\n\n\t\t\t\t\tif(literals.hasOwnProperty(identifier)) {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: LITERAL,\n\t\t\t\t\t\t\tvalue: literals[identifier],\n\t\t\t\t\t\t\traw: identifier\n\t\t\t\t\t\t};\n\t\t\t\t\t} else if(identifier === this_str) {\n\t\t\t\t\t\treturn { type: THIS_EXP };\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: IDENTIFIER,\n\t\t\t\t\t\t\tname: identifier\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Gobbles a list of arguments within the context of a function call\n\t\t\t\t// or array literal. This function also assumes that the opening character\n\t\t\t\t// `(` or `[` has already been gobbled, and gobbles expressions and commas\n\t\t\t\t// until the terminator character `)` or `]` is encountered.\n\t\t\t\t// e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`\n\t\t\t\tgobbleArguments = function(termination) {\n\t\t\t\t\tvar ch_i, args = [], node, closed = false;\n\t\t\t\t\twhile(index < length) {\n\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\tch_i = exprICode(index);\n\t\t\t\t\t\tif(ch_i === termination) { // done parsing\n\t\t\t\t\t\t\tclosed = true;\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else if (ch_i === COMMA_CODE) { // between expressions\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnode = gobbleExpression();\n\t\t\t\t\t\t\tif(!node || node.type === COMPOUND) {\n\t\t\t\t\t\t\t\tthrowError('Expected comma', index);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\targs.push(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!closed) {\n\t\t\t\t\t\tthrowError('Expected ' + String.fromCharCode(termination), index);\n\t\t\t\t\t}\n\t\t\t\t\treturn args;\n\t\t\t\t},\n\n\t\t\t\t// Gobble a non-literal variable name. This variable name may include properties\n\t\t\t\t// e.g. `foo`, `bar.baz`, `foo['bar'].baz`\n\t\t\t\t// It also gobbles function calls:\n\t\t\t\t// e.g. `Math.acos(obj.angle)`\n\t\t\t\tgobbleVariable = function() {\n\t\t\t\t\tvar ch_i, node;\n\t\t\t\t\tch_i = exprICode(index);\n\n\t\t\t\t\tif(ch_i === OPAREN_CODE) {\n\t\t\t\t\t\tnode = gobbleGroup();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tnode = gobbleIdentifier();\n\t\t\t\t\t}\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tch_i = exprICode(index);\n\t\t\t\t\twhile(ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\tif(ch_i === PERIOD_CODE) {\n\t\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\t\tnode = {\n\t\t\t\t\t\t\t\ttype: MEMBER_EXP,\n\t\t\t\t\t\t\t\tcomputed: false,\n\t\t\t\t\t\t\t\tobject: node,\n\t\t\t\t\t\t\t\tproperty: gobbleIdentifier()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else if(ch_i === OBRACK_CODE) {\n\t\t\t\t\t\t\tnode = {\n\t\t\t\t\t\t\t\ttype: MEMBER_EXP,\n\t\t\t\t\t\t\t\tcomputed: true,\n\t\t\t\t\t\t\t\tobject: node,\n\t\t\t\t\t\t\t\tproperty: gobbleExpression()\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\t\tch_i = exprICode(index);\n\t\t\t\t\t\t\tif(ch_i !== CBRACK_CODE) {\n\t\t\t\t\t\t\t\tthrowError('Unclosed [', index);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tindex++;\n\t\t\t\t\t\t} else if(ch_i === OPAREN_CODE) {\n\t\t\t\t\t\t\t// A function call is being made; gobble all the arguments\n\t\t\t\t\t\t\tnode = {\n\t\t\t\t\t\t\t\ttype: CALL_EXP,\n\t\t\t\t\t\t\t\t'arguments': gobbleArguments(CPAREN_CODE),\n\t\t\t\t\t\t\t\tcallee: node\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\t\tch_i = exprICode(index);\n\t\t\t\t\t}\n\t\t\t\t\treturn node;\n\t\t\t\t},\n\n\t\t\t\t// Responsible for parsing a group of things within parentheses `()`\n\t\t\t\t// This function assumes that it needs to gobble the opening parenthesis\n\t\t\t\t// and then tries to gobble everything within that parenthesis, assuming\n\t\t\t\t// that the next thing it should see is the close parenthesis. If not,\n\t\t\t\t// then the expression probably doesn't have a `)`\n\t\t\t\tgobbleGroup = function() {\n\t\t\t\t\tindex++;\n\t\t\t\t\tvar node = gobbleExpression();\n\t\t\t\t\tgobbleSpaces();\n\t\t\t\t\tif(exprICode(index) === CPAREN_CODE) {\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t\treturn node;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrowError('Unclosed (', index);\n\t\t\t\t\t}\n\t\t\t\t},\n\n\t\t\t\t// Responsible for parsing Array literals `[1, 2, 3]`\n\t\t\t\t// This function assumes that it needs to gobble the opening bracket\n\t\t\t\t// and then tries to gobble the expressions as arguments.\n\t\t\t\tgobbleArray = function() {\n\t\t\t\t\tindex++;\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: ARRAY_EXP,\n\t\t\t\t\t\telements: gobbleArguments(CBRACK_CODE)\n\t\t\t\t\t};\n\t\t\t\t},\n\n\t\t\t\tnodes = [], ch_i, node;\n\n\t\t\twhile(index < length) {\n\t\t\t\tch_i = exprICode(index);\n\n\t\t\t\t// Expressions can be separated by semicolons, commas, or just inferred without any\n\t\t\t\t// separators\n\t\t\t\tif(ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {\n\t\t\t\t\tindex++; // ignore separators\n\t\t\t\t} else {\n\t\t\t\t\t// Try to gobble each expression individually\n\t\t\t\t\tif((node = gobbleExpression())) {\n\t\t\t\t\t\tnodes.push(node);\n\t\t\t\t\t// If we weren't able to find a binary expression and are out of room, then\n\t\t\t\t\t// the expression passed in probably has too much\n\t\t\t\t\t} else if(index < length) {\n\t\t\t\t\t\tthrowError('Unexpected \"' + exprI(index) + '\"', index);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there's only one expression just try returning the expression\n\t\t\tif(nodes.length === 1) {\n\t\t\t\treturn nodes[0];\n\t\t\t} else {\n\t\t\t\treturn {\n\t\t\t\t\ttype: COMPOUND,\n\t\t\t\t\tbody: nodes\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\n\t// To be filled in by the template\n\tjsep.version = '0.3.4';\n\tjsep.toString = function() { return 'JavaScript Expression Parser (JSEP) v' + jsep.version; };\n\n\t/**\n\t * @method jsep.addUnaryOp\n\t * @param {string} op_name The name of the unary op to add\n\t * @return jsep\n\t */\n\tjsep.addUnaryOp = function(op_name) {\n\t\tmax_unop_len = Math.max(op_name.length, max_unop_len);\n\t\tunary_ops[op_name] = t; return this;\n\t};\n\n\t/**\n\t * @method jsep.addBinaryOp\n\t * @param {string} op_name The name of the binary op to add\n\t * @param {number} precedence The precedence of the binary op (can be a float)\n\t * @return jsep\n\t */\n\tjsep.addBinaryOp = function(op_name, precedence) {\n\t\tmax_binop_len = Math.max(op_name.length, max_binop_len);\n\t\tbinary_ops[op_name] = precedence;\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.addIdentifierChar\n\t * @param {string} char The additional character to treat as a valid part of an identifier\n\t * @return jsep\n\t */\n\tjsep.addIdentifierChar = function(char) {\n\t\tadditional_identifier_chars[char] = t; return this;\n\t};\n\n\t/**\n\t * @method jsep.addLiteral\n\t * @param {string} literal_name The name of the literal to add\n\t * @param {*} literal_value The value of the literal\n\t * @return jsep\n\t */\n\tjsep.addLiteral = function(literal_name, literal_value) {\n\t\tliterals[literal_name] = literal_value;\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeUnaryOp\n\t * @param {string} op_name The name of the unary op to remove\n\t * @return jsep\n\t */\n\tjsep.removeUnaryOp = function(op_name) {\n\t\tdelete unary_ops[op_name];\n\t\tif(op_name.length === max_unop_len) {\n\t\t\tmax_unop_len = getMaxKeyLen(unary_ops);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeAllUnaryOps\n\t * @return jsep\n\t */\n\tjsep.removeAllUnaryOps = function() {\n\t\tunary_ops = {};\n\t\tmax_unop_len = 0;\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeIdentifierChar\n\t * @param {string} char The additional character to stop treating as a valid part of an identifier\n\t * @return jsep\n\t */\n\tjsep.removeIdentifierChar = function(char) {\n\t\tdelete additional_identifier_chars[char];\n\t\treturn this;\n\t};\n\n\n\t/**\n\t * @method jsep.removeBinaryOp\n\t * @param {string} op_name The name of the binary op to remove\n\t * @return jsep\n\t */\n\tjsep.removeBinaryOp = function(op_name) {\n\t\tdelete binary_ops[op_name];\n\t\tif(op_name.length === max_binop_len) {\n\t\t\tmax_binop_len = getMaxKeyLen(binary_ops);\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeAllBinaryOps\n\t * @return jsep\n\t */\n\tjsep.removeAllBinaryOps = function() {\n\t\tbinary_ops = {};\n\t\tmax_binop_len = 0;\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeLiteral\n\t * @param {string} literal_name The name of the literal to remove\n\t * @return jsep\n\t */\n\tjsep.removeLiteral = function(literal_name) {\n\t\tdelete literals[literal_name];\n\t\treturn this;\n\t};\n\n\t/**\n\t * @method jsep.removeAllLiterals\n\t * @return jsep\n\t */\n\tjsep.removeAllLiterals = function() {\n\t\tliterals = {};\n\n\t\treturn this;\n\t};\n\n\t// In desktop environments, have a way to restore the old value for `jsep`\n\tif (typeof exports === 'undefined') {\n\t\tvar old_jsep = root.jsep;\n\t\t// The star of the show! It's a function!\n\t\troot.jsep = jsep;\n\t\t// And a courteous function willing to move out of the way for other similarly-named objects!\n\t\tjsep.noConflict = function() {\n\t\t\tif(root.jsep === jsep) {\n\t\t\t\troot.jsep = old_jsep;\n\t\t\t}\n\t\t\treturn jsep;\n\t\t};\n\t} else {\n\t\t// In Node.JS environments\n\t\tif (typeof module !== 'undefined' && module.exports) {\n\t\t\texports = module.exports = jsep;\n\t\t} else {\n\t\t\texports.parse = jsep;\n\t\t}\n\t}\n}(this));\n","'use strict'\n\nmodule.exports = LRUCache\n\n// This will be a proper iterable 'Map' in engines that support it,\n// or a fakey-fake PseudoMap in older versions.\nvar Map = require('pseudomap')\nvar util = require('util')\n\n// A linked list to keep track of recently-used-ness\nvar Yallist = require('yallist')\n\n// use symbols if possible, otherwise just _props\nvar hasSymbol = typeof Symbol === 'function'\nvar makeSymbol\nif (hasSymbol) {\n  makeSymbol = function (key) {\n    return Symbol(key)\n  }\n} else {\n  makeSymbol = function (key) {\n    return '_' + key\n  }\n}\n\nvar MAX = makeSymbol('max')\nvar LENGTH = makeSymbol('length')\nvar LENGTH_CALCULATOR = makeSymbol('lengthCalculator')\nvar ALLOW_STALE = makeSymbol('allowStale')\nvar MAX_AGE = makeSymbol('maxAge')\nvar DISPOSE = makeSymbol('dispose')\nvar NO_DISPOSE_ON_SET = makeSymbol('noDisposeOnSet')\nvar LRU_LIST = makeSymbol('lruList')\nvar CACHE = makeSymbol('cache')\n\nfunction naiveLength () { return 1 }\n\n// lruList is a yallist where the head is the youngest\n// item, and the tail is the oldest.  the list contains the Hit\n// objects as the entries.\n// Each Hit object has a reference to its Yallist.Node.  This\n// never changes.\n//\n// cache is a Map (or PseudoMap) that matches the keys to\n// the Yallist.Node object.\nfunction LRUCache (options) {\n  if (!(this instanceof LRUCache)) {\n    return new LRUCache(options)\n  }\n\n  if (typeof options === 'number') {\n    options = { max: options }\n  }\n\n  if (!options) {\n    options = {}\n  }\n\n  var max = this[MAX] = options.max\n  // Kind of weird to have a default max of Infinity, but oh well.\n  if (!max ||\n      !(typeof max === 'number') ||\n      max <= 0) {\n    this[MAX] = Infinity\n  }\n\n  var lc = options.length || naiveLength\n  if (typeof lc !== 'function') {\n    lc = naiveLength\n  }\n  this[LENGTH_CALCULATOR] = lc\n\n  this[ALLOW_STALE] = options.stale || false\n  this[MAX_AGE] = options.maxAge || 0\n  this[DISPOSE] = options.dispose\n  this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false\n  this.reset()\n}\n\n// resize the cache when the max changes.\nObject.defineProperty(LRUCache.prototype, 'max', {\n  set: function (mL) {\n    if (!mL || !(typeof mL === 'number') || mL <= 0) {\n      mL = Infinity\n    }\n    this[MAX] = mL\n    trim(this)\n  },\n  get: function () {\n    return this[MAX]\n  },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'allowStale', {\n  set: function (allowStale) {\n    this[ALLOW_STALE] = !!allowStale\n  },\n  get: function () {\n    return this[ALLOW_STALE]\n  },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'maxAge', {\n  set: function (mA) {\n    if (!mA || !(typeof mA === 'number') || mA < 0) {\n      mA = 0\n    }\n    this[MAX_AGE] = mA\n    trim(this)\n  },\n  get: function () {\n    return this[MAX_AGE]\n  },\n  enumerable: true\n})\n\n// resize the cache when the lengthCalculator changes.\nObject.defineProperty(LRUCache.prototype, 'lengthCalculator', {\n  set: function (lC) {\n    if (typeof lC !== 'function') {\n      lC = naiveLength\n    }\n    if (lC !== this[LENGTH_CALCULATOR]) {\n      this[LENGTH_CALCULATOR] = lC\n      this[LENGTH] = 0\n      this[LRU_LIST].forEach(function (hit) {\n        hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key)\n        this[LENGTH] += hit.length\n      }, this)\n    }\n    trim(this)\n  },\n  get: function () { return this[LENGTH_CALCULATOR] },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'length', {\n  get: function () { return this[LENGTH] },\n  enumerable: true\n})\n\nObject.defineProperty(LRUCache.prototype, 'itemCount', {\n  get: function () { return this[LRU_LIST].length },\n  enumerable: true\n})\n\nLRUCache.prototype.rforEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this[LRU_LIST].tail; walker !== null;) {\n    var prev = walker.prev\n    forEachStep(this, fn, walker, thisp)\n    walker = prev\n  }\n}\n\nfunction forEachStep (self, fn, node, thisp) {\n  var hit = node.value\n  if (isStale(self, hit)) {\n    del(self, node)\n    if (!self[ALLOW_STALE]) {\n      hit = undefined\n    }\n  }\n  if (hit) {\n    fn.call(thisp, hit.value, hit.key, self)\n  }\n}\n\nLRUCache.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this[LRU_LIST].head; walker !== null;) {\n    var next = walker.next\n    forEachStep(this, fn, walker, thisp)\n    walker = next\n  }\n}\n\nLRUCache.prototype.keys = function () {\n  return this[LRU_LIST].toArray().map(function (k) {\n    return k.key\n  }, this)\n}\n\nLRUCache.prototype.values = function () {\n  return this[LRU_LIST].toArray().map(function (k) {\n    return k.value\n  }, this)\n}\n\nLRUCache.prototype.reset = function () {\n  if (this[DISPOSE] &&\n      this[LRU_LIST] &&\n      this[LRU_LIST].length) {\n    this[LRU_LIST].forEach(function (hit) {\n      this[DISPOSE](hit.key, hit.value)\n    }, this)\n  }\n\n  this[CACHE] = new Map() // hash of items by key\n  this[LRU_LIST] = new Yallist() // list of items in order of use recency\n  this[LENGTH] = 0 // length of items in the list\n}\n\nLRUCache.prototype.dump = function () {\n  return this[LRU_LIST].map(function (hit) {\n    if (!isStale(this, hit)) {\n      return {\n        k: hit.key,\n        v: hit.value,\n        e: hit.now + (hit.maxAge || 0)\n      }\n    }\n  }, this).toArray().filter(function (h) {\n    return h\n  })\n}\n\nLRUCache.prototype.dumpLru = function () {\n  return this[LRU_LIST]\n}\n\nLRUCache.prototype.inspect = function (n, opts) {\n  var str = 'LRUCache {'\n  var extras = false\n\n  var as = this[ALLOW_STALE]\n  if (as) {\n    str += '\\n  allowStale: true'\n    extras = true\n  }\n\n  var max = this[MAX]\n  if (max && max !== Infinity) {\n    if (extras) {\n      str += ','\n    }\n    str += '\\n  max: ' + util.inspect(max, opts)\n    extras = true\n  }\n\n  var maxAge = this[MAX_AGE]\n  if (maxAge) {\n    if (extras) {\n      str += ','\n    }\n    str += '\\n  maxAge: ' + util.inspect(maxAge, opts)\n    extras = true\n  }\n\n  var lc = this[LENGTH_CALCULATOR]\n  if (lc && lc !== naiveLength) {\n    if (extras) {\n      str += ','\n    }\n    str += '\\n  length: ' + util.inspect(this[LENGTH], opts)\n    extras = true\n  }\n\n  var didFirst = false\n  this[LRU_LIST].forEach(function (item) {\n    if (didFirst) {\n      str += ',\\n  '\n    } else {\n      if (extras) {\n        str += ',\\n'\n      }\n      didFirst = true\n      str += '\\n  '\n    }\n    var key = util.inspect(item.key).split('\\n').join('\\n  ')\n    var val = { value: item.value }\n    if (item.maxAge !== maxAge) {\n      val.maxAge = item.maxAge\n    }\n    if (lc !== naiveLength) {\n      val.length = item.length\n    }\n    if (isStale(this, item)) {\n      val.stale = true\n    }\n\n    val = util.inspect(val, opts).split('\\n').join('\\n  ')\n    str += key + ' => ' + val\n  })\n\n  if (didFirst || extras) {\n    str += '\\n'\n  }\n  str += '}'\n\n  return str\n}\n\nLRUCache.prototype.set = function (key, value, maxAge) {\n  maxAge = maxAge || this[MAX_AGE]\n\n  var now = maxAge ? Date.now() : 0\n  var len = this[LENGTH_CALCULATOR](value, key)\n\n  if (this[CACHE].has(key)) {\n    if (len > this[MAX]) {\n      del(this, this[CACHE].get(key))\n      return false\n    }\n\n    var node = this[CACHE].get(key)\n    var item = node.value\n\n    // dispose of the old one before overwriting\n    // split out into 2 ifs for better coverage tracking\n    if (this[DISPOSE]) {\n      if (!this[NO_DISPOSE_ON_SET]) {\n        this[DISPOSE](key, item.value)\n      }\n    }\n\n    item.now = now\n    item.maxAge = maxAge\n    item.value = value\n    this[LENGTH] += len - item.length\n    item.length = len\n    this.get(key)\n    trim(this)\n    return true\n  }\n\n  var hit = new Entry(key, value, len, now, maxAge)\n\n  // oversized objects fall out of cache automatically.\n  if (hit.length > this[MAX]) {\n    if (this[DISPOSE]) {\n      this[DISPOSE](key, value)\n    }\n    return false\n  }\n\n  this[LENGTH] += hit.length\n  this[LRU_LIST].unshift(hit)\n  this[CACHE].set(key, this[LRU_LIST].head)\n  trim(this)\n  return true\n}\n\nLRUCache.prototype.has = function (key) {\n  if (!this[CACHE].has(key)) return false\n  var hit = this[CACHE].get(key).value\n  if (isStale(this, hit)) {\n    return false\n  }\n  return true\n}\n\nLRUCache.prototype.get = function (key) {\n  return get(this, key, true)\n}\n\nLRUCache.prototype.peek = function (key) {\n  return get(this, key, false)\n}\n\nLRUCache.prototype.pop = function () {\n  var node = this[LRU_LIST].tail\n  if (!node) return null\n  del(this, node)\n  return node.value\n}\n\nLRUCache.prototype.del = function (key) {\n  del(this, this[CACHE].get(key))\n}\n\nLRUCache.prototype.load = function (arr) {\n  // reset the cache\n  this.reset()\n\n  var now = Date.now()\n  // A previous serialized cache has the most recent items first\n  for (var l = arr.length - 1; l >= 0; l--) {\n    var hit = arr[l]\n    var expiresAt = hit.e || 0\n    if (expiresAt === 0) {\n      // the item was created without expiration in a non aged cache\n      this.set(hit.k, hit.v)\n    } else {\n      var maxAge = expiresAt - now\n      // dont add already expired items\n      if (maxAge > 0) {\n        this.set(hit.k, hit.v, maxAge)\n      }\n    }\n  }\n}\n\nLRUCache.prototype.prune = function () {\n  var self = this\n  this[CACHE].forEach(function (value, key) {\n    get(self, key, false)\n  })\n}\n\nfunction get (self, key, doUse) {\n  var node = self[CACHE].get(key)\n  if (node) {\n    var hit = node.value\n    if (isStale(self, hit)) {\n      del(self, node)\n      if (!self[ALLOW_STALE]) hit = undefined\n    } else {\n      if (doUse) {\n        self[LRU_LIST].unshiftNode(node)\n      }\n    }\n    if (hit) hit = hit.value\n  }\n  return hit\n}\n\nfunction isStale (self, hit) {\n  if (!hit || (!hit.maxAge && !self[MAX_AGE])) {\n    return false\n  }\n  var stale = false\n  var diff = Date.now() - hit.now\n  if (hit.maxAge) {\n    stale = diff > hit.maxAge\n  } else {\n    stale = self[MAX_AGE] && (diff > self[MAX_AGE])\n  }\n  return stale\n}\n\nfunction trim (self) {\n  if (self[LENGTH] > self[MAX]) {\n    for (var walker = self[LRU_LIST].tail;\n         self[LENGTH] > self[MAX] && walker !== null;) {\n      // We know that we're about to delete this one, and also\n      // what the next least recently used key will be, so just\n      // go ahead and set it now.\n      var prev = walker.prev\n      del(self, walker)\n      walker = prev\n    }\n  }\n}\n\nfunction del (self, node) {\n  if (node) {\n    var hit = node.value\n    if (self[DISPOSE]) {\n      self[DISPOSE](hit.key, hit.value)\n    }\n    self[LENGTH] -= hit.length\n    self[CACHE].delete(hit.key)\n    self[LRU_LIST].removeNode(node)\n  }\n}\n\n// classy, since V8 prefers predictable objects.\nfunction Entry (key, value, length, now, maxAge) {\n  this.key = key\n  this.value = value\n  this.length = length\n  this.now = now\n  this.maxAge = maxAge || 0\n}\n","module.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n","//      \n// An event handler can take an optional event argument\n// and should not return a value\n                                          \n                                                               \n\n// An array of all currently registered event handlers for a type\n                                            \n                                                            \n// A map of event types and their corresponding event handlers.\n                        \n                                 \n                                   \n  \n\n/** Mitt: Tiny (~200b) functional event emitter / pubsub.\n *  @name mitt\n *  @returns {Mitt}\n */\nfunction mitt(all                 ) {\n\tall = all || Object.create(null);\n\n\treturn {\n\t\t/**\n\t\t * Register an event handler for the given type.\n\t\t *\n\t\t * @param  {String} type\tType of event to listen for, or `\"*\"` for all events\n\t\t * @param  {Function} handler Function to call in response to given event\n\t\t * @memberOf mitt\n\t\t */\n\t\ton: function on(type        , handler              ) {\n\t\t\t(all[type] || (all[type] = [])).push(handler);\n\t\t},\n\n\t\t/**\n\t\t * Remove an event handler for the given type.\n\t\t *\n\t\t * @param  {String} type\tType of event to unregister `handler` from, or `\"*\"`\n\t\t * @param  {Function} handler Handler function to remove\n\t\t * @memberOf mitt\n\t\t */\n\t\toff: function off(type        , handler              ) {\n\t\t\tif (all[type]) {\n\t\t\t\tall[type].splice(all[type].indexOf(handler) >>> 0, 1);\n\t\t\t}\n\t\t},\n\n\t\t/**\n\t\t * Invoke all handlers for the given type.\n\t\t * If present, `\"*\"` handlers are invoked after type-matched handlers.\n\t\t *\n\t\t * @param {String} type  The event type to invoke\n\t\t * @param {Any} [evt]  Any value (object is recommended and powerful), passed to each handler\n\t\t * @memberOf mitt\n\t\t */\n\t\temit: function emit(type        , evt     ) {\n\t\t\t(all[type] || []).slice().map(function (handler) { handler(evt); });\n\t\t\t(all['*'] || []).slice().map(function (handler) { handler(type, evt); });\n\t\t}\n\t};\n}\n\nexport default mitt;\n//# sourceMappingURL=mitt.es.js.map\n","'use strict';\n\nmodule.exports = Pbf;\n\nvar ieee754 = require('ieee754');\n\nfunction Pbf(buf) {\n    this.buf = ArrayBuffer.isView && ArrayBuffer.isView(buf) ? buf : new Uint8Array(buf || 0);\n    this.pos = 0;\n    this.type = 0;\n    this.length = this.buf.length;\n}\n\nPbf.Varint  = 0; // varint: int32, int64, uint32, uint64, sint32, sint64, bool, enum\nPbf.Fixed64 = 1; // 64-bit: double, fixed64, sfixed64\nPbf.Bytes   = 2; // length-delimited: string, bytes, embedded messages, packed repeated fields\nPbf.Fixed32 = 5; // 32-bit: float, fixed32, sfixed32\n\nvar SHIFT_LEFT_32 = (1 << 16) * (1 << 16),\n    SHIFT_RIGHT_32 = 1 / SHIFT_LEFT_32;\n\nPbf.prototype = {\n\n    destroy: function() {\n        this.buf = null;\n    },\n\n    // === READING =================================================================\n\n    readFields: function(readField, result, end) {\n        end = end || this.length;\n\n        while (this.pos < end) {\n            var val = this.readVarint(),\n                tag = val >> 3,\n                startPos = this.pos;\n\n            this.type = val & 0x7;\n            readField(tag, result, this);\n\n            if (this.pos === startPos) this.skip(val);\n        }\n        return result;\n    },\n\n    readMessage: function(readField, result) {\n        return this.readFields(readField, result, this.readVarint() + this.pos);\n    },\n\n    readFixed32: function() {\n        var val = readUInt32(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n    },\n\n    readSFixed32: function() {\n        var val = readInt32(this.buf, this.pos);\n        this.pos += 4;\n        return val;\n    },\n\n    // 64-bit int handling is based on github.com/dpw/node-buffer-more-ints (MIT-licensed)\n\n    readFixed64: function() {\n        var val = readUInt32(this.buf, this.pos) + readUInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    },\n\n    readSFixed64: function() {\n        var val = readUInt32(this.buf, this.pos) + readInt32(this.buf, this.pos + 4) * SHIFT_LEFT_32;\n        this.pos += 8;\n        return val;\n    },\n\n    readFloat: function() {\n        var val = ieee754.read(this.buf, this.pos, true, 23, 4);\n        this.pos += 4;\n        return val;\n    },\n\n    readDouble: function() {\n        var val = ieee754.read(this.buf, this.pos, true, 52, 8);\n        this.pos += 8;\n        return val;\n    },\n\n    readVarint: function(isSigned) {\n        var buf = this.buf,\n            val, b;\n\n        b = buf[this.pos++]; val  =  b & 0x7f;        if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 7;  if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 14; if (b < 0x80) return val;\n        b = buf[this.pos++]; val |= (b & 0x7f) << 21; if (b < 0x80) return val;\n        b = buf[this.pos];   val |= (b & 0x0f) << 28;\n\n        return readVarintRemainder(val, isSigned, this);\n    },\n\n    readVarint64: function() { // for compatibility with v2.0.1\n        return this.readVarint(true);\n    },\n\n    readSVarint: function() {\n        var num = this.readVarint();\n        return num % 2 === 1 ? (num + 1) / -2 : num / 2; // zigzag encoding\n    },\n\n    readBoolean: function() {\n        return Boolean(this.readVarint());\n    },\n\n    readString: function() {\n        var end = this.readVarint() + this.pos,\n            str = readUtf8(this.buf, this.pos, end);\n        this.pos = end;\n        return str;\n    },\n\n    readBytes: function() {\n        var end = this.readVarint() + this.pos,\n            buffer = this.buf.subarray(this.pos, end);\n        this.pos = end;\n        return buffer;\n    },\n\n    // verbose for performance reasons; doesn't affect gzipped size\n\n    readPackedVarint: function(arr, isSigned) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readVarint(isSigned));\n        return arr;\n    },\n    readPackedSVarint: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSVarint());\n        return arr;\n    },\n    readPackedBoolean: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readBoolean());\n        return arr;\n    },\n    readPackedFloat: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFloat());\n        return arr;\n    },\n    readPackedDouble: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readDouble());\n        return arr;\n    },\n    readPackedFixed32: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFixed32());\n        return arr;\n    },\n    readPackedSFixed32: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSFixed32());\n        return arr;\n    },\n    readPackedFixed64: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readFixed64());\n        return arr;\n    },\n    readPackedSFixed64: function(arr) {\n        var end = readPackedEnd(this);\n        arr = arr || [];\n        while (this.pos < end) arr.push(this.readSFixed64());\n        return arr;\n    },\n\n    skip: function(val) {\n        var type = val & 0x7;\n        if (type === Pbf.Varint) while (this.buf[this.pos++] > 0x7f) {}\n        else if (type === Pbf.Bytes) this.pos = this.readVarint() + this.pos;\n        else if (type === Pbf.Fixed32) this.pos += 4;\n        else if (type === Pbf.Fixed64) this.pos += 8;\n        else throw new Error('Unimplemented type: ' + type);\n    },\n\n    // === WRITING =================================================================\n\n    writeTag: function(tag, type) {\n        this.writeVarint((tag << 3) | type);\n    },\n\n    realloc: function(min) {\n        var length = this.length || 16;\n\n        while (length < this.pos + min) length *= 2;\n\n        if (length !== this.length) {\n            var buf = new Uint8Array(length);\n            buf.set(this.buf);\n            this.buf = buf;\n            this.length = length;\n        }\n    },\n\n    finish: function() {\n        this.length = this.pos;\n        this.pos = 0;\n        return this.buf.subarray(0, this.length);\n    },\n\n    writeFixed32: function(val) {\n        this.realloc(4);\n        writeInt32(this.buf, val, this.pos);\n        this.pos += 4;\n    },\n\n    writeSFixed32: function(val) {\n        this.realloc(4);\n        writeInt32(this.buf, val, this.pos);\n        this.pos += 4;\n    },\n\n    writeFixed64: function(val) {\n        this.realloc(8);\n        writeInt32(this.buf, val & -1, this.pos);\n        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n    },\n\n    writeSFixed64: function(val) {\n        this.realloc(8);\n        writeInt32(this.buf, val & -1, this.pos);\n        writeInt32(this.buf, Math.floor(val * SHIFT_RIGHT_32), this.pos + 4);\n        this.pos += 8;\n    },\n\n    writeVarint: function(val) {\n        val = +val || 0;\n\n        if (val > 0xfffffff || val < 0) {\n            writeBigVarint(val, this);\n            return;\n        }\n\n        this.realloc(4);\n\n        this.buf[this.pos++] =           val & 0x7f  | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] = ((val >>>= 7) & 0x7f) | (val > 0x7f ? 0x80 : 0); if (val <= 0x7f) return;\n        this.buf[this.pos++] =   (val >>> 7) & 0x7f;\n    },\n\n    writeSVarint: function(val) {\n        this.writeVarint(val < 0 ? -val * 2 - 1 : val * 2);\n    },\n\n    writeBoolean: function(val) {\n        this.writeVarint(Boolean(val));\n    },\n\n    writeString: function(str) {\n        str = String(str);\n        this.realloc(str.length * 4);\n\n        this.pos++; // reserve 1 byte for short string length\n\n        var startPos = this.pos;\n        // write the string directly to the buffer and see how much was written\n        this.pos = writeUtf8(this.buf, str, this.pos);\n        var len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    },\n\n    writeFloat: function(val) {\n        this.realloc(4);\n        ieee754.write(this.buf, val, this.pos, true, 23, 4);\n        this.pos += 4;\n    },\n\n    writeDouble: function(val) {\n        this.realloc(8);\n        ieee754.write(this.buf, val, this.pos, true, 52, 8);\n        this.pos += 8;\n    },\n\n    writeBytes: function(buffer) {\n        var len = buffer.length;\n        this.writeVarint(len);\n        this.realloc(len);\n        for (var i = 0; i < len; i++) this.buf[this.pos++] = buffer[i];\n    },\n\n    writeRawMessage: function(fn, obj) {\n        this.pos++; // reserve 1 byte for short message length\n\n        // write the message directly to the buffer and see how much was written\n        var startPos = this.pos;\n        fn(obj, this);\n        var len = this.pos - startPos;\n\n        if (len >= 0x80) makeRoomForExtraLength(startPos, len, this);\n\n        // finally, write the message length in the reserved place and restore the position\n        this.pos = startPos - 1;\n        this.writeVarint(len);\n        this.pos += len;\n    },\n\n    writeMessage: function(tag, fn, obj) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeRawMessage(fn, obj);\n    },\n\n    writePackedVarint:   function(tag, arr) { this.writeMessage(tag, writePackedVarint, arr);   },\n    writePackedSVarint:  function(tag, arr) { this.writeMessage(tag, writePackedSVarint, arr);  },\n    writePackedBoolean:  function(tag, arr) { this.writeMessage(tag, writePackedBoolean, arr);  },\n    writePackedFloat:    function(tag, arr) { this.writeMessage(tag, writePackedFloat, arr);    },\n    writePackedDouble:   function(tag, arr) { this.writeMessage(tag, writePackedDouble, arr);   },\n    writePackedFixed32:  function(tag, arr) { this.writeMessage(tag, writePackedFixed32, arr);  },\n    writePackedSFixed32: function(tag, arr) { this.writeMessage(tag, writePackedSFixed32, arr); },\n    writePackedFixed64:  function(tag, arr) { this.writeMessage(tag, writePackedFixed64, arr);  },\n    writePackedSFixed64: function(tag, arr) { this.writeMessage(tag, writePackedSFixed64, arr); },\n\n    writeBytesField: function(tag, buffer) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeBytes(buffer);\n    },\n    writeFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFixed32(val);\n    },\n    writeSFixed32Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeSFixed32(val);\n    },\n    writeFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeFixed64(val);\n    },\n    writeSFixed64Field: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeSFixed64(val);\n    },\n    writeVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeVarint(val);\n    },\n    writeSVarintField: function(tag, val) {\n        this.writeTag(tag, Pbf.Varint);\n        this.writeSVarint(val);\n    },\n    writeStringField: function(tag, str) {\n        this.writeTag(tag, Pbf.Bytes);\n        this.writeString(str);\n    },\n    writeFloatField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed32);\n        this.writeFloat(val);\n    },\n    writeDoubleField: function(tag, val) {\n        this.writeTag(tag, Pbf.Fixed64);\n        this.writeDouble(val);\n    },\n    writeBooleanField: function(tag, val) {\n        this.writeVarintField(tag, Boolean(val));\n    }\n};\n\nfunction readVarintRemainder(l, s, p) {\n    var buf = p.buf,\n        h, b;\n\n    b = buf[p.pos++]; h  = (b & 0x70) >> 4;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 3;  if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 10; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 17; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x7f) << 24; if (b < 0x80) return toNum(l, h, s);\n    b = buf[p.pos++]; h |= (b & 0x01) << 31; if (b < 0x80) return toNum(l, h, s);\n\n    throw new Error('Expected varint not more than 10 bytes');\n}\n\nfunction readPackedEnd(pbf) {\n    return pbf.type === Pbf.Bytes ?\n        pbf.readVarint() + pbf.pos : pbf.pos + 1;\n}\n\nfunction toNum(low, high, isSigned) {\n    if (isSigned) {\n        return high * 0x100000000 + (low >>> 0);\n    }\n\n    return ((high >>> 0) * 0x100000000) + (low >>> 0);\n}\n\nfunction writeBigVarint(val, pbf) {\n    var low, high;\n\n    if (val >= 0) {\n        low  = (val % 0x100000000) | 0;\n        high = (val / 0x100000000) | 0;\n    } else {\n        low  = ~(-val % 0x100000000);\n        high = ~(-val / 0x100000000);\n\n        if (low ^ 0xffffffff) {\n            low = (low + 1) | 0;\n        } else {\n            low = 0;\n            high = (high + 1) | 0;\n        }\n    }\n\n    if (val >= 0x10000000000000000 || val < -0x10000000000000000) {\n        throw new Error('Given varint doesn\\'t fit into 10 bytes');\n    }\n\n    pbf.realloc(10);\n\n    writeBigVarintLow(low, high, pbf);\n    writeBigVarintHigh(high, pbf);\n}\n\nfunction writeBigVarintLow(low, high, pbf) {\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos++] = low & 0x7f | 0x80; low >>>= 7;\n    pbf.buf[pbf.pos]   = low & 0x7f;\n}\n\nfunction writeBigVarintHigh(high, pbf) {\n    var lsb = (high & 0x07) << 4;\n\n    pbf.buf[pbf.pos++] |= lsb         | ((high >>>= 3) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f | ((high >>>= 7) ? 0x80 : 0); if (!high) return;\n    pbf.buf[pbf.pos++]  = high & 0x7f;\n}\n\nfunction makeRoomForExtraLength(startPos, len, pbf) {\n    var extraLen =\n        len <= 0x3fff ? 1 :\n        len <= 0x1fffff ? 2 :\n        len <= 0xfffffff ? 3 : Math.ceil(Math.log(len) / (Math.LN2 * 7));\n\n    // if 1 byte isn't enough for encoding message length, shift the data to the right\n    pbf.realloc(extraLen);\n    for (var i = pbf.pos - 1; i >= startPos; i--) pbf.buf[i + extraLen] = pbf.buf[i];\n}\n\nfunction writePackedVarint(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeVarint(arr[i]);   }\nfunction writePackedSVarint(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeSVarint(arr[i]);  }\nfunction writePackedFloat(arr, pbf)    { for (var i = 0; i < arr.length; i++) pbf.writeFloat(arr[i]);    }\nfunction writePackedDouble(arr, pbf)   { for (var i = 0; i < arr.length; i++) pbf.writeDouble(arr[i]);   }\nfunction writePackedBoolean(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeBoolean(arr[i]);  }\nfunction writePackedFixed32(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed32(arr[i]);  }\nfunction writePackedSFixed32(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed32(arr[i]); }\nfunction writePackedFixed64(arr, pbf)  { for (var i = 0; i < arr.length; i++) pbf.writeFixed64(arr[i]);  }\nfunction writePackedSFixed64(arr, pbf) { for (var i = 0; i < arr.length; i++) pbf.writeSFixed64(arr[i]); }\n\n// Buffer code below from https://github.com/feross/buffer, MIT-licensed\n\nfunction readUInt32(buf, pos) {\n    return ((buf[pos]) |\n        (buf[pos + 1] << 8) |\n        (buf[pos + 2] << 16)) +\n        (buf[pos + 3] * 0x1000000);\n}\n\nfunction writeInt32(buf, val, pos) {\n    buf[pos] = val;\n    buf[pos + 1] = (val >>> 8);\n    buf[pos + 2] = (val >>> 16);\n    buf[pos + 3] = (val >>> 24);\n}\n\nfunction readInt32(buf, pos) {\n    return ((buf[pos]) |\n        (buf[pos + 1] << 8) |\n        (buf[pos + 2] << 16)) +\n        (buf[pos + 3] << 24);\n}\n\nfunction readUtf8(buf, pos, end) {\n    var str = '';\n    var i = pos;\n\n    while (i < end) {\n        var b0 = buf[i];\n        var c = null; // codepoint\n        var bytesPerSequence =\n            b0 > 0xEF ? 4 :\n            b0 > 0xDF ? 3 :\n            b0 > 0xBF ? 2 : 1;\n\n        if (i + bytesPerSequence > end) break;\n\n        var b1, b2, b3;\n\n        if (bytesPerSequence === 1) {\n            if (b0 < 0x80) {\n                c = b0;\n            }\n        } else if (bytesPerSequence === 2) {\n            b1 = buf[i + 1];\n            if ((b1 & 0xC0) === 0x80) {\n                c = (b0 & 0x1F) << 0x6 | (b1 & 0x3F);\n                if (c <= 0x7F) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 3) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0xC | (b1 & 0x3F) << 0x6 | (b2 & 0x3F);\n                if (c <= 0x7FF || (c >= 0xD800 && c <= 0xDFFF)) {\n                    c = null;\n                }\n            }\n        } else if (bytesPerSequence === 4) {\n            b1 = buf[i + 1];\n            b2 = buf[i + 2];\n            b3 = buf[i + 3];\n            if ((b1 & 0xC0) === 0x80 && (b2 & 0xC0) === 0x80 && (b3 & 0xC0) === 0x80) {\n                c = (b0 & 0xF) << 0x12 | (b1 & 0x3F) << 0xC | (b2 & 0x3F) << 0x6 | (b3 & 0x3F);\n                if (c <= 0xFFFF || c >= 0x110000) {\n                    c = null;\n                }\n            }\n        }\n\n        if (c === null) {\n            c = 0xFFFD;\n            bytesPerSequence = 1;\n\n        } else if (c > 0xFFFF) {\n            c -= 0x10000;\n            str += String.fromCharCode(c >>> 10 & 0x3FF | 0xD800);\n            c = 0xDC00 | c & 0x3FF;\n        }\n\n        str += String.fromCharCode(c);\n        i += bytesPerSequence;\n    }\n\n    return str;\n}\n\nfunction writeUtf8(buf, str, pos) {\n    for (var i = 0, c, lead; i < str.length; i++) {\n        c = str.charCodeAt(i); // code point\n\n        if (c > 0xD7FF && c < 0xE000) {\n            if (lead) {\n                if (c < 0xDC00) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                    lead = c;\n                    continue;\n                } else {\n                    c = lead - 0xD800 << 10 | c - 0xDC00 | 0x10000;\n                    lead = null;\n                }\n            } else {\n                if (c > 0xDBFF || (i + 1 === str.length)) {\n                    buf[pos++] = 0xEF;\n                    buf[pos++] = 0xBF;\n                    buf[pos++] = 0xBD;\n                } else {\n                    lead = c;\n                }\n                continue;\n            }\n        } else if (lead) {\n            buf[pos++] = 0xEF;\n            buf[pos++] = 0xBF;\n            buf[pos++] = 0xBD;\n            lead = null;\n        }\n\n        if (c < 0x80) {\n            buf[pos++] = c;\n        } else {\n            if (c < 0x800) {\n                buf[pos++] = c >> 0x6 | 0xC0;\n            } else {\n                if (c < 0x10000) {\n                    buf[pos++] = c >> 0xC | 0xE0;\n                } else {\n                    buf[pos++] = c >> 0x12 | 0xF0;\n                    buf[pos++] = c >> 0xC & 0x3F | 0x80;\n                }\n                buf[pos++] = c >> 0x6 & 0x3F | 0x80;\n            }\n            buf[pos++] = c & 0x3F | 0x80;\n        }\n    }\n    return pos;\n}\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","if (process.env.npm_package_name === 'pseudomap' &&\n    process.env.npm_lifecycle_script === 'test')\n  process.env.TEST_PSEUDOMAP = 'true'\n\nif (typeof Map === 'function' && !process.env.TEST_PSEUDOMAP) {\n  module.exports = Map\n} else {\n  module.exports = require('./pseudomap')\n}\n","var hasOwnProperty = Object.prototype.hasOwnProperty\n\nmodule.exports = PseudoMap\n\nfunction PseudoMap (set) {\n  if (!(this instanceof PseudoMap)) // whyyyyyyy\n    throw new TypeError(\"Constructor PseudoMap requires 'new'\")\n\n  this.clear()\n\n  if (set) {\n    if ((set instanceof PseudoMap) ||\n        (typeof Map === 'function' && set instanceof Map))\n      set.forEach(function (value, key) {\n        this.set(key, value)\n      }, this)\n    else if (Array.isArray(set))\n      set.forEach(function (kv) {\n        this.set(kv[0], kv[1])\n      }, this)\n    else\n      throw new TypeError('invalid argument')\n  }\n}\n\nPseudoMap.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  Object.keys(this._data).forEach(function (k) {\n    if (k !== 'size')\n      fn.call(thisp, this._data[k].value, this._data[k].key)\n  }, this)\n}\n\nPseudoMap.prototype.has = function (k) {\n  return !!find(this._data, k)\n}\n\nPseudoMap.prototype.get = function (k) {\n  var res = find(this._data, k)\n  return res && res.value\n}\n\nPseudoMap.prototype.set = function (k, v) {\n  set(this._data, k, v)\n}\n\nPseudoMap.prototype.delete = function (k) {\n  var res = find(this._data, k)\n  if (res) {\n    delete this._data[res._index]\n    this._data.size--\n  }\n}\n\nPseudoMap.prototype.clear = function () {\n  var data = Object.create(null)\n  data.size = 0\n\n  Object.defineProperty(this, '_data', {\n    value: data,\n    enumerable: false,\n    configurable: true,\n    writable: false\n  })\n}\n\nObject.defineProperty(PseudoMap.prototype, 'size', {\n  get: function () {\n    return this._data.size\n  },\n  set: function (n) {},\n  enumerable: true,\n  configurable: true\n})\n\nPseudoMap.prototype.values =\nPseudoMap.prototype.keys =\nPseudoMap.prototype.entries = function () {\n  throw new Error('iterators are not implemented in this version')\n}\n\n// Either identical, or both NaN\nfunction same (a, b) {\n  return a === b || a !== a && b !== b\n}\n\nfunction Entry (k, v, i) {\n  this.key = k\n  this.value = v\n  this._index = i\n}\n\nfunction find (data, k) {\n  for (var i = 0, s = '_' + k, key = s;\n       hasOwnProperty.call(data, key);\n       key = s + i++) {\n    if (same(data[key].key, k))\n      return data[key]\n  }\n}\n\nfunction set (data, k, v) {\n  for (var i = 0, s = '_' + k, key = s;\n       hasOwnProperty.call(data, key);\n       key = s + i++) {\n    if (same(data[key].key, k)) {\n      data[key].value = v\n      return\n    }\n  }\n  data.size++\n  data[key] = new Entry(k, v, key)\n}\n","module.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import mitt from 'mitt';\nimport CartoValidationError from './errors/carto-validation-error';\nimport getCMIntegrator from './integrator/carto';\nimport CartoMap from './integrator/Map';\nimport getMGLIntegrator from './integrator/mapbox-gl';\nimport RenderLayer from './renderer/RenderLayer';\nimport { cubic } from './renderer/viz/expressions';\nimport SourceBase from './sources/Base';\nimport util from './utils/util';\nimport { layerVisibility } from './constants/layer';\nimport Viz from './Viz';\n\n/**\n *\n * LayerEvent objects are fired by {@link carto.Layer|Layer} objects.\n *\n * @typedef {object} LayerEvent\n * @api\n */\n\n/**\n * A loaded event is fired once the layer is firstly loaded. Loaded events won't be fired after the initial load.\n *\n * @event loaded\n * @type {LayerEvent}\n * @api\n */\n\n/**\n * Updated events are fired every time that viz variables could have changed, like: map panning, map zooming, source data loading or viz changes.\n * This is useful to create external widgets that are refreshed reactively to changes in the CARTO VL map.\n *\n * @event updated\n * @type {LayerEvent}\n * @api\n*/\n\n/**\n*\n* A Layer is the primary way to visualize geospatial data.\n*\n* To create a layer a {@link carto.source.Base|source} and {@link carto.Viz|viz} are required:\n*\n* - The {@link carto.source.Base|source} is used to know **what** data will be displayed in the Layer.\n* - The {@link carto.Viz|viz} is used to know **how** to draw the data in the Layer.\n*\n* @param {string} id - The ID of the layer. Can be used in the {@link addTo|addTo} function\n* @param {carto.source.Base} source - The source of the data\n* @param {carto.Viz} viz - The description of the visualization of the data\n*\n* @example\n* const layer = new carto.Layer('layer0', source, viz);\n*\n* @fires CartoError\n*\n* @constructor Layer\n* @memberof carto\n* @api\n*/\nexport default class Layer {\n    constructor (id, source, viz) {\n        this._checkId(id);\n        this._checkSource(source);\n        this._checkViz(viz);\n        this._oldDataframes = new Set();\n        this._isInitialized = false;\n        this._init(id, source, viz);\n    }\n\n    _init (id, source, viz) {\n        viz._boundLayer = this;\n        this.state = 'init';\n        this._id = id;\n\n        this._emitter = mitt();\n        this._lastViewport = null;\n        this._lastMNS = null;\n        this._integrator = null;\n\n        this._context = new Promise((resolve) => {\n            this._contextInitialize = resolve;\n        });\n\n        this._integratorPromise = new Promise((resolve) => {\n            this._integratorCallback = resolve;\n        });\n\n        this.metadata = null;\n        this._renderLayer = new RenderLayer();\n        this.state = 'init';\n        this._isLoaded = false;\n        this._visible = true;\n        this._fireUpdateOnNextRender = false;\n\n        this.update(source, viz);\n    }\n\n    /**\n     * Get layer visibility. Can be 'visible' or 'none'.\n     * @readonly\n     */\n    get visibility () {\n        return this._visible ? layerVisibility.VISIBLE : layerVisibility.HIDDEN;\n    }\n\n    /**\n     * Get layer visibility. Can be true or false.\n     * @readonly\n     */\n    get visible () {\n        return this._visible;\n    }\n\n    /**\n     * Register an event handler for the given event name. Valid names are: `loaded`, `updated`.\n     *\n     * @param {string} eventName - Type of event to listen for\n     * @param {function} callback - Function to call in response to given event\n     * @memberof carto.Layer\n     * @instance\n     * @api\n     */\n    on (eventName, callback) {\n        return this._emitter.on(eventName, callback);\n    }\n\n    /**\n     * Remove an event handler for the given type.\n     *\n     * @param {string} eventName - Type of event to unregister\n     * @param {function} callback - Handler function to unregister\n     * @memberof carto.Layer\n     * @instance\n     * @api\n     */\n    off (eventName, callback) {\n        return this._emitter.off(eventName, callback);\n    }\n\n    /**\n     * Add this layer to a map.\n     *\n     * @param {mapboxgl.Map} map - The map on which to add the layer\n     * @param {string?} beforeLayerID - The ID of an existing layer to insert the new layer before. If this values is not passed the layer will be added on the top of the existing layers.\n     * @memberof carto.Layer\n     * @instance\n     * @api\n     */\n    addTo (map, beforeLayerID) {\n        if (this._isCartoMap(map)) {\n            this._addToCartoMap(map, beforeLayerID);\n        } else if (this._isMGLMap(map)) {\n            this._addToMGLMap(map, beforeLayerID);\n        } else {\n            throw new CartoValidationError('layer', 'nonValidMap');\n        }\n    }\n\n    /**\n     * Update the layer with a new Source and a new Viz object, replacing the current ones. The update is done atomically, i.e.: the viz will be changed with the source, not before it.\n     * This method will return a promise that will be resolved once the source and the visualization are validated.\n     * The promise will be rejected if the validation fails, for example because the visualization expects a property name that is not present in the source.\n     * The promise will be rejected also if this method is invoked again before the first promise is resolved.\n     * If the promise is rejected the layer's source and viz won't be changed.\n     * @param {carto.source.Base} source - the new Source object\n     * @param {carto.Viz} viz - the new Viz object\n     * @memberof carto.Layer\n     * @async\n     * @instance\n     * @api\n     */\n    async update (source, viz) {\n        this._checkSource(source);\n        this._checkViz(viz);\n        source = source._clone();\n        this._atomicChangeUID = this._atomicChangeUID + 1 || 1;\n        const uid = this._atomicChangeUID;\n        const loadImagesPromise = viz.loadImages();\n        const metadata = await source.requestMetadata(viz);\n        await this._integratorPromise;\n        await loadImagesPromise;\n\n        await this._context;\n        if (this._atomicChangeUID > uid) {\n            throw new Error('Another atomic change was done before this one committed');\n        }\n\n        // Everything was ok => commit changes\n        this.metadata = metadata;\n\n        source.bindLayer(this._onDataframeAdded.bind(this), this._onDataLoaded.bind(this));\n\n        if (this._source !== source) {\n            this._freeSource();\n        }\n\n        this._source = source;\n        this.requestData();\n\n        viz.setDefaultsIfRequired(this.metadata.geomType);\n        await this._context;\n        if (this._atomicChangeUID > uid) {\n            throw new Error('Another atomic change was done before this one committed');\n        }\n\n        if (this._viz) {\n            this._viz.onChange(null);\n        }\n        viz.setDefaultsIfRequired(this._renderLayer.type);\n        this._viz = viz;\n        viz.onChange(this._vizChanged.bind(this));\n        this._compileShaders(viz, metadata);\n    }\n\n    /**\n     * Blend the current viz with another viz.\n     *\n     * This allows smooth transforms between two different vizs.\n     *\n     * @example <caption> Smooth transition variating point size </caption>\n     * // We create two different vizs varying the width\n     * const viz0 = new carto.Viz({ width: 10 });\n     * const viz1 = new carto.Viz({ width: 20 });\n     * // Create a layer with the first viz\n     * const layer = new carto.Layer('layer', source, viz0);\n     * // We add the layer to the map, the points in this layer will have widh 10\n     * layer.addTo(map, 'layer0');\n     * // The points will be animated from 10px to 20px for 500ms.\n     * layer.blendToViz(viz1, 500);\n     *\n     * @param {carto.Viz} viz - The final viz\n     * @param {number} [duration=400] - The animation duration in milliseconds\n     *\n     * @memberof carto.Layer\n     * @instance\n     * @api\n     */\n    async blendToViz (viz, ms = 400, interpolator = cubic) {\n        try {\n            this._checkViz(viz);\n            viz.setDefaultsIfRequired(this.metadata.geomType);\n            if (this._viz && !this._source.requiresNewMetadata(viz)) {\n                Object.keys(this._viz.variables).map(varName => {\n                    // If an existing variable is not re-declared we add it to the new viz\n                    if (!viz.variables[varName]) {\n                        viz.variables[varName] = this._viz.variables[varName];\n                    }\n                });\n\n                Object.keys(viz.variables).map(varName => {\n                    // If the variable existed, we need to blend it, nothing to do if not\n                    if (this._viz.variables[varName]) {\n                        viz.variables[varName]._blendFrom(this._viz.variables[varName], ms, interpolator);\n                    }\n                });\n\n                viz.color._blendFrom(this._viz.color, ms, interpolator);\n                viz.strokeColor._blendFrom(this._viz.strokeColor, ms, interpolator);\n                viz.width._blendFrom(this._viz.width, ms, interpolator);\n                viz.strokeWidth._blendFrom(this._viz.strokeWidth, ms, interpolator);\n                viz.filter._blendFrom(this._viz.filter, ms, interpolator);\n            }\n\n            return this._vizChanged(viz).then(() => {\n                if (this._viz) {\n                    this._viz.onChange(null);\n                }\n                viz.setDefaultsIfRequired(this._renderLayer.type);\n                this._viz = viz;\n                this._viz.onChange(this._vizChanged.bind(this));\n            });\n        } catch (error) {\n            return Promise.reject(error);\n        }\n    }\n\n    // The integrator will call this method once the webgl context is ready.\n    initialize () {\n        if (!this._isInitialized) {\n            this._isInitialized = true;\n            this._renderLayer.renderer = this._integrator.renderer;\n            this._contextInitialize();\n            this._renderLayer.dataframes.forEach(d => d.bind(this._integrator.renderer));\n            this.requestMetadata();\n        }\n    }\n\n    async requestMetadata (viz) {\n        viz = viz || this._viz;\n        if (!viz) {\n            return;\n        }\n        return this._source.requestMetadata(viz);\n    }\n\n    async requestData () {\n        if (!this.metadata || !this._visible) {\n            return;\n        }\n\n        this._source.requestData(this._getZoom(), this._getViewport());\n        this._fireUpdateOnNextRender = true;\n    }\n\n    hasDataframes () {\n        return this._renderLayer.hasDataframes();\n    }\n\n    getId () {\n        return this._id;\n    }\n\n    getSource () {\n        return this._source;\n    }\n\n    getViz () {\n        return this._viz;\n    }\n\n    getNumFeatures () {\n        return this._renderLayer.getNumFeatures();\n    }\n\n    getIntegrator () {\n        return this._integrator;\n    }\n\n    getFeaturesAtPosition (pos) {\n        return this._visible\n            ? this._renderLayer.getFeaturesAtPosition(pos).map(this._addLayerIdToFeature.bind(this))\n            : [];\n    }\n\n    /**\n     * Change layer visibility to visible\n     *\n     * @memberof carto.Layer\n     * @instance\n     * @api\n     *\n     * @fires updated\n     */\n    show () {\n        this._visible = true;\n        this._integrator.changeVisibility(this);\n        this.requestData();\n        this._fire('updated');\n    }\n\n    /**\n     * Change layer visibility to hidden\n     *\n     * @memberof carto.Layer\n     * @instance\n     * @api\n     *\n     * @fires updated\n     */\n    hide () {\n        this._visible = false;\n        this._integrator.changeVisibility(this);\n        this._fire('updated');\n    }\n\n    $paintCallback () {\n        if (this._viz && this._viz.colorShader) {\n            this._renderLayer.viz = this._viz;\n            this._integrator.renderer.renderLayer(this._renderLayer);\n            if (this._viz.isAnimated() || this._fireUpdateOnNextRender || !util.isSetsEqual(this._oldDataframes, new Set(this._renderLayer.getActiveDataframes()))) {\n                this._oldDataframes = new Set(this._renderLayer.getActiveDataframes());\n                this._fireUpdateOnNextRender = false;\n                this._fire('updated');\n            }\n            if (!this._isLoaded && this.state === 'dataLoaded') {\n                this._isLoaded = true;\n                this._fire('loaded');\n            }\n        }\n    }\n\n    _fire (eventType, eventData) {\n        try {\n            return this._emitter.emit(eventType, eventData);\n        } catch (err) {\n            console.error(err);\n        }\n    }\n\n    /**\n     * Callback executed when the client adds a new dataframe\n     * @param {Dataframe} dataframe\n     */\n    _onDataframeAdded (dataframe) {\n        dataframe.setFreeObserver(() => {\n            this._integrator.invalidateWebGLState();\n            this._integrator.needRefresh();\n        });\n        this._renderLayer.addDataframe(dataframe);\n        this._integrator.invalidateWebGLState();\n        if (this._viz) {\n            this._viz.setDefaultsIfRequired(dataframe.type);\n        }\n        this._integrator.needRefresh();\n        this._fireUpdateOnNextRender = true;\n    }\n\n    /**\n     * Callback executed when the client finishes loading data\n     */\n    _onDataLoaded () {\n        this.state = 'dataLoaded';\n        this._integrator.needRefresh();\n    }\n\n    _addLayerIdToFeature (feature) {\n        feature.layerId = this._id;\n        return feature;\n    }\n\n    _isCartoMap (map) {\n        return map instanceof CartoMap;\n    }\n\n    _isMGLMap () {\n        // TODO: implement this\n        return true;\n    }\n\n    _addToCartoMap (map, beforeLayerID) {\n        this._integrator = getCMIntegrator(map);\n        this._integrator.addLayer(this, beforeLayerID);\n        this._integratorCallback(this._integrator);\n    }\n\n    _addToMGLMap (map, beforeLayerID) {\n        const STYLE_ERROR_REGEX = /Style is not done loading/;\n\n        try {\n            this._onMapLoaded(map, beforeLayerID);\n        } catch (error) {\n            if (!STYLE_ERROR_REGEX.test(error)) {\n                throw new Error(error);\n            }\n\n            map.on('load', () => {\n                this._onMapLoaded(map, beforeLayerID);\n            });\n        }\n    }\n\n    _onMapLoaded (map, beforeLayerID) {\n        this._integrator = getMGLIntegrator(map);\n        this._integrator.addLayer(this, beforeLayerID);\n        this._integratorCallback(this._integrator);\n    }\n\n    _compileShaders (viz, metadata) {\n        viz.compileShaders(this._integrator.renderer.gl, metadata);\n    }\n\n    async _vizChanged (viz) {\n        await this._context;\n        if (!this._source) {\n            throw new Error('A source is required before changing the viz');\n        }\n        const source = this._source;\n        const loadImagesPromise = viz.loadImages();\n        const metadata = await source.requestMetadata(viz);\n        await loadImagesPromise;\n\n        if (this._source !== source) {\n            throw new Error('A source change was made before the metadata was retrieved, therefore, metadata is stale and it cannot be longer consumed');\n        }\n        this.metadata = metadata;\n        this._compileShaders(viz, this.metadata);\n        this._integrator.needRefresh();\n        return this.requestData();\n    }\n\n    _checkId (id) {\n        if (util.isUndefined(id)) {\n            throw new CartoValidationError('layer', 'idRequired');\n        }\n        if (!util.isString(id)) {\n            throw new CartoValidationError('layer', 'idStringRequired');\n        }\n        if (id === '') {\n            throw new CartoValidationError('layer', 'nonValidId');\n        }\n    }\n\n    _checkSource (source) {\n        if (util.isUndefined(source)) {\n            throw new CartoValidationError('layer', 'sourceRequired');\n        }\n        if (!(source instanceof SourceBase)) {\n            throw new CartoValidationError('layer', 'nonValidSource');\n        }\n    }\n\n    _checkViz (viz) {\n        if (util.isUndefined(viz)) {\n            throw new CartoValidationError('layer', 'vizRequired');\n        }\n        if (!(viz instanceof Viz)) {\n            throw new CartoValidationError('layer', 'nonValidViz');\n        }\n        if (viz._boundLayer && viz._boundLayer !== this) {\n            throw new CartoValidationError('layer', 'sharedViz');\n        }\n    }\n\n    _getViewport () {\n        if (this._integrator) {\n            return this._integrator.renderer.getBounds();\n        }\n    }\n    _getZoom () {\n        if (this._integrator) {\n            return this._integrator.getZoomLevel();\n        }\n    }\n\n    _freeSource () {\n        if (this._source) {\n            this._source.free();\n        }\n        this._renderLayer.freeDataframes();\n    }\n}\n","import schema from './renderer/schema';\nimport shaders from './renderer/shaders/index';\nimport { compileShader } from './renderer/shaders/shaderCompiler';\nimport * as s from './renderer/viz/expressions';\nimport BaseExpression from './renderer/viz/expressions/base';\nimport { implicitCast } from './renderer/viz/expressions/utils';\nimport { parseVizDefinition } from './renderer/viz/parser';\nimport util from './utils/util';\nimport CartoValidationError from './errors/carto-validation-error';\n\nconst DEFAULT_COLOR_EXPRESSION = () => _markDefault(s.rgb(0, 0, 0));\nconst DEFAULT_WIDTH_EXPRESSION = () => _markDefault(s.number(1));\nconst DEFAULT_STROKE_COLOR_EXPRESSION = () => _markDefault(s.rgb(0, 0, 0));\nconst DEFAULT_STROKE_WIDTH_EXPRESSION = () => _markDefault(s.number(0));\nconst DEFAULT_ORDER_EXPRESSION = () => s.noOrder();\nconst DEFAULT_FILTER_EXPRESSION = () => s.constant(1);\nconst DEFAULT_SYMBOL_EXPRESSION = () => { const expr = s.FALSE; expr._default = true; return expr; };\nconst DEFAULT_SYMBOLPLACEMENT_EXPRESSION = () => s.ALIGN_BOTTOM;\nconst DEFAULT_RESOLUTION = () => 1;\n\nconst MIN_RESOLUTION = 0;\nconst MAX_RESOLUTION = 256;\n\nconst SUPPORTED_PROPERTIES = [\n    'color',\n    'width',\n    'strokeColor',\n    'strokeWidth',\n    'order',\n    'filter',\n    'symbol',\n    'symbolPlacement',\n    'resolution',\n    'variables'\n];\n\nexport default class Viz {\n    /**\n    * A Viz is one of the core elements of CARTO VL and defines how the data will be styled,\n    * displayed and processed.\n    *\n    *\n    * @param {string|VizSpec} definition - The definition of a viz. This parameter could be a `string` or a `VizSpec` object\n    *\n    * @example <caption> Create a viz with black dots using the string constructor </caption>\n    * const viz = new carto.Viz(`\n    *   color: rgb(0,0,0)\n    * `);\n    *\n    * @example <caption> Create a viz with black dots using the vizSpec constructor </caption>\n    * const viz = new carto.Viz({\n    *   color: carto.expressions.rgb(0,0,0)\n    * });\n    *\n    * @fires CartoError\n    *\n    * @constructor Viz\n    * @memberof carto\n    * @api\n    *\n    * @property {Color} color - fill color of points and polygons and color of lines, if used with `symbol` the color will override the original image RGB channels\n    * @property {Number} width - fill diameter of points, thickness of lines, not applicable to polygons\n    * @property {Color} strokeColor - stroke/border color of points and polygons, not applicable to lines\n    * @property {Number} strokeWidth - stroke width of points and polygons, not applicable to lines\n    * @property {Number} filter - filter features by removing from rendering and interactivity all the features that don't pass the test\n    * @property {Image} symbol - show an image instead in the place of points\n    * @property {Placement} symbolPlacement - when using `symbol`, offset to apply to the image\n    * @IGNOREproperty {Order} order - rendering order of the features, only applicable to points\n    * @property {number} resolution - resolution of the property-aggregation functions, a value of 4 means to produce aggregation on grid cells of 4x4 pixels, only applicable to points\n    * @property {object} variables - An object describing the variables used.\n    *\n    */\n    constructor (definition) {\n        const vizSpec = this._getVizDefinition(definition);\n        this._checkVizSpec(vizSpec);\n\n        Object.keys(vizSpec).forEach(property => {\n            this._defineProperty(property, vizSpec[property]);\n        });\n        if (!Object.keys(vizSpec).includes('variables')) {\n            this._defineProperty('variables', {});\n        }\n\n        this.updated = true;\n        this._changeCallback = null;\n\n        this._updateRootExpressionList();\n        this._updateRootExpressions();\n\n        this._resolveAliases();\n        this._validateAliasDAG();\n    }\n\n    loadImages () {\n        return Promise.all(this._getRootExpressions().map(expr => expr.loadImages()));\n    }\n\n    // Define a viz property, setting all the required getters, setters and creating a proxy for the variables object\n    // These setters and the proxy allow us to re-render without requiring further action from the user\n    _defineProperty (propertyName, propertyValue) {\n        if (!SUPPORTED_PROPERTIES.includes(propertyName)) {\n            return;\n        }\n        Object.defineProperty(this, propertyName, {\n            get: () => this['_' + propertyName],\n            set: expr => {\n                if (propertyName !== 'resolution') {\n                    expr = implicitCast(expr);\n                }\n                this['_' + propertyName] = expr;\n                this._changed();\n            }\n        });\n\n        let property = propertyValue;\n        if (propertyName === 'variables') {\n            let init = false;\n            const handler = {\n                get: (obj, prop) => {\n                    return obj[prop];\n                },\n                set: (obj, prop, value) => {\n                    value = implicitCast(value);\n                    obj[prop] = value;\n                    this['__cartovl_variable_' + prop] = value;\n                    if (init) {\n                        this._changed();\n                    }\n                    return true;\n                }\n            };\n            property = new Proxy({}, handler);\n            Object.keys(propertyValue).map(varName => {\n                property[varName] = propertyValue[varName];\n            });\n            init = true;\n        }\n        this['_' + propertyName] = property;\n    }\n\n    _getRootExpressions () {\n        return this._rootExpressions;\n    }\n\n    _updateRootExpressions () {\n        this._getRootExpressions().forEach(expr => {\n            expr.parent = this;\n            expr.notify = this._changed.bind(this);\n        });\n    }\n\n    isAnimated () {\n        return this.color.isAnimated() ||\n            this.width.isAnimated() ||\n            this.strokeColor.isAnimated() ||\n            this.strokeWidth.isAnimated() ||\n            this.filter.isAnimated() ||\n            this.symbol.isAnimated() ||\n            this.symbolPlacement.isAnimated();\n    }\n\n    onChange (callback) {\n        this._changeCallback = callback;\n    }\n\n    _changed () {\n        this._updateRootExpressionList();\n        this._resolveAliases();\n        this._validateAliasDAG();\n        if (this._changeCallback) {\n            this._changeCallback(this);\n        }\n    }\n\n    _updateRootExpressionList () {\n        this._rootExpressions = [\n            this.color,\n            this.width,\n            this.strokeColor,\n            this.strokeWidth,\n            this.order,\n            this.filter,\n            this.symbol,\n            this.symbolPlacement,\n            ...Object.values(this.variables)\n        ];\n    }\n\n    getMinimumNeededSchema () {\n        const exprs = this._getRootExpressions().filter(x => x && x._getMinimumNeededSchema);\n        return exprs.map(expr => expr._getMinimumNeededSchema()).reduce(schema.union, schema.IDENTITY);\n    }\n\n    setDefaultsIfRequired (geomType) {\n        if (this._appliedDefaults) {\n            return;\n        }\n        let defaults = this._getDefaultGeomStyle(geomType);\n        if (defaults) {\n            this._appliedDefaults = true;\n            if (this.color.default) {\n                this.color = defaults.COLOR_EXPRESSION();\n            }\n            if (this.width.default) {\n                this.width = defaults.WIDTH_EXPRESSION();\n            }\n            if (this.strokeColor.default) {\n                this.strokeColor = defaults.STROKE_COLOR_EXPRESSION();\n            }\n            if (this.strokeWidth.default) {\n                this.strokeWidth = defaults.STROKE_WIDTH_EXPRESSION();\n            }\n            this._updateRootExpressions();\n        }\n    }\n\n    _getDefaultGeomStyle (geomType) {\n        if (geomType === 'point') {\n            return {\n                COLOR_EXPRESSION: () => _markDefault(s.hex('#EE4D5A')),\n                WIDTH_EXPRESSION: () => _markDefault(s.number(7)),\n                STROKE_COLOR_EXPRESSION: () => _markDefault(s.hex('#FFF')),\n                STROKE_WIDTH_EXPRESSION: () => _markDefault(s.number(1))\n            };\n        } else if (geomType === 'line') {\n            return {\n                COLOR_EXPRESSION: () => _markDefault(s.hex('#4CC8A3')),\n                WIDTH_EXPRESSION: () => _markDefault(s.number(1.5)),\n                STROKE_COLOR_EXPRESSION: () => _markDefault(s.hex('#FFF')), // Not used in lines\n                STROKE_WIDTH_EXPRESSION: () => _markDefault(s.number(1)) // Not used in lines\n            };\n        } else if (geomType === 'polygon') {\n            return {\n                COLOR_EXPRESSION: () => _markDefault(s.hex('#826DBA')),\n                WIDTH_EXPRESSION: () => _markDefault(s.number(1)), // Not used in polygons\n                STROKE_COLOR_EXPRESSION: () => _markDefault(s.hex('#FFF')),\n                STROKE_WIDTH_EXPRESSION: () => _markDefault(s.number(1))\n            };\n        }\n    }\n\n    _resolveAliases () {\n        [\n            this.color,\n            this.width,\n            this.strokeColor,\n            this.strokeWidth,\n            this.filter,\n            this.symbol,\n            this.symbolPlacement\n        ].concat(Object.values(this.variables)).forEach(expr =>\n            expr._resolveAliases(this.variables)\n        );\n    }\n\n    _validateAliasDAG () {\n        const permanentMarkedSet = new Set();\n        const temporarilyMarkedSet = new Set();\n        const visit = node => {\n            if (permanentMarkedSet.has(node)) {\n                // Node is already a processed dependency\n                return;\n            }\n            if (temporarilyMarkedSet.has(node)) {\n                throw new Error('Viz contains a circular dependency');\n            }\n            temporarilyMarkedSet.add(node);\n            node._getDependencies().forEach(visit);\n            permanentMarkedSet.add(node);\n        };\n        const unmarked = [\n            ...this.color._getDependencies(),\n            ...this.strokeColor._getDependencies(),\n            ...this.width._getDependencies(),\n            ...this.strokeWidth._getDependencies(),\n            ...this.filter._getDependencies(),\n            ...this.symbol._getDependencies(),\n            ...this.symbolPlacement._getDependencies()];\n        while (unmarked.length) {\n            visit(unmarked.pop());\n        }\n    }\n\n    compileShaders (gl, metadata) {\n        this._getRootExpressions().forEach(expr => expr._bindMetadata(metadata));\n\n        this.colorShader = compileShader(gl, shaders.styler.colorShaderGLSL, { color: this.color }, this);\n        this.widthShader = compileShader(gl, shaders.styler.widthShaderGLSL, { width: this.width }, this);\n        this.strokeColorShader = compileShader(gl, shaders.styler.colorShaderGLSL, { color: this.strokeColor }, this);\n        this.strokeWidthShader = compileShader(gl, shaders.styler.widthShaderGLSL, { width: this.strokeWidth }, this);\n        this.filterShader = compileShader(gl, shaders.styler.filterShaderGLSL, { filter: this.filter }, this);\n\n        if (!this.symbol._default) {\n            this.symbolShader = compileShader(gl, shaders.symbolizer.symbolShaderGLSL, {\n                symbol: this.symbol,\n                symbolPlacement: this.symbolPlacement\n            }, this);\n        }\n    }\n\n    replaceChild (toReplace, replacer) {\n        if (Object.values(this.variables).includes(toReplace)) {\n            const varName = Object.keys(this.variables).find(varName => this.variables[varName] === toReplace);\n            this.variables[varName] = replacer;\n            replacer.parent = this;\n            replacer.notify = toReplace.notify;\n        } else if (toReplace === this.color) {\n            this.color = replacer;\n            replacer.parent = this;\n            replacer.notify = toReplace.notify;\n        } else if (toReplace === this.width) {\n            this.width = replacer;\n            replacer.parent = this;\n            replacer.notify = toReplace.notify;\n        } else if (toReplace === this.strokeColor) {\n            this.strokeColor = replacer;\n            replacer.parent = this;\n            replacer.notify = toReplace.notify;\n        } else if (toReplace === this.strokeWidth) {\n            this.strokeWidth = replacer;\n            replacer.parent = this;\n            replacer.notify = toReplace.notify;\n        } else if (toReplace === this.filter) {\n            this.filter = replacer;\n            replacer.parent = this;\n            replacer.notify = toReplace.notify;\n        } else if (toReplace === this.symbol) {\n            this.symbol = replacer;\n            replacer.parent = this;\n            replacer.notify = toReplace.notify;\n        } else if (toReplace === this.symbolPlacement) {\n            this.symbolPlacement = replacer;\n            replacer.parent = this;\n            replacer.notify = toReplace.notify;\n        } else {\n            throw new Error('No child found');\n        }\n    }\n\n    /**\n     * This function checks the input parameter `definition` returning always an object.\n     * If the `definition` is an object it returns the same object.\n     * If the `definition` is a string it returns the parsed string as an object.\n     * Otherwise it throws an error.\n     *\n     * @param  {string|object} definition\n     * @return {VizSpec}\n     */\n    _getVizDefinition (definition) {\n        if (util.isUndefined(definition)) {\n            return this._setDefaults({});\n        }\n        if (util.isObject(definition)) {\n            return this._setDefaults(definition);\n        }\n        if (util.isString(definition)) {\n            return this._setDefaults(parseVizDefinition(definition));\n        }\n        throw new CartoValidationError('viz', 'nonValidDefinition');\n    }\n\n    /**\n     * Add default values to a vizSpec object.\n     *\n     * @param {VizSpec} vizSpec\n     * @return {VizSpec}\n     */\n    _setDefaults (vizSpec) {\n        if (util.isUndefined(vizSpec.color)) {\n            vizSpec.color = DEFAULT_COLOR_EXPRESSION();\n        }\n        if (util.isUndefined(vizSpec.width)) {\n            vizSpec.width = DEFAULT_WIDTH_EXPRESSION();\n        }\n        if (util.isUndefined(vizSpec.strokeColor)) {\n            vizSpec.strokeColor = DEFAULT_STROKE_COLOR_EXPRESSION();\n        }\n        if (util.isUndefined(vizSpec.strokeWidth)) {\n            vizSpec.strokeWidth = DEFAULT_STROKE_WIDTH_EXPRESSION();\n        }\n        if (util.isUndefined(vizSpec.order)) {\n            vizSpec.order = DEFAULT_ORDER_EXPRESSION();\n        }\n        if (util.isUndefined(vizSpec.filter)) {\n            vizSpec.filter = DEFAULT_FILTER_EXPRESSION();\n        }\n        if (util.isUndefined(vizSpec.resolution)) {\n            vizSpec.resolution = DEFAULT_RESOLUTION();\n        }\n        if (util.isUndefined(vizSpec.symbol)) {\n            vizSpec.symbol = DEFAULT_SYMBOL_EXPRESSION();\n        }\n        if (util.isUndefined(vizSpec.symbolPlacement)) {\n            vizSpec.symbolPlacement = DEFAULT_SYMBOLPLACEMENT_EXPRESSION();\n        }\n        vizSpec.variables = vizSpec.variables || {};\n        return vizSpec;\n    }\n\n    _checkVizSpec (vizSpec) {\n        /**\n         * A vizSpec object is used to create a {@link carto.Viz|Viz} and controlling multiple aspects.\n         * For a better understanding we recommend reading the {@link TODO|VIZ guide}\n         * @typedef {object} VizSpec\n         * @property {Color} color - fill color of points and polygons and color of lines, if used with `symbol` the color will override the original image RGB channels\n         * @property {Number} width - fill diameter of points, thickness of lines, not applicable to polygons\n         * @property {Color} strokeColor - stroke/border color of points and polygons, not applicable to lines\n         * @property {Number} strokeWidth - stroke width of points and polygons, not applicable to lines\n         * @property {Number} filter - filter features by removing from rendering and interactivity all the features that don't pass the test\n         * @property {Image} symbol - show an image instead in the place of points\n         * @property {Placement} symbolPlacement - when using `symbol`, offset to apply to the image\n         * @IGNOREproperty {Order} order - rendering order of the features, only applicable to points\n         * @property {number} resolution - resolution of the property-aggregation functions, a value of 4 means to produce aggregation on grid cells of 4x4 pixels, only applicable to points\n         * @property {object} variables - An object describing the variables used.\n         * @api\n         */\n\n        // TODO: Check expression types ie: color is not a number expression!\n\n        // Apply implicit cast to numeric style properties\n        vizSpec.width = implicitCast(vizSpec.width);\n        vizSpec.strokeWidth = implicitCast(vizSpec.strokeWidth);\n        vizSpec.symbolPlacement = implicitCast(vizSpec.symbolPlacement);\n        vizSpec.symbol = implicitCast(vizSpec.symbol);\n        vizSpec.filter = implicitCast(vizSpec.filter);\n\n        if (!util.isNumber(vizSpec.resolution)) {\n            throw new CartoValidationError('viz', 'resolutionNumberRequired');\n        }\n        if (vizSpec.resolution <= MIN_RESOLUTION) {\n            throw new CartoValidationError('viz', `resolutionTooSmall[${MIN_RESOLUTION}]`);\n        }\n        if (vizSpec.resolution >= MAX_RESOLUTION) {\n            throw new CartoValidationError('viz', `resolutionTooBig[${MAX_RESOLUTION}]`);\n        }\n        if (!(vizSpec.color instanceof BaseExpression)) {\n            throw new CartoValidationError('viz', 'nonValidExpression[color]');\n        }\n        if (!(vizSpec.strokeColor instanceof BaseExpression)) {\n            throw new CartoValidationError('viz', 'nonValidExpression[strokeColor]');\n        }\n        if (!(vizSpec.width instanceof BaseExpression)) {\n            throw new CartoValidationError('viz', 'nonValidExpression[width]');\n        }\n        if (!(vizSpec.strokeWidth instanceof BaseExpression)) {\n            throw new CartoValidationError('viz', 'nonValidExpression[strokeWidth]');\n        }\n        if (!(vizSpec.order instanceof BaseExpression)) {\n            throw new CartoValidationError('viz', 'nonValidExpression[order]');\n        }\n        if (!(vizSpec.filter instanceof BaseExpression)) {\n            throw new CartoValidationError('viz', 'nonValidExpression[filter]');\n        }\n        if (!(vizSpec.symbol instanceof BaseExpression)) {\n            throw new CartoValidationError('viz', 'nonValidExpression[symbol]');\n        }\n        if (!(vizSpec.symbolPlacement instanceof BaseExpression)) {\n            throw new CartoValidationError('viz', 'nonValidExpression[symbolPlacement]');\n        }\n        for (let key in vizSpec) {\n            if (SUPPORTED_PROPERTIES.indexOf(key) === -1) {\n                console.warn(`Property '${key}' is not supported`);\n            }\n        }\n    }\n}\n\n/**\n * Mark default expressions to apply the style defaults for each\n * geometry (point, line, polygon) when available.\n */\nfunction _markDefault (expression) {\n    expression.default = true;\n    return expression;\n}\n","\nlet registeredHandlers = [];\n\n/**\n * Register an event handler for the given event name and for the given list of layers. Valid names are: `loaded`, `updated`.\n *\n * The 'loaded' event will be fired when all the layers are loaded (and their 'loaded' events are fired).\n *\n * The 'updated' event will be fired whenever one of the layers fired an 'updated' event,\n * but throttled by requestAnimationFrame to return a maximum of one event per frame.\n *\n * @param {string} eventName - Supported event names are 'loaded' and 'updated'\n * @param {carto.Layer[]} layerList - List of layers\n *\n * @memberof carto\n * @api\n */\nexport function on (eventName, layerList, callback) {\n    let internalCallbacks = [];\n    if (eventName === 'loaded') {\n        const waitingGroup = new Set(layerList);\n        layerList.forEach(layer => {\n            const internalCallback = () => {\n                waitingGroup.delete(layer);\n                if (waitingGroup.size === 0) {\n                    callback();\n                }\n            };\n            layer.on('loaded', internalCallback);\n            internalCallbacks.push(internalCallback);\n        });\n    } else if (eventName === 'updated') {\n        let scheduledRAF = false;\n        layerList.forEach(layer => {\n            const internalCallback = () => {\n                if (!scheduledRAF) {\n                    window.requestAnimationFrame(() => {\n                        scheduledRAF = false;\n                        callback();\n                    });\n                }\n            };\n            layer.on('updated', internalCallback);\n            internalCallbacks.push(internalCallback);\n        });\n    } else {\n        throw new Error(`Event name '${eventName}' is not supported by 'carto.on'. Supported event names are: 'loaded', 'updated'.`);\n    }\n    registeredHandlers.push({\n        eventName,\n        layerList,\n        callback,\n        internalCallbacks\n    });\n}\n\n/**\n* Remove an event handler for the given event name, layer list and callback.\n*\n* @param {string} eventName - event\n* @param {carto.Layer} layerList - List of layers\n* @param {function} callback - Handler function to unregister\n*\n* @memberof carto\n* @api\n*/\nexport function off (eventName, layerList, callback) {\n    registeredHandlers.forEach(register => {\n        if (register.eventName === eventName &&\n            register.layerList.every(registeredLayer => layerList.includes(registeredLayer)) &&\n            register.callback === callback) {\n            register.layerList.forEach(layer => {\n                register.internalCallbacks.forEach(internalCallback => {\n                    layer.off(eventName, internalCallback);\n                });\n            });\n        }\n    });\n    registeredHandlers = registeredHandlers.filter(register =>\n        !(\n            register.eventName === eventName &&\n            register.layerList.every(registeredLayer => layerList.includes(registeredLayer)) &&\n            register.callback === callback\n        )\n    );\n}\n","import geometryUtils from '../../utils/geometry';\nexport class Polygon {\n    constructor () {\n        this.flat = [];\n        this.holes = [];\n        this.clipped = [];\n        this.clippedType = []; // Store a bitmask of the clipped half-planes\n    }\n}\n\nexport function decodeLines (geometries, mvtExtent) {\n    let decodedGeometries = [];\n    geometries.map(l => {\n        let line = [];\n        l.map(point => {\n            line.push([2 * point.x / mvtExtent - 1, 2 * (1 - point.y / mvtExtent) - 1]);\n        });\n        decodedGeometries.push(...clipLine(line));\n    });\n    return decodedGeometries;\n}\n\n/*\n    All this clockwise non-sense is needed because the MVT decoder dont decode the MVT fully.\n    It doesn't distinguish between internal polygon rings (which defines holes) or external ones, which defines more polygons (mulipolygons)\n    See:\n        https://github.com/mapbox/vector-tile-spec/tree/master/2.1\n        https://en.wikipedia.org/wiki/Shoelace_formula\n*/\nexport function decodePolygons (geometries, mvtExtent) {\n    let currentPolygon = null;\n    let decoded = [];\n    let invertedOrientation;\n    geometries.forEach(geom => {\n        let area = signedPolygonArea(geom);\n        if (area === 0) {\n            return;\n        }\n        if (invertedOrientation === undefined) {\n            // According to the MVT spec this condition cannot happen for\n            // MVT spec compliant tiles, but many buggy implementations\n            // don't comply with this rule when generating tiles\n            // Also, other implementations accept this out-of-the-spec condition\n            invertedOrientation = area > 0;\n        }\n        const isExternalPolygon = invertedOrientation ? area > 0 : area < 0;\n\n        const preClippedVertices = _getPreClippedVertices(geom, mvtExtent);\n\n        if (isExternalPolygon) {\n            if (currentPolygon) {\n                decoded.push(currentPolygon);\n            }\n\n            currentPolygon = new Polygon();\n        }\n\n        currentPolygon = clipPolygon(preClippedVertices, currentPolygon, !isExternalPolygon);\n    });\n\n    if (currentPolygon) {\n        decoded.push(currentPolygon);\n    }\n\n    return decoded;\n}\n\nexport function signedPolygonArea (vertices) {\n    // https://en.wikipedia.org/wiki/Shoelace_formula\n    let a = 0;\n    for (let i = 0; i < vertices.length; i++) {\n        let j = (i + 1) % vertices.length;\n        a += vertices[i].x * vertices[j].y;\n        a -= vertices[j].x * vertices[i].y;\n    }\n    return a / 2;\n}\n\nconst CLIPMAX = 1;\nconst CLIPMIN = -CLIPMAX;\n\nconst clippingEdges = [\n    {\n        // Right edge; x <= CLIPMAX for points inside\n        inside: p => p[0] <= CLIPMAX,\n        intersect: (a, b) => geometryUtils.intersect(a, b, [CLIPMAX, -100], [CLIPMAX, 100])\n    },\n    {\n        // Top edge; y <= CLIPMAX for points inside\n        inside: p => p[1] <= CLIPMAX,\n        intersect: (a, b) => geometryUtils.intersect(a, b, [-100, CLIPMAX], [100, CLIPMAX])\n    },\n    {\n        // Left edge; x >= CLIPMIN for points inside\n        inside: p => p[0] >= CLIPMIN,\n        intersect: (a, b) => geometryUtils.intersect(a, b, [CLIPMIN, -100], [CLIPMIN, 100])\n    },\n    {\n        // Bottom edge; y >= CLIPMIN for points inside\n        inside: p => p[1] >= CLIPMIN,\n        intersect: (a, b) => geometryUtils.intersect(a, b, [-100, CLIPMIN], [100, CLIPMIN])\n    }\n];\nconst numberOfEdges = clippingEdges.length;\n\nexport function clipPolygon (preClippedVertices, polygon, isHole) {\n    // Sutherland-Hodgman Algorithm to clip polygons to the tile\n    // https://www.cs.drexel.edu/~david/Classes/CS430/Lectures/L-05_Polygons.6.pdf\n\n    let clippedTypes = {};\n\n    // for each clipping edge\n    for (let i = 0; i < numberOfEdges; i++) {\n        const preClippedVertices2 = [];\n        const clippedTypes2 = {};\n\n        const setClippedType = (vertexIndex, oldVertexIndex, edge = -1) => {\n            let clippedType = 0;\n            if (oldVertexIndex >= 0) {\n                clippedType = clippedTypes[oldVertexIndex] || 0;\n            }\n            if (edge >= 0) {\n                clippedType = clippedType | (1 << edge);\n            }\n            if (clippedType) {\n                clippedTypes2[vertexIndex] = clippedType;\n            }\n        };\n\n        // for each edge on polygon\n        for (let k = 0; k < preClippedVertices.length - 1; k++) {\n            // clip polygon edge\n            const a = preClippedVertices[k];\n            const b = preClippedVertices[k + 1];\n\n            const insideA = clippingEdges[i].inside(a);\n            const insideB = clippingEdges[i].inside(b);\n\n            if (insideA && insideB) {\n                // case 1: both inside, push B vertex\n                setClippedType(preClippedVertices2.length, k + 1);\n                preClippedVertices2.push(b);\n            } else if (insideA) {\n                // case 2: just B outside, push intersection\n                const intersectionPoint = clippingEdges[i].intersect(a, b);\n                setClippedType(preClippedVertices2.length, k + 1, i);\n                preClippedVertices2.push(intersectionPoint);\n            } else if (insideB) {\n                // case 4: just A outside: push intersection, push B\n                const intersectionPoint = clippingEdges[i].intersect(a, b);\n                setClippedType(preClippedVertices2.length, k, i);\n                preClippedVertices2.push(intersectionPoint);\n                setClippedType(preClippedVertices2.length, k + 1);\n                preClippedVertices2.push(b);\n            } else {\n                // case 3: both outside: do nothing\n            }\n        }\n        if (preClippedVertices2.length) {\n            if (clippedTypes2[0]) {\n                clippedTypes2[preClippedVertices2.length] = clippedTypes2[0];\n            }\n            preClippedVertices2.push(preClippedVertices2[0]);\n        }\n        preClippedVertices = preClippedVertices2;\n        clippedTypes = clippedTypes2;\n    }\n\n    // rings with less than 3 vertices are degenerate\n    const MIN_VALID_NUM_VERTICES = 3;\n\n    // preClippedVertices is closed by repeating the first vertex\n    if (preClippedVertices.length >= MIN_VALID_NUM_VERTICES + 1) {\n        if (isHole) {\n            polygon.holes.push(polygon.flat.length / 2);\n        }\n        preClippedVertices.forEach(v => {\n            polygon.flat.push(v[0], v[1]);\n        });\n        Object.keys(clippedTypes).forEach(i => {\n            polygon.clipped.push(Number(i) * 2);\n            polygon.clippedType.push(clippedTypes[i]);\n        });\n    }\n\n    return polygon;\n}\n\nfunction _getPreClippedVertices (geom, mvtExtent) {\n    return geom.map((coord) => {\n        let x = coord.x;\n        let y = coord.y;\n\n        x = 2 * x / mvtExtent - 1;\n        y = 2 * (1 - y / mvtExtent) - 1;\n\n        return [x, y];\n    });\n}\n\nfunction clipLine (line) {\n    // linestring clipping based on the Cohen-Sutherland algorithm\n    // input is a single linestring [point0, point1, ...]\n    // output is an array of flat linestrings:\n    // [[p0x, p0y, p1x, p1y, ...], ...]\n    let clippedLine = [];\n    const clippedLines = [];\n    function clipType (point) {\n        let type = 0;\n        for (let i = 0; i < numberOfEdges; i++) {\n            type = type | (clippingEdges[i].inside(point) ? 0 : (1 << i));\n        }\n        return type;\n    }\n    function intersect (point1, point2, type) {\n        for (let i = 0; i < numberOfEdges; i++) {\n            const mask = 1 << i;\n            if (type & mask) {\n                const p = clippingEdges[i].intersect(point1, point2);\n                type = clipType(p) & ~mask;\n                return [p, type];\n            }\n        }\n    }\n    let point0 = line[0];\n    let type0 = clipType(point0);\n    for (let i = 1; i < line.length; ++i) {\n        let point1 = line[i];\n        let type1 = clipType(point1);\n        const nextType = type1;\n        const nextPoint = point1;\n\n        for (; ;) {\n            if (!(type0 | type1)) {\n                // both points inside\n                clippedLine.push(...point0);\n                if (type1 !== nextType) {\n                    clippedLine.push(...point1);\n                    if (i < line.length - 1) {\n                        // break line\n                        clippedLines.push(clippedLine);\n                        clippedLine = [];\n                    }\n                } else if (i === line.length - 1) {\n                    clippedLine.push(...point1);\n                }\n                break;\n            } else if (type0 & type1) {\n                // both points outside\n                break;\n            } else if (type0) {\n                // only point1 inside\n                [point0, type0] = intersect(point0, point1, type0);\n            } else {\n                // only point0 inside\n                [point1, type1] = intersect(point0, point1, type1);\n            }\n        }\n\n        point0 = nextPoint;\n        type0 = nextType;\n    }\n\n    clippedLine = _removeDuplicatedVerticesOnLine(clippedLine);\n    if (clippedLine.length > 0) {\n        clippedLines.push(clippedLine);\n    }\n\n    return clippedLines;\n}\n\nfunction _removeDuplicatedVerticesOnLine (line) {\n    const result = [];\n    let prevX;\n    let prevY;\n    for (let i = 0; i < line.length; i += 2) {\n        const x = line[i];\n        const y = line[i + 1];\n        if (x !== prevX || y !== prevY) {\n            result.push(x, y);\n            prevX = x;\n            prevY = y;\n        }\n    }\n    return result;\n}\n","/**\n * An RSys defines a local coordinate system that maps the coordinates\n * in the range -1 <= x <= +1; -1 <= y <= +1 to an arbitrary rectangle\n * in an external coordinate system. (e.g. Dataframe coordinates to World coordinates)\n * It is the combination of a translation and anisotropic scaling.\n * @typedef {object} RSys - Renderer relative coordinate system\n * @property {RPoint} center - Position of the local system in external coordinates\n * @property {number} scale - Y-scale (local Y-distance / external Y-distance)\n*/\n\n/*\n * Random notes\n *\n * We can redefine Dataframe to use a Rsys instead of center, scale\n * and we can use an Rsys for the Renderer's canvas.\n *\n * Some interesting World coordinate systems:\n *\n * WM (Webmercator): represents a part of the world (excluding polar regions)\n * with coordinates in the range +/-WM_R for both X and Y. (positive orientation: E,N)\n *\n * NWMC (Normalized Webmercator Coordinates): represents the Webmercator *square*\n * with coordinates in the range +/-1. Results from dividing Webmercator coordinates\n * by WM_R. (positive orientation: E,N)\n *\n * TC (Tile coordinates): integers in [0, 2^Z) for zoom level Z. Example: the tile 0/0/0 (zoom, x, y) is the root tile.\n * (positive orientation: E,S)\n *\n * An RSys's rectangle (its bounds) is the area covered by the local coordinates in\n * the range +/-1.\n *\n * When an RSys external coordinate system is WM or NWMC, we can compute:\n * * Minimum zoom level for which tiles are no larger than the RSys rectangle:\n *   Math.ceil(Math.log2(1 / r.scale));\n * * Maximum zoom level for which tiles are no smaller than the rectangle:\n *   Math.floor(Math.log2(1 / r.scale));\n * (note that 1 / r.scale is the fraction of the World height that the local rectangle's height represents)\n *\n * We'll use the term World coordinates below for the *external* reference system\n * of an RSys (usually NWMC).\n */\n\n/* eslint no-unused-vars: [\"off\"] */\n\n/**\n * R coordinates to World\n * @param {RSys} r - ref. of the passed coordinates\n * @param {number} x - x coordinate in r\n * @param {number} y - y coordinate in r\n * @return {RPoint} World coordinates\n */\nfunction rToW (r, x, y) {\n    return { x: x * r.scale + r.center.x, y: y * r.scale + r.center.y };\n}\n\n/**\n * World coordinates to local RSys\n * @param {number} x - x W-coordinate\n * @param {number} y - y W-coordinate\n * @param {RSys} r - target ref. system\n * @return {RPoint} R coordinates\n */\nexport function wToR (x, y, r) {\n    return { x: (x - r.center.x) / r.scale, y: (y - r.center.y) / r.scale };\n}\n\n/**\n * RSys of a tile (mapping local tile coordinates in +/-1 to NWMC)\n * @param {number} x - TC x coordinate\n * @param {number} y - TC y coordinate\n * @param {number} z - Tile zoom level\n * @return {RSys}\n */\nfunction tileRsys (x, y, z) {\n    let max = Math.pow(2, z);\n    return { scale: 1 / max, center: { x: 2 * (x + 0.5) / max - 1, y: 1 - 2 * (y + 0.5) / max } };\n}\n\n/**\n * TC tiles that intersect the local rectangle of an RSys\n * (with the largest tile size no larger than the rectangle)\n * @param {RSys} rsys\n * @return {Array} - array of TC tiles {x, y, z}\n */\nexport function rTiles (zoom, bounds, viewportZoomToSourceZoom = Math.ceil) {\n    return wRectangleTiles(viewportZoomToSourceZoom(zoom), bounds);\n}\n\n/**\n * TC tiles of a given zoom level that intersect a W rectangle\n * @param {number} z\n * @param {Array} - rectangle extents [minx, miny, maxx, maxy]\n * @return {Array} - array of TC tiles {x, y, z}\n */\nfunction wRectangleTiles (z, wr) {\n    const [wMinx, wMiny, wMaxx, wMaxy] = wr;\n    const n = (1 << z); // for 0 <= z <= 30 equals Math.pow(2, z)\n\n    const clamp = x => Math.min(Math.max(x, 0), n - 1);\n    // compute tile coordinate ranges\n    const tMinx = clamp(Math.floor(n * (wMinx + 1) * 0.5));\n    const tMaxx = clamp(Math.ceil(n * (wMaxx + 1) * 0.5) - 1);\n    const tMiny = clamp(Math.floor(n * (1 - wMaxy) * 0.5));\n    const tMaxy = clamp(Math.ceil(n * (1 - wMiny) * 0.5) - 1);\n    let tiles = [];\n    for (let x = tMinx; x <= tMaxx; ++x) {\n        for (let y = tMiny; y <= tMaxy; ++y) {\n            tiles.push({ x: x, y: y, z: z });\n        }\n    }\n    return tiles;\n}\n\n/**\n * Get the Rsys of a tile where the Rsys's center is the tile center and the Rsys's scale is the tile extent.\n * @param {*} x\n * @param {*} y\n * @param {*} z\n * @returns {RSys}\n */\nexport function getRsysFromTile (x, y, z) {\n    return {\n        center: {\n            x: ((x + 0.5) / Math.pow(2, z)) * 2.0 - 1,\n            y: (1.0 - (y + 0.5) / Math.pow(2, z)) * 2.0 - 1.0\n        },\n        scale: 1 / Math.pow(2, z)\n    };\n}\n\nexport default { rTiles, getRsysFromTile, wToR };\n","import { And, Or, Equals, NotEquals, LessThan, LessThanOrEqualTo, GreaterThan, GreaterThanOrEqualTo } from '../renderer/viz/expressions/binary';\nimport { In, Nin } from '../renderer/viz/expressions/belongs';\nimport Between from '../renderer/viz/expressions/between';\nimport Property from '../renderer/viz/expressions/basic/property';\nimport Blend from '../renderer/viz/expressions/blend';\nimport Transition from '../renderer/viz/expressions/transition';\nimport NumberExpression from '../renderer/viz/expressions/basic/number';\nimport ConstantExpression from '../renderer/viz/expressions/basic/constant';\nimport CategoryExpression from '../renderer/viz/expressions/basic/category';\nimport ClusterAvg from '../renderer/viz/expressions/aggregation/cluster/ClusterAvg';\nimport ClusterMax from '../renderer/viz/expressions/aggregation/cluster/ClusterMax';\nimport ClusterMin from '../renderer/viz/expressions/aggregation/cluster/ClusterMin';\nimport ClusterMode from '../renderer/viz/expressions/aggregation/cluster/ClusterMode';\nimport ClusterSum from '../renderer/viz/expressions/aggregation/cluster/ClusterSum';\n\nimport * as schema from '../renderer/schema';\n\nclass AggregationFiltering {\n    /**\n     * Generate aggregation filters:\n     * This extracts, from the vizs filters, those compatible to be\n     * executed through the Maps API aggregation API.\n     * The extracted filters are in the format admitted by the Maps API\n     * `filters` parameter.\n     * Filters affecting dimensions (non-aggregated columns) can optionally\n     * be extracted too, but it is more efficient to not do so and apply those\n     * filters before aggregation.\n     */\n    constructor (options) {\n        // exclusive mode: aggregate filters don't include pre-aggregate conditions (dimensions)\n        // in that case pre-aggregate filters should always be applied, even with aggregation\n        // (which can be more efficient)\n        this._onlyAggregateFilters = options.exclusive;\n    }\n\n    // return (partial) filters as an object (JSON) in the format of the Maps API aggregation interface\n    getFilters (vizFilter) {\n        let filters = {};\n        let filterList = this._and(vizFilter).filter(Boolean);\n        for (let p of filterList) {\n            let name = p.property;\n            let existingFilter = filters[name];\n            if (existingFilter) {\n                if (this._compatibleAndFilters(existingFilter, p.filters)) {\n                    // combine inequalities into a range\n                    Object.assign(existingFilter[0], p.filters[0]);\n                } else {\n                    // can't AND-combine filters for the same property\n                    return {};\n                }\n            } else {\n                filters[name] = p.filters;\n            }\n        }\n        return filters;\n    }\n\n    _and (f) {\n        if (f.isA(And)) {\n            return this._and(f.a).concat(this._and(f.b)).filter(Boolean);\n        }\n        return [this._or(f)].filter(Boolean);\n    }\n\n    _or (f) {\n        if (f.isA(Or)) {\n            let a = this._basicCondition(f.a);\n            let b = this._basicCondition(f.b);\n            if (a && b) {\n                if (a.property === b.property) {\n                    a.filters = a.filters.concat(b.filters);\n                    return a;\n                }\n            }\n        }\n        return this._basicCondition(f);\n    }\n\n    _removeBlend (f) {\n        if (f.isA(Blend) && f.originalMix.isA(Transition)) {\n            return f.b;\n        }\n        return f;\n    }\n\n    _basicCondition (f) {\n        f = this._removeBlend(f);\n        return this._between(f) ||\n            this._equals(f) || this._notEquals(f) ||\n            this._lessThan(f) || this._lessThanOrEqualTo(f) ||\n            this._greaterThan(f) || this._greaterThanOrEqualTo(f) ||\n            this._in(f) || this._notIn(f);\n    }\n\n    _value (f) {\n        f = this._removeBlend(f);\n        if (f.isA(NumberExpression) || f.isA(ConstantExpression) || f.isA(CategoryExpression)) {\n            return f.expr;\n        }\n    }\n\n    _between (f) {\n        if (f.isA(Between)) {\n            let p = this._aggregation(f.value);\n            let lo = p && this._value(f.lowerLimit);\n            let hi = p && lo && this._value(f.upperLimit);\n            if (hi) {\n                p.filters.push({\n                    greater_than_or_equal_to: lo,\n                    less_than_or_equal_to: hi\n                });\n                return p;\n            }\n        }\n    }\n\n    _in (f) {\n        if (f.isA(In)) {\n            let p = this._aggregation(f.value);\n            let values = f.list.elems.map(c => this._value(c)).filter(v => v !== null);\n            if (p && values.length > 0 && values.length === f.list.elems.length) {\n                p.filters.push({\n                    in: values\n                });\n                return p;\n            }\n        }\n    }\n\n    _notIn (f) {\n        if (f.isA(Nin)) {\n            let p = this._aggregation(f.value);\n            let values = f.list.elems.map(c => this._value(c)).filter(v => v !== null);\n            if (p && values.length > 0 && values.length === f.list.elems.length) {\n                p.filters.push({\n                    not_in: values\n                });\n                return p;\n            }\n        }\n    }\n\n    _equals (f) {\n        return this._cmpOp(f, Equals, 'equal');\n    }\n\n    _notEquals (f) {\n        return this._cmpOp(f, NotEquals, 'not_equal');\n    }\n\n    _lessThan (f) {\n        return this._cmpOp(f, LessThan, 'less_than', 'greater_than');\n    }\n\n    _lessThanOrEqualTo (f) {\n        return this._cmpOp(f, LessThanOrEqualTo, 'less_than_or_equal_to', 'greater_than_or_equal_to');\n    }\n\n    _greaterThan (f) {\n        return this._cmpOp(f, GreaterThan, 'greater_than', 'less_than');\n    }\n\n    _greaterThanOrEqualTo (f) {\n        return this._cmpOp(f, GreaterThanOrEqualTo, 'greater_than_or_equal_to', 'less_than_or_equal_to');\n    }\n\n    _aggregation (f) {\n        f = this._removeBlend(f);\n        if (f.isA(ClusterAvg) || f.isA(ClusterMax) || f.isA(ClusterMin) || f.isA(ClusterMode) || f.isA(ClusterSum)) {\n            let p = this._property(f.property);\n            if (p) {\n                p.property = schema.column.aggColumn(p.property, f.aggName);\n                return p;\n            }\n        }\n        if (this._onlyAggregateFilters) {\n            // no filters on non-aggregate columns (i.e. dimensions) are generated\n            // such filtering should be applied elsewhere\n            return;\n        }\n        return this._property(f);\n    }\n\n    _property (f) {\n        f = this._removeBlend(f);\n        if (f.isA(Property)) {\n            return {\n                property: f.name,\n                filters: []\n            };\n        }\n    }\n\n    _cmpOp (f, opClass, opParam, inverseOpParam) {\n        inverseOpParam = inverseOpParam || opParam;\n        if (f.isA(opClass)) {\n            let p = this._aggregation(f.a);\n            let v = p && this._value(f.b);\n            let op = opParam;\n            if (!v) {\n                p = this._aggregation(f.b);\n                v = p && this._value(f.a);\n                op = inverseOpParam;\n            }\n            if (v) {\n                let filter = {};\n                filter[op] = v;\n                p.filters.push(filter);\n                return p;\n            }\n        }\n    }\n\n    _compatibleAndFilters (a, b) {\n        // check if a and b can be combined into a range filter\n        if (a.length === 0 || b.length === 0) {\n            return true;\n        }\n        if (a.length === 1 && b.length === 1) {\n            const af = a[0];\n            const bf = b[0];\n            if (Object.keys(af).length === 1 && Object.keys(bf).length === 1) {\n                const ka = Object.keys(af)[0];\n                const kb = Object.keys(bf)[0];\n                const lessOps = ['less_than', 'less_than_or_equal_to'];\n                const greaterOps = ['greater_than', 'greater_than_or_equal_to'];\n                return (lessOps.includes(ka) && greaterOps.includes(kb)) ||\n                    (lessOps.includes(kb) && greaterOps.includes(ka));\n            }\n        }\n        return false;\n    }\n}\n\nclass PreaggregationFiltering {\n    /**\n     * Generate pre-aggregation filters, i.e. filters that can be\n     * applied to the dataset before aggregation.\n     * This extracts, from the vizs filters, those compatible to be\n     * executed before aggregation.\n     * The extracted filters are in an internal tree-like format;\n     * each node has a `type` property and various other parameters\n     * that depend on the type.\n     */\n\n    // return (partial) filters as an object (JSON) representing the SQL syntax tree\n    getFilter (vizFilter) {\n        return this._filter(vizFilter);\n    }\n\n    _filter (f) {\n        return this._and(f) || this._or(f) ||\n            this._in(f) || this._notIn(f) ||\n            this._between(f) ||\n            this._equals(f) || this._notEquals(f) ||\n            this._lessThan(f) || this._lessThanOrEqualTo(f) ||\n            this._greaterThan(f) || this._greaterThanOrEqualTo(f) ||\n            this._blend(f) || null;\n    }\n\n    _and (f) {\n        if (f.isA(And)) {\n            // we can ignore nonsupported (null) subexpressions that are combined with AND\n            // and keep the supported ones as a partial filter\n            const l = [this._filter(f.a), this._filter(f.b)].filter(Boolean).reduce((x, y) => x.concat(y), []);\n            if (l.length) {\n                if (l.length === 1) {\n                    return l[0];\n                }\n                return {\n                    type: 'and',\n                    left: l[0],\n                    right: l[1]\n                };\n            }\n        }\n    }\n\n    _or (f) {\n        if (f.isA(Or)) {\n            // if any subexpression is not supported the OR combination isn't supported either\n            let a = this._filter(f.a);\n            let b = this._filter(f.b);\n            if (a && b) {\n                return {\n                    type: 'or',\n                    left: a,\n                    right: b\n                };\n            }\n        }\n    }\n\n    _lessThan (f) {\n        return this._cmpOp(f, LessThan, 'lessThan');\n    }\n\n    _lessThanOrEqualTo (f) {\n        return this._cmpOp(f, LessThanOrEqualTo, 'lessThanOrEqualTo');\n    }\n\n    _greaterThan (f) {\n        return this._cmpOp(f, GreaterThan, 'greaterThan');\n    }\n\n    _greaterThanOrEqualTo (f) {\n        return this._cmpOp(f, GreaterThanOrEqualTo, 'greaterThanOrEqualTo');\n    }\n\n    _equals (f) {\n        return this._cmpOp(f, Equals, 'equals');\n    }\n\n    _notEquals (f) {\n        return this._cmpOp(f, NotEquals, 'notEquals');\n    }\n\n    _cmpOp (f, opClass, type) {\n        if (f.isA(opClass)) {\n            let a = this._property(f.a) || this._value(f.a);\n            let b = this._property(f.b) || this._value(f.b);\n            if (a && b) {\n                return {\n                    type: type,\n                    left: a,\n                    right: b\n                };\n            }\n        }\n    }\n\n    _blend (f) {\n        if (f.isA(Blend) && f.originalMix.isA(Transition)) {\n            return this._filter(f.b);\n        }\n    }\n\n    _property (f) {\n        if (f.isA(Property)) {\n            return {\n                type: 'property',\n                property: f.name\n            };\n        }\n    }\n\n    _value (f) {\n        if (f.isA(NumberExpression) || f.isA(ConstantExpression) || f.isA(CategoryExpression)) {\n            return {\n                type: 'value',\n                value: f.expr\n            };\n        }\n    }\n\n    _in (f) {\n        if (f.isA(In)) {\n            let p = this._property(f.value);\n            let values = f.list.elems.map(cat => this._value(cat));\n            if (p && values.length > 0 && values.length === f.list.elems.length) {\n                return {\n                    type: 'in',\n                    property: p.property,\n                    values: values.map(v => v.value)\n                };\n            }\n        }\n    }\n\n    _notIn (f) {\n        if (f.isA(Nin)) {\n            let p = this._property(f.value);\n            let values = f.list.elems.map(cat => this._value(cat));\n            if (p && values.length > 0 && values.length === f.list.elems.length) {\n                return {\n                    type: 'notIn',\n                    property: p.property,\n                    values: values.map(v => v.value)\n                };\n            }\n        }\n    }\n\n    _between (f) {\n        if (f.isA(Between)) {\n            let p = this._property(f.value);\n            let lo = this._value(f.lowerLimit);\n            let hi = this._value(f.upperLimit);\n            if (p && lo && hi) {\n                return {\n                    type: 'between',\n                    property: p.property,\n                    lower: lo.value,\n                    upper: hi.value\n                };\n            }\n        }\n    }\n}\n\nfunction getSQL (node) {\n    if (node.type) {\n        return `(${SQLGenerators[node.type](node)})`;\n    }\n    return sqlQ(node);\n}\n\nfunction sqlQ (value) {\n    if (isFinite(value)) {\n        return String(value);\n    }\n    return `'${value.replace(/\\'/g, '\\'\\'')}'`;\n}\n\nfunction sqlId (id) {\n    if (!id.match(/^[a-z\\d_]+$/)) {\n        id = `\"${id.replace(/\\\"/g, '\"\"')}\"`;\n    }\n    return id;\n}\n\nfunction sqlSep (sep, ...args) {\n    return args.map(arg => getSQL(arg)).join(sep);\n}\n\nconst SQLGenerators = {\n    'and': f => sqlSep(' AND ', f.left, f.right),\n    'or': f => sqlSep(' OR ', f.left, f.right),\n    'between': f => `${sqlId(f.property)} BETWEEN ${sqlQ(f.lower)} AND ${sqlQ(f.upper)}`,\n    'in': f => `${sqlId(f.property)} IN (${sqlSep(',', ...f.values)})`,\n    'notIn': f => `${sqlId(f.property)} NOT IN (${sqlSep(',', ...f.values)})`,\n    'equals': f => sqlSep(' = ', f.left, f.right),\n    'notEquals': f => sqlSep(' <> ', f.left, f.right),\n    'lessThan': f => sqlSep(' < ', f.left, f.right),\n    'lessThanOrEqualTo': f => sqlSep(' <= ', f.left, f.right),\n    'greaterThan': f => sqlSep(' > ', f.left, f.right),\n    'greaterThanOrEqualTo': f => sqlSep(' >= ', f.left, f.right),\n    'property': f => sqlId(f.property),\n    'value': f => sqlQ(f.value)\n};\n\n/**\n * Returns supported windshaft filters for the viz\n * @param {*} viz\n * @returns {Filtering}\n */\nexport function getFiltering (viz, options = {}) {\n    const aggrFiltering = new AggregationFiltering(options);\n    const preFiltering = new PreaggregationFiltering(options);\n    const filtering = {\n        preaggregation: preFiltering.getFilter(viz.filter),\n        aggregation: aggrFiltering.getFilters(viz.filter)\n    };\n    if (!filtering.preaggregation && !filtering.aggregation) {\n        return null;\n    }\n    return filtering;\n}\n\n/**\n * Convert preaggregation filters (as generated by PreaggregationFiltering)\n * into an equivalent SQL WHERE expression.\n *\n * @param {Filtering} filtering\n */\nexport function getSQLWhere (filtering) {\n    filtering = filtering && filtering.preaggregation;\n    let sql;\n    if (filtering && Object.keys(filtering).length > 0) {\n        sql = getSQL(filtering);\n    }\n    return sql ? 'WHERE ' + sql : '';\n}\n\nexport function getAggregationFilters (filtering) {\n    return filtering && filtering.aggregation;\n}\n","import { version } from '../../package';\nimport MVT from '../sources/MVT';\nimport Metadata from '../renderer/Metadata';\nimport schema from '../renderer/schema';\nimport Time from '../renderer/viz/expressions/time';\nimport * as windshaftFiltering from './windshaft-filtering';\n\nconst SAMPLE_ROWS = 1000;\nconst MIN_FILTERING = 2000000;\nconst REQUEST_GET_MAX_URL_LENGTH = 2048;\n\n// Get dataframes <- MVT <- Windshaft\n// Get metadata\n// Instantiate map Windshaft\n// Requrest SQL API (temp)\n// Cache dataframe\n\nexport default class Windshaft {\n    constructor (source) {\n        this._source = source;\n        this._exclusive = true;\n\n        this._MNS = null;\n        this._promiseMNS = null;\n        this.inProgressInstantiations = {};\n    }\n\n    bindLayer (addDataframe, dataLoadedCallback) {\n        this._addDataframe = addDataframe;\n        this._dataLoadedCallback = dataLoadedCallback;\n        this._mvtClient.bindLayer(addDataframe, dataLoadedCallback);\n    }\n\n    _getInstantiationID (MNS, resolution, filtering, choices) {\n        return JSON.stringify({\n            MNS,\n            resolution,\n            filtering: choices.backendFilters ? filtering : null,\n            options: choices\n        });\n    }\n\n    /**\n     * Should be called whenever the viz changes (even if metadata is not going to be used)\n     * This not only computes metadata: it also updates the map (instantiates) for the new viz if needed\n     * Returns  a promise to a Metadata\n     * @param {*} viz\n     */\n    async getMetadata (viz) {\n        const MNS = viz.getMinimumNeededSchema();\n        this._checkAcceptableMNS(MNS);\n        const resolution = viz.resolution;\n        const filtering = windshaftFiltering.getFiltering(viz, { exclusive: this._exclusive });\n        // Force to include `cartodb_id` in the MNS columns.\n        // TODO: revisit this request to Maps API\n        if (!MNS.columns.includes('cartodb_id')) {\n            MNS.columns.push('cartodb_id');\n        }\n        if (this._needToInstantiate(MNS, resolution, filtering)) {\n            const instantiationData = await this._repeatableInstantiate(MNS, resolution, filtering);\n            this._updateStateAfterInstantiating(instantiationData);\n        }\n        return this.metadata;\n    }\n\n    requiresNewMetadata (viz) {\n        const MNS = viz.getMinimumNeededSchema();\n        this._checkAcceptableMNS(MNS);\n        const resolution = viz.resolution;\n        const filtering = windshaftFiltering.getFiltering(viz, { exclusive: this._exclusive });\n        if (!MNS.columns.includes('cartodb_id')) {\n            MNS.columns.push('cartodb_id');\n        }\n        return this._needToInstantiate(MNS, resolution, filtering);\n    }\n\n    _checkAcceptableMNS (MNS) {\n        const columnAgg = {};\n        MNS.columns.map(column => {\n            const basename = schema.column.getBase(column);\n            const isAgg = schema.column.isAggregated(column);\n            if (columnAgg[basename] === undefined) {\n                columnAgg[basename] = isAgg;\n            } else if (columnAgg[basename] !== isAgg) {\n                throw new Error(`Incompatible combination of cluster aggregation with un-aggregated property: '${basename}'`);\n            }\n        });\n    }\n\n    /**\n     * After calling getMetadata(), data for a viewport can be obtained with this function.\n     * So long as the viz doesn't change, getData() can be called repeatedly for different\n     * viewports. If viz changes getMetadata() should be called before requesting data\n     * for the new viz.\n     */\n    getData (zoom, viewport) {\n        if (this._mvtClient) {\n            return this._mvtClient.requestData(zoom, viewport);// FIXME extend\n        }\n    }\n\n    /**\n     * Check if the map needs to be reinstantiated\n     * This happens:\n     *  - When the minimun required schema changed.\n     *  - When the resolution changed.\n     *  - When the filter conditions changed and the dataset should be server-filtered.\n     */\n    _needToInstantiate (MNS, resolution, filtering) {\n        return !schema.equals(this._MNS, MNS) ||\n            resolution !== this.resolution ||\n            (\n                JSON.stringify(filtering) !== JSON.stringify(this.filtering) &&\n                this.metadata.featureCount > MIN_FILTERING\n            );\n    }\n\n    _isInstantiated () {\n        return !!this.metadata;\n    }\n\n    _intantiationChoices (metadata) {\n        let choices = {\n            // default choices\n            backendFilters: true\n        };\n        if (metadata) {\n            if (metadata.featureCount >= 0) {\n                choices.backendFilters = metadata.featureCount > MIN_FILTERING || !metadata.backendFiltersApplied;\n            }\n        }\n        return choices;\n    }\n\n    async _instantiateUncached (MNS, resolution, filters, choices = { backendFilters: true }, overrideMetadata = null) {\n        const conf = this._getConfig();\n        const agg = await this._generateAggregation(MNS, resolution);\n        let select = this._buildSelectClause(MNS);\n        let aggSQL = this._buildQuery(select);\n\n        const query = `(${aggSQL}) AS tmp`;\n\n        let backendFilters = choices.backendFilters ? filters : null;\n        let backendFiltersApplied = false;\n\n        if (backendFilters && this._requiresAggregation(MNS)) {\n            agg.filters = windshaftFiltering.getAggregationFilters(backendFilters);\n            if (agg.filters) {\n                backendFiltersApplied = true;\n            }\n            if (!this._exclusive) {\n                backendFilters = null;\n            }\n        }\n        if (backendFilters) {\n            const filteredSQL = this._buildQuery(select, backendFilters);\n            backendFiltersApplied = backendFiltersApplied || filteredSQL !== aggSQL;\n            aggSQL = filteredSQL;\n        }\n\n        let { url, metadata } = await this._getInstantiationPromise(query, conf, agg, aggSQL, select, overrideMetadata);\n        metadata.backendFiltersApplied = backendFiltersApplied;\n\n        return { MNS, resolution, filters, metadata, urlTemplate: url };\n    }\n\n    _updateStateAfterInstantiating ({ MNS, resolution, filters, metadata, urlTemplate }) {\n        if (this._mvtClient) {\n            this._mvtClient.free();\n        }\n        this._mvtClient = new MVT(this._URLTemplates);\n        this._mvtClient.bindLayer(this._addDataframe, this._dataLoadedCallback);\n        this._mvtClient.decodeProperty = (propertyName, propertyValue) => {\n            const basename = schema.column.getBase(propertyName);\n            const column = this.metadata.properties[basename];\n            if (!column) {\n                return;\n            }\n            switch (column.type) {\n                case 'date':\n                {\n                    const d = new Date();\n                    d.setTime(1000 * propertyValue);\n                    const min = column.min;\n                    const max = column.max;\n                    const n = (d - min) / (max.getTime() - min.getTime());\n                    return n;\n                }\n                case 'category':\n                    return this.metadata.categorizeString(propertyValue);\n                case 'number':\n                    return propertyValue;\n                default:\n                    throw new Error(`Windshaft MVT decoding error. Feature property value of type '${typeof propertyValue}' cannot be decoded.`);\n            }\n        };\n        this.urlTemplate = urlTemplate;\n        this.metadata = metadata;\n        this._mvtClient._metadata = metadata;\n        this._MNS = MNS;\n        this.filtering = filters;\n        this.resolution = resolution;\n        this._checkLayerMeta(MNS);\n    }\n    async _instantiate (MNS, resolution, filters, choices, metadata) {\n        if (this.inProgressInstantiations[this._getInstantiationID(MNS, resolution, filters, choices)]) {\n            return this.inProgressInstantiations[this._getInstantiationID(MNS, resolution, filters, choices)];\n        }\n        const instantiationPromise = this._instantiateUncached(MNS, resolution, filters, choices, metadata);\n        this.inProgressInstantiations[this._getInstantiationID(MNS, resolution, filters, choices)] = instantiationPromise;\n        return instantiationPromise;\n    }\n\n    async _repeatableInstantiate (MNS, resolution, filters) {\n        // TODO: we shouldn't reinstantiate just to not apply backend filters\n        // (we'd need to add a choice comparison function argument to repeatablePromise)\n        let finalMetadata = null;\n        const initialChoices = this._intantiationChoices(this.metadata);\n        const finalChoices = instantiation => {\n            // first instantiation metadata is kept\n            finalMetadata = instantiation.metadata;\n            return this._intantiationChoices(instantiation.metadata);\n        };\n        return repeatablePromise(initialChoices, finalChoices, choices => this._instantiate(MNS, resolution, filters, choices, finalMetadata));\n    }\n\n    _checkLayerMeta (MNS) {\n        if (!this._isAggregated()) {\n            if (this._requiresAggregation(MNS)) {\n                throw new Error('Aggregation not supported for this dataset');\n            }\n        }\n    }\n\n    _isAggregated () {\n        return this.metadata && this.metadata.isAggregated;\n    }\n\n    _requiresAggregation (MNS) {\n        return MNS.columns.some(column => schema.column.isAggregated(column));\n    }\n\n    _generateAggregation (MNS, resolution) {\n        let aggregation = {\n            columns: {},\n            dimensions: {},\n            placement: 'centroid',\n            resolution: resolution,\n            threshold: 1\n        };\n\n        MNS.columns\n            .forEach(name => {\n                if (name !== 'cartodb_id') {\n                    if (schema.column.isAggregated(name)) {\n                        aggregation.columns[name] = {\n                            aggregate_function: schema.column.getAggFN(name),\n                            aggregated_column: schema.column.getBase(name)\n                        };\n                    } else {\n                        aggregation.dimensions[name] = name;\n                    }\n                }\n            });\n\n        return aggregation;\n    }\n\n    _buildSelectClause (MNS) {\n        const columns = MNS.columns.map(name => schema.column.getBase(name))\n            .concat(['the_geom', 'the_geom_webmercator', 'cartodb_id']);\n        return columns.filter((item, pos) => columns.indexOf(item) === pos); // get unique values\n    }\n\n    _buildQuery (select, filters) {\n        const columns = select.join();\n        const relation = this._source._query ? `(${this._source._query}) as _cdb_query_wrapper` : this._source._tableName;\n        const condition = filters ? windshaftFiltering.getSQLWhere(filters) : '';\n        return `SELECT ${columns} FROM ${relation} ${condition}`;\n    }\n\n    _getConfig () {\n        return {\n            apiKey: this._source._apiKey,\n            username: this._source._username,\n            serverURL: this._source._serverURL\n        };\n    }\n\n    free () {\n        if (this._mvtClient) {\n            this._mvtClient.free();\n        }\n    }\n\n    async _getInstantiationPromise (query, conf, agg, aggSQL, columns, overrideMetadata = null) {\n        const LAYER_INDEX = 0;\n        const mapConfigAgg = {\n            buffersize: {\n                mvt: 1\n            },\n            layers: [\n                {\n                    type: 'mapnik',\n                    options: {\n                        sql: aggSQL,\n                        aggregation: agg,\n                        dates_as_numbers: true\n                    }\n                }\n            ]\n        };\n        if (!overrideMetadata) {\n            const excludedColumns = ['the_geom', 'the_geom_webmercator'];\n            const includedColumns = columns.filter(name => !excludedColumns.includes(name));\n            mapConfigAgg.layers[0].options.metadata = {\n                geometryType: true,\n                columnStats: { topCategories: 32768, includeNulls: true },\n                sample: {\n                    num_rows: SAMPLE_ROWS,\n                    include_columns: includedColumns // TODO: when supported by Maps API: exclude_columns: excludedColumns\n                }\n            };\n        }\n        const response = await fetch(getMapRequest(conf, mapConfigAgg));\n        const layergroup = await response.json();\n        if (!response.ok) {\n            throw new Error(`Maps API error: ${JSON.stringify(layergroup)}`);\n        }\n        this._URLTemplates = layergroup.metadata.tilejson.vector.tiles;\n        return {\n            url: getLayerUrl(layergroup, LAYER_INDEX, conf),\n            metadata: overrideMetadata || this._adaptMetadata(layergroup.metadata.layers[0].meta, agg)\n        };\n    }\n\n    _adaptMetadata (meta, agg) {\n        meta.datesAsNumbers = meta.dates_as_numbers;\n        const { stats, aggregation, datesAsNumbers } = meta;\n        const featureCount = stats.hasOwnProperty('featureCount') ? stats.featureCount : stats.estimatedFeatureCount;\n        const geomType = adaptGeometryType(stats.geometryType);\n\n        const properties = stats.columns;\n        Object.keys(agg.columns).forEach(aggName => {\n            const basename = schema.column.getBase(aggName);\n            const fnName = schema.column.getAggFN(aggName);\n            if (!properties[basename].aggregations) {\n                properties[basename].aggregations = {};\n            }\n            properties[basename].aggregations[fnName] = aggName;\n        });\n        Object.values(properties).map(property => {\n            property.type = adaptColumnType(property.type);\n        });\n\n        Object.keys(properties).forEach(propertyName => {\n            const property = properties[propertyName];\n            if (property.type === 'category' && property.categories) {\n                property.categories.forEach(category => {\n                    category.name = category.category;\n                    delete category.category;\n                });\n            } else if (datesAsNumbers && datesAsNumbers.includes(propertyName)) {\n                property.type = 'date';\n                ['min', 'max', 'avg'].map(fn => {\n                    if (property[fn]) {\n                        property[fn] = new Time(property[fn] * 1000).value;\n                    }\n                });\n            }\n        });\n\n        const idProperty = 'cartodb_id';\n\n        const metadata = new Metadata({ properties, featureCount, sample: stats.sample, geomType, isAggregated: aggregation.mvt, idProperty });\n        return metadata;\n    }\n}\n\nfunction adaptGeometryType (type) {\n    switch (type) {\n        case 'ST_MultiPolygon':\n        case 'ST_Polygon':\n            return 'polygon';\n        case 'ST_Point':\n            return 'point';\n        case 'ST_MultiLineString':\n        case 'ST_LineString':\n            return 'line';\n        default:\n            throw new Error(`Unimplemented geometry type ''${type}'`);\n    }\n}\n\nfunction adaptColumnType (type) {\n    if (type === 'string') {\n        return 'category';\n    }\n    return type;\n}\n\n// generate a promise under certain assumptions/choices; then if the result changes the assumptions,\n// repeat the generation with the new information\nasync function repeatablePromise (initialAssumptions, assumptionsFromResult, promiseGenerator) {\n    let promise = promiseGenerator(initialAssumptions);\n    let result = await promise;\n    let finalAssumptions = assumptionsFromResult(result);\n    if (JSON.stringify(initialAssumptions) === JSON.stringify(finalAssumptions)) {\n        return promise;\n    } else {\n        return promiseGenerator(finalAssumptions);\n    }\n}\n\nfunction getMapRequest (conf, mapConfig) {\n    const mapConfigPayload = JSON.stringify(mapConfig);\n    const auth = encodeParameter('api_key', conf.apiKey);\n    const client = encodeParameter('client', `vl-${version}`);\n\n    const parameters = [auth, client, encodeParameter('config', mapConfigPayload)];\n    const url = generateUrl(generateMapsApiUrl(conf), parameters);\n    if (url.length < REQUEST_GET_MAX_URL_LENGTH) {\n        return new Request(url, {\n            method: 'GET',\n            headers: {\n                'Accept': 'application/json'\n            }\n        });\n    }\n\n    return new Request(generateUrl(generateMapsApiUrl(conf), [auth, client]), {\n        method: 'POST',\n        headers: {\n            'Accept': 'application/json',\n            'Content-Type': 'application/json'\n        },\n        body: mapConfigPayload\n    });\n}\n\nfunction getLayerUrl (layergroup, layerIndex, conf) {\n    const params = [encodeParameter('api_key', conf.apiKey)];\n    if (layergroup.cdn_url && layergroup.cdn_url.templates) {\n        const urlTemplates = layergroup.cdn_url.templates.https;\n        return generateUrl(`${urlTemplates.url}/${conf.username}/api/v1/map/${layergroup.layergroupid}/${layerIndex}/{z}/{x}/{y}.mvt`, params);\n    }\n    return generateUrl(generateMapsApiUrl(conf, `/${layergroup.layergroupid}/${layerIndex}/{z}/{x}/{y}.mvt`), params);\n}\n\nfunction encodeParameter (name, value) {\n    return `${name}=${encodeURIComponent(value)}`;\n}\n\nfunction generateUrl (url, parameters = []) {\n    return `${url}?${parameters.join('&')}`;\n}\n\nfunction generateMapsApiUrl (conf, path) {\n    let url = `${conf.serverURL}/api/v1/map`;\n    if (path) {\n        url += path;\n    }\n    return url;\n}\n","export const layerVisibility = Object.freeze({\n    VISIBLE: 'visible',\n    HIDDEN: 'none'\n});\n","import * as ERROR_LIST from './error-list';\n\nconst UNEXPECTED_ERROR = 'unexpected error';\nconst GENERIC_ORIGIN = 'generic';\n\n/**\n * Represents an error in the carto library.\n *\n * @typedef {object} CartoError\n * @property {string} message - A short error description\n * @property {string} name - The name of the error \"CartoError\"\n * @property {string} origin - Where the error was originated: 'validation'\n * @property {object} originalError - An object containing the internal/original error\n * @property {object} stack - Error stack trace\n * @property {string} type - Error type\n *\n * @event CartoError\n * @api\n */\nclass CartoError extends Error {\n    /**\n     * Build a cartoError from a generic error.\n     * @constructor\n     *\n     * @return {CartoError} A well formed object representing the error.\n     */\n    constructor (error) {\n        super((error && error.message) || UNEXPECTED_ERROR);\n\n        this.name = 'CartoError';\n        this.originalError = error;\n        // this.stack = (new Error()).stack;\n        this.type = (error && error.type) || '';\n        this.origin = (error && error.origin) || GENERIC_ORIGIN;\n\n        // Add extra fields\n        const extraFields = this._getExtraFields();\n        this.message = extraFields.friendlyMessage;\n    }\n\n    _getExtraFields () {\n        const errorList = this._getErrorList();\n        for (let key in errorList) {\n            const error = errorList[key];\n            if (!(error.messageRegex instanceof RegExp)) {\n                throw new Error(`MessageRegex on ${key} is not a RegExp.`);\n            }\n            if (error.messageRegex.test(this.message)) {\n                return {\n                    friendlyMessage: this._replaceRegex(error)\n                };\n            }\n        }\n\n        // When cartoError not found return generic values\n        return {\n            friendlyMessage: this.message || ''\n        };\n    }\n\n    _getErrorList () {\n        return ERROR_LIST[this.origin] && ERROR_LIST[this.origin][this.type];\n    }\n\n    /**\n     * Replace $0 with the proper paramter in the listedError regex to build a friendly message.\n     */\n    _replaceRegex (error) {\n        if (!error.friendlyMessage) {\n            return this.message;\n        }\n        const match = this.message && this.message.match(error.messageRegex);\n        if (match && match.length > 1) {\n            return error.friendlyMessage.replace('$0', match[1]);\n        }\n        return error.friendlyMessage;\n    }\n}\n\nexport { CartoError };\n","import { CartoError } from './carto-error';\n\n/**\n * Utility to build a cartoError related to validation errors.\n *\n * @return {CartoError} A well formed object representing the error.\n */\nexport default class CartoValidationError extends CartoError {\n    constructor (type, message) {\n        super({\n            origin: 'validation',\n            type: type,\n            message: message\n        });\n    }\n}\n","const validation = {\n    layer: {\n        'id-required': {\n            messageRegex: /idRequired/,\n            friendlyMessage: '`id` property required.'\n        },\n        'id-string-required': {\n            messageRegex: /idStringRequired/,\n            friendlyMessage: '`id` property must be a string.'\n        },\n        'non-valid-id': {\n            messageRegex: /nonValidId/,\n            friendlyMessage: '`id` property must be not empty.'\n        },\n        'source-required': {\n            messageRegex: /sourceRequired/,\n            friendlyMessage: '`source` property required.'\n        },\n        'non-valid-source': {\n            messageRegex: /nonValidSource/,\n            friendlyMessage: 'The given object is not a valid source. See \"carto.source.Base\".'\n        },\n        'viz-required': {\n            messageRegex: /vizRequired/,\n            friendlyMessage: '`viz` property required.'\n        },\n        'non-valid-viz': {\n            messageRegex: /nonValidViz/,\n            friendlyMessage: 'The given object is not a valid viz. See \"carto.Viz\".'\n        },\n        'shared-viz': {\n            messageRegex: /sharedViz/,\n            friendlyMessage: 'The given Viz object is already bound to another layer. Vizs cannot be shared between different layers'\n        }\n    },\n    setup: {\n        'auth-required': {\n            messageRegex: /authRequired/,\n            friendlyMessage: '`auth` property is required.'\n        },\n        'auth-object-required': {\n            messageRegex: /authObjectRequired/,\n            friendlyMessage: '`auth` property must be an object.'\n        },\n        'api-key-required': {\n            messageRegex: /apiKeyRequired/,\n            friendlyMessage: '`apiKey` property is required.'\n        },\n        'api-key-string-required': {\n            messageRegex: /apiKeyStringRequired/,\n            friendlyMessage: '`apiKey` property must be a string.'\n        },\n        'non-valid-api-key': {\n            messageRegex: /nonValidApiKey/,\n            friendlyMessage: '`apiKey` property must be not empty.'\n        },\n        'username-required': {\n            messageRegex: /usernameRequired/,\n            friendlyMessage: '`username` property is required.'\n        },\n        'username-string-required': {\n            messageRegex: /usernameStringRequired/,\n            friendlyMessage: '`username` property must be a string.'\n        },\n        'non-valid-username': {\n            messageRegex: /nonValidUsername/,\n            friendlyMessage: '`username` property must be not empty.'\n        },\n        'config-object-required': {\n            messageRegex: /configObjectRequired/,\n            friendlyMessage: '`config` property must be an object.'\n        },\n        'server-url-string-required': {\n            messageRegex: /serverURLStringRequired/,\n            friendlyMessage: '`serverURL` property must be a string.'\n        }\n    },\n    source: {\n        'non-valid-server-url': {\n            messageRegex: /nonValidServerURL/,\n            friendlyMessage: '`serverURL` property is not a valid URL.'\n        },\n        'non-valid-template-url': {\n            messageRegex: /nonValidTemplateURL/,\n            friendlyMessage: '`templateURL` property is not a valid URL.'\n        },\n        'metadata-required': {\n            messageRegex: /metadataRequired/,\n            friendlyMessage: '`metadata` property is required for MVT source.'\n        },\n        'table-name-required': {\n            messageRegex: /tableNameRequired/,\n            friendlyMessage: '`tableName` property is required.'\n        },\n        'table-name-string-required': {\n            messageRegex: /tableNameStringRequired$/,\n            friendlyMessage: '`tableName` property must be a string.'\n        },\n        'non-valid-table-name': {\n            messageRegex: /nonValidTableName$/,\n            friendlyMessage: '`tableName` property must be not empty.'\n        },\n        'query-required': {\n            messageRegex: /queryRequired/,\n            friendlyMessage: '`query` property is required.'\n        },\n        'query-string-required': {\n            messageRegex: /queryStringRequired$/,\n            friendlyMessage: '`query` property must be a string.'\n        },\n        'non-valid-query': {\n            messageRegex: /nonValidQuery$/,\n            friendlyMessage: '`query` property must be not empty.'\n        },\n        'non-valid-sql-query': {\n            messageRegex: /nonValidSQLQuery$/,\n            friendlyMessage: '`query` property must be a SQL query.'\n        },\n        'data-required': {\n            messageRegex: /dataRequired/,\n            friendlyMessage: '`data` property is required.'\n        },\n        'data-object-required': {\n            messageRegex: /dataObjectRequired$/,\n            friendlyMessage: '`data` property must be an object.'\n        },\n        'non-valid-geojson-data': {\n            messageRegex: /nonValidGeoJSONData$/,\n            friendlyMessage: '`data` property must be a GeoJSON object.'\n        },\n        'multiple-feature-types': {\n            messageRegex: /multipleFeatureTypes\\[(.+)\\]$/,\n            friendlyMessage: 'multiple types not supported: $0.'\n        },\n        'first-polygon-external': {\n            messageRegex: /firstPolygonExternal$/,\n            friendlyMessage: 'first polygon ring must be external.'\n        },\n        'feature-has-cartodb_id': {\n            messageRegex: /featureHasCartodbId$/,\n            friendlyMessage: '`cartodb_id` is a reserved property so it can not be used'\n        }\n    },\n    viz: {\n        'non-valid-definition': {\n            messageRegex: /nonValidDefinition$/,\n            friendlyMessage: 'viz definition should be a vizSpec object or a valid viz string.'\n        },\n        'non-valid-expression': {\n            messageRegex: /nonValidExpression\\[(.+)\\]$/,\n            friendlyMessage: '`$0` parameter is not a valid viz Expresion.'\n        },\n        'resolution-number-required': {\n            messageRegex: /resolutionNumberRequired$/,\n            friendlyMessage: '`resolution` must be a number.'\n        },\n        'resolution-too-small': {\n            messageRegex: /resolutionTooSmall\\[(.+)\\]$/,\n            friendlyMessage: '`resolution` must be greater than $0.'\n        },\n        'resolution-too-big': {\n            messageRegex: /resolutionTooBig\\[(.+)\\]$/,\n            friendlyMessage: '`resolution` must be less than $0.'\n        }\n    }\n};\n\nexport { validation };\n","/**\n *  @namespace carto\n *  @api\n *\n *  @description\n *  The CARTO VL functionality is exposed through the **carto** namespace including:\n *\n * - {@link carto.version|carto.version}\n * - {@link carto.source.Dataset|carto.source.Dataset}\n * - {@link carto.source.SQL|carto.source.SQL}\n * - {@link carto.source.GeoJSON|carto.source.GeoJSON}\n * - {@link carto.source.MVT|carto.source.MVT}\n * - {@link carto.source.MVT.Metadata|carto.source.MVT.Metadata}\n * - {@link carto.expressions|carto.expressions}\n * - {@link carto.Layer|carto.Layer}\n * - {@link carto.Viz|carto.Viz}\n * - {@link carto.Interactivity|carto.Interactivity}\n * - {@link carto.setDefaultAuth|carto.setDefaultAuth}\n * - {@link carto.setDefaultConfig|carto.setDefaultConfig}\n */\n\nimport { setDefaultAuth } from './setup/auth-service';\nimport { setDefaultConfig } from './setup/config-service';\nimport Viz from './Viz';\nimport Map from './integrator/Map';\nimport Interactivity from './interactivity/Interactivity';\nimport Layer from './Layer';\nimport * as expressions from './renderer/viz/expressions';\nimport Dataset from './sources/Dataset';\nimport GeoJSON from './sources/GeoJSON';\nimport MVT from './sources/MVT';\nimport SQL from './sources/SQL';\nimport { on, off } from './apiUtils';\n\n/**\n * The version of CARTO VL in use as specified in `package.json` and the GitHub release.\n *\n * @var {string} version\n *\n * @memberof carto\n * @api\n */\nimport { version } from '../package.json';\n\n// Namespaces\n\nconst source = { Dataset, SQL, GeoJSON, MVT };\n\nexport { version, on, off, setDefaultAuth, setDefaultConfig, source, expressions, Layer, Viz, Map, Interactivity };\n","import { layerVisibility } from '../constants/layer';\n/**\n * @description A simple non-interactive map.\n */\n\nexport default class Map {\n    /**\n     * Create a simple carto.Map by specifying a container `id`.\n     *\n     * @param  {object} options\n     * @param  {string} options.container The element's string `id`.\n     *\n     * @constructor Map\n     * @memberof carto\n     */\n    constructor (options) {\n        options = options || {};\n\n        if (typeof options.container === 'string') {\n            const container = window.document.getElementById(options.container);\n            if (!container) {\n                throw new Error(`Container '${options.container}' not found.`);\n            } else {\n                this._container = container;\n            }\n        }\n\n        this._background = options.background || '';\n\n        this._layers = new Set();\n        this._hiddenLayers = new Set();\n        this._repaint = true;\n        this.invalidateWebGLState = () => {};\n        this._canvas = this._createCanvas();\n        this._container.appendChild(this._canvas);\n        this._gl = this._canvas.getContext('webgl') || this._canvas.getContext('experimental-webgl');\n\n        this._resizeCanvas(this._containerDimensions());\n    }\n\n    addLayer (layer, beforeLayerID) {\n        layer.initialize();\n\n        if (!this._layers.has(layer)) {\n            this._layers.add(layer);\n        }\n\n        window.requestAnimationFrame(this.update.bind(this));\n    }\n\n    update (timestamp) {\n        // Don't re-render more than once per animation frame\n        if (this.lastFrame === timestamp) {\n            return;\n        }\n        this.lastFrame = timestamp;\n\n        this._drawBackground(this._background);\n\n        let loaded = true;\n        let animated = false;\n\n        this._layers.forEach((layer) => {\n            const hasData = layer.hasDataframes();\n            const hasAnimation = layer.getViz() && layer.getViz().isAnimated();\n\n            if (hasData || hasAnimation) {\n                layer.$paintCallback();\n            }\n\n            loaded = loaded && hasData;\n            animated = animated || hasAnimation;\n        });\n\n        // Update until all layers are loaded or there is an animation\n        if (!loaded || animated) {\n            window.requestAnimationFrame(this.update.bind(this));\n        }\n    }\n\n    changeVisibility (layer) {\n        switch (layer.visibility) {\n            case layerVisibility.VISIBLE:\n                this.show(layer);\n                break;\n            case layerVisibility.HIDDEN:\n                this.hide(layer);\n                break;\n        }\n    }\n\n    hide (layer) {\n        if (this._layers.has(layer)) {\n            this._layers.delete(layer);\n            this._hiddenLayers.add(layer);\n        }\n    }\n\n    show (layer) {\n        if (this._hiddenLayers.has(layer)) {\n            this._hiddenLayers.delete(layer);\n            this._layers.add(layer);\n        }\n    }\n\n    _drawBackground (color) {\n        switch (color) {\n            case 'black':\n                this._gl.clearColor(0, 0, 0, 1);\n                this._gl.clear(this._gl.COLOR_BUFFER_BIT);\n                break;\n            case 'red':\n                this._gl.clearColor(1, 0, 0, 1);\n                this._gl.clear(this._gl.COLOR_BUFFER_BIT);\n                break;\n            case 'green':\n                this._gl.clearColor(0, 1, 0, 1);\n                this._gl.clear(this._gl.COLOR_BUFFER_BIT);\n                break;\n            case 'blue':\n                this._gl.clearColor(0, 0, 1, 1);\n                this._gl.clear(this._gl.COLOR_BUFFER_BIT);\n                break;\n            default:\n            // white\n        }\n    }\n\n    _createCanvas () {\n        const canvas = window.document.createElement('canvas');\n\n        canvas.className = 'canvas';\n        canvas.style.position = 'absolute';\n\n        return canvas;\n    }\n\n    _containerDimensions () {\n        let width = 0;\n        let height = 0;\n\n        if (this._container) {\n            width = this._container.offsetWidth || 400;\n            height = this._container.offsetHeight || 300;\n        }\n\n        return { width, height };\n    }\n\n    _resizeCanvas (size) {\n        const pixelRatio = window.devicePixelRatio || 1;\n\n        this._canvas.width = pixelRatio * size.width;\n        this._canvas.height = pixelRatio * size.height;\n\n        this._canvas.style.width = `${size.width}px`;\n        this._canvas.style.height = `${size.height}px`;\n    }\n}\n","import Renderer from '../renderer/Renderer';\n\nlet integrator = null;\nexport default function getCartoMapIntegrator (map) {\n    if (!integrator) {\n        integrator = new CartoMapIntegrator(map);\n    }\n    return integrator;\n}\n\nclass CartoMapIntegrator {\n    constructor (map) {\n        this.map = map;\n        this.renderer = new Renderer();\n        this.renderer._initGL(this.map._gl);\n        this.invalidateWebGLState = () => { };\n    }\n\n    addLayer (layerId, layer) {\n        this.map.addLayer(layerId, layer);\n    }\n    needRefresh () {\n    }\n\n    getZoomLevel () {\n        return 0;\n    }\n}\n","import mitt from 'mitt';\nimport Renderer from '../renderer/Renderer';\nimport util from '../utils/util';\n\nlet uid = 0;\n\n// TODO This needs to be separated by each mgl map to support multi map pages\nconst integrators = new WeakMap();\nexport default function getMGLIntegrator (map) {\n    if (!integrators.get(map)) {\n        integrators.set(map, new MGLIntegrator(map));\n    }\n    return integrators.get(map);\n}\n\n/**\n * Responsabilities, keep all MGL integration state and functionality that lies outside Layer\n */\nclass MGLIntegrator {\n    constructor (map) {\n        this.renderer = new Renderer();\n        this.map = map;\n        this.invalidateWebGLState = null;\n        this.moveObservers = {};\n\n        this._emitter = mitt();\n        this._layers = [];\n        this._paintedLayers = 0;\n        this._isRendererInitialized = false;\n\n        this._suscribeToMapEvents(map);\n        this.invalidateWebGLState = () => { };\n    }\n\n    on (name, cb) {\n        return this._emitter.on(name, cb);\n    }\n\n    off (name, cb) {\n        return this._emitter.off(name, cb);\n    }\n\n    _suscribeToMapEvents (map) {\n        map.on('movestart', this.move.bind(this));\n        map.on('move', this.move.bind(this));\n        map.on('moveend', this.move.bind(this));\n        map.on('resize', this.move.bind(this));\n\n        map.on('mousemove', data => {\n            this._emitter.emit('mousemove', data);\n        });\n        map.on('click', data => {\n            this._emitter.emit('click', data);\n        });\n    }\n\n    _registerMoveObserver (observerName, observerCallback) {\n        this.moveObservers[observerName] = observerCallback;\n    }\n\n    _unregisterMoveObserver (observerName) {\n        delete this.moveObservers[observerName];\n    }\n\n    addLayer (layer, beforeLayerID) {\n        const callbackID = `_cartovl_${uid++}`;\n        const layerId = layer.getId();\n\n        this._registerMoveObserver(callbackID, layer.requestData.bind(layer));\n        this.map.setCustomWebGLDrawCallback(layerId, (gl, invalidate) => {\n            if (!this._isRendererInitialized) {\n                this._isRendererInitialized = true;\n                this.invalidateWebGLState = invalidate;\n                this.notifyObservers();\n                this.renderer._initGL(gl);\n            }\n\n            layer.initialize();\n            layer.$paintCallback();\n            this._paintedLayers++;\n\n            // Last layer has been painted\n            const isAnimated = this._layers.some(layer =>\n                layer.getViz() && layer.getViz().isAnimated());\n            // Checking this.map.repaint is needed, because MGL repaint is a setter and it has the strange quite buggy side-effect of doing a \"final\" repaint after being disabled\n            // if we disable it every frame, MGL will do a \"final\" repaint every frame, which will not disabled it in practice\n            if (!isAnimated && this.map.repaint) {\n                this.map.repaint = false;\n            }\n\n            invalidate();\n        });\n\n        this.map.addLayer({\n            id: layerId,\n            type: 'custom-webgl'\n        }, beforeLayerID);\n\n        this._layers.push(layer);\n        this.move();\n    }\n\n    needRefresh () {\n        this.map.repaint = true;\n    }\n\n    move () {\n        const c = this.map.getCenter();\n        // TODO create getCenter method\n        this.renderer.setCenter(c.lng / 180.0, util.projectToWebMercator(c).y / util.WM_R);\n        this.renderer.setZoom(this.getZoom());\n        this.notifyObservers();\n    }\n\n    notifyObservers () {\n        Object.keys(this.moveObservers).map(id => this.moveObservers[id]());\n    }\n\n    getZoom () {\n        const b = this.map.getBounds();\n        const c = this.map.getCenter();\n        const nw = b.getNorthWest();\n        const sw = b.getSouthWest();\n        const z = (util.projectToWebMercator(nw).y - util.projectToWebMercator(sw).y) / util.WM_2R;\n        this.renderer.setCenter(c.lng / 180.0, util.projectToWebMercator(c).y / util.WM_R);\n        return z;\n    }\n\n    getZoomLevel () {\n        return this.map.getZoom();\n    }\n\n    changeVisibility (layer) {\n        this.map.setLayoutProperty(layer.getId(), 'visibility', layer.visibility);\n    }\n}\n","import mitt from 'mitt';\nimport Layer from '../Layer';\nimport { WM_R, projectToWebMercator } from '../utils/util';\nimport { wToR } from '../client/rsys';\n\n/**\n *\n * FeatureEvent objects are fired by {@link carto.Interactivity|Interactivity} objects.\n *\n * @typedef {object} FeatureEvent\n * @property {object} coordinates - LongLat coordinates in { lng, lat } form\n * @property {object} position - Pixel coordinates in { x, y } form\n * @property {Feature[]} features - Array of {@link Feature}\n * @api\n */\n\n/**\n * featureClick events are fired when the user clicks on features. The list of features behind the cursor is provided.\n *\n * @event featureClick\n * @type {FeatureEvent}\n * @api\n */\n\n/**\n * featureClickOut events are fired when the user clicks outside a feature that was clicked in the last featureClick event.\n * The list of features that were clicked before and that are no longer behind this new click is provided.\n *\n * @event featureClickOut\n * @type {FeatureEvent}\n * @api\n */\n\n/**\n * featureEnter events are fired when the user moves the cursor and the movement implies that a non-previously hovered feature (as reported by featureHover or featureLeave) is now under the cursor.\n * The list of features that are now behind the cursor and that weren't before is provided.\n *\n * @event featureEnter\n * @type {FeatureEvent}\n * @api\n */\n\n/**\n * featureHover events are fired when the user moves the cursor.\n * The list of features behind the cursor is provided.\n *\n * @event featureHover\n * @type {FeatureEvent}\n * @api\n */\n\n/**\n * featureLeave events are fired when the user moves the cursor and the movement implies that a previously hovered feature (as reported by featureHover or featureEnter) is no longer behind the cursor.\n * The list of features that are no longer behind the cursor and that were before is provided.\n *\n * @event featureLeave\n * @type {FeatureEvent}\n * @api\n */\n\nconst EVENTS = [\n    'featureClick',\n    'featureClickOut',\n    'featureEnter',\n    'featureHover',\n    'featureLeave'\n];\n\nexport default class Interactivity {\n    /**\n    *\n    * Interactivity purpose is to allow the reception and management of user-generated events, like clicking, over layer features.\n    *\n    * To create a Interactivity object an array of {@link carto.Layer} is required.\n    * Events fired from interactivity objects will refer to the features of these layers and only these layers.\n    * Moreover, the order of the features in the events will be determined by the order of the layers in this list.\n    *\n    * @param {carto.Layer|carto.Layer[]} layerList - {@link carto.Layer} or array of {@link carto.Layer}, events will be fired based on the features of these layers. The array cannot be empty, and all the layers must be attached to the same map.\n    * @param {object} [options={}] - Object containing interactivity options\n    * @param {boolean} [options.autoChangePointer=true] - A boolean flag indicating if the cursor should change when the mouse is over a feature.\n    *\n    * @example\n    * const interactivity = new carto.Interactivity(layer);\n    * interactivity.on('click', event => {\n    *   style(event.features);\n    *   show(event.coordinates);\n    * });\n    *\n    * @fires featureClick\n    * @fires featureClickOut\n    * @fires featureHover\n    * @fires featureEnter\n    * @fires featureLeave\n    * @fires CartoError\n    *\n    * @constructor Interactivity\n    * @memberof carto\n    * @api\n    */\n    constructor (layerList, options = { autoChangePointer: true }) {\n        if (layerList instanceof Layer) {\n            // Allow one layer as input\n            layerList = [layerList];\n        }\n        preCheckLayerList(layerList);\n        this._init(layerList, options);\n    }\n\n    /**\n     * Register an event handler for the given type.\n     *\n     * @param {string} eventName - Type of event to listen for\n     * @param {function} callback - Function to call in response to given event, function will be called with a {@link carto.FeatureEvent}\n     * @memberof carto.Interactivity\n     * @instance\n     * @api\n     */\n    on (eventName, callback) {\n        checkEvent(eventName);\n        this._numListeners[eventName] = (this._numListeners[eventName] || 0) + 1;\n        return this._emitter.on(eventName, callback);\n    }\n\n    /**\n     * Remove an event handler for the given type.\n     *\n     * @param {string} eventName - Type of event to unregister\n     * @param {function} callback - Handler function to unregister\n     * @memberof carto.Interactivity\n     * @instance\n     * @api\n     */\n    off (eventName, callback) {\n        checkEvent(eventName);\n        this._numListeners[eventName] = this._numListeners[eventName] - 1;\n        return this._emitter.off(eventName, callback);\n    }\n\n    _init (layerList, options) {\n        this._emitter = mitt();\n        this._layerList = layerList;\n        this._prevHoverFeatures = [];\n        this._prevClickFeatures = [];\n        this._numListeners = {};\n        return Promise.all(layerList.map(layer => layer._context)).then(() => {\n            postCheckLayerList(layerList);\n            this._subscribeToIntegratorEvents(layerList[0].getIntegrator());\n        }).then(() => {\n            if (options.autoChangePointer) {\n                this._setInteractiveCursor();\n            }\n        });\n    }\n\n    _setInteractiveCursor () {\n        const map = this._layerList[0].getIntegrator().map; // All layers belong to the same map\n        if (!map.__carto_interacivities) {\n            map.__carto_interacivities = new Set();\n        }\n        this.on('featureHover', event => {\n            if (event.features.length) {\n                map.__carto_interacivities.add(this);\n            } else {\n                map.__carto_interacivities.delete(this);\n            }\n            map.getCanvas().style.cursor = (map.__carto_interacivities.size > 0) ? 'pointer' : '';\n        });\n    }\n\n    _subscribeToIntegratorEvents (integrator) {\n        integrator.on('mousemove', this._onMouseMove.bind(this));\n        integrator.on('click', this._onClick.bind(this));\n    }\n\n    _onMouseMove (event) {\n        if (!this._numListeners['featureEnter'] && !this._numListeners['featureHover'] && !this._numListeners['featureLeave']) {\n            return;\n        }\n\n        const featureEvent = this._createFeatureEvent(event);\n        const currentFeatures = featureEvent.features;\n\n        // Manage enter/leave events\n        const featuresLeft = this._getDiffFeatures(this._prevHoverFeatures, currentFeatures);\n        const featuresEntered = this._getDiffFeatures(currentFeatures, this._prevHoverFeatures);\n\n        if (featuresLeft.length > 0) {\n            this._fireEvent('featureLeave', {\n                coordinates: featureEvent.coordinates,\n                position: featureEvent.position,\n                features: featuresLeft\n            });\n        }\n\n        if (featuresEntered.length > 0) {\n            this._fireEvent('featureEnter', {\n                coordinates: featureEvent.coordinates,\n                position: featureEvent.position,\n                features: featuresEntered\n            });\n        }\n\n        this._prevHoverFeatures = featureEvent.features;\n\n        // Launch hover event\n        this._fireEvent('featureHover', featureEvent);\n    }\n\n    _onClick (event) {\n        if (!this._numListeners['featureClick'] && !this._numListeners['featureClickOut']) {\n            return;\n        }\n\n        const featureEvent = this._createFeatureEvent(event);\n        const currentFeatures = featureEvent.features;\n\n        // Manage clickOut event\n        const featuresClickedOut = this._getDiffFeatures(this._prevClickFeatures, currentFeatures);\n\n        if (featuresClickedOut.length > 0) {\n            this._fireEvent('featureClickOut', {\n                coordinates: featureEvent.coordinates,\n                position: featureEvent.position,\n                features: featuresClickedOut\n            });\n        }\n\n        this._prevClickFeatures = featureEvent.features;\n\n        // Launch click event\n        this._fireEvent('featureClick', featureEvent);\n    }\n\n    _createFeatureEvent (eventData) {\n        const features = this._getFeaturesAtPosition(eventData.lngLat);\n        return {\n            coordinates: eventData.lngLat,\n            position: eventData.point,\n            features\n        };\n    }\n\n    _fireEvent (type, featureEvent) {\n        this._emitter.emit(type, featureEvent);\n    }\n\n    _getFeaturesAtPosition (lngLat) {\n        const wm = projectToWebMercator(lngLat);\n        const nwmc = wToR(wm.x, wm.y, { scale: WM_R, center: { x: 0, y: 0 } });\n        return [].concat(...this._layerList.map(layer => layer.getFeaturesAtPosition(nwmc)));\n    }\n\n    /**\n     * Return the difference between the feature arrays A and B.\n     * The output value is also an array of features.\n     */\n    _getDiffFeatures (featuresA, featuresB) {\n        const IDs = this._getFeatureIDs(featuresB);\n        return featuresA.filter(feature => !IDs.includes(feature.id));\n    }\n\n    _getFeatureIDs (features) {\n        return features.map(feature => feature.id);\n    }\n}\n\nfunction preCheckLayerList (layerList) {\n    if (!Array.isArray(layerList)) {\n        throw new Error('Invalid layer list, parameter must be an array of carto.Layer objects');\n    }\n    if (!layerList.length) {\n        throw new Error('Invalid argument, layer list must not be empty');\n    }\n    if (!layerList.every(layer => layer instanceof Layer)) {\n        throw new Error('Invalid layer, layer must be an instance of carto.Layer');\n    }\n}\nfunction postCheckLayerList (layerList) {\n    if (!layerList.every(layer => layer.getIntegrator() === layerList[0].getIntegrator())) {\n        throw new Error('Invalid argument, all layers must belong to the same map');\n    }\n}\n\nfunction checkEvent (eventName) {\n    if (!EVENTS.includes(eventName)) {\n        throw new Error(`Unrecognized event: ${eventName}. Available events: ${EVENTS.join(', ')}`);\n    }\n}\n","import FeatureVizProperty from './featureVizProperty';\n\n/**\n *\n * Feature objects are provided by {@link FeatureEvent} events.\n *\n * @typedef {object} Feature\n * @property {number} id - Unique identification code\n * @property {FeatureVizProperty} color\n * @property {FeatureVizProperty} width\n * @property {FeatureVizProperty} colorStroke\n * @property {FeatureVizProperty} widthStroke\n * @property {FeatureVizProperty[]} variables - Declared variables in the viz object\n * @property {function} reset - Reset custom feature vizs by fading out `duration` milliseconds, where `duration` is the first parameter to reset\n * @api\n */\nexport default class Feature {\n    constructor (rawFeature, viz, customizedFeatures, trackFeatureViz, idProperty) {\n        const variables = {};\n        Object.keys(viz.variables).map(varName => {\n            variables[varName] = new FeatureVizProperty(`__cartovl_variable_${varName}`, rawFeature, viz, customizedFeatures, trackFeatureViz, idProperty);\n        });\n\n        this.id = rawFeature[idProperty];\n        this.color = new FeatureVizProperty('color', rawFeature, viz, customizedFeatures, trackFeatureViz, idProperty);\n        this.width = new FeatureVizProperty('width', rawFeature, viz, customizedFeatures, trackFeatureViz, idProperty);\n        this.strokeColor = new FeatureVizProperty('strokeColor', rawFeature, viz, customizedFeatures, trackFeatureViz, idProperty);\n        this.strokeWidth = new FeatureVizProperty('strokeWidth', rawFeature, viz, customizedFeatures, trackFeatureViz, idProperty);\n        this.variables = variables;\n    }\n\n    reset (duration = 500) {\n        this.color.reset(duration);\n        this.width.reset(duration);\n        this.strokeColor.reset(duration);\n        this.strokeWidth.reset(duration);\n\n        for (let key in this.variables) {\n            this.variables[key].reset(duration);\n        }\n    }\n}\n","import { blend, property, transition, notEquals } from '../renderer/viz/expressions';\nimport { parseVizExpression } from '../renderer/viz/parser';\n\n/**\n *\n * FeatureVizProperty objects can be accessed through {@link Feature} objects.\n *\n * @typedef {object} FeatureVizProperty\n * @property {function} blendTo - Change the feature viz by blending to a destination viz expression `expr` in `duration` milliseconds, where `expr` is the first parameter and `duration` the last one\n * @property {function} reset - Reset custom feature viz property by fading out `duration` milliseconds, where `duration` is the first parameter to reset\n * @property {function} value - Getter that evaluates the property and returns the computed value\n * @api\n */\nexport default class FeatureVizProperty {\n    constructor (propertyName, feature, viz, customizedFeatures, trackFeatureViz, idProperty) {\n        this._propertyName = propertyName;\n        this._properties = feature;\n        this._viz = viz;\n\n        this.blendTo = _generateBlenderFunction(propertyName, feature[idProperty], customizedFeatures, viz, trackFeatureViz, idProperty);\n        this.reset = _generateResetFunction(propertyName, feature[idProperty], customizedFeatures, viz, idProperty);\n    }\n\n    get value () {\n        return this._viz[this._propertyName].eval(this._properties);\n    }\n}\n\nfunction _generateResetFunction (propertyName, id, customizedFeatures, viz, idProperty) {\n    return function reset (duration = 500) {\n        if (customizedFeatures[id] && customizedFeatures[id][propertyName]) {\n            customizedFeatures[id][propertyName].replaceChild(\n                customizedFeatures[id][propertyName].mix,\n                // transition(0) is used to ensure that blend._predraw() \"GC\" collects it\n                blend(notEquals(property(idProperty), id), transition(0), transition(duration))\n            );\n            viz[propertyName].notify();\n            customizedFeatures[id][propertyName] = undefined;\n        }\n    };\n}\n\nfunction _generateBlenderFunction (propertyName, id, customizedFeatures, viz, trackFeatureViz, idProperty) {\n    return function generatedBlendTo (newExpression, duration = 500) {\n        if (typeof newExpression === 'string') {\n            newExpression = parseVizExpression(newExpression);\n        }\n        if (customizedFeatures[id] && customizedFeatures[id][propertyName]) {\n            customizedFeatures[id][propertyName].a.blendTo(newExpression, duration);\n            return;\n        }\n        const blendExpr = blend(\n            newExpression,\n            viz[propertyName],\n            blend(1, notEquals(property(idProperty), id), transition(duration))\n        );\n        trackFeatureViz(id, propertyName, blendExpr, customizedFeatures);\n        viz.replaceChild(\n            viz[propertyName],\n            blendExpr\n        );\n        viz[propertyName].notify();\n    };\n}\n","import { decodeGeom } from './decoder';\nimport { wToR } from '../client/rsys';\nimport { pointInTriangle, pointInCircle, pointInRectangle } from '../../src/utils/geometry';\nimport { triangleCollides } from '../utils/collision';\n\n// Maximum number of property textures that will be uploaded automatically to the GPU\n// in a non-lazy manner\nconst MAX_GPU_AUTO_UPLOAD_TEXTURE_LIMIT = 32;\n\nconst featureClassCache = new Map();\nconst AABBTestResults = {\n    INSIDE: 1,\n    OUTSIDE: -1,\n    INTERSECTS: 0\n};\n\nexport default class Dataframe {\n    constructor ({ center, scale, geom, properties, type, active, size, metadata }) {\n        this.active = active;\n        this.center = center;\n        this.geom = geom;\n        this.properties = properties;\n        this.scale = scale;\n        this.type = type;\n        this.decodedGeom = decodeGeom(this.type, this.geom);\n        this.numVertex = type === 'point' ? size : this.decodedGeom.vertices.length / 2;\n        this.numFeatures = type === 'point' ? size : this.decodedGeom.breakpoints.length || this.numVertex;\n        this.propertyTex = [];\n        this.metadata = metadata;\n        this.propertyID = {}; // Name => PID\n        this.propertyCount = 0;\n        this._aabb = this._computeAABB(geom, type);\n    }\n\n    get widthScale () {\n        return this.renderer\n            ? (2 / this.renderer.gl.canvas.clientHeight) / this.scale * this.renderer._zoom\n            : 1;\n    }\n\n    _computeAABB (geometry, type) {\n        switch (type) {\n            case 'point':\n                return [];\n            case 'line':\n            case 'polygon':\n                const aabbList = [];\n\n                for (let i = 0; i < geometry.length; i++) {\n                    const feature = geometry[i];\n\n                    let aabb = {\n                        minx: Number.POSITIVE_INFINITY,\n                        miny: Number.POSITIVE_INFINITY,\n                        maxx: Number.NEGATIVE_INFINITY,\n                        maxy: Number.NEGATIVE_INFINITY\n                    };\n\n                    for (let j = 0; j < feature.length; j++) {\n                        aabb = _updateAABBForGeometry(feature[j], aabb, type);\n                    }\n\n                    aabbList.push(aabb);\n                }\n\n                return aabbList;\n        }\n    }\n\n    setFreeObserver (freeObserver) {\n        this.freeObserver = freeObserver;\n    }\n\n    bind (renderer) {\n        const gl = renderer.gl;\n        this.renderer = renderer;\n        const vertices = this.decodedGeom.vertices;\n        const breakpoints = this.decodedGeom.breakpoints;\n\n        this.addProperties(this.properties);\n\n        const width = this.renderer.RTT_WIDTH;\n        const height = Math.ceil(this.numFeatures / width);\n        this.height = height;\n\n        this.vertexBuffer = gl.createBuffer();\n        this.featureIDBuffer = gl.createBuffer();\n\n        this.texColor = this._createStyleTileTexture(this.numFeatures);\n        this.texWidth = this._createStyleTileTexture(this.numFeatures);\n        this.texStrokeColor = this._createStyleTileTexture(this.numFeatures);\n        this.texStrokeWidth = this._createStyleTileTexture(this.numFeatures);\n        this.texFilter = this._createStyleTileTexture(this.numFeatures);\n\n        const ids = new Float32Array(vertices.length);\n        let index = 0;\n\n        for (let i = 0; i < vertices.length; i += 2) {\n            if (!breakpoints.length) {\n                if (i > 0) {\n                    index++;\n                }\n            } else {\n                while (i === breakpoints[index]) {\n                    index++;\n                }\n            }\n            // Transform integer ID into a `vec2` to overcome WebGL 1 limitations, output IDs will be in the `vec2([0,1], [0,1])` range\n            ids[i + 0] = ((index) % width) / (width - 1);\n            ids[i + 1] = height > 1 ? Math.floor((index) / width) / (height - 1) : 0.5;\n        }\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n\n        if (this.decodedGeom.normals) {\n            this.normalBuffer = gl.createBuffer();\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);\n            gl.bufferData(gl.ARRAY_BUFFER, this.decodedGeom.normals, gl.STATIC_DRAW);\n        }\n\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.featureIDBuffer);\n        gl.bufferData(gl.ARRAY_BUFFER, ids, gl.STATIC_DRAW);\n    }\n\n    getFeaturesAtPosition (pos, viz) {\n        switch (this.type) {\n            case 'point':\n                return this._getPointsAtPosition(pos, viz);\n            case 'line':\n                return this._getFeaturesFromTriangles('line', pos, viz);\n            case 'polygon':\n                return this._getFeaturesFromTriangles('polygon', pos, viz);\n            default:\n                return [];\n        }\n    }\n\n    inViewport (featureIndex, renderScale, center, aspect, viz) {\n        const feature = this.getFeature(featureIndex);\n        const viewportAABB = this._getBounds(renderScale, center, aspect);\n        let strokeWidthScale = 1;\n\n        switch (this.type) {\n            case 'point':\n                return this._isPointInViewport(featureIndex, viewportAABB);\n            case 'line':\n                strokeWidthScale = this._computeLineWidthScale(feature, viz);\n                return this._isPolygonInViewport(featureIndex, viewportAABB, strokeWidthScale);\n            case 'polygon':\n                strokeWidthScale = this._computePolygonWidthScale(feature, viz);\n                return this._isPolygonInViewport(featureIndex, viewportAABB, strokeWidthScale);\n            default:\n                return false;\n        }\n    }\n\n    getPropertyTexture (propertyName) {\n        if (this.propertyTex[propertyName]) {\n            return this.propertyTex[propertyName];\n        }\n\n        const propertiesFloat32Array = this.properties[propertyName];\n        // Dataframe is already bound to this context, \"hot update\" it\n        const gl = this.renderer.gl;\n        const width = this.renderer.RTT_WIDTH;\n        const height = Math.ceil(this.numFeatures / width);\n        this.height = height;\n\n        this.propertyTex[propertyName] = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, this.propertyTex[propertyName]);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA,\n            width, height, 0, gl.ALPHA, gl.FLOAT,\n            propertiesFloat32Array);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        return this.propertyTex[propertyName];\n    }\n\n    free () {\n        if (this.propertyTex) {\n            const gl = this.renderer.gl;\n            this.propertyTex.map(tex => gl.deleteTexture(tex));\n            gl.deleteTexture(this.texColor);\n            gl.deleteTexture(this.texStrokeColor);\n            gl.deleteTexture(this.texWidth);\n            gl.deleteTexture(this.texStrokeWidth);\n            gl.deleteTexture(this.texFilter);\n            gl.deleteBuffer(this.vertexBuffer);\n            gl.deleteBuffer(this.featureIDBuffer);\n        }\n        const freeObserver = this.freeObserver;\n\n        Object.keys(this).map(key => {\n            this[key] = null;\n        });\n\n        this.freed = true;\n\n        if (freeObserver) {\n            freeObserver(this);\n        }\n    }\n\n    _isPointInViewport (featureIndex, viewportAABB) {\n        const { minx, maxx, miny, maxy } = viewportAABB;\n        const x = this.geom[2 * featureIndex + 0];\n        const y = this.geom[2 * featureIndex + 1];\n        return x > minx && x < maxx && y > miny && y < maxy;\n    }\n\n    _isPolygonInViewport (featureIndex, viewportAABB, strokeWidthScale) {\n        const featureAABB = this._aabb[featureIndex];\n        const aabbResult = this._compareAABBs(featureAABB, viewportAABB, strokeWidthScale);\n        const vertices = this.decodedGeom.vertices;\n        const normals = this.decodedGeom.normals;\n\n        if (aabbResult === AABBTestResults.INTERSECTS) {\n            const range = this.decodedGeom.featureIDToVertexIndex.get(featureIndex);\n            return _isPolygonCollidingViewport(vertices, normals, range.start, range.end, strokeWidthScale, viewportAABB);\n        }\n\n        return aabbResult === AABBTestResults.INSIDE;\n    }\n\n    _compareAABBs (featureAABB, viewportAABB, stroke) {\n        const featureStrokeAABB = {\n            minx: featureAABB.minx - stroke,\n            miny: featureAABB.miny - stroke,\n            maxx: featureAABB.maxx + stroke,\n            maxy: featureAABB.maxy + stroke\n        };\n\n        switch (true) {\n            case _isFeatureAABBInsideViewport(featureStrokeAABB, viewportAABB):\n                return AABBTestResults.INSIDE;\n            case _isFeatureAABBOutsideViewport(featureStrokeAABB, viewportAABB):\n                return AABBTestResults.OUTSIDE;\n            default:\n                return AABBTestResults.INTERSECTS;\n        }\n    }\n\n    _getBounds (renderScale, center, aspect) {\n        this.vertexScale = [(renderScale / aspect) * this.scale, renderScale * this.scale];\n        this.vertexOffset = [(renderScale / aspect) * (center.x - this.center.x), renderScale * (center.y - this.center.y)];\n\n        const minx = (-1 + this.vertexOffset[0]) / this.vertexScale[0];\n        const maxx = (1 + this.vertexOffset[0]) / this.vertexScale[0];\n        const miny = (-1 + this.vertexOffset[1]) / this.vertexScale[1];\n        const maxy = (1 + this.vertexOffset[1]) / this.vertexScale[1];\n\n        return { minx, maxx, miny, maxy };\n    }\n\n    _getPointsAtPosition (pos, viz) {\n        const p = wToR(pos.x, pos.y, {\n            center: this.center,\n            scale: this.scale\n        });\n\n        const points = this.decodedGeom.vertices;\n        const features = [];\n\n        for (let i = 0; i < points.length; i += 2) {\n            const featureIndex = i / 2;\n            const center = {\n                x: points[i],\n                y: points[i + 1]\n            };\n\n            const feature = this.getFeature(featureIndex);\n\n            if (this._isFeatureFiltered(feature, viz.filter)) {\n                continue;\n            }\n\n            const strokeWidthScale = this._computePointWidthScale(feature, viz);\n\n            if (!viz.symbol._default) {\n                const offset = viz.symbolPlacement.eval();\n                center.x += offset[0] * strokeWidthScale;\n                center.y += offset[1] * strokeWidthScale;\n            }\n\n            const inside = pointInCircle(p, center, strokeWidthScale);\n\n            if (inside) {\n                features.push(this.getFeature(featureIndex));\n            }\n        }\n\n        return features;\n    }\n\n    _getFeaturesFromTriangles (geometryType, pos, viz) {\n        const p = wToR(pos.x, pos.y, {\n            center: this.center,\n            scale: this.scale\n        });\n\n        const vertices = this.decodedGeom.vertices;\n        const normals = this.decodedGeom.normals;\n        const breakpoints = this.decodedGeom.breakpoints;\n        const features = [];\n        // Linear search for all features\n        // Tests triangles since we already have the triangulated form\n        // Moreover, with an acceleration structure and triangle testing features could be subdivided easily\n        let featureIndex = -1;\n        let strokeWidthScale;\n\n        for (let i = 0; i < vertices.length; i += 6) {\n            if (i === 0 || i >= breakpoints[featureIndex]) {\n                featureIndex++;\n                const feature = this.getFeature(featureIndex);\n\n                if (!pointInRectangle(p, this._aabb[featureIndex]) ||\n                    this._isFeatureFiltered(feature, viz.filter)) {\n                    i = breakpoints[featureIndex] - 6;\n                    continue;\n                }\n\n                strokeWidthScale = geometryType === 'line'\n                    ? this._computeLineWidthScale(feature, viz)\n                    : this._computePolygonWidthScale(feature, viz);\n            }\n\n            const v1 = {\n                x: vertices[i + 0] + normals[i + 0] * strokeWidthScale,\n                y: vertices[i + 1] + normals[i + 1] * strokeWidthScale\n            };\n\n            const v2 = {\n                x: vertices[i + 2] + normals[i + 2] * strokeWidthScale,\n                y: vertices[i + 3] + normals[i + 3] * strokeWidthScale\n            };\n\n            const v3 = {\n                x: vertices[i + 4] + normals[i + 4] * strokeWidthScale,\n                y: vertices[i + 5] + normals[i + 5] * strokeWidthScale\n            };\n\n            const inside = pointInTriangle(p, v1, v2, v3);\n\n            if (inside) {\n                features.push(this.getFeature(featureIndex));\n                // Don't repeat a feature if we the point is on a shared (by two triangles) edge\n                // Also, don't waste CPU cycles\n                i = breakpoints[featureIndex] - 6;\n            }\n        }\n\n        return features;\n    }\n\n    _isFeatureFiltered (feature, filterExpression) {\n        return filterExpression.eval(feature) < 0.5;\n    }\n\n    _genFeatureClass () {\n        if (featureClassCache.has(this.metadata)) {\n            this._cls = featureClassCache.get(this.metadata);\n            return;\n        }\n        const cls = class ViewportFeature {\n            constructor (index, dataframe) {\n                this._index = index;\n                this._dataframe = dataframe;\n            }\n        };\n\n        const metadata = this.metadata;\n        const getters = {};\n        for (let i = 0; i < this.metadata.propertyKeys.length; i++) {\n            const propertyName = this.metadata.propertyKeys[i];\n            getters[propertyName] = {\n                get: function () {\n                    const index = this._index;\n                    if (metadata.properties[propertyName].type === 'category') {\n                        return metadata.IDToCategory.get(this._dataframe.properties[propertyName][index]);\n                    } else {\n                        return this._dataframe.properties[propertyName][index];\n                    }\n                }\n            };\n        }\n\n        Object.defineProperties(cls.prototype, getters);\n\n        featureClassCache.set(this.metadata, cls);\n        this._cls = cls;\n    }\n\n    _getFeatureProperty (index, propertyName) {\n        if (this.metadata.properties[propertyName].type === 'category') {\n            return this.metadata.IDToCategory.get(this.properties[propertyName][index]);\n        } else {\n            return this.properties[propertyName][index];\n        }\n    }\n\n    getFeature (index) {\n        if (!this.cachedFeatures) {\n            this.cachedFeatures = new Array(this.numFeatures);\n        }\n\n        if (this.cachedFeatures[index] !== undefined) {\n            return this.cachedFeatures[index];\n        }\n\n        if (!this._cls) {\n            this._genFeatureClass();\n        }\n\n        const feature = new this._cls(index, this);\n        this.cachedFeatures[index] = feature;\n        return feature;\n    }\n\n    _addProperty (propertyName) {\n        if (Object.keys(this.propertyTex).length < MAX_GPU_AUTO_UPLOAD_TEXTURE_LIMIT) {\n            this.getPropertyTexture(propertyName);\n        }\n    }\n\n    // Add new properties to the dataframe or overwrite previously stored ones.\n    // `properties` is of the form: {propertyName: Float32Array}\n    addProperties (properties) {\n        for (let i = 0; i < this.metadata.propertyKeys.length; i++) {\n            const propertyName = this.metadata.propertyKeys[i];\n            this._addProperty(propertyName);\n        }\n        this._genFeatureClass();\n    }\n\n    _createStyleTileTexture (numFeatures) {\n        // TODO we are wasting 75% of the memory for the scalar attributes (width, strokeWidth),\n        // since RGB components are discarded\n        const gl = this.renderer.gl;\n        const width = this.renderer.RTT_WIDTH;\n        const height = Math.ceil(numFeatures / width);\n        const texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,\n            width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE,\n            null);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        return texture;\n    }\n\n    _computePointWidthScale (feature, viz) {\n        const SATURATION_PX = 126;\n        const diameter = Math.min(viz.width.eval(feature) + viz.strokeWidth.eval(feature), SATURATION_PX);\n\n        return diameter / 2 * this.widthScale;\n    }\n\n    _computeLineWidthScale (feature, viz) {\n        const SATURATION_PX = 336;\n        const diameter = Math.min(viz.width.eval(feature), SATURATION_PX);\n\n        return diameter / 2 * this.widthScale;\n    }\n\n    _computePolygonWidthScale (feature, viz) {\n        const SATURATION_PX = 336;\n        const diameter = Math.min(viz.strokeWidth.eval(feature), SATURATION_PX);\n\n        return diameter / 2 * this.widthScale;\n    }\n}\n\nfunction _updateAABBForGeometry (feature, aabb, geometryType) {\n    switch (geometryType) {\n        case 'line':\n            return _updateAABBLine(feature, aabb);\n        case 'polygon':\n            return _updateAABBPolygon(feature, aabb);\n    }\n}\n\nfunction _updateAABBLine (line, aabb) {\n    const vertices = line;\n    const numVertices = line.length;\n\n    for (let i = 0; i < numVertices; i += 2) {\n        aabb.minx = Math.min(aabb.minx, vertices[i + 0]);\n        aabb.miny = Math.min(aabb.miny, vertices[i + 1]);\n        aabb.maxx = Math.max(aabb.maxx, vertices[i + 0]);\n        aabb.maxy = Math.max(aabb.maxy, vertices[i + 1]);\n    }\n\n    return aabb;\n}\n\nfunction _updateAABBPolygon (polygon, aabb) {\n    const [ vertices, numVertices ] = [ polygon.flat, polygon.holes[0] || polygon.flat.length / 2 ];\n\n    for (let i = 0; i < numVertices; i++) {\n        aabb.minx = Math.min(aabb.minx, vertices[2 * i + 0]);\n        aabb.miny = Math.min(aabb.miny, vertices[2 * i + 1]);\n        aabb.maxx = Math.max(aabb.maxx, vertices[2 * i + 0]);\n        aabb.maxy = Math.max(aabb.maxy, vertices[2 * i + 1]);\n    }\n\n    return aabb;\n}\n\nfunction _isFeatureAABBInsideViewport (featureAABB, viewportAABB) {\n    return (featureAABB.minx >= viewportAABB.minx && featureAABB.maxx <= viewportAABB.maxx &&\n            featureAABB.miny >= viewportAABB.miny && featureAABB.maxy <= viewportAABB.maxy);\n}\n\nfunction _isFeatureAABBOutsideViewport (featureAABB, viewportAABB) {\n    return (featureAABB.minx > viewportAABB.maxx || featureAABB.miny > viewportAABB.maxy ||\n            featureAABB.maxx < viewportAABB.minx || featureAABB.maxy < viewportAABB.miny);\n}\n\nfunction _isPolygonCollidingViewport (vertices, normals, start, end, strokeWidthScale, viewportAABB) {\n    for (let i = start; i < end; i += 6) {\n        const triangle = [{\n            x: vertices[i + 0] + normals[i + 0] * strokeWidthScale,\n            y: vertices[i + 1] + normals[i + 1] * strokeWidthScale\n        }, {\n            x: vertices[i + 2] + normals[i + 2] * strokeWidthScale,\n            y: vertices[i + 3] + normals[i + 3] * strokeWidthScale\n        }, {\n            x: vertices[i + 4] + normals[i + 4] * strokeWidthScale,\n            y: vertices[i + 5] + normals[i + 5] * strokeWidthScale\n        }, {\n            x: vertices[i + 0] + normals[i + 0] * strokeWidthScale,\n            y: vertices[i + 1] + normals[i + 1] * strokeWidthScale\n        }];\n\n        if (triangleCollides(triangle, viewportAABB)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n","\n// The IDENTITY metadata contains zero properties\nexport const IDENTITY = {\n    properties: {}\n};\n\nexport default class Metadata {\n    constructor ({ properties, featureCount, sample, geomType, isAggregated, idProperty } = { properties: {} }) {\n        this.properties = properties;\n        this.featureCount = featureCount;\n        this.sample = sample;\n        this.geomType = geomType;\n        this.isAggregated = isAggregated;\n        this.idProperty = idProperty || 'cartodb_id';\n\n        this.categoryToID = new Map();\n        this.IDToCategory = new Map();\n        this.numCategories = 0;\n\n        Object.values(properties).map(property => {\n            property.categories = property.categories || [];\n            property.categories.map(category => this.categorizeString(category.name));\n        });\n\n        this.propertyKeys = Object.keys(this.properties);\n    }\n    categorizeString (category) {\n        if (category === undefined) {\n            category = null;\n        }\n        if (this.categoryToID.has(category)) {\n            return this.categoryToID.get(category);\n        }\n        this.categoryToID.set(category, this.numCategories);\n        this.IDToCategory.set(this.numCategories, category);\n        this.numCategories++;\n        return this.numCategories - 1;\n    }\n    propertyNames (propertyName) {\n        const prop = this.properties[propertyName];\n        if (prop.aggregations) {\n            return Object.keys(prop.aggregations).map(fn => prop.aggregations[fn]);\n        }\n        return [propertyName];\n    }\n}\n","import Feature from '../interactivity/feature';\n\nexport default class RenderLayer {\n    constructor () {\n        this.dataframes = [];\n        this.renderer = null;\n        this.viz = null;\n        this.type = null;\n        this.customizedFeatures = {};\n        this.idProperty = null;\n    }\n    // Performance-intensive. The required allocation and copy of resources will happen synchronously.\n    // To achieve good performance, avoid multiple calls within the same event, particularly with large dataframes.\n    addDataframe (dataframe) {\n        if (this.type) {\n            this._checkDataframeType(dataframe);\n        }\n        this.type = dataframe.type;\n        if (this.renderer) {\n            dataframe.bind(this.renderer);\n        }\n        this.dataframes.push(dataframe);\n        this.idProperty = dataframe.metadata.idProperty;\n    }\n\n    getActiveDataframes () {\n        this.dataframes = this.dataframes.filter(df => !df.freed);\n        let active = this.dataframes.filter(df => df.active && df.numVertex);\n        if (active.length && active[0].orderID !== undefined) {\n            active = active.sort((a, b) => a.orderID - b.orderID);\n        }\n        return active;\n    }\n\n    hasDataframes () {\n        return this.getActiveDataframes().length > 0;\n    }\n\n    getNumFeatures () {\n        return this.getActiveDataframes().map(d => d.numFeatures).reduce((x, y) => x + y, 0);\n    }\n\n    _checkDataframeType (dataframe) {\n        if (this.type !== dataframe.type) {\n            throw new Error('Layer dataframes must always be of the same type');\n        }\n    }\n\n    getFeaturesAtPosition (pos) {\n        if (!this.viz) {\n            return [];\n        }\n        return [].concat(...this.getActiveDataframes().map(df =>\n            df.getFeaturesAtPosition(pos, this.viz)\n        )).map(rawFeature =>\n            new Feature(rawFeature, this.viz, this.customizedFeatures, this.trackFeatureViz, this.idProperty)\n        );\n    }\n\n    trackFeatureViz (featureID, vizProperty, newViz, customizedFeatures) {\n        customizedFeatures[featureID] = customizedFeatures[featureID] || {};\n        customizedFeatures[featureID][vizProperty] = newViz;\n    }\n\n    freeDataframes () {\n        this.dataframes.map(df => df.free());\n        this.dataframes = [];\n        this.type = null;\n    }\n}\n","import shaders from './shaders';\nimport { Asc, Desc } from './viz/expressions';\nimport { getFloat32ArrayFromArray } from '../utils/util';\n\nconst INITIAL_TIMESTAMP = Date.now();\n\n/**\n * The renderer use fuzzy logic where < 0.5 means false and >= 0.5 means true\n */\nconst FILTERING_THRESHOLD = 0.5;\n\n/**\n * @typedef {object} RPoint - Point in renderer coordinates space\n * @property {number} x\n * @property {number} y\n */\n\n/**\n * @description The Render To Texture Width limits the maximum number of features per tile: *maxFeatureCount = RTT_WIDTH^2*\n *\n * Large RTT_WIDTH values are unsupported by hardware. Limits vary on each machine.\n * Support starts to drop from 2048, with a drastic reduction in support for more than 4096 pixels.\n *\n * Large values imply a small overhead too.\n */\nexport const RTT_WIDTH = 1024;\n\n/**\n * @description Renderer constructor. Use it to create a new renderer bound to the provided canvas.\n * Initialization will be done synchronously.\n * The function will fail in case that a WebGL context cannot be created this can happen because of the following reasons:\n *   * The provided canvas element is invalid\n *   * The browser or the machine doesn't support WebGL or the required WebGL extension and minimum parameter values\n * @jsapi\n * @memberOf renderer\n * @constructor\n * @param {HTMLElement} canvas - the WebGL context will be created on this element\n */\n\nexport default class Renderer {\n    constructor (canvas) {\n        if (canvas) {\n            this.gl = canvas.getContext('webgl');\n            if (!this.gl) {\n                throw new Error('WebGL 1 is unsupported');\n            }\n            this._initGL(this.gl);\n        }\n        this._center = { x: 0, y: 0 };\n        this._zoom = 1;\n        this.RTT_WIDTH = RTT_WIDTH;\n        this.dataframes = [];\n    }\n\n    _initGL (gl) {\n        this.gl = gl;\n        const OESTextureFloat = gl.getExtension('OES_texture_float');\n        if (!OESTextureFloat) {\n            throw new Error('WebGL extension OES_texture_float is unsupported');\n        }\n        const supportedRTT = gl.getParameter(gl.MAX_RENDERBUFFER_SIZE);\n        if (supportedRTT < RTT_WIDTH) {\n            throw new Error(`WebGL parameter 'gl.MAX_RENDERBUFFER_SIZE' is below the requirement: ${supportedRTT} < ${RTT_WIDTH}`);\n        }\n        this._initShaders();\n\n        this.auxFB = gl.createFramebuffer();\n\n        // Create a VBO that covers the entire screen\n        // Use a \"big\" triangle instead of a square for performance and simplicity\n        this.bigTriangleVBO = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.bigTriangleVBO);\n        const vertices = [\n            10.0, -10.0,\n            0.0, 10.0,\n            -10.0, -10.0\n        ];\n        gl.bufferData(gl.ARRAY_BUFFER, getFloat32ArrayFromArray(vertices), gl.STATIC_DRAW);\n\n        // Create a 1x1 RGBA texture set to [0,0,0,0]\n        // Needed because sometimes we don't really use some textures within the shader, but they are declared anyway.\n        this.zeroTex = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, this.zeroTex);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,\n            1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,\n            new Uint8Array(4));\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n        this._AATex = gl.createTexture();\n        this._AAFB = gl.createFramebuffer();\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.bindTexture(gl.TEXTURE_2D, this.zeroTex);\n    }\n\n    /**\n    * Get Renderer visualization center\n    * @return {RPoint}\n    */\n    getCenter () {\n        return { x: this._center.x, y: this._center.y };\n    }\n\n    /**\n     * Set Renderer visualization center\n     * @param {number} x\n     * @param {number} y\n     */\n    setCenter (x, y) {\n        this._center.x = x;\n        this._center.y = y;\n    }\n\n    /**\n     * Get Renderer visualization bounds\n     * @return {*}\n     */\n    getBounds () {\n        const center = this.getCenter();\n        const sx = this.getZoom() * this.getAspect();\n        const sy = this.getZoom();\n        return [center.x - sx, center.y - sy, center.x + sx, center.y + sy];\n    }\n\n    /**\n     * Get Renderer visualization zoom\n     * @return {number}\n     */\n    getZoom () {\n        return this._zoom;\n    }\n\n    /**\n     * Set Renderer visualization zoom\n     * @param {number} zoom\n     */\n    setZoom (zoom) {\n        this._zoom = zoom;\n    }\n\n    getAspect () {\n        if (this.gl) {\n            return this.gl.canvas.width / this.gl.canvas.height;\n        }\n        return 1;\n    }\n\n    /**\n     * Run aggregation functions over the visible features.\n     */\n    _runViewportAggregations (renderLayer) {\n        const dataframes = renderLayer.getActiveDataframes();\n        const viz = renderLayer.viz;\n\n        // Performance optimization to avoid doing DFS at each feature iteration\n        const viewportExpressions = this._getViewportExpressions(viz._getRootExpressions());\n\n        if (!viewportExpressions.length) {\n            return;\n        }\n\n        // Assume that all dataframes of a renderLayer share the same metadata\n        const metadata = dataframes.length ? dataframes[0].metadata : {};\n\n        viewportExpressions.forEach(expr => expr._resetViewportAgg(metadata));\n\n        const viewportExpressionsLength = viewportExpressions.length;\n\n        // Avoid acumulating the same feature multiple times keeping a set of processed features (same feature can belong to multiple dataframes).\n        const processedFeaturesIDs = new Set();\n\n        const aspect = this.gl.canvas.width / this.gl.canvas.height;\n        dataframes.forEach(dataframe => {\n            for (let i = 0; i < dataframe.numFeatures; i++) {\n                const featureId = dataframe.properties[metadata.idProperty][i];\n\n                // If feature has been acumulated ignore it\n                if (processedFeaturesIDs.has(featureId)) {\n                    continue;\n                }\n                // Ignore features outside viewport\n                if (!this._isFeatureInViewport(dataframe, i, aspect, viz)) {\n                    continue;\n                }\n\n                processedFeaturesIDs.add(featureId);\n\n                const feature = this._featureFromDataFrame(dataframe, i, metadata);\n\n                // Ignore filtered features\n                if (viz.filter.eval(feature) < FILTERING_THRESHOLD) {\n                    continue;\n                }\n\n                for (let j = 0; j < viewportExpressionsLength; j++) {\n                    viewportExpressions[j].accumViewportAgg(feature);\n                }\n            }\n        });\n    }\n\n    /**\n     * Check if the feature at the \"index\" position of the given dataframe is in the renderer viewport.\n     * NOTE: requires `this.aspect` to be set\n     */\n    _isFeatureInViewport (dataframe, index, aspect, viz) {\n        const scale = 1 / this._zoom;\n        return dataframe.inViewport(index, scale, this._center, aspect, viz);\n    }\n\n    /**\n     * Perform a depth first search through the expression tree collecting all viewport expressions.\n     */\n    _getViewportExpressions (rootExpressions) {\n        const viewportExpressions = [];\n\n        function dfs (expr) {\n            if (expr._isViewport) {\n                viewportExpressions.push(expr);\n            } else {\n                expr._getChildren().map(dfs);\n            }\n        }\n\n        rootExpressions.map(dfs);\n        return viewportExpressions;\n    }\n\n    /**\n     * Build a feature object from a dataframe and an index copying all the properties.\n     */\n    _featureFromDataFrame (dataframe, index, metadata) {\n        return dataframe.getFeature(index);\n    }\n\n    renderLayer (renderLayer) {\n        const tiles = renderLayer.getActiveDataframes();\n        const viz = renderLayer.viz;\n        const gl = this.gl;\n        const aspect = this.getAspect();\n        const drawMetadata = {\n            zoom: gl.drawingBufferHeight / (this._zoom * 1024 * (window.devicePixelRatio || 1)) // Used by zoom expression\n        };\n\n        if (!tiles.length) {\n            return;\n        }\n        viz._getRootExpressions().map(expr => expr._dataReady());\n\n        gl.enable(gl.CULL_FACE);\n        gl.disable(gl.BLEND);\n        gl.disable(gl.DEPTH_TEST);\n        gl.disable(gl.STENCIL_TEST);\n        gl.depthMask(false);\n        gl.bindFramebuffer(gl.FRAMEBUFFER, this.auxFB);\n\n        this._runViewportAggregations(renderLayer);\n\n        const styleDataframe = (tile, tileTexture, shader, vizExpr) => {\n            const textureId = shader.textureIds.get(viz);\n\n            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tileTexture, 0);\n            gl.viewport(0, 0, RTT_WIDTH, tile.height);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n\n            gl.useProgram(shader.program);\n            // Enforce that property texture TextureUnit don't clash with auxiliar ones\n            drawMetadata.freeTexUnit = Object.keys(textureId).length;\n            vizExpr._setTimestamp((Date.now() - INITIAL_TIMESTAMP) / 1000.0);\n            vizExpr._preDraw(shader.program, drawMetadata, gl);\n\n            Object.keys(textureId).forEach((name, i) => {\n                gl.activeTexture(gl.TEXTURE0 + i);\n                gl.bindTexture(gl.TEXTURE_2D, tile.getPropertyTexture(name));\n                gl.uniform1i(textureId[name], i);\n            });\n\n            gl.enableVertexAttribArray(shader.vertexAttribute);\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.bigTriangleVBO);\n            gl.vertexAttribPointer(shader.vertexAttribute, 2, gl.FLOAT, false, 0, 0);\n\n            gl.drawArrays(gl.TRIANGLES, 0, 3);\n            gl.disableVertexAttribArray(shader.vertexAttribute);\n        };\n\n        tiles.map(tile => styleDataframe(tile, tile.texColor, viz.colorShader, viz.color));\n        tiles.map(tile => styleDataframe(tile, tile.texWidth, viz.widthShader, viz.width));\n        tiles.map(tile => styleDataframe(tile, tile.texStrokeColor, viz.strokeColorShader, viz.strokeColor));\n        tiles.map(tile => styleDataframe(tile, tile.texStrokeWidth, viz.strokeWidthShader, viz.strokeWidth));\n        tiles.map(tile => styleDataframe(tile, tile.texFilter, viz.filterShader, viz.filter));\n\n        gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n        gl.enable(gl.BLEND);\n\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n\n        if (renderLayer.type !== 'point') {\n            const antialiasingScale = (window.devicePixelRatio || 1) >= 2 ? 1 : 2;\n            gl.bindFramebuffer(gl.FRAMEBUFFER, this._AAFB);\n            const [w, h] = [gl.drawingBufferWidth, gl.drawingBufferHeight];\n\n            if (w !== this._width || h !== this._height) {\n                gl.bindTexture(gl.TEXTURE_2D, this._AATex);\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA,\n                    w * antialiasingScale, h * antialiasingScale, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this._AATex, 0);\n\n                const renderbuffer = gl.createRenderbuffer();\n                gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);\n                gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, w * antialiasingScale, h * antialiasingScale);\n                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);\n\n                [this._width, this._height] = [w, h];\n            }\n            gl.viewport(0, 0, w * antialiasingScale, h * antialiasingScale);\n            gl.clear(gl.COLOR_BUFFER_BIT);\n        }\n\n        const scale = 1.0 / this._zoom;\n\n        const { orderingMins, orderingMaxs } = getOrderingRenderBuckets(renderLayer);\n\n        const renderDrawPass = orderingIndex => tiles.forEach(tile => {\n            let freeTexUnit = 0;\n            let renderer = null;\n            if (!viz.symbol._default) {\n                renderer = viz.symbolShader;\n            } else if (tile.type === 'point') {\n                renderer = this.finalRendererProgram;\n            } else if (tile.type === 'line') {\n                renderer = this.lineRendererProgram;\n            } else {\n                renderer = this.triRendererProgram;\n            }\n            gl.useProgram(renderer.program);\n\n            if (!viz.symbol._default) {\n                gl.uniform1i(renderer.overrideColor, viz.color.default === undefined ? 1 : 0);\n            }\n\n            // Set filtering condition on \"... AND feature is in current order bucket\"\n            gl.uniform1f(renderer.orderMinWidth, orderingMins[orderingIndex]);\n            gl.uniform1f(renderer.orderMaxWidth, orderingMaxs[orderingIndex]);\n\n            gl.uniform2f(renderer.vertexScaleUniformLocation,\n                (scale / aspect) * tile.scale,\n                scale * tile.scale);\n            gl.uniform2f(renderer.vertexOffsetUniformLocation,\n                (scale / aspect) * (this._center.x - tile.center.x),\n                scale * (this._center.y - tile.center.y));\n            if (tile.type === 'line' || tile.type === 'polygon') {\n                gl.uniform2f(renderer.normalScale, 1 / gl.canvas.clientWidth, 1 / gl.canvas.clientHeight);\n            } else if (tile.type === 'point') {\n                gl.uniform1f(renderer.devicePixelRatio, window.devicePixelRatio || 1);\n            }\n\n            tile.vertexScale = [(scale / aspect) * tile.scale, scale * tile.scale];\n\n            tile.vertexOffset = [(scale / aspect) * (this._center.x - tile.center.x), scale * (this._center.y - tile.center.y)];\n\n            gl.enableVertexAttribArray(renderer.vertexPositionAttribute);\n            gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);\n            gl.vertexAttribPointer(renderer.vertexPositionAttribute, 2, gl.FLOAT, false, 0, 0);\n\n            gl.enableVertexAttribArray(renderer.featureIdAttr);\n            gl.bindBuffer(gl.ARRAY_BUFFER, tile.featureIDBuffer);\n            gl.vertexAttribPointer(renderer.featureIdAttr, 2, gl.FLOAT, false, 0, 0);\n\n            if (tile.type === 'line' || tile.type === 'polygon') {\n                gl.enableVertexAttribArray(renderer.normalAttr);\n                gl.bindBuffer(gl.ARRAY_BUFFER, tile.normalBuffer);\n                gl.vertexAttribPointer(renderer.normalAttr, 2, gl.FLOAT, false, 0, 0);\n            }\n\n            gl.activeTexture(gl.TEXTURE0 + freeTexUnit);\n            gl.bindTexture(gl.TEXTURE_2D, tile.texColor);\n            gl.uniform1i(renderer.colorTexture, freeTexUnit);\n            freeTexUnit++;\n\n            gl.activeTexture(gl.TEXTURE0 + freeTexUnit);\n            gl.bindTexture(gl.TEXTURE_2D, tile.texWidth);\n            gl.uniform1i(renderer.widthTexture, freeTexUnit);\n            freeTexUnit++;\n\n            gl.activeTexture(gl.TEXTURE0 + freeTexUnit);\n            gl.bindTexture(gl.TEXTURE_2D, tile.texFilter);\n            gl.uniform1i(renderer.filterTexture, freeTexUnit);\n            freeTexUnit++;\n\n            if (!viz.symbol._default) {\n                const textureId = viz.symbolShader.textureIds.get(viz);\n                // Enforce that property texture and style texture TextureUnits don't clash with auxiliar ones\n                drawMetadata.freeTexUnit = freeTexUnit + Object.keys(textureId).length;\n                viz.symbol._setTimestamp((Date.now() - INITIAL_TIMESTAMP) / 1000.0);\n                viz.symbol._preDraw(viz.symbolShader.program, drawMetadata, gl);\n\n                viz.symbolPlacement._setTimestamp((Date.now() - INITIAL_TIMESTAMP) / 1000.0);\n                viz.symbolPlacement._preDraw(viz.symbolShader.program, drawMetadata, gl);\n\n                freeTexUnit = drawMetadata.freeTexUnit;\n\n                Object.keys(textureId).forEach(name => {\n                    gl.activeTexture(gl.TEXTURE0 + freeTexUnit);\n                    gl.bindTexture(gl.TEXTURE_2D, tile.getPropertyTexture(name));\n                    gl.uniform1i(textureId[name], freeTexUnit);\n                    freeTexUnit++;\n                });\n\n                gl.uniform2f(renderer.resolution, gl.canvas.width, gl.canvas.height);\n            } else if (tile.type !== 'line') {\n                // Lines don't support stroke\n                gl.activeTexture(gl.TEXTURE0 + freeTexUnit);\n                gl.bindTexture(gl.TEXTURE_2D, tile.texStrokeColor);\n                gl.uniform1i(renderer.colorStrokeTexture, freeTexUnit);\n                freeTexUnit++;\n\n                gl.activeTexture(gl.TEXTURE0 + freeTexUnit);\n                gl.bindTexture(gl.TEXTURE_2D, tile.texStrokeWidth);\n                gl.uniform1i(renderer.strokeWidthTexture, freeTexUnit);\n                freeTexUnit++;\n            }\n\n            if (tile.type === 'line' /* || tile.type === 'polygon' */) {\n                gl.clearDepth(1);\n                gl.depthRange(0, 1);\n                gl.depthFunc(gl.NOTEQUAL);\n                gl.depthMask(true);\n                gl.clear(gl.DEPTH_BUFFER_BIT);\n                gl.enable(gl.DEPTH_TEST);\n            }\n\n            gl.drawArrays(tile.type === 'point' ? gl.POINTS : gl.TRIANGLES, 0, tile.numVertex);\n\n            gl.disableVertexAttribArray(renderer.vertexPositionAttribute);\n            gl.disableVertexAttribArray(renderer.featureIdAttr);\n            if (tile.type === 'line' || tile.type === 'polygon') {\n                gl.disableVertexAttribArray(renderer.normalAttr);\n                gl.disable(gl.DEPTH_TEST);\n            }\n        });\n        orderingMins.map((_, orderingIndex) => {\n            renderDrawPass(orderingIndex);\n        });\n\n        if (renderLayer.type !== 'point') {\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n\n            gl.useProgram(this._aaBlendShader.program);\n\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, this._AATex);\n            gl.uniform1i(this._aaBlendShader.readTU, 0);\n\n            gl.enableVertexAttribArray(this._aaBlendShader.vertexAttribute);\n            gl.bindBuffer(gl.ARRAY_BUFFER, this.bigTriangleVBO);\n            gl.vertexAttribPointer(this._aaBlendShader.vertexAttribute, 2, gl.FLOAT, false, 0, 0);\n\n            gl.drawArrays(gl.TRIANGLES, 0, 3);\n            gl.disableVertexAttribArray(this._aaBlendShader.vertexAttribute);\n        }\n\n        gl.disable(gl.CULL_FACE);\n    }\n\n    /**\n     * Initialize static shaders\n     */\n    _initShaders () {\n        this.finalRendererProgram = shaders.renderer.createPointShader(this.gl);\n        this.triRendererProgram = shaders.renderer.createTriShader(this.gl);\n        this.lineRendererProgram = shaders.renderer.createLineShader(this.gl);\n        this._aaBlendShader = new shaders.AABlender(this.gl);\n    }\n}\n\nfunction getOrderingRenderBuckets (renderLayer) {\n    const orderer = renderLayer.viz.order;\n    let orderingMins = [0];\n    let orderingMaxs = [1000];\n    // We divide the ordering into 64 buckets of 2 pixels each, since the size limit is 127 pixels\n    const NUM_BUCKETS = 64;\n    if (orderer.isA(Asc)) {\n        orderingMins = Array.from({ length: NUM_BUCKETS }, (_, i) => ((NUM_BUCKETS - 1) - i) * 2);\n        orderingMaxs = Array.from({ length: NUM_BUCKETS }, (_, i) => i === 0 ? 1000 : ((NUM_BUCKETS - 1) - i + 1) * 2);\n    } else if (orderer.isA(Desc)) {\n        orderingMins = Array.from({ length: NUM_BUCKETS }, (_, i) => i * 2);\n        orderingMaxs = Array.from({ length: NUM_BUCKETS }, (_, i) => i === (NUM_BUCKETS - 1) ? 1000 : (i + 1) * 2);\n    }\n    return {\n        orderingMins,\n        orderingMaxs\n    };\n}\n","import { decodePoint } from './pointDecoder';\nimport { decodeLine } from './lineDecoder';\nimport { decodePolygon } from './polygonDecoder';\n\nexport function decodeGeom (geomType, geom) {\n    switch (geomType) {\n        case 'point':\n            return decodePoint(geom);\n        case 'line':\n            return decodeLine(geom);\n        case 'polygon':\n            return decodePolygon(geom);\n        default:\n            throw new Error(`Unimplemented geometry type: '${geomType}'`);\n    }\n}\n","import { getFloat32ArrayFromArray } from '../../utils/util';\nimport { getJoinNormal, getLineNormal, neg } from '../../utils/geometry';\n\n// If the geometry type is 'line' it will generate the appropriate zero-sized, vertex-shader expanded triangle list with `miter` and `bevel` joins.\n// The geom will be an array of coordinates in this case\n\nexport function decodeLine (geometry) {\n    let vertices = [];\n    let normals = [];\n    let breakpoints = []; // Array of indices (to vertexArray) that separate each feature\n    let featureIDToVertexIndex = new Map();\n\n    for (let i = 0; i < geometry.length; i++) {\n        const feature = geometry[i];\n        for (let j = 0; j < feature.length; j++) {\n            const lineString = feature[j];\n            addLine(lineString, vertices, normals);\n        }\n\n        featureIDToVertexIndex.set(breakpoints.length, breakpoints.length === 0\n            ? { start: 0, end: vertices.length }\n            : { start: featureIDToVertexIndex.get(breakpoints.length - 1).end, end: vertices.length });\n\n        breakpoints.push(vertices.length);\n    }\n\n    return {\n        vertices: getFloat32ArrayFromArray(vertices),\n        normals: getFloat32ArrayFromArray(normals),\n        featureIDToVertexIndex,\n        breakpoints\n    };\n}\n\n/**\n * Create a triangulated lineString: zero-sized, vertex-shader expanded triangle list\n * with `miter` joins. For angle < 60 joins are automatically adjusted to `bevel`.\n */\nfunction addLine (lineString, vertices, normals) {\n    let prevPoint, currentPoint, nextPoint;\n    let prevNormal, nextNormal;\n\n    // We need at least two points\n    if (lineString.length >= 4) {\n        // Initialize the first two points\n        prevPoint = [lineString[0], lineString[1]];\n        currentPoint = [lineString[2], lineString[3]];\n        prevNormal = getLineNormal(prevPoint, currentPoint);\n\n        for (let i = 4; i <= lineString.length; i += 2) {\n            // First triangle\n            addTriangle(\n                [prevPoint, prevPoint, currentPoint],\n                [neg(prevNormal), prevNormal, prevNormal]\n            );\n\n            // Second triangle\n            addTriangle(\n                [prevPoint, currentPoint, currentPoint],\n                [neg(prevNormal), prevNormal, neg(prevNormal)]\n            );\n\n            if (i <= lineString.length - 2) {\n                // If there is a next point, compute its properties\n                nextPoint = [lineString[i], lineString[i + 1]];\n                nextNormal = getLineNormal(currentPoint, nextPoint);\n                // `turnLeft` indicates that the nextLine turns to the left\n                // `joinNormal` contains the direction and size for the `miter` vertex\n                //  If this is not defined means that the join must be `bevel`.\n                let {turnLeft, joinNormal} = getJoinNormal(prevNormal, nextNormal);\n\n                // Third triangle\n                addTriangle(\n                    [currentPoint, currentPoint, currentPoint],\n                    [[0, 0],\n                        turnLeft ? prevNormal : neg(nextNormal),\n                        turnLeft ? nextNormal : neg(prevNormal)]\n                );\n\n                if (joinNormal) {\n                    // Forth triangle\n                    addTriangle(\n                        [currentPoint, currentPoint, currentPoint],\n                        [joinNormal,\n                            turnLeft ? nextNormal : neg(prevNormal),\n                            turnLeft ? prevNormal : neg(nextNormal)]\n                    );\n                }\n            }\n\n            // Update the variables for the next iteration\n            prevPoint = currentPoint;\n            currentPoint = nextPoint;\n            prevNormal = nextNormal;\n        }\n    }\n\n    function addTriangle (p, n) {\n        vertices.push(\n            p[0][0], p[0][1],\n            p[1][0], p[1][1],\n            p[2][0], p[2][1]\n        );\n        normals.push(\n            n[0][0], n[0][1],\n            n[1][0], n[1][1],\n            n[2][0], n[2][1]\n        );\n    }\n}\n","// If the geometry type is 'point' it will pass trough the geom (the vertex array)\n\nexport function decodePoint (vertices) {\n    return {\n        vertices: vertices,\n        breakpoints: []\n    };\n}\n","import * as earcut from 'earcut';\nimport { getFloat32ArrayFromArray } from '../../utils/util';\nimport { getLineNormal, neg } from '../../utils/geometry';\n\n// If the geometry type is 'polygon' it will triangulate the polygon list (geom)\n//      geom will be a list of polygons in which each polygon will have a flat array of vertices and a list of holes indices\n//      Example:\n/*         let geom = [\n                {\n                    flat: [\n                        0.,0., 1.,0., 1.,1., 0.,1., 0.,0, //A square\n                        0.25,0.25, 0.75,0.25, 0.75,0.75, 0.25,0.75, 0.25,0.25//A small square\n                    ]\n                    holes: [5]\n                }\n            ]\n*/\n\nexport function decodePolygon (geometry) {\n    let vertices = []; // Array of triangle vertices\n    let normals = [];\n    let breakpoints = []; // Array of indices (to vertexArray) that separate each feature\n    let featureIDToVertexIndex = new Map();\n    const geometryLength = geometry.length;\n\n    for (let i = 0; i < geometryLength; i++) {\n        const feature = geometry[i];\n        const featureLength = feature.length;\n\n        for (let j = 0; j < featureLength; j++) {\n            const polygon = feature[j];\n            const triangles = earcut(polygon.flat, polygon.holes);\n            const trianglesLength = triangles.length;\n\n            for (let k = 0; k < trianglesLength; k++) {\n                const index = triangles[k];\n                vertices.push(polygon.flat[2 * index], polygon.flat[2 * index + 1]);\n                normals.push(0, 0);\n            }\n\n            const lineString = polygon.flat;\n            const lineStringLength = lineString.length;\n\n            for (let l = 0; l < lineStringLength - 2; l += 2) {\n                if (polygon.holes.includes((l + 2) / 2)) {\n                    // Skip adding the line which connects two rings\n                    continue;\n                }\n\n                const a = [lineString[l + 0], lineString[l + 1]];\n                const b = [lineString[l + 2], lineString[l + 3]];\n\n                if (isClipped(polygon, l, l + 2)) {\n                    continue;\n                }\n\n                const normal = getLineNormal(b, a);\n\n                if (Number.isNaN(normal[0]) || Number.isNaN(normal[1])) {\n                    // Skip when there is no normal vector\n                    continue;\n                }\n\n                // First triangle\n                addTriangle(\n                    [a, a, b],\n                    [normal, neg(normal), normal]\n                );\n\n                // Second triangle\n                addTriangle(\n                    [a, b, b],\n                    [neg(normal), neg(normal), normal]\n                );\n            }\n        }\n\n        featureIDToVertexIndex.set(breakpoints.length, breakpoints.length === 0\n            ? { start: 0, end: vertices.length }\n            : { start: featureIDToVertexIndex.get(breakpoints.length - 1).end, end: vertices.length });\n\n        breakpoints.push(vertices.length);\n    }\n\n    function addTriangle (p, n) {\n        vertices.push(\n            p[0][0], p[0][1],\n            p[1][0], p[1][1],\n            p[2][0], p[2][1]\n        );\n        normals.push(\n            n[0][0], n[0][1],\n            n[1][0], n[1][1],\n            n[2][0], n[2][1]\n        );\n    }\n\n    return {\n        vertices: getFloat32ArrayFromArray(vertices),\n        normals: getFloat32ArrayFromArray(normals),\n        featureIDToVertexIndex,\n        breakpoints\n    };\n}\n\nfunction isClipped (polygon, i, j) {\n    if (polygon.clipped.includes(i) && polygon.clipped.includes(j)) {\n        if (polygon.clippedType[polygon.clipped.indexOf(i)] &\n            polygon.clippedType[polygon.clipped.indexOf(j)]) {\n            return true;\n        }\n    }\n    return false;\n}\n","// The IDENTITY schema contains zero columns, and it has two interesting properties:\n//      union(a,IDENTITY)=union(IDENTITY, a)=a\n//      contains(x, IDENTITY)=true  (for x = valid schema)\nexport const IDENTITY = {\n    columns: []\n};\n\n/*\nconst schema = {\n    columns: ['temp', 'cat']\n}; */\n\n// TODO\n// Returns true if subsetSchema is a contained by supersetSchema\n// A schema A is contained by the schema B when all columns of A are present in B and\n// all aggregations in A are present in B, if a column is not aggregated in A, it must\n// be not aggregated in B\n// export function contains(supersetSchema, subsetSchema) {\n// }\n\n// Returns the union of a and b schemas\n// The union of two schemas is a schema with all the properties in both schemas and with their\n// aggregtions set to the union of both aggregation sets, or null if a property aggregation is null in both schemas\n// The union is not defined when one schema set the aggregation of one column and the other schema left the aggregation\n// to null. In this case the function will throw an exception.\nexport function union (a, b) {\n    const t = a.columns.concat(b.columns);\n    return {\n        columns: t.filter((item, pos) => t.indexOf(item) === pos)\n    };\n}\n\nexport function equals (a, b) {\n    if (!a || !b) {\n        return false;\n    }\n    return a.columns.length === b.columns.length && a.columns.every(v => b.columns.includes(v));\n}\n\nconst AGG_PREFIX = '_cdb_agg_';\nconst AGG_PATTERN = new RegExp('^' + AGG_PREFIX + '[a-zA-Z0-9]+_');\n\n// column information functions\nexport const column = {\n    isAggregated: function isAggregated (name) {\n        return name.startsWith(AGG_PREFIX);\n    },\n    getBase: function getBase (name) {\n        return name.replace(AGG_PATTERN, '');\n    },\n    getAggFN: function getAggFN (name) {\n        let s = name.substr(AGG_PREFIX.length);\n        return s.substr(0, s.indexOf('_'));\n    },\n    aggColumn (name, aggFN) {\n        return `${AGG_PREFIX}${aggFN}_${name}`;\n    }\n};\n\nexport default { column, equals, union, IDENTITY };\n","/**\n * Keep a cacheTo avoid recompiling webgl programs and shaders.\n * We need a different shader per webgl context so we use a 2 level cache where at the first level\n * the webgl context is the key and at the second level the shader code is the cache key.\n */\nexport default class Cache {\n    constructor () {\n        this.caches = new WeakMap();\n    }\n\n    get (gl, shadercode) {\n        if (this.caches.has(gl)) {\n            let cache = this.caches.get(gl);\n\n            return cache[shadercode];\n        }\n    }\n\n    set (gl, shadercode, shader) {\n        if (this.caches.has(gl)) {\n            let cache = this.caches.get(gl);\n            cache[shadercode] = shader;\n        } else {\n            let cache = {};\n            cache[shadercode] = shader;\n            this.caches.set(gl, cache);\n        }\n    }\n\n    has (gl, shadercode) {\n        return this.get(gl, shadercode) !== undefined;\n    }\n}\n","import { compileProgram } from '../../utils';\nimport antialiasingFragmentShader from './antialiasingFragmentShader.glsl';\nimport antialiasingVertexShader from './antialiasingVertexShader.glsl';\n\nexport default class AntiAliasingShader {\n    constructor (gl) {\n        Object.assign(this, compileProgram(gl, antialiasingVertexShader, antialiasingFragmentShader));\n        this.vertexAttribute = gl.getAttribLocation(this.program, 'vertex');\n        this.readTU = gl.getUniformLocation(this.program, 'aaTex');\n    }\n}\n","module.exports = \"precision highp float;\\n\\nvarying  vec2 uv;\\n\\nuniform sampler2D aaTex;\\n\\nvoid main(void) {\\n    vec4 aa = texture2D(aaTex, uv);\\n    gl_FragColor = aa;\\n}\\n\"","module.exports = \"precision highp float;\\nattribute vec2 vertex;\\n\\nvarying  vec2 uv;\\n\\nvoid main(void) {\\n    uv = vertex*0.5+vec2(0.5);\\n    gl_Position = vec4(vertex, 0.5, 1.);\\n}\\n\"","import { compileProgram } from '../../utils';\nimport lineFragmentShader from './lineFragmentShader.glsl';\nimport lineVertexShader from './lineVertexShader.glsl';\n\nexport default class LineShader {\n    constructor (gl) {\n        Object.assign(this, compileProgram(gl, lineVertexShader, lineFragmentShader));\n        this.vertexPositionAttribute = gl.getAttribLocation(this.program, 'vertexPosition');\n        this.featureIdAttr = gl.getAttribLocation(this.program, 'featureID');\n        this.normalAttr = gl.getAttribLocation(this.program, 'normal');\n        this.vertexScaleUniformLocation = gl.getUniformLocation(this.program, 'vertexScale');\n        this.vertexOffsetUniformLocation = gl.getUniformLocation(this.program, 'vertexOffset');\n        this.colorTexture = gl.getUniformLocation(this.program, 'colorTex');\n        this.widthTexture = gl.getUniformLocation(this.program, 'widthTex');\n        this.filterTexture = gl.getUniformLocation(this.program, 'filterTex');\n        this.normalScale = gl.getUniformLocation(this.program, 'normalScale');\n    }\n}\n","module.exports = \"precision highp float;\\n\\nvarying lowp vec4 color;\\n\\nvoid main(void) {\\n    gl_FragColor = color;\\n}\\n\"","module.exports = \"precision highp float;\\n\\nattribute vec2 vertexPosition;\\nattribute vec2 featureID;\\nattribute vec2 normal;\\n\\nuniform vec2 vertexScale;\\nuniform vec2 vertexOffset;\\nuniform vec2 normalScale;\\n\\nuniform sampler2D colorTex;\\nuniform sampler2D widthTex;\\nuniform sampler2D filterTex;\\n\\nvarying lowp vec4 color;\\n\\n// From [0.,1.] in exponential-like form to pixels in [0.,255.]\\nfloat decodeWidth(float x){\\n    float w;\\n    if (x < 0.25098039215686274){ // x < 64/255\\n        w = 63.75 * x; // 255 * 0.25\\n    }else if (x < 0.5019607843137255){ // x < 128/255\\n        w = x*255. -48.;\\n    }else {\\n        w = x*510. -174.;\\n    }\\n    return w;\\n}\\n\\nvoid main(void) {\\n    color = texture2D(colorTex, featureID);\\n    float filtering = texture2D(filterTex, featureID).a;\\n    color.a *= filtering;\\n    color.rgb *= color.a;\\n    float size = decodeWidth(texture2D(widthTex, featureID).a);\\n\\n    // 64 is computed based on RTT_WIDTH and the depth buffer precision\\n    // 64 = 2^(BUFFER_BITS)/RTT_WIDTH = 2^16/1024 = 64\\n    float z = mod(featureID.y, 1./64.)*63. + featureID.x / (64.);\\n    // Set z range (-1, 1)\\n    z = z * 2. - 1.;\\n\\n    vec4 p = vec4(vertexScale*(vertexPosition)+normalScale*normal*size-vertexOffset, z, 1.);\\n    if (size==0. || color.a==0.){\\n        p.x=10000.;\\n    }\\n    gl_Position  = p;\\n}\\n\"","import { compileProgram } from '../../utils';\nimport pointFragmentShader from './pointFragmentShader.glsl';\nimport pointVertexShader from './pointVertexShader.glsl';\n\nexport default class PointShader {\n    constructor (gl) {\n        Object.assign(this, compileProgram(gl, pointVertexShader, pointFragmentShader));\n        this.vertexPositionAttribute = gl.getAttribLocation(this.program, 'vertexPosition');\n        this.featureIdAttr = gl.getAttribLocation(this.program, 'featureID');\n        this.vertexScaleUniformLocation = gl.getUniformLocation(this.program, 'vertexScale');\n        this.vertexOffsetUniformLocation = gl.getUniformLocation(this.program, 'vertexOffset');\n        this.colorTexture = gl.getUniformLocation(this.program, 'colorTex');\n        this.colorStrokeTexture = gl.getUniformLocation(this.program, 'colorStrokeTex');\n        this.strokeWidthTexture = gl.getUniformLocation(this.program, 'strokeWidthTex');\n        this.widthTexture = gl.getUniformLocation(this.program, 'widthTex');\n        this.orderMinWidth = gl.getUniformLocation(this.program, 'orderMinWidth');\n        this.orderMaxWidth = gl.getUniformLocation(this.program, 'orderMaxWidth');\n        this.filterTexture = gl.getUniformLocation(this.program, 'filterTex');\n        this.devicePixelRatio = gl.getUniformLocation(this.program, 'devicePixelRatio');\n    }\n}\n","module.exports = \"precision highp float;\\n\\nvarying lowp vec4 color;\\nvarying lowp vec4 stroke;\\nvarying highp float dp;\\nvarying highp float sizeNormalizer;\\nvarying highp float fillScale;\\nvarying highp float strokeScale;\\n\\nfloat distanceAntialias(vec2 p){\\n    return 1. - smoothstep(1.-dp*1.4142, 1.+dp*1.4142, length(p));\\n}\\n\\n\\nvoid main(void) {\\n    vec2 p = (2.*gl_PointCoord-vec2(1.))*sizeNormalizer;\\n    vec4 c = color;\\n\\n    vec4 s = stroke;\\n\\n    c.a *= distanceAntialias(p*fillScale);\\n    c.rgb*=c.a;\\n\\n    s.a *= distanceAntialias(p);\\n    s.a *= 1.-distanceAntialias((strokeScale)*p);\\n    s.rgb*=s.a;\\n\\n    c=s+(1.-s.a)*c;\\n\\n    gl_FragColor = c;\\n}\\n\"","module.exports = \"precision highp float;\\n\\nattribute vec2 vertexPosition;\\nattribute vec2 featureID;\\n\\nuniform vec2 vertexScale;\\nuniform vec2 vertexOffset;\\nuniform float orderMinWidth;\\nuniform float orderMaxWidth;\\nuniform float devicePixelRatio;\\n\\nuniform sampler2D colorTex;\\nuniform sampler2D widthTex;\\nuniform sampler2D colorStrokeTex;\\nuniform sampler2D strokeWidthTex;\\nuniform sampler2D filterTex;\\n//TODO order bucket texture\\n\\nvarying highp vec4 color;\\nvarying highp vec4 stroke;\\nvarying highp float dp;\\nvarying highp float sizeNormalizer;\\nvarying highp float fillScale;\\nvarying highp float strokeScale;\\n\\n// From [0.,1.] in exponential-like form to pixels in [0.,255.]\\nfloat decodeWidth(float x) {\\n  float w;\\n  if (x < 0.25098039215686274) { // x < 64/255\\n    w = 63.75 * x; // 255 * 0.25\\n  } else if (x < 0.5019607843137255) { // x < 128/255\\n    w = x * 255. - 48.;\\n  } else {\\n    w = x * 510. - 174.;\\n  }\\n  return w;\\n}\\n\\nvoid main(void) {\\n  color = texture2D(colorTex, featureID);\\n  stroke = texture2D(colorStrokeTex, featureID);\\n  float filtering = texture2D(filterTex, featureID).a;\\n  color.a *= filtering;\\n  stroke.a *= filtering;\\n\\n  float size = decodeWidth(texture2D(widthTex, featureID).a);\\n  float fillSize = size;\\n  float strokeSize = decodeWidth(texture2D(strokeWidthTex, featureID).a);\\n  size += strokeSize;\\n  fillScale = size / fillSize;\\n  strokeScale = size / max(0.001, (fillSize - strokeSize));\\n  if (fillScale == strokeScale) {\\n    stroke.a = 0.;\\n  }\\n  if (size > 126.) {\\n    size = 126.;\\n  }\\n  gl_PointSize = size * devicePixelRatio + 2.;\\n  dp = 1.0 / (size + 1.);\\n  sizeNormalizer = (size + 1.) / (size);\\n\\n  vec4 p = vec4(vertexScale * vertexPosition - vertexOffset, 0.5, 1.);\\n  if (size == 0. || (stroke.a == 0. && color.a == 0.) || size < orderMinWidth || size >= orderMaxWidth) {\\n    p.x = 10000.;\\n  }\\n  gl_Position = p;\\n}\\n\"","import { compileProgram } from '../../utils';\nimport triangleFragmentShader from './triangleFragmentShader.glsl';\nimport triangleVertexShader from './triangleVertexShader.glsl';\n\nexport default class TriangleShader {\n    constructor (gl) {\n        Object.assign(this, compileProgram(gl, `${triangleVertexShader}`, `${triangleFragmentShader}`));\n        this.vertexPositionAttribute = gl.getAttribLocation(this.program, 'vertexPosition');\n        this.normalAttr = gl.getAttribLocation(this.program, 'normal');\n        this.featureIdAttr = gl.getAttribLocation(this.program, 'featureID');\n        this.vertexScaleUniformLocation = gl.getUniformLocation(this.program, 'vertexScale');\n        this.vertexOffsetUniformLocation = gl.getUniformLocation(this.program, 'vertexOffset');\n        this.colorTexture = gl.getUniformLocation(this.program, 'colorTex');\n        this.colorStrokeTexture = gl.getUniformLocation(this.program, 'strokeColorTex');\n        this.strokeWidthTexture = gl.getUniformLocation(this.program, 'strokeWidthTex');\n        this.filterTexture = gl.getUniformLocation(this.program, 'filterTex');\n        this.normalScale = gl.getUniformLocation(this.program, 'normalScale');\n    }\n}\n","module.exports = \"precision lowp float;\\n\\nvarying lowp vec4 color;\\n\\nvoid main(void) {\\n    gl_FragColor = color;\\n}\\n\"","module.exports = \"precision mediump float;\\n\\nattribute vec2 vertexPosition;\\nattribute vec2 featureID;\\nattribute vec2 normal;\\n\\nuniform vec2 vertexScale;\\nuniform vec2 vertexOffset;\\nuniform vec2 normalScale;\\n\\nuniform sampler2D colorTex;\\nuniform sampler2D strokeColorTex;\\nuniform sampler2D strokeWidthTex;\\nuniform sampler2D filterTex;\\n\\nvarying lowp vec4 color;\\n\\n// From [0.,1.] in exponential-like form to pixels in [0.,255.]\\nfloat decodeWidth(float x){\\n    float w;\\n    if (x < 0.25098039215686274){ // x < 64/255\\n        w = 63.75 * x; // 255 * 0.25\\n    }else if (x < 0.5019607843137255){ // x < 128/255\\n        w = x*255. -48.;\\n    }else {\\n        w = x*510. -174.;\\n    }\\n    return w;\\n}\\n\\nvoid main(void) {\\n    vec4 c;\\n    if (normal == vec2(0.)){\\n        c = texture2D(colorTex, featureID);\\n    }else{\\n        c = texture2D(strokeColorTex, featureID);\\n    }\\n    float filtering = texture2D(filterTex, featureID).a;\\n    c.a *= filtering;\\n    float size = decodeWidth(texture2D(strokeWidthTex, featureID).a);\\n\\n    vec4 p = vec4(vertexScale*(vertexPosition)+normalScale*normal*size-vertexOffset, 0.5, 1.);\\n\\n    if (c.a==0.){\\n        p.x=10000.;\\n    }\\n    color = vec4(c.rgb*c.a, c.a);\\n    gl_Position  = p;\\n}\\n\"","import AntiAliasingShader from './common/antialiasing/AntiAliasingShader';\nimport LineShader from './geometry/line/LineShader';\nimport PointShader from './geometry/point/PointShader';\nimport TriangleShader from './geometry/triangle/TriangleShader';\nimport * as styler from './styler/stylerShaders';\nimport * as symbolizer from './symbolizer/symbolizerShaders';\n\nconst AABlender = AntiAliasingShader;\n\nconst renderer = {\n    createPointShader: gl => new PointShader(gl),\n    createTriShader: gl => new TriangleShader(gl),\n    createLineShader: gl => new LineShader(gl)\n};\n\nexport { renderer, styler, symbolizer, AABlender };\n\nexport default {\n    renderer,\n    styler,\n    symbolizer,\n    AABlender\n};\n","import { createShaderFromTemplate } from './utils';\n\nclass IDGenerator {\n    constructor () {\n        this._ids = new Map();\n    }\n    getID (expression) {\n        if (this._ids.has(expression)) {\n            return this._ids.get(expression);\n        }\n        const id = this._ids.size;\n        this._ids.set(expression, id);\n        return id;\n    }\n}\n\nexport function compileShader (gl, template, expressions, viz) {\n    let tid = {};\n    const getPropertyAccessCode = name => {\n        if (tid[name] === undefined) {\n            tid[name] = Object.keys(tid).length;\n        }\n        return `texture2D(propertyTex${tid[name]}, featureID).a`;\n    };\n\n    let codes = {};\n\n    const idGen = new IDGenerator();\n\n    Object.keys(expressions).forEach(exprName => {\n        const expr = expressions[exprName];\n        expr._setUID(idGen);\n        const exprCodes = expr._applyToShaderSource(getPropertyAccessCode);\n        codes[exprName + '_preface'] = exprCodes.preface;\n        codes[exprName + '_inline'] = exprCodes.inline;\n    });\n\n    codes.propertyPreface = Object.keys(tid).map(name => `uniform sampler2D propertyTex${tid[name]};`).join('\\n');\n\n    const shader = createShaderFromTemplate(gl, template, codes);\n\n    Object.keys(tid).map(name => {\n        tid[name] = gl.getUniformLocation(shader.program, `propertyTex${tid[name]}`);\n    });\n\n    Object.values(expressions).forEach(expr => {\n        expr._postShaderCompile(shader.program, gl);\n    });\n\n    if (!shader.textureIds) {\n        shader.textureIds = new Map();\n    }\n\n    shader.textureIds.set(viz, tid);\n\n    return shader;\n}\n","module.exports = \"// From pixels in [0.,255.] to [0.,1.] in exponential-like form\\nfloat encodeWidth(float x) {\\n    if (x<16.){\\n        x = x*4.;\\n    }else if (x<80.){\\n        x = (x-16.)+64.;\\n    }else{\\n        x = (x-80.)*0.5 + 128.;\\n    }\\n    return x / 255.;\\n}\\n\\n$width_preface\\n\"","module.exports = \"precision highp float;\\n\\nvarying vec2 uv;\\n\\n$style_preface\\n$propertyPreface\\n\\nvoid main(void) {\\n    vec2 featureID = uv;\\n    gl_FragColor = $style_inline;\\n}\\n\"","import stylerEncodeWidth from './stylerEncodeWidth.glsl';\nimport stylerFragmentShader from './stylerFragmentShader.glsl';\nimport stylerVertexShader from './stylerVertexShader.glsl';\n\nexport const colorShaderGLSL = {\n    vertexShader: `${stylerVertexShader}`,\n    fragmentShader: `${stylerFragmentShader}`\n        .replace('$style_inline', '$color_inline')\n        .replace('$style_preface', '$color_preface')\n};\n\nexport const filterShaderGLSL = {\n    vertexShader: `${stylerVertexShader}`,\n    fragmentShader: `${stylerFragmentShader}`\n        .replace('$style_inline', 'vec4($filter_inline)')\n        .replace('$style_preface', '$filter_preface')\n};\n\nexport const widthShaderGLSL = {\n    vertexShader: `${stylerVertexShader}`,\n    fragmentShader: `${stylerFragmentShader}`\n        .replace('$style_inline', 'vec4(encodeWidth($width_inline))')\n        .replace('$style_preface', `${stylerEncodeWidth}`)\n};\n","module.exports = \"precision highp float;\\nattribute vec2 vertex;\\n\\nvarying  vec2 uv;\\n\\nvoid main(void) {\\n    uv = vertex*0.5+vec2(0.5);\\n    gl_Position = vec4(vertex, 0.5, 1.);\\n}\\n\"","module.exports = \"precision highp float;\\n\\nvarying highp vec2 featureIDVar;\\nvarying highp vec4 color;\\n\\nuniform bool overrideColor;\\n\\n$symbol_preface\\n$propertyPreface\\n\\nvoid main(void) {\\n    vec2 featureID = featureIDVar;\\n    vec2 imageUV = gl_PointCoord.xy;\\n    vec4 symbolColor = $symbol_inline;\\n\\n    vec4 c;\\n    if (overrideColor){\\n        c = color * vec4(vec3(1), symbolColor.a);\\n    }else{\\n        c = symbolColor;\\n    }\\n\\n    gl_FragColor = vec4(c.rgb*c.a, c.a);\\n}\\n\"","import symbolizerFragmentShader from './symbolizerFragmentShader.glsl';\nimport symbolizerVertexShader from './symbolizerVertexShader.glsl';\n\nexport const symbolShaderGLSL = {\n    vertexShader: `${symbolizerVertexShader}`,\n    fragmentShader: `${symbolizerFragmentShader}`\n};\n","module.exports = \"precision highp float;\\n\\nattribute vec2 vertexPosition;\\nattribute vec2 featureID;\\n\\nuniform vec2 vertexScale;\\nuniform vec2 vertexOffset;\\nuniform float orderMinWidth;\\nuniform float orderMaxWidth;\\nuniform float devicePixelRatio;\\nuniform vec2 resolution;\\n\\nuniform sampler2D colorTex;\\nuniform sampler2D widthTex;\\nuniform sampler2D filterTex;\\n//TODO order bucket texture\\n\\nvarying highp vec2 featureIDVar;\\nvarying highp vec4 color;\\n\\n// From [0.,1.] in exponential-like form to pixels in [0.,255.]\\nfloat decodeWidth(float x){\\n    x*=255.;\\n    if (x < 64.){\\n        return x*0.25;\\n    }else if (x<128.){\\n        return (x-64.)+16.;\\n    }else{\\n        return (x-127.)*2.+80.;\\n    }\\n}\\n\\n$symbolPlacement_preface\\n$propertyPreface\\n\\nvoid main(void) {\\n    featureIDVar = featureID;\\n    color = texture2D(colorTex, featureID);\\n    float filtering = texture2D(filterTex, featureID).a;\\n    color.a *= filtering;\\n\\n    float size = decodeWidth(texture2D(widthTex, featureID).a);\\n    float fillSize = size;\\n    if (size > 126.){\\n        size = 126.;\\n    }\\n    gl_PointSize = size * devicePixelRatio;\\n\\n    vec4 p = vec4(vertexScale*vertexPosition-vertexOffset, 0.5, 1.);\\n    p.xy += ($symbolPlacement_inline)*gl_PointSize/resolution;\\n    if (size==0. || color.a==0. || size<orderMinWidth || size>=orderMaxWidth){\\n        p.x=10000.;\\n    }\\n    gl_Position  = p;\\n}\\n\"","import Cache from './Cache';\n\nlet programID = 1;\nconst shaderCache = new Cache();\nconst programCache = new Cache();\n\n/**\n * Compile a webgl program.\n * Use a cache to improve speed.\n *\n * @param {WebGLRenderingContext} gl - The context where the program will be executed\n * @param {string} glslvertexShader - vertex shader code\n * @param {string} glslfragmentShader - fragment shader code\n */\nexport function compileProgram (gl, glslvertexShader, glslfragmentShader) {\n    const code = glslvertexShader + glslfragmentShader;\n\n    if (programCache.has(gl, code)) {\n        return programCache.get(gl, code);\n    }\n\n    const shader = {};\n    const vertexShader = _compileShader(gl, glslvertexShader, gl.VERTEX_SHADER);\n    const fragmentShader = _compileShader(gl, glslfragmentShader, gl.FRAGMENT_SHADER);\n\n    shader.program = gl.createProgram();\n\n    gl.attachShader(shader.program, vertexShader);\n    gl.attachShader(shader.program, fragmentShader);\n    gl.linkProgram(shader.program);\n    gl.deleteShader(vertexShader);\n    gl.deleteShader(fragmentShader);\n\n    if (!gl.getProgramParameter(shader.program, gl.LINK_STATUS)) {\n        throw new Error('Unable to link the shader program: ' + gl.getProgramInfoLog(shader.program));\n    }\n\n    shader.programID = programID++;\n    programCache.set(gl, code, shader);\n\n    return shader;\n}\n\nfunction _compileShader (gl, sourceCode, type) {\n    if (shaderCache.has(gl, sourceCode)) {\n        return shaderCache.get(gl, sourceCode);\n    }\n\n    const shader = gl.createShader(type);\n    gl.shaderSource(shader, sourceCode);\n    gl.compileShader(shader);\n\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n        const log = gl.getShaderInfoLog(shader);\n        gl.deleteShader(shader);\n        throw new Error('An error occurred compiling the shaders: ' + log + '\\nSource:\\n' + sourceCode);\n    }\n\n    shaderCache.set(gl, sourceCode, shader);\n\n    return shader;\n}\n\nexport function createShaderFromTemplate (gl, glslTemplate, codes) {\n    let vertexShader = glslTemplate.vertexShader;\n    let fragmentShader = glslTemplate.fragmentShader;\n\n    Object.keys(codes).forEach(codeName => {\n        vertexShader = vertexShader.replace('$' + codeName, codes[codeName]);\n        fragmentShader = fragmentShader.replace('$' + codeName, codes[codeName]);\n    });\n\n    const shader = compileProgram(gl, vertexShader, fragmentShader);\n\n    shader.vertexAttribute = gl.getAttribLocation(shader.program, 'vertex');\n    shader.vertexPositionAttribute = gl.getAttribLocation(shader.program, 'vertexPosition');\n    shader.featureIdAttr = gl.getAttribLocation(shader.program, 'featureID');\n    shader.vertexScaleUniformLocation = gl.getUniformLocation(shader.program, 'vertexScale');\n    shader.vertexOffsetUniformLocation = gl.getUniformLocation(shader.program, 'vertexOffset');\n    shader.colorTexture = gl.getUniformLocation(shader.program, 'colorTex');\n    shader.colorStrokeTexture = gl.getUniformLocation(shader.program, 'colorStrokeTex');\n    shader.strokeWidthTexture = gl.getUniformLocation(shader.program, 'strokeWidthTex');\n    shader.widthTexture = gl.getUniformLocation(shader.program, 'widthTex');\n    shader.orderMinWidth = gl.getUniformLocation(shader.program, 'orderMinWidth');\n    shader.orderMaxWidth = gl.getUniformLocation(shader.program, 'orderMaxWidth');\n    shader.filterTexture = gl.getUniformLocation(shader.program, 'filterTex');\n    shader.devicePixelRatio = gl.getUniformLocation(shader.program, 'devicePixelRatio');\n    shader.resolution = gl.getUniformLocation(shader.program, 'resolution');\n    shader.overrideColor = gl.getUniformLocation(shader.program, 'overrideColor');\n\n    return shader;\n}\n","import { clamp } from './expressions/utils';\n\nexport function sRGBToCielab (srgb) {\n    return XYZToCieLab(sRGBToXYZ(srgb));\n}\nexport function cielabToSRGB (cielab) {\n    return XYZToSRGB(cielabToXYZ(cielab));\n}\n\nexport function interpolateRGBAinCieLAB (rgbColorA, rgbColorB, m) {\n    const cielabColorA = sRGBToCielab({\n        r: rgbColorA.r,\n        g: rgbColorA.g,\n        b: rgbColorA.b,\n        a: rgbColorA.a\n    });\n\n    const cielabColorB = sRGBToCielab({\n        r: rgbColorB.r,\n        g: rgbColorB.g,\n        b: rgbColorB.b,\n        a: rgbColorB.a\n    });\n\n    const cielabInterpolated = {\n        l: (1 - m) * cielabColorA.l + m * cielabColorB.l,\n        a: (1 - m) * cielabColorA.a + m * cielabColorB.a,\n        b: (1 - m) * cielabColorA.b + m * cielabColorB.b,\n        alpha: (1 - m) * cielabColorA.alpha + m * cielabColorB.alpha\n    };\n\n    return cielabToSRGB(cielabInterpolated);\n}\n\n// Following functionality has been inspired by http://www.getreuer.info/home/colorspace\n// License:\n/*\nLicense (BSD)\nCopyright  20052010, Pascal Getreuer\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE U\n*/\n\n// Convert sRGB to CIE XYZ with the D65 white point\nfunction sRGBToXYZ (srgb) {\n    // Poynton, \"Frequently Asked Questions About Color,\" page 10\n    // Wikipedia: http://en.wikipedia.org/wiki/SRGB\n    // Wikipedia: http://en.wikipedia.org/wiki/CIE_1931_color_space\n    const { r, g, b, a } = sRGBToLinearRGB(srgb);\n    return {\n        x: (0.4123955889674142161 * r + 0.3575834307637148171 * g + 0.1804926473817015735 * b),\n        y: (0.2125862307855955516 * r + 0.7151703037034108499 * g + 0.07220049864333622685 * b),\n        z: (0.01929721549174694484 * r + 0.1191838645808485318 * g + 0.9504971251315797660 * b),\n        a\n    };\n}\n\nfunction sRGBToLinearRGB ({ r, g, b, a }) {\n    // http://en.wikipedia.org/wiki/SRGB\n    const inverseGammaCorrection = t =>\n        t <= 0.0404482362771076 ? t / 12.92 : Math.pow((t + 0.055) / 1.055, 2.4);\n    return {\n        r: inverseGammaCorrection(r),\n        g: inverseGammaCorrection(g),\n        b: inverseGammaCorrection(b),\n        a\n    };\n}\nfunction linearRGBToSRGB ({ r, g, b, a }) {\n    // http://en.wikipedia.org/wiki/SRGB\n    const gammaCorrection = t =>\n        t <= 0.0031306684425005883 ? 12.92 * t : 1.055 * Math.pow(t, 0.416666666666666667) - 0.055;\n    return {\n        r: gammaCorrection(r),\n        g: gammaCorrection(g),\n        b: gammaCorrection(b),\n        a\n    };\n}\n\nconst WHITEPOINT_D65_X = 0.950456;\nconst WHITEPOINT_D65_Y = 1.0;\nconst WHITEPOINT_D65_Z = 1.088754;\n\n// Convert CIE XYZ to CIE L*a*b* (CIELAB) with the D65 white point\nfunction XYZToCieLab ({ x, y, z, a }) {\n    // Wikipedia: http://en.wikipedia.org/wiki/Lab_color_space\n\n    const xn = WHITEPOINT_D65_X;\n    const yn = WHITEPOINT_D65_Y;\n    const zn = WHITEPOINT_D65_Z;\n\n    const f = t =>\n        t >= 8.85645167903563082e-3\n            ? Math.pow(t, 0.333333333333333) : (841.0 / 108.0) * t + 4.0 / 29.0;\n\n    return {\n        l: 116 * f(y / yn) - 16,\n        a: 500 * (f(x / xn) - f(y / yn)),\n        b: 200 * (f(y / yn) - f(z / zn)),\n        alpha: a\n    };\n}\n\n// Convert CIE XYZ to sRGB with the D65 white point\nfunction XYZToSRGB ({ x, y, z, a }) {\n    // Poynton, \"Frequently Asked Questions About Color,\" page 10\n    // Wikipedia: http://en.wikipedia.org/wiki/SRGB\n    // Wikipedia: http://en.wikipedia.org/wiki/CIE_1931_color_space\n\n    // Convert XYZ to linear RGB\n    const r = clamp(3.2406 * x - 1.5372 * y - 0.4986 * z, 0, 1);\n    const g = clamp(-0.9689 * x + 1.8758 * y + 0.0415 * z, 0, 1);\n    const b = clamp(0.0557 * x - 0.2040 * y + 1.0570 * z, 0, 1);\n\n    return linearRGBToSRGB({ r, g, b, a });\n}\n\n// Convert CIE L*a*b* (CIELAB) to CIE XYZ with the D65 white point\nfunction cielabToXYZ ({ l, a, b, alpha }) {\n    // Wikipedia: http://en.wikipedia.org/wiki/Lab_color_space\n\n    const f = t =>\n        ((t >= 0.206896551724137931)\n            ? ((t) * (t) * (t)) : (108.0 / 841.0) * ((t) - (4.0 / 29.0)));\n\n    return {\n        x: WHITEPOINT_D65_X * f((l + 16) / 116 + a / 500),\n        y: WHITEPOINT_D65_Y * f((l + 16) / 116),\n        z: WHITEPOINT_D65_Z * f((l + 16) / 116 - b / 200),\n        a: alpha\n    };\n}\n","import bicycle from './svgs/bicycle.svg';\nimport building from './svgs/building.svg';\nimport bus from './svgs/bus.svg';\nimport car from './svgs/car.svg';\nimport circle from './svgs/circle.svg';\nimport circleOutline from './svgs/circleOutline.svg';\nimport cross from './svgs/cross.svg';\nimport house from './svgs/house.svg';\nimport flag from './svgs/flag.svg';\nimport marker from './svgs/marker.svg';\nimport markerOutline from './svgs/markerOutline.svg';\nimport plus from './svgs/plus.svg';\nimport square from './svgs/square.svg';\nimport squareOutline from './svgs/squareOutline.svg';\nimport star from './svgs/star.svg';\nimport starOutline from './svgs/starOutline.svg';\nimport triangle from './svgs/triangle.svg';\nimport triangleOutline from './svgs/triangleOutline.svg';\n\nexport default {\n    bicycle,\n    building,\n    bus,\n    car,\n    circle,\n    circleOutline,\n    cross,\n    house,\n    flag,\n    marker,\n    markerOutline,\n    plus,\n    square,\n    squareOutline,\n    star,\n    starOutline,\n    triangle,\n    triangleOutline\n};\n","/**\n *  Expressions are used to define visualizations, a visualization (viz) is a set named properties and variables and its corresponding values: expressions.\n *  A viz has the following properties:\n *\n *  - **color**: fill color of points and polygons and color of lines\n *  - **strokeColor**: stroke/border color of points and polygons, not applicable to lines\n *  - **width**: fill diameter of points, thickness of lines, not applicable to polygons\n *  - **strokeWidth**: stroke width of points and polygons, not applicable to lines\n *  - **filter**: filter features by removing from rendering and interactivity all the features that don't pass the test\n *  - **symbol** - show an image instead in the place of points\n *  - **symbolPlacement** - when using `symbol`, offset to apply to the image\n *  - **resolution**: resolution of the property-aggregation functions, a value of 4 means to produce aggregation on grid cells of 4x4 pixels, only applicable to points\n *\n * For example the point diameter could be using the `add` expression:\n *\n * ```javascript\n * const viz = new carto.Viz({\n *   width: carto.expressions.add(5, 5)  // Equivalent to `width: 10`\n * });\n * ```\n *\n * You can use dataset properties inside expressions. Imagine we are representing cities in a map,\n * we can make the point width proportional to the population using the `property`/`prop` expression.\n *\n * ```javascript\n * const viz = new carto.Viz({\n *   width: carto.expressions.prop('population')\n * });\n * ```\n *\n * Multiple expressions can be combined to form more powerful ones,\n * for example lets divide the population between a number using the `div` expression to make points smaller:\n *\n * ```javascript\n * const s = carto.expressions; // We use this alias along documentation.\n * const viz = new carto.Viz({\n *   width: s.div(\n *     s.prop('population'),\n *     10000\n *  )\n * });\n * ```\n *\n * All these expressions can be used also in a String API form. This API is a more compact way to create and use expressions.\n * It has shortcut notation to access your feature properties using the `$` symbol. It also allows inline comments using the JavaScript syntax.\n *\n * ```javascript\n * const viz = new carto.Viz(`\n *   width: $population / 10000  // Size proportional to the population for each feature\n * `);\n * ```\n *\n * Although the combination of expressions is very powerful, you must be aware of the different types to produce valid combinations.\n * For example, the previous example is valid since we assumed that 'population' is a numeric property, it won't be valid if\n * it was a categorical property. Each expression defines some restrictions regarding their parameters, particularly, the\n * type of their parameters.\n *\n * The most important types are:\n *  - **Number** expression. Expressions that contains numbers, both integers and floating point numbers. Boolean types are emulated by this type, being 0 false, and 1 true.\n *  - **Category** expression. Expressions that contains categories. Categories can have a limited set of values, like the country or the region of a feature.\n *  - **Color** expression. Expressions that contains colors. An alpha or transparency channel is included in this type.\n *\n * @namespace carto.expressions\n * @api\n */\n\n/**\n * Type of Numeric Expressions.\n *\n * Associated to expressions that return is an integer or float. When these expressions are evaluated it should return a JavaScript number.\n *\n * JavaScript numbers are automatically converted to Numeric Expressions.\n *\n * @typedef {} Number\n * @api\n */\n\n/**\n * Type of Category Expressions.\n *\n * Associated to expressions that return is a category string. When these expressions are evaluated it should return a JavaScript string.\n *\n * JavaScript strings are automatically converted to Category Expressions.\n *\n * @typedef {} Category\n * @api\n */\n\n/**\n * Type of Color Expressions.\n *\n * Associated to expressions that return a color. When these expressions are evaluated it should return a RGBA object like:\n *\n * ```\n * { r: 255, g: 255, b: 255, a: 1.0 }\n * ```\n *\n * @typedef {} Color\n * @api\n */\n\n/**\n * Type of Date Expressions.\n *\n * @typedef {} Date\n * @api\n */\n\n/**\n * Type of Fade Expressions.\n *\n * @typedef {} Fade\n * @api\n */\n\n/**\n * Type of Palette Expressions.\n *\n * More information in {@link carto.expressions.palettes|carto.expressions.palettes}.\n *\n * @typedef {} Palette\n * @api\n */\n\nimport Transition from './expressions/transition';\n\nimport BaseArray from './expressions/basic/array';\n\nimport { In } from './expressions/belongs';\nimport { Nin } from './expressions/belongs';\n\nimport Between from './expressions/between';\n\nimport { Mul } from './expressions/binary';\nimport { Div } from './expressions/binary';\nimport { Add } from './expressions/binary';\nimport { Sub } from './expressions/binary';\nimport { Mod } from './expressions/binary';\nimport { Pow } from './expressions/binary';\nimport { GreaterThan } from './expressions/binary';\nimport { GreaterThanOrEqualTo } from './expressions/binary';\nimport { LessThan } from './expressions/binary';\nimport { LessThanOrEqualTo } from './expressions/binary';\nimport { Equals } from './expressions/binary';\nimport { NotEquals } from './expressions/binary';\nimport { Or } from './expressions/binary';\nimport { And } from './expressions/binary';\n\nimport Blend from './expressions/blend';\n\nimport Buckets from './expressions/buckets';\n\nimport BaseCategory from './expressions/basic/category';\n\nimport CIELab from './expressions/color/CIELab';\n\nimport ClusterAvg from './expressions/aggregation/cluster/ClusterAvg';\nimport ClusterMax from './expressions/aggregation/cluster/ClusterMax';\nimport ClusterMin from './expressions/aggregation/cluster/ClusterMin';\nimport ClusterMode from './expressions/aggregation/cluster/ClusterMode';\nimport ClusterSum from './expressions/aggregation/cluster/ClusterSum';\n\nimport Constant from './expressions/basic/constant';\n\nimport Hex from './expressions/color/hex';\n\nimport { HSL } from './expressions/color/hsl';\nimport { HSLA } from './expressions/color/hsl';\n\nimport { HSV } from './expressions/color/hsv';\nimport { HSVA } from './expressions/color/hsv';\n\nimport { Cubic } from './expressions/interpolators';\nimport { ILinear } from './expressions/interpolators';\n\nimport Linear from './expressions/linear';\n\nimport NamedColor from './expressions/color/NamedColor';\n\nimport Now from './expressions/now';\n\nimport BaseNumber from './expressions/basic/number';\n\nimport Opacity from './expressions/color/opacity';\n\nimport { Asc } from './expressions/ordering';\nimport { Desc } from './expressions/ordering';\nimport { NoOrder } from './expressions/ordering';\nimport { Width } from './expressions/ordering';\n\nimport palettes from './expressions/color/palettes';\nimport Reverse from './expressions/color/palettes/Reverse';\n\nimport Property from './expressions/basic/property';\n\nimport GlobalEqIntervals from './expressions/classification/GlobalEqIntervals';\nimport GlobalQuantiles from './expressions/classification/GlobalQuantiles';\nimport ViewportEqIntervals from './expressions/classification/ViewportEqIntervals';\nimport ViewportQuantiles from './expressions/classification/ViewportQuantiles';\n\nimport Ramp from './expressions/ramp';\n\nimport { RGB } from './expressions/color/rgb';\nimport { RGBA } from './expressions/color/rgb';\n\nimport Time from './expressions/time';\n\nimport Top from './expressions/top';\n\nimport { Fade } from './expressions/Fade';\nimport { Animation } from './expressions/Animation';\n\nimport { Log } from './expressions/unary';\nimport { Sqrt } from './expressions/unary';\nimport { Sin } from './expressions/unary';\nimport { Cos } from './expressions/unary';\nimport { Tan } from './expressions/unary';\nimport { Sign } from './expressions/unary';\nimport { Abs, IsNaN } from './expressions/unary';\nimport { Not } from './expressions/unary';\nimport { Floor } from './expressions/unary';\nimport { Ceil } from './expressions/unary';\n\nimport variableFn from './expressions/basic/variable';\n\nimport ViewportAvg from './expressions/aggregation/viewport/ViewportAvg';\nimport ViewportMax from './expressions/aggregation/viewport/ViewportMax';\nimport ViewportMin from './expressions/aggregation/viewport/ViewportMin';\nimport ViewportSum from './expressions/aggregation/viewport/ViewportSum';\nimport ViewportCount from './expressions/aggregation/viewport/ViewportCount';\nimport ViewportPercentile from './expressions/aggregation/viewport/ViewportPercentile';\nimport ViewportHistogram from './expressions/aggregation/viewport/ViewportHistogram';\n\nimport GlobalAvg from './expressions/aggregation/global/GlobalAvg';\nimport GlobalCount from './expressions/aggregation/global/GlobalCount';\nimport GlobalMax from './expressions/aggregation/global/GlobalMax';\nimport GlobalMin from './expressions/aggregation/global/GlobalMin';\nimport GlobalSum from './expressions/aggregation/global/GlobalSum';\nimport GlobalPercentile from './expressions/aggregation/global/GlobalPercentile';\n\nimport ViewportFeatures from './expressions/viewportFeatures';\n\nimport XYZ from './expressions/xyz';\n\nimport Zoom from './expressions/zoom';\n\nimport Placement from './expressions/placement';\nimport Image from './expressions/Image';\nimport ImageList from './expressions/ImageList';\nimport SVG from './expressions/SVG';\nimport svgs from './defaultSVGs';\n\n/* Expose classes as constructor functions */\n\nexport const transition = (...args) => new Transition(...args);\n\nexport const array = (...args) => new BaseArray(...args);\n\nconst in_ = (...args) => new In(...args);\nexport const nin = (...args) => new Nin(...args);\nexport { in_ as in };\n\nexport const between = (...args) => new Between(...args);\n\nexport const mul = (...args) => new Mul(...args);\nexport const div = (...args) => new Div(...args);\nexport const add = (...args) => new Add(...args);\nexport const sub = (...args) => new Sub(...args);\nexport const pow = (...args) => new Pow(...args);\nexport const mod = (...args) => new Mod(...args);\nexport const greaterThan = (...args) => new GreaterThan(...args);\nexport const greaterThanOrEqualTo = (...args) => new GreaterThanOrEqualTo(...args);\nexport const lessThan = (...args) => new LessThan(...args);\nexport const lessThanOrEqualTo = (...args) => new LessThanOrEqualTo(...args);\nexport const equals = (...args) => new Equals(...args);\nexport const notEquals = (...args) => new NotEquals(...args);\nexport const and = (...args) => new And(...args);\nexport const or = (...args) => new Or(...args);\nexport const gt = greaterThan;\nexport const gte = greaterThanOrEqualTo;\nexport const lt = lessThan;\nexport const lte = lessThanOrEqualTo;\nexport const eq = equals;\nexport const neq = notEquals;\n\nexport const blend = (...args) => new Blend(...args);\n\nexport const buckets = (...args) => new Buckets(...args);\n\nexport const cielab = (...args) => new CIELab(...args);\n\nexport const clusterAvg = (...args) => new ClusterAvg(...args);\nexport const clusterMax = (...args) => new ClusterMax(...args);\nexport const clusterMin = (...args) => new ClusterMin(...args);\nexport const clusterMode = (...args) => new ClusterMode(...args);\nexport const clusterSum = (...args) => new ClusterSum(...args);\n\nexport const constant = (...args) => new Constant(...args);\n\nexport const image = (...args) => new Image(...args);\nexport const imageList = (...args) => new ImageList(...args);\n\nexport const svg = (...args) => new SVG(...args);\n\nexport const hex = (...args) => new Hex(...args);\n\nexport const hsl = (...args) => new HSL(...args);\nexport const hsla = (...args) => new HSLA(...args);\n\nexport const hsv = (...args) => new HSV(...args);\nexport const hsva = (...args) => new HSVA(...args);\n\nexport const cubic = (...args) => new Cubic(...args);\nexport const ilinear = (...args) => new ILinear(...args);\n\nexport const linear = (...args) => new Linear(...args);\n\nexport const namedColor = (...args) => new NamedColor(...args);\n\nexport const now = (...args) => new Now(...args);\n\nexport const number = (...args) => new BaseNumber(...args);\n\nexport const opacity = (...args) => new Opacity(...args);\n\nexport const asc = (...args) => new Asc(...args);\nexport const desc = (...args) => new Desc(...args);\nexport const noOrder = (...args) => new NoOrder(...args);\nexport const width = (...args) => new Width(...args);\n\nexport const reverse = (...args) => new Reverse(...args);\n\nexport const property = (...args) => new Property(...args);\nexport { property as prop };\n\nexport const viewportQuantiles = (...args) => new ViewportQuantiles(...args);\nexport const globalQuantiles = (...args) => new GlobalQuantiles(...args);\nexport const globalEqIntervals = (...args) => new GlobalEqIntervals(...args);\nexport const viewportEqIntervals = (...args) => new ViewportEqIntervals(...args);\n\nexport const ramp = (...args) => new Ramp(...args);\n\nexport const rgb = (...args) => new RGB(...args);\nexport const rgba = (...args) => new RGBA(...args);\n\nexport const category = (...args) => new BaseCategory(...args);\n\nexport const time = (...args) => new Time(...args);\nexport { time as date };\n\nexport const top = (...args) => new Top(...args);\n\nexport const fade = (...args) => new Fade(...args);\nexport const animation = (...args) => new Animation(...args);\n\nexport const log = (...args) => new Log(...args);\nexport const sqrt = (...args) => new Sqrt(...args);\nexport const sin = (...args) => new Sin(...args);\nexport const cos = (...args) => new Cos(...args);\nexport const tan = (...args) => new Tan(...args);\nexport const sign = (...args) => new Sign(...args);\nexport const abs = (...args) => new Abs(...args);\nexport const isNaN = (...args) => new IsNaN(...args);\nexport const not = (...args) => new Not(...args);\nexport const floor = (...args) => new Floor(...args);\nexport const ceil = (...args) => new Ceil(...args);\n\nexport const variable = (...args) => variableFn(...args);\nexport { variable as var };\n\nexport const viewportAvg = (...args) => new ViewportAvg(...args);\nexport const viewportMax = (...args) => new ViewportMax(...args);\nexport const viewportMin = (...args) => new ViewportMin(...args);\nexport const viewportSum = (...args) => new ViewportSum(...args);\nexport const viewportCount = (...args) => new ViewportCount(...args);\nexport const viewportPercentile = (...args) => new ViewportPercentile(...args);\nexport const viewportHistogram = (...args) => new ViewportHistogram(...args);\nexport const viewportFeatures = (...args) => new ViewportFeatures(...args);\nexport const globalAvg = (...args) => new GlobalAvg(...args);\nexport const globalMax = (...args) => new GlobalMax(...args);\nexport const globalMin = (...args) => new GlobalMin(...args);\nexport const globalSum = (...args) => new GlobalSum(...args);\nexport const globalCount = (...args) => new GlobalCount(...args);\nexport const globalPercentile = (...args) => new GlobalPercentile(...args);\n\nexport const xyz = (...args) => new XYZ(...args);\n\nexport const zoom = (...args) => new Zoom(...args);\nexport const placement = (...args) => new Placement(...args);\n\nexport const HOLD = new Constant(Number.MAX_SAFE_INTEGER);\nexport const TRUE = new Constant(1);\nexport const FALSE = new Constant(0);\nexport const PI = new Constant(Math.PI);\nexport const E = new Constant(Math.E);\n\nexport const BICYCLE = new SVG(svgs.bicycle);\nexport const BUILDING = new SVG(svgs.building);\nexport const BUS = new SVG(svgs.bus);\nexport const CAR = new SVG(svgs.car);\nexport const CIRCLE = new SVG(svgs.circle);\nexport const CIRCLE_OUTLINE = new SVG(svgs.circleOutline);\nexport const CROSS = new SVG(svgs.cross);\nexport const FLAG = new SVG(svgs.flag);\nexport const HOUSE = new SVG(svgs.house);\nexport const MARKER = new SVG(svgs.marker);\nexport const MARKER_OUTLINE = new SVG(svgs.markerOutline);\nexport const PLUS = new SVG(svgs.plus);\nexport const SQUARE = new SVG(svgs.square);\nexport const SQUARE_OUTLINE = new SVG(svgs.squareOutline);\nexport const STAR = new SVG(svgs.star);\nexport const STAR_OUTLINE = new SVG(svgs.starOutline);\nexport const TRIANGLE = new SVG(svgs.triangle);\nexport const TRIANGLE_OUTLINE = new SVG(svgs.triangleOutline);\n\nexport const ALIGN_CENTER = new Placement(constant(0), constant(0));\nexport const ALIGN_BOTTOM = new Placement(constant(0), constant(1));\n\nexport { palettes, Asc, Desc };\n","import BaseExpression from './base';\nimport { Fade } from './Fade';\nimport { implicitCast, clamp, checkType, checkLooseType, checkFeatureIndependent } from './utils';\nimport { number, linear, globalMin, globalMax } from '../expressions';\nimport Property from './basic/property';\nimport { castDate } from '../../../utils/util';\n\nlet waitingForLayer = new Set();\nlet waitingForOthers = new Set();\n\n/**\n * Create an animated temporal filter (animation).\n *\n * @param {Number} input input to base the temporal filter,\n * if input is a property, the beginning and end of the animation will be determined by the minimum and maximum timestamps of the property on the dataset,\n * this can be problematic if outliers are present. Otherwise input must be a number expression in which 0 means beginning of the animation and 1 means end.\n * If `input` is NULL or NaN the filter won't be passed at any moment of the animation.\n *\n * It can be combined with linear and time expressions.\n * @param {Number} duration duration of the animation in seconds, optional, defaults to 10 seconds\n * @param {Fade} fade fadeIn/fadeOut configuration, optional, defaults to 0.15 seconds of fadeIn and 0.15 seconds of fadeOut\n * @return {Number}\n *\n * @example <caption>Temporal map by $day (of numeric type), with a duration of 40 seconds, fadeIn of 0.1 seconds and fadeOut of 0.3 seconds. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: 2\n *   color: ramp(linear(clusterAvg($temp), 0,30), tealrose)\n *   filter: animation($day, 40, fade(0.1, 0.3))\n * `);\n *\n * @example <caption>Temporal map by $date (of date type), with a duration of 40 seconds, fadeIn of 0.1 seconds and fadeOut of 0.3 seconds. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: 2\n *   color: ramp(linear(clusterAvg($temp), 0,30), tealrose)\n *   filter: animation(linear($date, time('2022-03-09T00:00:00Z'), time('2033-08-12T00:00:00Z')), 40, fade(0.1, 0.3))\n * `);\n *\n * @example <caption>Using the `getProgressValue` method to get the animation current value</caption>\n * const s = carto.expressions;\n * let animationExpr = s.animation(s.linear(s.prop('saledate'), 1991, 2017), 20, s.fade(0.7, 0.4));\n * const animationStyle = {\n *   color: s.ramp(s.linear(s.prop('priceperunit'), 2000, 1010000), [s.rgb(0, 255, 0), s.rgb(255, 0, 0)]),\n *   width: s.mul(s.sqrt(s.prop('priceperunit')), 0.05),\n *   filter: animationExpr\n * };\n * layer.on('updated', () => {\n *   let currTime = Math.floor(animationExpr.getProgressValue());\n *   document.getElementById('timestamp').innerHTML = currTime;\n * });\n *\n * @memberof carto.expressions\n * @name animation\n * @function\n * @api\n*/\n/**\n * Animation class\n *\n * This class is instanced automatically by using the `animation` function. It is documented for its methods.\n *\n * @memberof carto.expressions\n * @name Animation\n * @abstract\n * @hideconstructor\n * @class\n * @api\n */\nexport class Animation extends BaseExpression {\n    constructor (input, duration = 10, fade = new Fade()) {\n        duration = implicitCast(duration);\n        input = implicitCast(input);\n        const originalInput = input;\n\n        if (input.isA(Property)) {\n            input = linear(input, globalMin(input), globalMax(input));\n        }\n\n        checkLooseType('animation', 'input', 0, 'number', input);\n        checkLooseType('animation', 'duration', 1, 'number', duration);\n        checkFeatureIndependent('animation', 'duration', 1, duration);\n        checkLooseType('animation', 'fade', 2, 'fade', fade);\n\n        const progress = number(0);\n\n        super({ _input: input, progress, fade, duration });\n        // TODO improve type check\n        this.type = 'number';\n        this._originalInput = originalInput;\n        this._paused = false;\n\n        this.preface = `\n        #ifndef ANIMATION\n        #define ANIMATION\n\n        float animation(float _input, float progress, float duration, float fadeIn, float fadeOut){\n            float x = 0.;\n\n            // Check for NaN\n            if (_input <= 0.0 || 0.0 <= _input){\n                x = 1. - clamp(abs(_input - progress) * duration / (_input > progress ? fadeIn: fadeOut), 0., 1.);\n            }\n\n            return x;\n        }\n\n        #endif\n    `;\n\n        this.inlineMaker = inline =>\n            `animation(${inline._input}, ${inline.progress}, ${inline.duration}, ${inline.fade.in}, ${inline.fade.out})`;\n    }\n\n    isAnimated () {\n        return !this.paused;\n    }\n\n    _dataReady () {\n        if (waitingForLayer.has(this)) {\n            waitingForLayer.delete(this);\n            waitingForOthers.add(this);\n        }\n        if (waitingForOthers.has(this)) {\n            waitingForLayer = new Set([...waitingForLayer].filter(expr => {\n                while (expr.parent) {\n                    expr = expr.parent;\n                }\n                if (expr._getRootExpressions) {\n                    // The animation hasn't been removed from the viz\n                    return true;\n                }\n                return false;\n            }));\n            if (waitingForLayer.size > 0) {\n                return;\n            }\n            [...waitingForOthers.values()].map(anim => {\n                if (anim._paused === 'default') {\n                    anim.play();\n                }\n            });\n            waitingForOthers.clear();\n        }\n    }\n\n    _postShaderCompile (program, gl) {\n        waitingForLayer.add(this);\n        this._paused = 'default';\n        super._postShaderCompile(program, gl);\n    }\n\n    _setTimestamp (timestamp) {\n        super._setTimestamp(timestamp);\n\n        if (this._paused && this._lastTime === undefined) {\n            return;\n        }\n        let deltaTime = 0;\n        const speed = 1 / this.duration.value;\n\n        if (this._lastTime !== undefined) {\n            deltaTime = timestamp - this._lastTime;\n        }\n\n        this._lastTime = timestamp;\n\n        if (this._paused) {\n            return;\n        }\n\n        this.progress.expr = (this.progress.expr + speed * deltaTime) % 1;\n    }\n\n    eval (feature) {\n        const input = this._input.eval(feature);\n\n        if (Number.isNaN(input)) {\n            return 0;\n        }\n\n        const progress = this.progress.value;\n        const duration = this.duration.value;\n        const fadeIn = this.fade.fadeIn.eval(feature);\n        const fadeOut = this.fade.fadeOut.eval(feature);\n\n        const output = 1 - clamp(Math.abs(input - progress) * duration / (input > progress ? fadeIn : fadeOut), 0, 1);\n        return output;\n    }\n\n    /**\n     * Get the current time stamp of the animation\n     *\n     * @api\n     * @returns {Number|Date} Current time stamp of the animation. If the animation is based on a numeric expression this will output a number, if it is based on a date expression it will output a date\n     * @memberof carto.expressions.Animation\n     * @instance\n     * @name getProgressValue\n     */\n    getProgressValue () {\n        const progress = this.progress.eval(); // from 0 to 1\n        const min = this._input.min.eval();\n        const max = this._input.max.eval();\n\n        if (!(min instanceof Date)) {\n            return progress * (max - min) + min;\n        }\n\n        const tmin = min.getTime();\n        const tmax = max.getTime();\n        const tmix = (1 - progress) * tmin + tmax * progress;\n\n        return new Date(tmix);\n    }\n\n    /**\n     * Set the time stamp of the animation\n     * @api\n     * @memberof carto.expressions.Animation\n     * @instance\n     * @name setCurrent\n     * @param {Date|number} value - A JavaScript Date object with the new animation time\n     */\n    setTimestamp (timestamp) {\n        const date = castDate(timestamp);\n        const tmin = this._input.min.eval();\n        const tmax = this._input.max.eval();\n\n        if (date.getTime() < tmin) {\n            throw new RangeError('animation.setTimestamp requires the date parameter to be higher than the lower limit');\n        }\n        if (date.getTime() > tmax) {\n            throw new RangeError('animation.setTimestamp requires the date parameter to be lower than the higher limit');\n        }\n\n        this.progress.expr = (date.getTime() - tmin) / (tmax - tmin);\n    }\n\n    /**\n     * Get the animation progress.\n     *\n     * @returns {Number} A number representing the progress. 0 when the animation just started and 1 at the end of the cycle.\n     * @api\n     * @instance\n     * @memberof carto.expressions.Animation\n     * @name getProgressPct\n     */\n    getProgressPct () {\n        return this.progress.value;\n    }\n\n    /**\n     * Set the animation progress from 0 to 1.\n     * @param {number} progress - A number in the [0-1] range setting the animation progress.\n     * @api\n     * @instance\n     * @memberof carto.expressions.Animation\n     * @name setProgressPct\n     */\n    setProgressPct (progress) {\n        progress = Number.parseFloat(progress);\n\n        if (progress < 0 || progress > 1) {\n            throw new TypeError(`animation.setProgressPct requires a number between 0 and 1 as parameter but got: ${progress}`);\n        }\n\n        this.progress.expr = progress;\n    }\n\n    /**\n     * Pause the animation\n     *\n     * @api\n     * @memberof carto.expressions.Animation\n     * @instance\n     * @name pause\n     */\n    pause () {\n        this._paused = true;\n    }\n\n    /**\n     * Play/resume the animation\n     *\n     * @api\n     * @memberof carto.expressions.Animation\n     * @instance\n     * @name play\n     */\n    play () {\n        this._paused = false;\n    }\n\n    /**\n     * Stops the animation\n     *\n     * @api\n     * @memberof carto.expressions.Animation\n     * @instance\n     * @name stop\n     */\n    stop () {\n        this.progress.expr = 0;\n        this._paused = true;\n    }\n\n    _bindMetadata (meta) {\n        this._originalInput._bindMetadata(meta);\n        this.duration._bindMetadata(meta);\n\n        checkType('animation', 'input', 0, ['number', 'date'], this._originalInput);\n        checkType('animation', 'duration', 1, 'number', this.duration);\n        super._bindMetadata(meta);\n\n        checkType('animation', 'input', 0, 'number', this._input);\n        checkType('animation', 'fade', 2, 'fade', this.fade);\n        checkFeatureIndependent('animation', 'duration', 1, this.duration);\n    }\n}\n","import BaseExpression from './base';\nimport { implicitCast, checkLooseType } from './utils';\n\n/**\n * Create a FadeIn/FadeOut configuration. See `animation` for more details.\n *\n * @param {Number} param1 - Expression of type number or Number\n * @param {Number} param2 - Expression of type number or Number\n * @return {Fade}\n *\n * @example <caption>Fade in of 0.1 seconds, fade out of 0.3 seconds.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   filter: s.animation(s.prop('day'), 40, s.fade(0.1, 0.3))\n * });\n *\n * @example <caption>Fade in of 0.1 seconds, fade out of 0.3 seconds. (String)</caption>\n * const viz = new carto.Viz(`\n *   filter: animation($day, 40, fade(0.1, 0.3))\n * `);\n *\n * @example<caption>Fade in and fade out of 0.5 seconds.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   filter: s.animation(s.prop('day'), 40, s.fade(0.5))\n * });\n *\n * @example<caption>Fade in and fade out of 0.5 seconds. (String)</caption>\n * const viz = new carto.Viz(`\n *   filter: animation($day, 40, fade(0.5))\n * `);\n *\n * @example<caption>Fade in of 0.3 seconds without fading out.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   filter: s.animation(s.prop('day'), 40, s.fade(0.1, s.HOLD))\n * });\n *\n * @example<caption>Fade in of 0.3 seconds without fading out. (String)</caption>\n * const viz = new carto.Viz(`\n *   filter: animation($day, 40, fade(0.3, HOLD))\n * `);\n *\n * @memberof carto.expressions\n * @name fade\n * @function\n * @api\n*/\n\nconst DEFAULT_FADE = 0.15;\nconst DEFAULT_PARAM = undefined;\n\nexport class Fade extends BaseExpression {\n    constructor (param1 = DEFAULT_PARAM, param2 = DEFAULT_PARAM) {\n        let fadeIn = param1 === DEFAULT_PARAM\n            ? implicitCast(DEFAULT_FADE)\n            : implicitCast(param1);\n\n        let fadeOut = param2 === DEFAULT_PARAM\n            ? fadeIn\n            : implicitCast(param2);\n\n        checkLooseType('fade', 'param1', 0, 'number', fadeIn);\n        checkLooseType('fade', 'param2', 1, 'number', fadeOut);\n\n        // TODO improve type check\n        super({ fadeIn, fadeOut });\n\n        this.type = 'fade';\n\n        this.inlineMaker = (inline) => ({\n            in: inline.fadeIn,\n            out: inline.fadeOut\n        });\n    }\n}\n","import Base from './base';\nimport { checkString } from './utils';\n\n/**\n * Image. Load an image and use it as a symbol.\n *\n * Note: image RGB color will be overridden if the viz `color` property is set.\n *\n * @param {string} url - Image path\n *\n * @example <caption>Load a svg image.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   symbol: s.image('./marker.svg')\n * });\n *\n * @example <caption>Load a svg image. (String)</caption>\n * const viz = new carto.Viz(`\n *    symbol: image('./marker.svg')\n * `);\n * @memberof carto.expressions\n * @name image\n * @function\n * @api\n*/\n\nexport default class Image extends Base {\n    constructor (url) {\n        checkString('image', 'url', 0, url);\n        super({});\n        this.type = 'image';\n        this.canvas = null;\n        this._url = url;\n        this._promise = new Promise((resolve, reject) => {\n            this.image = new window.Image();\n            this.image.onload = () => {\n                this.canvas = _getCanvasFromImage(this.image);\n                this.image = null;\n                resolve();\n            };\n            this.image.onerror = reject;\n            this.image.crossOrigin = 'anonymous';\n            this.image.src = this._url;\n        });\n    }\n\n    loadImages () {\n        this.count = this.count + 1 || 1;\n        return this._promise;\n    }\n\n    eval () {}\n\n    _free (gl) {\n        if (this.texture) {\n            gl.deleteTexture(this.texture);\n        }\n    }\n\n    _applyToShaderSource () {\n        return {\n            preface: this._prefaceCode(`uniform sampler2D texSprite${this._uid};`),\n            inline: `texture2D(texSprite${this._uid}, imageUV).rgba`\n        };\n    }\n\n    _postShaderCompile (program, gl) {\n        this._getBinding(program)._texLoc = gl.getUniformLocation(program, `texSprite${this._uid}`);\n    }\n\n    _preDraw (program, drawMetadata, gl) {\n        if (!this.init && this.canvas) {\n            this.init = true;\n            gl.activeTexture(gl.TEXTURE0 + drawMetadata.freeTexUnit);\n            this.texture = gl.createTexture();\n            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n            gl.bindTexture(gl.TEXTURE_2D, this.texture);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.canvas);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            gl.generateMipmap(gl.TEXTURE_2D);\n            this.canvas = null;\n        }\n\n        if (this.texture) {\n            gl.activeTexture(gl.TEXTURE0 + drawMetadata.freeTexUnit);\n            gl.bindTexture(gl.TEXTURE_2D, this.texture);\n            gl.uniform1i(this._getBinding(program)._texLoc, drawMetadata.freeTexUnit);\n            drawMetadata.freeTexUnit++;\n        }\n    }\n}\n\nfunction _getCanvasFromImage (img) {\n    const CANVAS_SIZE = 256;\n    const canvas = document.createElement('canvas');\n    canvas.width = CANVAS_SIZE;\n    canvas.height = CANVAS_SIZE;\n\n    const ctx = canvas.getContext('2d');\n\n    const max = Math.max(img.width, img.height);\n    const width = img.width / max * CANVAS_SIZE;\n    const height = img.height / max * CANVAS_SIZE;\n\n    ctx.drawImage(img, 1 + (CANVAS_SIZE - width) / 2, 1 + (CANVAS_SIZE - height) / 2, width - 2, height - 2);\n\n    return canvas;\n}\n","import Base from './base';\nimport { checkArray, checkLooseType } from './utils';\n\n/**\n * ImageList. Load an array of images and use them as a symbols.\n *\n * Note: images RGB color will be overridden if the viz `color` property is set.\n *\n * @param {Image[]} imageList - Array of images\n *\n * @example <caption>Match different images to the different categories generated by buckets.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   symbol: s.ramp(s.buckets(s.prop('pop_max'), [10]), s.imageList([s.image('./marker.svg'), s.image('./marker2.svg')]))\n * });\n *\n * @example <caption>Match different images to the different categories generated by buckets. (String)</caption>\n * const viz = new carto.Viz(`\n *    symbol: ramp(buckets($pop_max, [10]), imageList([image('./marker.svg'), image('./marker2.svg')]))\n * `);\n *\n * @memberof carto.expressions\n * @name imageList\n * @function\n * @api\n*/\n\nexport default class ImageList extends Base {\n    constructor (imageList) {\n        checkArray('imageList', 'imageList', 0, imageList);\n        imageList.forEach((image, i) => checkLooseType('imageList', `imageList[${i}]`, 0, 'image', image));\n\n        const children = {};\n\n        imageList.forEach((image, i) => {\n            children[`image${i}`] = image;\n        });\n        super(children);\n        this.numImages = imageList.length;\n        this.type = 'image';\n    }\n\n    _applyToShaderSource () {\n        return {\n            preface: this._prefaceCode(`\n                uniform sampler2D atlas${this._uid};\n\n                vec4 atlas${this._uid}Fn(vec2 imageUV, float cat) {\n                    return texture2D(atlas${this._uid}, imageUV/16. + vec2(mod(cat, 16.), floor(cat/16.))/16. ).rgba;\n                }\n            `),\n            inline: `atlas${this._uid}Fn`\n        };\n    }\n\n    _postShaderCompile (program, gl) {\n        this._getBinding(program).texLoc = gl.getUniformLocation(program, `atlas${this._uid}`);\n    }\n\n    _preDraw (program, drawMetadata, gl) {\n        this.init = true;\n        for (let i = 0; i < this.numImages; i++) {\n            const image = this[`image${i}`];\n            this.init = this.init && image.canvas;\n        }\n\n        if (this.init && !this.texture) {\n            const textureAtlasSize = 4096;\n            const imageSize = 256;\n\n            gl.activeTexture(gl.TEXTURE0 + drawMetadata.freeTexUnit);\n            this.texture = gl.createTexture();\n            gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n            gl.bindTexture(gl.TEXTURE_2D, this.texture);\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, textureAtlasSize, textureAtlasSize, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n            let offsetX = 0;\n            let offsetY = 0;\n            for (let i = 0; i < this.numImages; i++) {\n                const image = this[`image${i}`];\n                // get image, push image to texture atlas\n                gl.texSubImage2D(gl.TEXTURE_2D, 0, offsetX, offsetY, gl.RGBA, gl.UNSIGNED_BYTE, image.canvas);\n                offsetX += imageSize;\n\n                if (offsetX + imageSize > textureAtlasSize) {\n                    offsetX = 0;\n                    offsetY += imageSize;\n                }\n\n                image.canvas = null;\n            }\n\n            gl.generateMipmap(gl.TEXTURE_2D);\n        }\n\n        if (this.texture) {\n            gl.activeTexture(gl.TEXTURE0 + drawMetadata.freeTexUnit);\n            gl.bindTexture(gl.TEXTURE_2D, this.texture);\n            gl.uniform1i(this._getBinding(program).texLoc, drawMetadata.freeTexUnit);\n            drawMetadata.freeTexUnit++;\n        }\n    }\n}\n","import Image from './Image';\n\nexport default class SVG extends Image {\n    constructor (svg) {\n        super(`data:image/svg+xml,${encodeURIComponent(svg)}`);\n    }\n}\n","import BaseExpression from '../../base';\nimport PropertyExpression from '../../basic/property';\nimport { checkType, checkInstance } from '../../utils';\nimport * as schema from '../../../../schema';\n\nexport default class ClusterAggregation extends BaseExpression {\n    constructor ({ property, expressionName, aggName, aggType }) {\n        checkInstance(expressionName, 'property', 0, PropertyExpression, property);\n        super({ property });\n        this._aggName = aggName;\n        this._expressionName = expressionName;\n        this.type = aggType;\n    }\n\n    get name () {\n        return this.property.name;\n    }\n\n    get aggName () {\n        return this._aggName;\n    }\n\n    get numCategories () {\n        return this.property.numCategories;\n    }\n\n    eval (feature) {\n        return feature[schema.column.aggColumn(this.property.name, this._aggName)];\n    }\n\n    _bindMetadata (metadata) {\n        super._bindMetadata(metadata);\n        checkType(this._expressionName, 'property', 0, this.type, this.property);\n    }\n\n    _resolveAliases () {}\n\n    _applyToShaderSource (getGLSLforProperty) {\n        return {\n            preface: '',\n            inline: `${getGLSLforProperty(schema.column.aggColumn(this.property.name, this._aggName))}`\n        };\n    }\n\n    _postShaderCompile () {}\n\n    _getMinimumNeededSchema () {\n        return {\n            columns: [\n                schema.column.aggColumn(this.property.name, this._aggName)\n            ]\n        };\n    }\n}\n","import ClusterAggregation from './ClusterAggregation';\n/**\n * Aggregate using the average. This operation disables the access to the property\n * except within other cluster aggregate functions.\n *\n * Note: `clusterAvg` can only be created by {@link carto.expressions.prop|carto.expressions.prop}, not other expressions.\n *\n * @param {Number} property - Column of the table to be aggregated\n * @return {Number} Aggregated column\n *\n * @example <caption>Use cluster average of the population as width.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.clusterAvg(s.prop('population'))\n * });\n *\n * @example <caption>Use cluster average of the population as width. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: clusterAvg($population)\n * `);\n *\n * @memberof carto.expressions\n * @name clusterAvg\n * @function\n * @api\n */\nexport default class ClusterAvg extends ClusterAggregation {\n    constructor (property) {\n        super({ property, expressionName: 'clusterAvg', aggName: 'avg', aggType: 'number' });\n    }\n}\n","import ClusterAggregation from './ClusterAggregation';\n\n/**\n * Aggregate using the maximum. This operation disables the access to the property\n * except within other cluster aggregate functions.\n *\n * Note: `clusterMax` can only be created by {@link carto.expressions.prop|carto.expressions.prop}, not other expressions.\n *\n * @param {Number} property - Column of the table to be aggregated\n * @return {Number} Aggregated column\n *\n * @example <caption>Use cluster maximum of the population as width.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.clusterMax(s.prop('population'))\n * });\n *\n * @example <caption>Use cluster maximum of the population as width. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: clusterMax($population)\n * `);\n *\n * @memberof carto.expressions\n * @name clusterMax\n * @function\n * @api\n */\nexport default class ClusterMax extends ClusterAggregation {\n    constructor (property) {\n        super({ property, expressionName: 'clusterMax', aggName: 'max', aggType: 'number' });\n    }\n}\n","import ClusterAggregation from './ClusterAggregation';\n\n/**\n * Aggregate using the minimum. This operation disables the access to the property\n * except within other cluster aggregate functions.\n *\n * Note: `clusterMin` can only be created by {@link carto.expressions.prop|carto.expressions.prop}, not other expressions.\n *\n * @param {Number} property - Column of the table to be aggregated\n * @return {Number} Aggregated column\n *\n * @example <caption>Use cluster minimum of the population as width.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.clusterMin(s.prop('population'))\n * });\n *\n * @example <caption>Use cluster minimum of the population as width. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: clusterMin($population)\n * `);\n *\n * @memberof carto.expressions\n * @name clusterMin\n * @function\n * @api\n */\nexport default class ClusterMin extends ClusterAggregation {\n    constructor (property) {\n        super({ property, expressionName: 'clusterMin', aggName: 'min', aggType: 'number' });\n    }\n}\n","import ClusterAggregation from './ClusterAggregation';\n/**\n * Aggregate using the mode. This operation disables the access to the property\n * except within other cluster aggregate functions.\n *\n * Note: `clusterMode` can only be created by {@link carto.expressions.prop|carto.expressions.prop}, not other expressions.\n *\n * @param {Category} property - Column of the table to be aggregated\n * @return {Category} Aggregated column\n *\n * @example <caption>Use cluster mode of the population in a color ramp.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   color: s.ramp(s.clusterMode(s.prop('category')), s.palettes.PRISM)\n * });\n *\n * @example <caption>Use cluster mode of the population in a color ramp. (String)</caption>\n * const viz = new carto.Viz(`\n *   color: ramp(clusterMode($category), PRISM)\n * `);\n *\n * @memberof carto.expressions\n * @name clusterMode\n * @function\n * @api\n */\nexport default class ClusterMode extends ClusterAggregation {\n    constructor (property) {\n        super({ property, expressionName: 'clusterMode', aggName: 'mode', aggType: 'category' });\n    }\n}\n","import ClusterAggregation from './ClusterAggregation';\n\n/**\n * Aggregate using the sum. This operation disables the access to the property\n * except within other cluster aggregate functions.\n *\n * Note: `clusterSum` can only be created by {@link carto.expressions.prop|carto.expressions.prop}, not other expressions.\n *\n * @param {Number} property - Column of the table to be aggregated\n * @return {Number} Aggregated column\n *\n * @example <caption>Use cluster sum of the population as width.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.clusterSum(s.prop('population'))\n * });\n *\n * @example <caption>Use cluster sum of the population as width. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: clusterSum($population)\n * `);\n *\n * @memberof carto.expressions\n * @name clusterSum\n * @function\n * @api\n */\nexport default class ClusterSum extends ClusterAggregation {\n    constructor (property) {\n        super({ property, expressionName: 'clusterSum', aggName: 'sum', aggType: 'number' });\n    }\n}\n","import BaseExpression from '../../base';\nimport * as schema from '../../../../schema';\nimport { number } from '../../../expressions';\nimport { implicitCast } from '../../utils';\n\nexport default class GlobalAggregation extends BaseExpression {\n    /**\n     * @param {*} property\n     * @param {*} name\n     */\n    constructor ({ property, name, type }) {\n        super({ _value: number(0) });\n        this.property = implicitCast(property);\n        this._name = name;\n        this.type = type;\n        super.inlineMaker = inline => inline._value;\n    }\n\n    isFeatureDependent () {\n        return false;\n    }\n\n    get value () {\n        return this._value.expr;\n    }\n\n    eval () {\n        return this._value.expr;\n    }\n\n    _bindMetadata (metadata) {\n        super._bindMetadata(metadata);\n        this.property._bindMetadata(metadata);\n        // TODO improve type check\n        if (metadata.properties[this.property.name][this._name] === undefined) {\n            throw new Error(`Metadata ${this._name} for property ${this.property.name} is not defined`);\n        }\n        this._value.expr = metadata.properties[this.property.name][this._name];\n    }\n\n    _getMinimumNeededSchema () {\n        return this.property._getMinimumNeededSchema();\n    }\n\n    _getColumnName () {\n        if (this.property.aggName) {\n            return schema.column.aggColumn(this.property.name, this.property.aggName);\n        }\n        return this.property.name;\n    }\n}\n","import GlobalAggregation from './GlobalAggregation';\n\n/**\n * Return the average of the feature property for the entire source data.\n *\n * Note: `globalAvg` can only be created by {@link carto.expressions.prop|carto.expressions.prop}, not other expressions.\n *\n * @param {Number} property - property expression of number type\n * @return {Number} Result of the aggregation\n *\n * @example <caption>Assign the global average of the `amount` property to a variable.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   variables: {\n *      g_avg: s.globalAvg(s.prop('amount'))\n *   }\n * });\n *\n * @example <caption>Assign the global average of the `amount` property to a variable. (String)</caption>\n * const viz = new carto.Viz(`\n *   \\@g_avg: globalAvg($amount)\n * `);\n *\n * @memberof carto.expressions\n * @name globalAvg\n * @function\n * @api\n */\nexport default class GlobalAvg extends GlobalAggregation {\n    constructor (property) {\n        super({ property, name: 'avg', type: 'number' });\n    }\n}\n","import GlobalAggregation from './GlobalAggregation';\n\n/**\n * Return the feature count for the entire source data.\n *\n * Note: `globalCount` can only be created by {@link carto.expressions.prop|carto.expressions.prop}, not other expressions.\n *\n * @param {Number} property - property expression\n * @return {Number} Result of the aggregation\n *\n * @example <caption>Assign the global count of the `amount` property to a variable.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   variables: {\n *      g_count: s.globalCount(s.prop('amount'))\n *   }\n * });\n *\n * @example <caption>Assign the global count of the `amount` property to a variable. (String)</caption>\n * const viz = new carto.Viz(`\n *   \\@g_count: globalCount($amount)\n * `);\n *\n * @memberof carto.expressions\n * @name globalCount\n * @function\n * @api\n */\nexport default class GlobalCount extends GlobalAggregation {\n    constructor (property) {\n        super({ property, name: 'count', type: 'number' });\n    }\n}\n","import GlobalAggregation from './GlobalAggregation';\n\n/**\n * Return the maximum of the feature property for the entire source data.\n *\n * Note: `globalMax` can only be created by {@link carto.expressions.prop|carto.expressions.prop}, not other expressions.\n *\n * @param {Number|Date} property - property expression of date or number type\n * @return {Number|Date} Result of the aggregation\n *\n * @example <caption>Assign the global maximum of the `amount` property to a variable.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   variables: {\n *      g_max: s.globalMax(s.prop('amount'))\n *   }\n * });\n *\n * @example <caption>Assign the global maximum of the `amount` property to a variable. (String)</caption>\n * const viz = new carto.Viz(`\n *   \\@g_max: globalMax($amount)\n * `);\n *\n * @memberof carto.expressions\n * @name globalMax\n * @function\n * @api\n */\nexport default class GlobalMax extends GlobalAggregation {\n    constructor (property) {\n        super({ property, name: 'max', type: 'number' });\n    }\n}\n","import GlobalAggregation from './GlobalAggregation';\n/**\n * Return the minimum of the feature property for the entire source data.\n *\n * Note: `globalMin` can only be created by {@link carto.expressions.prop|carto.expressions.prop}, not other expressions.\n *\n * @param {Number|Date} property - property expression of date or number type\n * @return {Number|Date} Result of the aggregation\n *\n * @example <caption>Assign the global minimum of the `amount` property to a variable.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   variables: {\n *      g_min: s.globalMin(s.prop('amount'))\n *   }\n * });\n *\n * @example <caption>Assign the global minimum of the `amount` property to a variable. (String)</caption>\n * const viz = new carto.Viz(`\n *   \\@g_min: globalMin($amount)\n * `);\n *\n * @memberof carto.expressions\n * @name globalMin\n * @function\n * @api\n */\nexport default class GlobalMin extends GlobalAggregation {\n    constructor (property) {\n        super({ property, name: 'min', type: 'number' });\n    }\n}\n","import BaseExpression from '../../base';\nimport * as schema from '../../../../schema';\nimport { number } from '../../../expressions';\n\nexport default class GlobalPercentile extends BaseExpression {\n    constructor (property, percentile) {\n        if (!Number.isFinite(percentile)) {\n            throw new Error('Percentile must be a fixed literal number');\n        }\n        super({ _value: number(0) });\n        // TODO improve type check\n        this.property = property;\n        this.percentile = percentile;\n    }\n\n    isFeatureDependent () {\n        return false;\n    }\n\n    get value () {\n        return this._value.expr;\n    }\n\n    _bindMetadata (metadata) {\n        super._bindMetadata(metadata);\n        this.property._bindMetadata(metadata);\n        this.type = 'number';\n        super.inlineMaker = inline => inline._value;\n        const copy = metadata.sample.map(s => s[this.property.name]);\n        copy.sort((x, y) => x - y);\n        const p = this.percentile / 100;\n        this._value.expr = copy[Math.floor(p * copy.length)];\n    }\n\n    _getMinimumNeededSchema () {\n        return this.property._getMinimumNeededSchema();\n    }\n\n    _getColumnName () {\n        if (this.property.aggName) {\n            // Property has aggregation\n            return schema.column.aggColumn(this.property.name, this.property.aggName);\n        }\n        return this.property.name;\n    }\n}\n","import GlobalAggregation from './GlobalAggregation';\n\n/**\n * Return the sum of the feature property for the entire source data.\n *\n * Note: `globalSum` can only be created by {@link carto.expressions.prop|carto.expressions.prop}, not other expressions.\n *\n * @param {Number} property - property expression of number type\n * @return {Number} Result of the aggregation\n *\n * @example <caption>Assign the global sum of the `amount` property to a variable.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   variables: {\n *      g_sum: s.globalSum(s.prop('amount'))\n *   }\n * });\n *\n * @example <caption>Assign the global sum of the `amount` property to a variable. (String)</caption>\n * const viz = new carto.Viz(`\n *   \\@g_sum: globalSum($amount)\n * `);\n *\n * @memberof carto.expressions\n * @name globalSum\n * @function\n * @api\n */\nexport default class GlobalSum extends GlobalAggregation {\n    constructor (property) {\n        super({ property, name: 'sum' });\n    }\n}\n","import BaseExpression from '../../base';\nimport { implicitCast } from '../../utils';\nimport { number } from '../../../expressions';\n\nexport default class ViewportAggregation extends BaseExpression {\n    /**\n     * @param {*} property\n     */\n    constructor ({ property }) {\n        super({ property: implicitCast(property), _impostor: number(0) });\n        this._isViewport = true;\n        this.type = 'number';\n        this.inlineMaker = inline => inline._impostor;\n    }\n\n    isFeatureDependent () {\n        return false;\n    }\n\n    _bindMetadata (metadata) {\n        // TODO improve type check\n        super._bindMetadata(metadata);\n    }\n\n    _getMinimumNeededSchema () {\n        return this.property._getMinimumNeededSchema();\n    }\n\n    _preDraw (...args) {\n        this._impostor.expr = this.eval();\n        super._preDraw(...args);\n    }\n}\n","import ViewportAggregation from './ViewportAggregation';\n\n/**\n * Return the average value of an expression for the features showed in the viewport (features outside the viewport and features that don't pass the filter will be excluded).\n *\n * @param {Number} input - numeric expression\n * @return {Number} Result of the aggregation\n *\n * @example <caption>Assign the average of the `amount` property in the viewport to a variable.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   variables: {\n *      v_avg: s.viewportAvg(s.prop('amount'))\n *   }\n * });\n *\n * @example <caption>Assign the average of the `amount` property in the viewport to a variable. (String)</caption>\n * const viz = new carto.Viz(`\n *   \\@v_avg: viewportAvg($amount)\n * `);\n *\n * @memberof carto.expressions\n * @name viewportAvg\n * @function\n * @api\n */\nexport default class ViewportAvg extends ViewportAggregation {\n    constructor (property) {\n        super({ property });\n        this._sum = 0;\n        this._count = 0;\n    }\n\n    get value () {\n        return this._sum / this._count;\n    }\n\n    eval () {\n        return this.value;\n    }\n\n    accumViewportAgg (feature) {\n        const propertyValue = this.property.eval(feature);\n\n        if (!Number.isNaN(propertyValue)) {\n            this._count++;\n            this._sum += propertyValue;\n        }\n    }\n\n    _resetViewportAgg () {\n        this._sum = 0;\n        this._count = 0;\n    }\n}\n","import ViewportAggregation from './ViewportAggregation';\nimport { number } from '../../../expressions';\n\n/**\n * Return the feature count of the features showed in the viewport (features outside the viewport and features that don't pass the filter will be excluded).\n *\n * @param {Number} input - numeric expression\n * @return {Number} Result of the aggregation\n *\n * @example <caption>Assign the feature count in the viewport to a variable.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   variables: {\n *      v_count: s.viewportCount(s.prop('amount'))\n *   }\n * });\n *\n * @example <caption>Assign the feature count in the viewport to a variable. (String)</caption>\n * const viz = new carto.Viz(`\n *   \\@v_count: viewportCount($amount)\n * `);\n *\n * @memberof carto.expressions\n * @name viewportCount\n * @function\n * @api\n */\nexport default class ViewportCount extends ViewportAggregation {\n    constructor () {\n        super({ property: number(0) });\n        this._value = 0;\n    }\n\n    get value () {\n        return this._value;\n    }\n\n    eval () {\n        return this.value;\n    }\n\n    accumViewportAgg () {\n        this._value++;\n    }\n\n    _resetViewportAgg () {\n        this._value = 0;\n    }\n}\n","import BaseExpression from '../../base';\nimport { implicitCast } from '../../utils';\n\n/**\n * Generates an histogram.\n *\n * The histogram can be based on a categorical expression, in which case each category will correspond to a histogram bar.\n * The histogram can be based on a numeric expression, in which case the minimum and maximum will be computed automatically and bars will be generated\n * at regular intervals between the minimum and maximum. The number of bars in this case is controllable through the `size` parameter.\n *\n * Histograms are useful to get insights and create widgets outside the scope of CARTO VL, see the following example for more info.\n *\n * @param {Number} input - expression to base the histogram\n * @param {Number} weight - Weight each occurrence differently based on this weight, defaults to `1`, which will generate a simple, non-weighted count.\n * @param {Number} size - Optional (defaults to 1000). Number of bars to use if `x` is a numeric expression\n * @return {Histogram} Histogram\n *\n * @example <caption>Create and use an histogram. (String)</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz(`\n *          \\@categoryHistogram: viewportHistogram($type)\n *          \\@numericHistogram:  viewportHistogram($amount, 1, 3)\n * `);\n * ...\n * console.log(viz.variables.categoryHistogram.eval());\n * // [{x: 'typeA', y: 10}, {x: 'typeB', y: 20}]\n * // There are 10 features of type A and 20 of type B\n *\n * console.log(viz.variables.numericHistogram.eval());\n * // [{x: [0,10],  y: 20}, {x: [10,20],  y: 7}, {x: [20, 30], y: 3}]\n * // There are 20 features with an amount between 0 and 10, 7 features with an amount between 10 and 20, and 3 features with an amount between 20 and 30\n *\n * @memberof carto.expressions\n * @name ViewportHistogram\n * @function\n * @api\n */\nexport default class ViewportHistogram extends BaseExpression {\n    constructor (x, weight = 1, size = 1000) {\n        super({ x: implicitCast(x), weight: implicitCast(weight) });\n\n        this.type = 'histogram';\n        this._size = size;\n        this._isViewport = true;\n        this.inlineMaker = () => null;\n    }\n\n    accumViewportAgg (feature) {\n        const x = this.x.eval(feature);\n\n        if (x !== undefined) {\n            const weight = this.weight.eval(feature);\n            const count = this._histogram.get(x) || 0;\n            this._histogram.set(x, count + weight);\n        }\n    }\n\n    get value () {\n        if (this._cached === null) {\n            if (!this._histogram) {\n                return null;\n            }\n\n            this._cached = this.x.type === 'number'\n                ? _getNumericValue(this._histogram, this._size)\n                : _getCategoryValue(this._histogram);\n\n            return this._cached;\n        }\n\n        return this._cached;\n    }\n\n    eval () {\n        return this.value;\n    }\n\n    _bindMetadata (metadata) {\n        super._bindMetadata(metadata);\n        this._metadata = metadata;\n    }\n\n    _resetViewportAgg (metadata) {\n        metadata = metadata || [];\n        this._bindMetadata(metadata);\n        this._cached = null;\n        this._histogram = new Map();\n    }\n}\n\nfunction _getNumericValue (histogram, size) {\n    const array = [...histogram];\n    const arrayLength = array.length;\n    let min = Number.POSITIVE_INFINITY;\n    let max = Number.NEGATIVE_INFINITY;\n\n    for (let i = 0; i < arrayLength; i++) {\n        const x = array[i][0];\n        min = Math.min(min, x);\n        max = Math.max(max, x);\n    }\n\n    const hist = Array(size).fill(0);\n    const range = max - min;\n    const sizeMinusOne = size - 1;\n\n    for (let i = 0; i < arrayLength; i++) {\n        const x = array[i][0];\n        const y = array[i][1];\n        const index = Math.min(Math.floor(size * (x - min) / range), sizeMinusOne);\n        hist[index] += y;\n    }\n\n    return hist.map((count, index) => {\n        return {\n            x: [min + index / size * range, min + (index + 1) / size * range],\n            y: count\n        };\n    });\n}\n\nfunction _getCategoryValue (histogram) {\n    return [...histogram]\n        .map(([x, y]) => {\n            return { x, y };\n        })\n        .sort(_sortFirstNumerically);\n}\n\nfunction _sortFirstNumerically (a, b) {\n    if (b.y - a.y === 0) {\n        return a.x.localeCompare(b.x);\n    }\n\n    return b.y - a.y;\n}\n","import ViewportAggregation from './ViewportAggregation';\n\n/**\n * Return the maximum value of an expression for the features showed in the viewport (features outside the viewport and features that don't pass the filter will be excluded).\n *\n * @param {Number} input - numeric expression\n * @return {Number} Result of the aggregation\n *\n * @example <caption>Assign the maximum of the `amount` property in the viewport to a variable.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   variables: {\n *      v_max: s.viewportMax(s.prop('amount'))\n *   }\n * });\n *\n * @example <caption>Assign the maximum of the `amount` property in the viewport to a variable. (String)</caption>\n * const viz = new carto.Viz(`\n *   \\@v_max: viewportMax($amount)\n * `);\n *\n * @memberof carto.expressions\n * @name viewportMax\n * @function\n * @api\n */\nexport default class ViewportMax extends ViewportAggregation {\n    constructor (property) {\n        super({ property });\n        this._value = Number.NEGATIVE_INFINITY;\n    }\n\n    get value () {\n        return this._value;\n    }\n\n    eval () {\n        return this.value;\n    }\n\n    accumViewportAgg (feature) {\n        const propertyValue = this.property.eval(feature);\n\n        if (!Number.isNaN(propertyValue)) {\n            this._value = Math.max(this._value, propertyValue);\n        }\n    }\n\n    _resetViewportAgg () {\n        this._value = Number.NEGATIVE_INFINITY;\n    }\n}\n","import ViewportAggregation from './ViewportAggregation';\n\n/**\n * Return the minimum value of an expression for the features showed in the viewport (features outside the viewport and features that don't pass the filter will be excluded).\n *\n * @param {Number} input - numeric expression\n * @return {Number} Result of the aggregation\n *\n * @example <caption>Assign the minimum of the `amount` property in the viewport to a variable.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   variables: {\n *      v_min: s.viewportMin(s.prop('amount'))\n *   }\n * });\n *\n * @example <caption>Assign the minimum of the `amount` property in the viewport to a variable. (String)</caption>\n * const viz = new carto.Viz(`\n *   \\@v_min: viewportMin($amount)\n * `);\n *\n * @memberof carto.expressions\n * @name viewportMin\n * @function\n * @api\n */\nexport default class ViewportMin extends ViewportAggregation {\n    constructor (property) {\n        super({ property });\n        this._value = Number.POSITIVE_INFINITY;\n    }\n\n    get value () {\n        return this._value;\n    }\n\n    eval () {\n        return this.value;\n    }\n\n    accumViewportAgg (feature) {\n        const propertyValue = this.property.eval(feature);\n\n        if (!Number.isNaN(propertyValue)) {\n            this._value = Math.min(this._value, propertyValue);\n        }\n    }\n\n    _resetViewportAgg () {\n        this._value = Number.POSITIVE_INFINITY;\n    }\n}\n","import ViewportAggregation from './ViewportAggregation';\nimport { number } from '../../../expressions';\nimport { implicitCast, clamp } from '../../utils';\n\n/**\n * Return the Nth percentile of an expression for the features showed in the viewport (features outside the viewport and features that don't pass the filter will be excluded).\n *\n * @param {Number} input - Numeric expression\n * @param {Number} percentile - Numeric expression [0, 100]\n * @return {Number} Result of the aggregation\n *\n * @example <caption>Assign the percentile of the `amount` property in the viewport to a variable.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   variables: {\n *      v_percentile: s.viewportPercentile(s.prop('amount'), 90)\n *   }\n * });\n *\n * @example <caption>Assign the percentile of the `amount` property in the viewport to a variable. (String)</caption>\n * const viz = new carto.Viz(`\n *   \\@v_percentile: viewportPercentile($amount, 90)\n * `);\n *\n * @memberof carto.expressions\n * @name viewportPercentile\n * @function\n * @api\n */\nexport default class ViewportPercentile extends ViewportAggregation {\n    /**\n     * @param {*} property\n     * @param {*} percentile\n     */\n    constructor (property, percentile) {\n        super({ property, _impostor: number(0) });\n\n        this._isViewport = true;\n        this.percentile = implicitCast(percentile);\n        this.type = 'number';\n        super.inlineMaker = inline => inline.impostor;\n    }\n\n    get value () {\n        return this.eval();\n    }\n\n    eval (feature) {\n        if (this._value === null) {\n            const percentile = _getPercentile(this.percentile.eval(feature), this._array.length);\n            const index = clamp(percentile, 0, this._array.length - 1);\n\n            this._array.sort((a, b) => a - b);\n            this._value = this._array[index];\n        }\n\n        return this._value;\n    }\n\n    _getMinimumNeededSchema () {\n        return this.property._getMinimumNeededSchema();\n    }\n\n    _resetViewportAgg () {\n        this._value = null;\n        this._array = [];\n    }\n\n    accumViewportAgg (feature) {\n        const v = this.property.eval(feature);\n        this._array.push(v);\n    }\n\n    _preDraw (...args) {\n        this.impostor.expr = this.eval();\n        super._preDraw(...args);\n    }\n}\n\nfunction _getPercentile (value, length) {\n    return Math.floor(value / 100 * length);\n}\n","import ViewportAggregation from './ViewportAggregation';\n\n/**\n * Return the sum of an expression for the features showed in the viewport (features outside the viewport and features that don't pass the filter will be excluded).\n *\n * @param {Number} input - numeric expression\n * @return {Number} Result of the aggregation\n *\n * @example <caption>Assign the sum of the `amount` property in the viewport to a variable.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   variables: {\n *      v_sum: s.viewportSum(s.prop('amount'))\n *   }\n * });\n *\n * @example <caption>Assign the sum of the `amount` property in the viewport to a variable. (String)</caption>\n * const viz = new carto.Viz(`\n *   \\@v_sum: viewportSum($amount)\n * `);\n *\n * @memberof carto.expressions\n * @name viewportSum\n * @function\n * @api\n */\nexport default class ViewportSum extends ViewportAggregation {\n    constructor (property) {\n        super({ property });\n        this._value = 0;\n    }\n\n    get value () {\n        return this._value;\n    }\n\n    eval () {\n        return this.value;\n    }\n\n    accumViewportAgg (feature) {\n        const propertyValue = this.property.eval(feature);\n\n        if (!Number.isNaN(propertyValue)) {\n            this._value = this._value + propertyValue;\n        }\n    }\n\n    _resetViewportAgg () {\n        this._value = 0;\n    }\n}\n","import { implicitCast } from './utils';\nimport { blend, transition } from '../expressions';\nimport * as schema from '../../schema';\n\n/**\n * Abstract expression class\n *\n * All expressions listed in  {@link carto.expressions} inherit from this class so any of them\n * they can be used where an Expression is required as long as the types match.\n *\n * This means that you can't use a numeric expression where a color expression is expected.\n *\n * @memberof carto.expressions\n * @name Base\n * @hideconstructor\n * @abstract\n * @IGNOREapi\n */\nexport default class Base {\n    /**\n     * @hideconstructor\n     * @param {*} children\n     * @param {*} inlineMaker\n     * @param {*} preface\n     */\n    constructor (children) {\n        this.childrenNames = Object.keys(children);\n        Object.keys(children).map(name => {\n            this[name] = implicitCast(children[name]);\n        });\n        this._getChildren().map(child => {\n            child.parent = this;\n        });\n        this.preface = '';\n        this._shaderBindings = new Map();\n    }\n\n    loadImages () {\n        return Promise.all(this._getChildren().map(child => child.loadImages()));\n    }\n\n    _bindMetadata (metadata) {\n        this._getChildren().forEach(child => child._bindMetadata(metadata));\n    }\n\n    _setUID (idGenerator) {\n        this._uid = idGenerator.getID(this);\n        this._getChildren().map(child => child._setUID(idGenerator));\n    }\n\n    _dataReady () {\n        this._getChildren().map(child => child._dataReady());\n    }\n\n    isFeatureDependent () {\n        return this._getChildren().some(child => child.isFeatureDependent());\n    }\n\n    _prefaceCode (glslCode) {\n        return glslCode\n            ? `\\n${this._buildGLSLCode(glslCode)}\\n`\n            : '';\n    }\n\n    _buildGLSLCode (glslCode) {\n        return `\n            #ifndef DEF_${this._uid}\n            #define DEF_${this._uid}\n            ${glslCode}\n            #endif`;\n    }\n\n    _getDependencies () {\n        return this._getChildren().map(child => child._getDependencies()).reduce((x, y) => x.concat(y), []);\n    }\n\n    _resolveAliases (aliases) {\n        this._getChildren().map(child => child._resolveAliases(aliases));\n    }\n\n    _setGenericGLSL (inlineMaker, preface) {\n        this.inlineMaker = inlineMaker;\n        this.preface = (preface || '');\n    }\n\n    /**\n     * Generate GLSL code\n     * @param {*} getGLSLforProperty  fn to get property IDs and inform of used properties\n     */\n    _applyToShaderSource (getGLSLforProperty) {\n        const childSources = this.childrenNames.map(name => this[name]._applyToShaderSource(getGLSLforProperty));\n        let childInlines = {};\n        childSources.map((source, index) => {\n            childInlines[this.childrenNames[index]] = source.inline;\n        });\n        return {\n            preface: this._prefaceCode(childSources.map(s => s.preface).reduce((a, b) => a + b, '') + this.preface),\n            inline: this.inlineMaker(childInlines, getGLSLforProperty)\n        };\n    }\n\n    /**\n     * Inform about a successful shader compilation. One-time post-compilation WebGL calls should be done here.\n     * @param {*} program\n     */\n    _postShaderCompile (program, gl) {\n        this.childrenNames.forEach(name => this[name]._postShaderCompile(program, gl));\n    }\n\n    _getBinding (shader) {\n        if (!this._shaderBindings.has(shader)) {\n            this._shaderBindings.set(shader, {});\n        }\n        return this._shaderBindings.get(shader);\n    }\n\n    _resetViewportAgg (metadata) {\n        this._getChildren().forEach(child => child._resetViewportAgg(metadata));\n    }\n\n    accumViewportAgg (feature) {\n        this._getChildren().forEach(child => child.accumViewportAgg(feature));\n    }\n\n    /**\n     * Pre-rendering routine. Should establish the current timestamp in seconds since an arbitrary point in time as needed.\n     * @param {number} timestamp\n     */\n    _setTimestamp (timestamp) {\n        this.childrenNames.forEach(name => this[name]._setTimestamp(timestamp));\n    }\n\n    /**\n     * Pre-rendering routine. Should establish related WebGL state as needed.\n     * @param {*} l\n     */\n    _preDraw (...args) {\n        this.childrenNames.forEach(name => this[name]._preDraw(...args));\n    }\n\n    /**\n     * @jsapi\n     * @returns true if the evaluation of the function at styling time won't be the same every time.\n     */\n    isAnimated () {\n        return this._getChildren().some(child => child.isAnimated());\n    }\n\n    /**\n     * Replace child *toReplace* by *replacer*\n     * @param {*} toReplace\n     * @param {*} replacer\n     */\n    replaceChild (toReplace, replacer) {\n        const name = this.childrenNames.find(name => this[name] === toReplace);\n        this[name] = replacer;\n        replacer.parent = this;\n        replacer.notify = toReplace.notify;\n    }\n\n    notify () {\n        this.parent.notify();\n    }\n\n    /**\n     * Linear interpolation between this and finalValue with the specified duration\n     * @api\n     * @param {Expression} final\n     * @param {Expression} duration\n     * @param {Expression} blendFunc\n     * @memberof carto.expressions.Base\n     * @instance\n     * @name blendTo\n     */\n    blendTo (final, duration = 500) {\n        // TODO blendFunc = 'linear'\n        final = implicitCast(final);\n        const parent = this.parent;\n        const blender = blend(this, final, transition(duration));\n        parent.replaceChild(this, blender);\n        blender.notify();\n        return final;\n    }\n\n    _blendFrom (final, duration = 500, interpolator = null) {\n        if (this.default && final.default) {\n            return;\n        }\n        final = implicitCast(final);\n        const parent = this.parent;\n        const blender = blend(final, this, transition(duration), interpolator);\n        parent.replaceChild(this, blender);\n        blender.notify();\n    }\n\n    /**\n     * @returns a list with the expression children\n     */\n    _getChildren () {\n        return this.childrenNames.map(name => this[name]);\n    }\n\n    _getMinimumNeededSchema () {\n        // Depth First Search => reduce using union\n        return this._getChildren().map(child => child._getMinimumNeededSchema()).reduce(schema.union, schema.IDENTITY);\n    }\n    // eslint-disable-next-line no-unused-vars\n    eval (feature) {\n        throw new Error('Unimplemented');\n    }\n\n    isA (expressionClass) {\n        return this instanceof expressionClass;\n    }\n}\n","import BaseExpression from '../base';\nimport { checkExpression, implicitCast, getOrdinalFromIndex } from '../utils';\n\n/**\n * Wrapper around arrays. Explicit usage is unnecessary since CARTO VL will wrap implicitly all arrays using this function.\n *\n * @param {Number[]|Category[]|Color[]|Date[]} elements\n * @returns {Array}\n *\n * @memberof carto.expressions\n * @name array\n * @function\n * @api\n */\nexport default class BaseArray extends BaseExpression {\n    constructor (elems) {\n        elems = elems || [];\n        if (!Array.isArray(elems)) {\n            elems = [elems];\n        }\n        elems = elems.map(implicitCast);\n        if (!elems.length) {\n            throw new Error('array(): invalid parameters: must receive at least one argument');\n        }\n        let type = '';\n        for (let elem of elems) {\n            type = elem.type;\n            if (elem.type !== undefined) {\n                break;\n            }\n        }\n        if (['number', 'category', 'color', 'time', undefined].indexOf(type) === -1) {\n            throw new Error(`array(): invalid parameters type: ${type}`);\n        }\n        elems.map((item, index) => {\n            checkExpression('array', `item[${index}]`, index, item);\n            if (item.type !== type && item.type !== undefined) {\n                throw new Error(`array(): invalid ${getOrdinalFromIndex(index + 1)} parameter type, invalid argument type combination`);\n            }\n        });\n        super({});\n        this.type = type + '-array';\n        this.elems = elems;\n        try {\n            this.elems.map(c => c.value);\n        } catch (error) {\n            throw new Error('Arrays must be formed by constant expressions, they cannot depend on feature properties');\n        }\n    }\n    get value () {\n        return this.elems.map(c => c.value);\n    }\n    eval () {\n        return this.elems.map(c => c.eval());\n    }\n    _resolveAliases (aliases) {\n        this.elems.map(c => c._resolveAliases(aliases));\n    }\n\n    _bindMetadata (metadata) {\n        super._bindMetadata(metadata);\n\n        const type = this.elems[0].type;\n        if (['number', 'category', 'color', 'time'].indexOf(type) === -1) {\n            throw new Error(`array(): invalid parameters type: ${type}`);\n        }\n        this.elems.map((item, index) => {\n            checkExpression('array', `item[${index}]`, index, item);\n            if (item.type !== type) {\n                throw new Error(`array(): invalid ${getOrdinalFromIndex(index)} parameter, invalid argument type combination`);\n            }\n        });\n    }\n}\n","import BaseExpression from '../base';\nimport { checkString } from '../utils';\n\n/**\n * Wrapper around category names. Explicit usage is unnecessary since CARTO VL will wrap implicitly all strings using this function.\n *\n * @param {string} categoryName\n * @returns {Category} category expression with the name provided\n *\n * @memberof carto.expressions\n * @name category\n * @function\n * @IGNOREapi\n */\nexport default class BaseCategory extends BaseExpression {\n    constructor (categoryName) {\n        checkString('category', 'categoryName', 0, categoryName);\n        super({});\n        this.expr = categoryName;\n        this.type = 'category';\n    }\n\n    get value () {\n        // Return the plain string\n        return this.expr;\n    }\n\n    eval () {\n        return this.expr;\n    }\n\n    isAnimated () {\n        return false;\n    }\n\n    _bindMetadata (metadata) {\n        this._metadata = metadata;\n    }\n\n    _applyToShaderSource () {\n        return {\n            preface: this._prefaceCode(`uniform float cat${this._uid};\\n`),\n            inline: `cat${this._uid}`\n        };\n    }\n\n    _postShaderCompile (program, gl) {\n        this._getBinding(program).uniformLocation = gl.getUniformLocation(program, `cat${this._uid}`);\n    }\n\n    _preDraw (program, drawMetadata, gl) {\n        const id = this._metadata.categoryToID.get(this.expr);\n        gl.uniform1f(this._getBinding(program).uniformLocation, id);\n    }\n}\n","import BaseExpression from '../base';\nimport { checkNumber } from '../utils';\n\n/**\n * Wraps a constant number. Implies a GPU optimization vs {@link carto.expressions.number|number expression}.\n *\n * @param {number} x - A number to be warped in a constant numeric expression\n * @return {Number} Numeric expression\n *\n * @example <caption>Creating a constant number expression.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.constant(15)\n * });\n *\n * @example <caption>Creating a constant number expression. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: constant(15)\n * `);\n *\n * @memberof carto.expressions\n * @name constant\n * @function\n * @api\n */\nexport default class Constant extends BaseExpression {\n    constructor (x) {\n        checkNumber('constant', 'x', 0, x);\n        super({});\n        this.expr = x;\n        this.type = 'number';\n        this.inlineMaker = () => `(${x.toFixed(20)})`;\n    }\n    get value () {\n        return this.eval();\n    }\n    eval () {\n        return this.expr;\n    }\n}\n","import BaseExpression from '../base';\nimport { checkNumber } from '../utils';\n\n/**\n * Wraps a number. Explicit usage is unnecessary since CARTO VL will wrap implicitly all numbers using this function.\n *\n * @param {number} x - A number to be warped in a numeric expression\n * @return {Number} Numeric expression\n *\n * @example <caption>Creating a number expression.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.number(15)  // Equivalent to `width: 15`\n * });\n *\n * @example <caption>Creating a number expression. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: 15  // Equivalent to number(15)\n * `);\n *\n * @memberof carto.expressions\n * @name number\n * @function\n * @IGNOREapi\n */\nexport default class BaseNumber extends BaseExpression {\n    constructor (x) {\n        checkNumber('number', 'x', 0, x);\n        super({});\n        this.expr = x;\n        this.type = 'number';\n    }\n    get value () {\n        return this.eval();\n    }\n    eval () {\n        return this.expr;\n    }\n    isAnimated () {\n        return false;\n    }\n    _applyToShaderSource () {\n        return {\n            preface: this._prefaceCode(`uniform float number${this._uid};`),\n            inline: `number${this._uid}`\n        };\n    }\n    _postShaderCompile (program, gl) {\n        this._getBinding(program).uniformLocation = gl.getUniformLocation(program, `number${this._uid}`);\n    }\n    _preDraw (program, drawMetadata, gl) {\n        gl.uniform1f(this._getBinding(program).uniformLocation, this.expr);\n    }\n}\n","import BaseExpression from '../base';\nimport { checkString } from '../utils';\n\n/**\n * Evaluates the value of a column for every row in the dataset.\n *\n * For example think about a dataset containing 3 cities: Barcelona, Paris and London.\n * The `prop('name')` will return the name of the current city for every point in the dataset.\n *\n * @param {string} name - The property in the dataset that is going to be evaluated\n * @return {Number|Category|Date}\n *\n * @example <caption>Display only cities with name different from \"London\".</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *  filter: s.neq(s.prop('name'), 'london')\n * });\n *\n * @example <caption>Display only cities with name different from \"London\". (String)</caption>\n * const viz = new carto.Viz(`\n *   filter: neq(prop('name'), 'london')\n * `);\n *\n * const viz = new carto.Viz(`\n *   filter: $name !== 'london'\n * `);\n *\n * @memberof carto.expressions\n * @name prop\n * @function\n * @api\n */\nexport default class Property extends BaseExpression {\n    constructor (name) {\n        checkString('property', 'name', 0, name);\n        if (name === '') {\n            throw new Error('property(): invalid parameter, zero-length string');\n        }\n        super({});\n        this.name = name;\n        super._setGenericGLSL((childInlines, getGLSLforProperty) => getGLSLforProperty(this.name));\n    }\n\n    isFeatureDependent () {\n        return true;\n    }\n\n    get value () {\n        return this.eval();\n    }\n\n    eval (feature) {\n        if (!feature) {\n            throw new Error('A property needs to be evaluated in a feature');\n        }\n        return feature[this.name];\n    }\n\n    _bindMetadata (meta) {\n        const metaColumn = meta.properties[this.name];\n        if (!metaColumn) {\n            throw new Error(`Property '${this.name}' does not exist`);\n        }\n        this.type = metaColumn.type;\n\n        if (this.type === 'category') {\n            this.numCategories = metaColumn.categories.length;\n        }\n    }\n\n    _applyToShaderSource (getGLSLforProperty) {\n        return {\n            preface: '',\n            inline: getGLSLforProperty(this.name)\n        };\n    }\n\n    _getMinimumNeededSchema () {\n        return {\n            columns: [\n                this.name\n            ]\n        };\n    }\n}\n","import BaseExpression from '../base';\nimport { checkString } from '../utils';\n\n/**\n * Alias to a named variable defined in the Viz.\n *\n * @param {string} name - The variable name that is going to be evaluated\n * @return {Number|Category|Color|Date}\n *\n * @example <caption></caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   variables: {\n *     sum_price: s.clusterSum(s.prop('price'))\n *   }\n *  filter: s.neq(s.var('sum_price'), 'london'),\n * });\n *\n * @example <caption>(String)</caption>\n * const viz = new carto.Viz(`\n *   @sum_price: clusterSum($price)\n *   filter: @sum_price !== 'london'\n * `);\n *\n * @memberof carto.expressions\n * @name var\n * @function\n * @api\n */\nexport class Variable extends BaseExpression {\n    constructor () {\n        super({});\n    }\n}\nfunction isFunction (functionToCheck) {\n    return functionToCheck && {}.toString.call(functionToCheck) === '[object Function]';\n}\nexport default function variable (name) {\n    checkString('variable', 'name', 0, name);\n    if (name === '') {\n        throw new Error('variable(): invalid parameter, zero-length string');\n    }\n    let alias;\n    const resolve = aliases => {\n        if (aliases[name]) {\n            alias = aliases[name];\n        } else {\n            throw new Error(`variable() name '${name}' doesn't exist`);\n        }\n    };\n    const _getDependencies = () => {\n        return [alias];\n    };\n    let aliaser = {\n        set: (obj, prop, value) => {\n            if (prop === 'parent') {\n                obj[prop] = value;\n            } else if (prop === 'notify') {\n                obj[prop] = value;\n            } else if (alias && alias[prop]) {\n                alias[prop] = value;\n            } else {\n                return false;\n            }\n            // Indicate success\n            return true;\n        },\n        get: (obj, prop) => {\n            if (prop === 'parent') {\n                return obj[prop];\n            } else if (prop === '_resolveAliases') {\n                return resolve;\n            } else if (prop === '_getDependencies') {\n                return _getDependencies;\n            } else if (prop === 'notify') {\n                return obj[prop];\n            } else if (prop === 'blendTo') {\n                return obj[prop];\n            }\n            if (alias && alias[prop]) {\n                if (isFunction(alias[prop])) {\n                    return alias[prop].bind(alias);\n                }\n                return alias[prop];\n            }\n            return obj[prop];\n        }\n    };\n    const proxy = new Proxy(new Variable(), aliaser);\n    return proxy;\n}\n","import { implicitCast, checkType, checkLooseType, checkExpression } from './utils';\nimport BaseExpression from './base';\n\n/**\n * Check if a categorical value belongs to a list of categories.\n *\n * @param {Category} value - Categorical expression to be tested against the whitelist\n * @param {Category[]} list - Multiple expression parameters that will form the whitelist\n * @return {Number} Numeric expression with the result of the check\n *\n * @example <caption>Display only cities where $type is 'metropolis' or 'capital'.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   filter: s.in(s.prop('type'), ['metropolis', 'capital'])\n * });\n *\n * @example <caption>Display only cities where $type is 'metropolis' or 'capital'. (String)</caption>\n * const viz = new carto.Viz(`\n *   filter: in($type, ['metropolis', 'capital'])\n * `);\n *\n * @memberof carto.expressions\n * @name in\n * @function\n * @api\n */\nexport const In = generateBelongsExpression('in', IN_INLINE_MAKER, (value, list) => list.some(item => item === value) ? 1 : 0);\n\nfunction IN_INLINE_MAKER (list) {\n    if (list.length === 0) {\n        return () => '0.';\n    }\n    return inline => `(${list.map((cat, index) => `(${inline.value} == ${inline[`arg${index}`]})`).join(' || ')})? 1.: 0.`;\n}\n\n/**\n * Check if value does not belong to the list of elements.\n *\n * @param {Category} value - Categorical expression to be tested against the blacklist\n * @param {Category[]} list - Multiple expression parameters that will form the blacklist\n * @return {Number} Numeric expression with the result of the check\n *\n * @example <caption>Display only cities where $type is not 'metropolis' or 'capital'.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   filter: s.nin(s.prop('type'), ['metropolis', 'capital'])\n * });\n *\n * @example <caption>Display only cities where $type is not 'metropolis' or 'capital'. (String)</caption>\n * const viz = new carto.Viz(`\n *   filter: nin($type, ['metropolis', 'capital'])\n * `);\n *\n * @memberof carto.expressions\n * @name nin\n * @function\n * @api\n */\nexport const Nin = generateBelongsExpression('nin', NIN_INLINE_MAKER, (value, list) => list.some(item => item === value) ? 0 : 1);\n\nfunction NIN_INLINE_MAKER (list) {\n    if (list.length === 0) {\n        return () => '1.';\n    }\n    return inline => `(${list.map((cat, index) => `(${inline.value} != ${inline[`arg${index}`]})`).join(' && ')})? 1.: 0.`;\n}\n\nfunction generateBelongsExpression (name, inlineMaker, jsEval) {\n    return class BelongExpression extends BaseExpression {\n        constructor (value, list) {\n            value = implicitCast(value);\n            list = implicitCast(list);\n\n            checkExpression(name, 'value', 0, value);\n            checkExpression(name, 'list', 1, list);\n\n            checkLooseType(name, 'value', 0, 'category', value);\n            checkLooseType(name, 'list', 1, 'category-array', list);\n\n            let children = { value };\n            list.elems.map((arg, index) => {\n                children[`arg${index}`] = arg;\n            });\n            super(children);\n            this.list = list;\n            this.inlineMaker = inlineMaker(this.list.elems);\n            this.type = 'number';\n        }\n        eval (feature) {\n            return jsEval(this.value.eval(feature), this.list.eval(feature));\n        }\n        _bindMetadata (meta) {\n            super._bindMetadata(meta);\n            checkType(name, 'value', 0, 'category', this.value);\n            checkType(name, 'list', 1, 'category-array', this.list);\n        }\n    };\n}\n","import BaseExpression from './base';\nimport { implicitCast, checkLooseType, checkType } from './utils';\n\n/**\n * Check if a given value is contained within an inclusive range (including the limits).\n *\n * This returns a numeric expression where 0 means `false` and 1 means `true`.\n *\n * @param {Number} value - Numeric expression that is going to be tested against the [lowerLimit, upperLimit] range\n * @param {Number} lowerLimit - Numeric expression with the lower limit of the range\n * @param {Number} upperLimit -  Numeric expression with the upper limit of the range\n * @return {Number} Numeric expression with the result of the check\n *\n * @example <caption>Display only cities where the population density is within the [50,100] range.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   filter: s.between(s.prop('dn'), 50, 100);\n * });\n *\n * @example <caption>Display only cities where the population density is within the [50,100] range. (String)</caption>\n * const viz = new carto.Viz(`\n *   filter: between($dn, 50, 100)\n * `);\n *\n * @memberof carto.expressions\n * @name between\n * @function\n * @api\n */\nexport default class Between extends BaseExpression {\n    constructor (value, lowerLimit, upperLimit) {\n        value = implicitCast(value);\n        lowerLimit = implicitCast(lowerLimit);\n        upperLimit = implicitCast(upperLimit);\n\n        checkLooseType('between', 'value', 0, 'number', value);\n        checkLooseType('between', 'lowerLimit', 1, 'number', lowerLimit);\n        checkLooseType('between', 'upperLimit', 2, 'number', upperLimit);\n\n        super({ value, lowerLimit, upperLimit });\n        this.type = 'number';\n        this.inlineMaker = inline => `((${inline.value} >= ${inline.lowerLimit} &&  ${inline.value} <= ${inline.upperLimit}) ? 1. : 0.)`;\n    }\n    eval (feature) {\n        const value = this.value.eval(feature);\n        const lower = this.lowerLimit.eval(feature);\n        const upper = this.upperLimit.eval(feature);\n        return (value >= lower && value <= upper) ? 1 : 0;\n    }\n    _bindMetadata (meta) {\n        super._bindMetadata(meta);\n\n        checkType('between', 'value', 0, 'number', this.value);\n        checkType('between', 'lowerLimit', 1, 'number', this.lowerLimit);\n        checkType('between', 'upperLimit', 2, 'number', this.upperLimit);\n    }\n}\n","import { number } from '../expressions';\nimport { implicitCast } from './utils';\nimport BaseExpression from './base';\n\n// Each binary expression can have a set of the following signatures (OR'ed flags)\nconst UNSUPPORTED_SIGNATURE = 0;\nconst NUMBERS_TO_NUMBER = 1;\nconst NUMBER_AND_COLOR_TO_COLOR = 2;\nconst COLORS_TO_COLOR = 4;\nconst CATEGORIES_TO_NUMBER = 8;\nconst IMAGES_TO_IMAGE = 16;\n\n/**\n * Multiply two numeric expressions.\n *\n * @param {Number|Color} x - First value to multiply\n * @param {Number|Color} y - Second value to multiply\n * @return {Number|Color} Result of the multiplication\n *\n * @example <caption>Number multiplication.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.mul(5, 5)  // 25\n * });\n *\n * @example <caption>Number multiplication. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: 5 * 5  // Equivalent to mul(5, 5)\n * `);\n *\n * @memberof carto.expressions\n * @name mul\n * @function\n * @api\n */\nexport const Mul = genBinaryOp('mul',\n    NUMBERS_TO_NUMBER | NUMBER_AND_COLOR_TO_COLOR | COLORS_TO_COLOR | IMAGES_TO_IMAGE,\n    (x, y) => x * y,\n    (x, y) => `(${x} * ${y})`\n);\n\n/**\n * Divide two numeric expressions.\n *\n * @param {Number|Color} numerator - Numerator of the division\n * @param {Number|Color} denominator - Denominator of the division\n * @return {Number|Color} Result of the division\n *\n * @example <caption>Number division.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.div(10, 2)  // 5\n * });\n *\n * @example <caption>Number division. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: 10 / 2  // Equivalent to div(10, 2)\n * `);\n *\n * @memberof carto.expressions\n * @name div\n * @function\n * @api\n */\nexport const Div = genBinaryOp('div',\n    NUMBERS_TO_NUMBER | NUMBER_AND_COLOR_TO_COLOR | COLORS_TO_COLOR | IMAGES_TO_IMAGE,\n    (x, y) => x / y,\n    (x, y) => `(${x} / ${y})`\n);\n\n/**\n * Add two numeric expressions.\n *\n * @param {Number|Color} x - First value to add\n * @param {Number|Color} y - Second value to add\n * @return {Number|Color} Result of the addition\n *\n * @example <caption>Number addition.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.add(10, 2)  // 12\n * });\n *\n * @example <caption>Number addition. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: 10 + 2  // Equivalent to add(10, 2)\n * `);\n *\n * @memberof carto.expressions\n * @name add\n * @function\n * @api\n */\nexport const Add = genBinaryOp('add',\n    NUMBERS_TO_NUMBER | COLORS_TO_COLOR | IMAGES_TO_IMAGE,\n    (x, y) => x + y,\n    (x, y) => `(${x} + ${y})`\n);\n\n/**\n * Substract two numeric expressions.\n *\n * @param {Number|Color} minuend - The minuend of the subtraction\n * @param {Number|Color} subtrahend - The subtrahend of the subtraction\n * @return {Number|Color} Result of the substraction\n *\n * @example <caption>Number subtraction.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.sub(10, 2)  // 8\n * });\n *\n * @example <caption>Number subtraction. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: 10 - 2  // Equivalent to sub(10, 2)\n * `);\n *\n * @memberof carto.expressions\n * @name sub\n * @function\n * @api\n */\nexport const Sub = genBinaryOp('sub',\n    NUMBERS_TO_NUMBER | COLORS_TO_COLOR | IMAGES_TO_IMAGE,\n    (x, y) => x - y,\n    (x, y) => `(${x} - ${y})`\n);\n\n/**\n * Modulus of two numeric expressions, mod returns a numeric expression with the value of x modulo y. This is computed as x - y * floor(x/y).\n *\n * @param {Number} x - First value of the modulus\n * @param {Number} y - Second value of the modulus\n * @return {Number} Result of the modulus\n *\n * @example <caption>Number modulus.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.mod(10, 6)  // 4\n * });\n *\n * @example <caption>Number modulus. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: 10 % 6  // Equivalent to mod(10, 6)\n * `);\n *\n * @memberof carto.expressions\n * @name mod\n * @function\n * @api\n */\nexport const Mod = genBinaryOp('mod',\n    NUMBERS_TO_NUMBER,\n    (x, y) => x % y,\n    (x, y) => `mod(${x}, ${y})`\n);\n\n/**\n * Compute the base to the exponent power, return a numeric expression with the value of the first parameter raised to the power of the second.\n * The result is undefined if x<0 or if x=0 and y0.\n *\n * @param {Number} base - Base of the power\n * @param {Number} exponent - Exponent of the power\n * @return {Number} Result of the power\n *\n * @example <caption>Number power.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.pow(2, 3)  // 8\n * });\n *\n * @example <caption>Number power. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: 2 ^ 3  // Equivalent to pow(2, 3)\n * `);\n *\n * @memberof carto.expressions\n * @name pow\n * @function\n * @api\n */\nexport const Pow = genBinaryOp('pow',\n    NUMBERS_TO_NUMBER,\n    (x, y) => Math.pow(x, y),\n    (x, y) => `pow(${x}, ${y})`\n);\n\n/**\n * Compare if x is greater than y.\n *\n * This returns a numeric expression where 0 means `false` and 1 means `true`.\n *\n * @param {Number} x - Firt value of the comparison\n * @param {Number} y - Firt value of the comparison\n * @return {Number} Result of the comparison: 0 or 1\n *\n * @example <caption>Compare two numbers to show only elements with price greater than 30.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   filter: s.gt(s.prop('price'), 30)\n * });\n *\n * @example <caption>Compare two numbers to show only elements with price greater than 30. (String)</caption>\n * const viz = new carto.Viz(`\n *   filter: $price > 30  // Equivalent to gt($price, 30)\n * `);\n *\n * @memberof carto.expressions\n * @name gt\n * @function\n * @api\n */\nexport const GreaterThan = genBinaryOp('greaterThan',\n    NUMBERS_TO_NUMBER,\n    (x, y) => x > y ? 1 : 0,\n    (x, y) => `(${x}>${y}? 1.:0.)`\n);\n\n/**\n * Compare if x is greater than or equal to y.\n *\n * This returns a numeric expression where 0 means `false` and 1 means `true`.\n *\n * @param {Number} x - Firt value of the comparison\n * @param {Number} y - Second value of the comparison\n * @return {Number} Result of the comparison: 0 or 1\n *\n * @example <caption>Compare two numbers to show only elements with price greater than or equal to 30.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   filter: s.gte(s.prop('price'), 30)\n * });\n *\n * @example <caption>Compare two numbers to show only elements with price greater than or equal to 30. (String)</caption>\n * const viz = new carto.Viz(`\n *   filter: $price >= 30  // Equivalent to gte($price, 30)\n * `);\n *\n * @memberof carto.expressions\n * @name gte\n * @function\n * @api\n */\nexport const GreaterThanOrEqualTo = genBinaryOp('greaterThanOrEqualTo',\n    NUMBERS_TO_NUMBER,\n    (x, y) => x >= y ? 1 : 0,\n    (x, y) => `(${x}>=${y}? 1.:0.)`\n);\n\n/**\n * Compare if x is lower than y.\n *\n * This returns a numeric expression where 0 means `false` and 1 means `true`.\n *\n * @param {Number} x - Firt value of the comparison\n * @param {Number} y - Second value of the comparison\n * @return {Number} Result of the comparison: 0 or 1\n *\n * @example <caption>Compare two numbers to show only elements with price less than 30.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   filter: s.lt(s.prop('price'), 30)\n * });\n *\n * @example <caption>Compare two numbers to show only elements with price less than 30. (String)</caption>\n * const viz = new carto.Viz(`\n *   filter: $price < 30  // Equivalent to lt($price, 30)\n * `);\n *\n * @memberof carto.expressions\n * @name lt\n * @function\n * @api\n */\nexport const LessThan = genBinaryOp('lessThan',\n    NUMBERS_TO_NUMBER,\n    (x, y) => x < y ? 1 : 0,\n    (x, y) => `(${x}<${y}? 1.:0.)`\n);\n\n/**\n * Compare if x is lower than or equal to y.\n *\n * This returns a numeric expression where 0 means `false` and 1 means `true`.\n *\n * @param {Number} x - Firt value of the comparison\n * @param {Number} y - Second value of the comparison\n * @return {Number} Result of the comparison: 0 or 1\n *\n * @example <caption>Compare two numbers to show only elements with price less than or equal to 30.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   filter: s.lte(s.prop('price'), 30)\n * });\n *\n * @example <caption>Compare two numbers to show only elements with price less than or equal to 30. (String)</caption>\n * const viz = new carto.Viz(`\n *   filter: $price <= 30  // Equivalent to lte($price, 30)\n * `);\n *\n * @memberof carto.expressions\n * @name lte\n * @function\n * @api\n */\nexport const LessThanOrEqualTo = genBinaryOp('lessThanOrEqualTo',\n    NUMBERS_TO_NUMBER,\n    (x, y) => x <= y ? 1 : 0,\n    (x, y) => `(${x}<=${y}? 1.:0.)`\n);\n\n/**\n * Compare if x is equal to a y.\n *\n * This returns a numeric expression where 0 means `false` and 1 means `true`.\n *\n * @param {Number|Category} x - Firt value of the comparison\n * @param {Number|Category} y - Second value of the comparison\n * @return {Number} Result of the comparison: 0 or 1\n *\n * @example <caption>Compare two numbers to show only elements with price equal to 30.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   filter: s.eq(s.prop('price'), 30)\n * });\n *\n * @example <caption>Compare two numbers to show only elements with price equal to 30. (String)</caption>\n * const viz = new carto.Viz(`\n *   filter: $price === 30  // Equivalent to eq($price, 30)\n * `);\n *\n * @memberof carto.expressions\n * @name eq\n * @function\n * @api\n */\nexport const Equals = genBinaryOp('equals',\n    NUMBERS_TO_NUMBER | CATEGORIES_TO_NUMBER,\n    (x, y) => x === y ? 1 : 0,\n    (x, y) => `(${x}==${y}? 1.:0.)`\n);\n\n/**\n * Compare if x is different than y.\n *\n * This returns a number expression where 0 means `false` and 1 means `true`.\n *\n * @param {Number|Category} x - Firt value of the comparison\n * @param {Number|Category} y - Second value of the comparison\n * @return {Number} Result of the comparison: 0 or 1\n *\n * @example <caption>Compare two numbers to show only elements with price not equal to 30.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   filter: s.neq(s.prop('price'), 30);\n * });\n *\n * @example <caption>Compare two numbers to show only elements with price not equal to 30. (String)</caption>\n * const viz = new carto.Viz(`\n *   filter: $price !== 30  // Equivalent to neq($price, 30)\n * `);\n *\n * @memberof carto.expressions\n * @name neq\n * @function\n * @api\n */\nexport const NotEquals = genBinaryOp('notEquals',\n    NUMBERS_TO_NUMBER | CATEGORIES_TO_NUMBER,\n    (x, y) => x !== y ? 1 : 0,\n    (x, y) => `(${x}!=${y}? 1.:0.)`\n);\n\n/**\n * Perform a binary OR between two numeric expressions.\n * If the numbers are different from 0 or 1 this performs a [fuzzy or operation](https://en.wikipedia.org/wiki/Fuzzy_logic#Fuzzification).\n * This fuzzy behavior will allow transitions to work in a continuos, non-discrete, fashion.\n *\n * This returns a number expression where 0 means `false` and 1 means `true`.\n *\n * @param {Number} x - First value of the expression\n * @param {Number} y - Second value of the expression\n * @return {Number} Result of the expression\n *\n * @example <caption>Show only elements with price < 30 OR price > 1000.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   filter: s.or(\n *     s.lt(s.prop('price'), 30),\n *     s.gt(s.prop('price'), 1000)\n *   )\n * });\n *\n * @example <caption>Show only elements with price < 30 OR price > 1000. (String)</caption>\n * const viz = new carto.Viz(`\n *   filter: $price < 30 or $price > 1000  // Equivalent to or(lt($price, 30), gt($price, 1000))\n * `);\n *\n * @memberof carto.expressions\n * @name or\n * @function\n * @api\n */\nexport const Or = genBinaryOp('or',\n    NUMBERS_TO_NUMBER,\n    (x, y) => Math.min(x + y, 1),\n    (x, y) => `min(${x} + ${y}, 1.)`\n);\n\n/**\n * Perform a binary AND between two numeric expressions.\n * If the numbers are different from 0 or 1 this performs a [fuzzy and operation](https://en.wikipedia.org/wiki/Fuzzy_logic#Fuzzification).\n * This fuzzy behavior will allow transitions to work in a continuos, non-discrete, fashion.\n *\n * This returns a number expression where 0 means `false` and 1 means `true`.\n *\n * @param {Number} x - First value of the expression\n * @param {Number} y - Second value of the expression\n * @return {Number} Result of the expression\n *\n * @example <caption>Show only elements with price < 30 AND category === 'fruit'.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   filter: s.and(\n *     s.lt(s.prop('price'), 30),\n *     s.eq(s.prop('category'), 'fruit')\n *   )\n * });\n *\n * @example <caption>Show only elements with price < 30 AND category === 'fruit'. (String)</caption>\n * const viz = new carto.Viz(`\n *   filter: $price < 30 and $category === 'fruit'  // Equivalent to and(lt($price, 30), eq($category, 'fruit'))\n * `);\n *\n * @memberof carto.expressions\n * @name and\n * @function\n * @api\n */\nexport const And = genBinaryOp('and',\n    NUMBERS_TO_NUMBER,\n    (x, y) => Math.min(x * y, 1),\n    (x, y) => `min(${x} * ${y}, 1.)`\n);\n\nfunction genBinaryOp (name, allowedSignature, jsFn, glsl) {\n    return class BinaryOperation extends BaseExpression {\n        constructor (a, b) {\n            if (Number.isFinite(a) && Number.isFinite(b)) {\n                return number(jsFn(a, b));\n            }\n            a = implicitCast(a);\n            b = implicitCast(b);\n\n            const signature = getSignatureLoose(a, b);\n            if (signature !== undefined) {\n                if (signature === UNSUPPORTED_SIGNATURE || !(signature & allowedSignature)) {\n                    throw new Error(`${name}(): invalid parameter types\\n'x' type was ${a.type}, 'y' type was ${b.type}`);\n                }\n            }\n\n            super({ a, b });\n            this.type = getReturnTypeFromSignature(signature);\n            this.inlineMaker = inline => glsl(inline.a, inline.b);\n        }\n        get value () {\n            return this.eval();\n        }\n        eval (feature) {\n            return jsFn(this.a.eval(feature), this.b.eval(feature));\n        }\n        _bindMetadata (meta) {\n            super._bindMetadata(meta);\n            const [a, b] = [this.a, this.b];\n\n            const signature = getSignature(a, b);\n            if (signature === UNSUPPORTED_SIGNATURE || !(signature & allowedSignature)) {\n                throw new Error(`${name}(): invalid parameter types\\n'x' type was ${a.type}, 'y' type was ${b.type}`);\n            }\n            this.type = getReturnTypeFromSignature(signature);\n        }\n    };\n}\n\nfunction getSignatureLoose (a, b) {\n    if (!a.type || !b.type) {\n        if (!a.type && !b.type) {\n            return undefined;\n        }\n        const knownType = a.type || b.type;\n        if (knownType === 'color') {\n            return NUMBER_AND_COLOR_TO_COLOR;\n        }\n    } else if (a.type === 'number' && b.type === 'number') {\n        return NUMBERS_TO_NUMBER;\n    } else if (a.type === 'number' && b.type === 'color') {\n        return NUMBER_AND_COLOR_TO_COLOR;\n    } else if (a.type === 'color' && b.type === 'number') {\n        return NUMBER_AND_COLOR_TO_COLOR;\n    } else if (a.type === 'color' && b.type === 'color') {\n        return COLORS_TO_COLOR;\n    } else if (a.type === 'category' && b.type === 'category') {\n        return CATEGORIES_TO_NUMBER;\n    } else if ((a.type === 'image' && b.type === 'color') ||\n        (a.type === 'image' && b.type === 'color') ||\n        (a.type === 'image' && b.type === 'image') ||\n        (a.type === 'color' && b.type === 'image')) {\n        return IMAGES_TO_IMAGE;\n    } else {\n        return UNSUPPORTED_SIGNATURE;\n    }\n}\n\nfunction getSignature (a, b) {\n    if (!a.type || !b.type) {\n        return undefined;\n    } else if (a.type === 'number' && b.type === 'number') {\n        return NUMBERS_TO_NUMBER;\n    } else if (a.type === 'number' && b.type === 'color') {\n        return NUMBER_AND_COLOR_TO_COLOR;\n    } else if (a.type === 'color' && b.type === 'number') {\n        return NUMBER_AND_COLOR_TO_COLOR;\n    } else if (a.type === 'color' && b.type === 'color') {\n        return COLORS_TO_COLOR;\n    } else if (a.type === 'category' && b.type === 'category') {\n        return CATEGORIES_TO_NUMBER;\n    } else if ((a.type === 'image' && b.type === 'color') ||\n        (a.type === 'image' && b.type === 'color') ||\n        (a.type === 'image' && b.type === 'image') ||\n        (a.type === 'color' && b.type === 'image')) {\n        return IMAGES_TO_IMAGE;\n    } else {\n        return UNSUPPORTED_SIGNATURE;\n    }\n}\n\nfunction getReturnTypeFromSignature (signature) {\n    switch (signature) {\n        case NUMBERS_TO_NUMBER:\n            return 'number';\n        case NUMBER_AND_COLOR_TO_COLOR:\n            return 'color';\n        case COLORS_TO_COLOR:\n            return 'color';\n        case CATEGORIES_TO_NUMBER:\n            return 'number';\n        case IMAGES_TO_IMAGE:\n            return 'image';\n        default:\n            return undefined;\n    }\n}\n","import { implicitCast, clamp, mix, checkLooseType, checkType, checkExpression } from './utils';\nimport Transition from './transition';\nimport BaseExpression from './base';\n\n/**\n * Linearly interpolate from `a` to `b` based on `mix`.\n *\n * @param {Number|Color} a - Numeric or color expression, `a` type must match `b` type\n * @param {Number|Color} b - Numeric or color expression, `b` type must match `a` type\n * @param {Number} mix - Numeric expression with the interpolation parameter in the [0,1] range\n * @returns {Number|Color} Numeric or color expression with the same type as `a` and `b`\n *\n * @example <caption>Blend based on the zoom level to display a bubble map at high zoom levels and display fixed-sized points at low zoom levels.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.blend(3,\n *                  s.prop('dn'),\n *                  s.linear(s.zoom(), s.pow(2, 10), s.pow(2, 14))\n *           );\n * });\n *\n * @example <caption>Blend based on the zoom level to display a bubble map at high zoom levels and display fixed-sized points at low zoom levels. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: blend(3,\n *                $dn,\n *                linear(zoom(), 2^10, 2^14)\n *          )\n * `);\n *\n * @memberof carto.expressions\n * @name blend\n * @function\n * @api\n */\nexport default class Blend extends BaseExpression {\n    constructor (a, b, mix, interpolator) {\n        a = implicitCast(a);\n        b = implicitCast(b);\n        mix = implicitCast(mix);\n\n        checkExpression('blend', 'a', 0, a);\n        checkExpression('blend', 'b', 1, b);\n        checkExpression('blend', 'mix', 2, mix);\n        if (a.type && b.type) {\n            abTypeCheck(a, b);\n        }\n        checkLooseType('blend', 'mix', 2, 'number', mix);\n\n        // TODO check interpolator type\n        const originalMix = mix;\n        if (interpolator) {\n            mix = interpolator(mix);\n        }\n        super({ a, b, mix });\n        this.originalMix = originalMix;\n\n        if (a.type && b.type) {\n            this.type = a.type;\n        }\n        this.inlineMaker = inline => `mix(${inline.a}, ${inline.b}, clamp(${inline.mix}, 0., 1.))`;\n    }\n    eval (feature) {\n        const a = clamp(this.mix.eval(feature), 0, 1);\n        const x = this.a.eval(feature);\n        const y = this.b.eval(feature);\n        return mix(x, y, a);\n    }\n    replaceChild (toReplace, replacer) {\n        if (toReplace === this.mix) {\n            this.originalMix = replacer;\n        }\n        super.replaceChild(toReplace, replacer);\n    }\n    _bindMetadata (meta) {\n        super._bindMetadata(meta);\n\n        abTypeCheck(this.a, this.b);\n        checkType('blend', 'mix', 1, 'number', this.mix);\n\n        this.type = this.a.type;\n    }\n    _preDraw (...args) {\n        super._preDraw(...args);\n        if (this.originalMix.isA(Transition) && !this.originalMix.isAnimated()) {\n            this.parent.replaceChild(this, this.b);\n            this.notify();\n        }\n    }\n}\n\nfunction abTypeCheck (a, b) {\n    if (!((a.type === 'number' && b.type === 'number') || (a.type === 'color' && b.type === 'color'))) {\n        throw new Error(`blend(): invalid parameter types\\n\\t'a' type was '${a.type}'\\n\\t'b' type was ${b.type}'`);\n    }\n}\n","import BaseExpression from './base';\nimport { implicitCast, getOrdinalFromIndex } from './utils';\n\n/**\n * Given a property create \"sub-groups\" based on the given breakpoints.\n *\n * Imagine a traffic dataset with a speed property. We want to divide the roads in\n * 3 buckets (slow, medium, fast) based on the speed using a different color each bucket.\n *\n * Well need:\n *  - A {@link carto.expressions.ramp|ramp} to add a color for every bucket.\n *  - A {@link carto.expressions.palettes|colorPalette} to define de color scheme.\n *\n * ```javascript\n *  const s = carto.expressions;\n *  const $speed = s.prop('speed');\n *  const viz = new carto.Viz({\n *    color: s.ramp(\n *      s.buckets($speed, [30, 80, 120]),\n *      s.palettes.PRISM\n *    )\n * });\n * ```\n *\n * ```javascript\n *  const viz = new carto.Viz(`\n *    color: ramp(buckets($speed, [30, 80, 120]), PRISM)\n * `);\n * ```\n *\n * Using the buckets `expression` we divide the dataset in 3 buckets according to the speed:\n *  - From 0 to 29\n *  - From 30 to 79\n *  - From 80 to 120\n *\n * Values lower than 0 will be in the first bucket and values higher than 120 will be in the third one.\n *\n * This expression can be used for categorical properties, imagine the previous example with the data already\n * procesed in a new categorical `procesedSpeed` column:\n *\n * ```javascript\n *  const s = carto.expressions;\n *  const $procesedSpeed = s.prop('procesedSpeed');\n *  const viz = new carto.Viz({\n *    color: s.ramp(\n *      s.buckets($procesedSpeed, ['slow', 'medium', 'high']),\n *      s.palettes.PRISM)\n *    )\n * });\n * ```\n *\n * ```javascript\n *  const viz = new carto.Viz(`\n *    color: ramp(buckets($procesedSpeed, ['slow', 'medium', 'high']), PRISM)\n * `);\n * ```\n *\n * @param {Number|Category} property - The property to be evaluated and interpolated\n * @param {Number[]|Category[]} breakpoints - Numeric expression containing the different breakpoints.\n * @return {Number|Category}\n *\n * @memberof carto.expressions\n * @name buckets\n * @function\n * @api\n */\nexport default class Buckets extends BaseExpression {\n    constructor (input, list) {\n        input = implicitCast(input);\n        list = implicitCast(list);\n\n        let looseType;\n\n        if (input.type) {\n            if (input.type !== 'number' && input.type !== 'category') {\n                throw new Error(`buckets(): invalid first parameter type\\n\\t'input' type was ${input.type}`);\n            }\n            looseType = input.type;\n        }\n\n        list.elems.map((item, index) => {\n            if (item.type) {\n                if (looseType && looseType !== item.type) {\n                    throw new Error(`buckets(): invalid ${getOrdinalFromIndex(index + 1)} parameter type` +\n                        `\\n\\texpected type was ${looseType}\\n\\tactual type was ${item.type}`);\n                } else if (item.type !== 'number' && item.type !== 'category') {\n                    throw new Error(`buckets(): invalid ${getOrdinalFromIndex(index + 1)} parameter type\\n\\ttype was ${item.type}`);\n                }\n            }\n        });\n\n        let children = {\n            input\n        };\n\n        list.elems.map((item, index) => {\n            children[`arg${index}`] = item;\n        });\n        super(children);\n        this.numCategories = list.elems.length + 1;\n        this.list = list;\n        this.type = 'category';\n    }\n\n    eval (feature) {\n        const v = this.input.eval(feature);\n        let i = 0;\n\n        if (this.input.type === 'category') {\n            for (i = 0; i < this.list.elems.length; i++) {\n                if (v === this.list.elems[i].eval(feature)) {\n                    return i;\n                }\n            }\n        }\n\n        if (this.input.type === 'number') {\n            for (i = 0; i < this.list.elems.length; i++) {\n                if (v < this.list.elems[i].eval(feature)) {\n                    return i;\n                }\n            }\n        }\n\n        return i;\n    }\n\n    _bindMetadata (metadata) {\n        super._bindMetadata(metadata);\n\n        if (this.input.type !== 'number' && this.input.type !== 'category') {\n            throw new Error(`buckets(): invalid first parameter type\\n\\t'input' type was ${this.input.type}`);\n        }\n\n        this.list.elems.map((item, index) => {\n            if (this.input.type !== item.type) {\n                throw new Error(`buckets(): invalid ${getOrdinalFromIndex(index + 1)} parameter type` +\n                    `\\n\\texpected type was ${this.input.type}\\n\\tactual type was ${item.type}`);\n            } else if (item.type !== 'number' && item.type !== 'category') {\n                throw new Error(`buckets(): invalid ${getOrdinalFromIndex(index + 1)} parameter type\\n\\ttype was ${item.type}`);\n            }\n        });\n    }\n\n    _applyToShaderSource (getGLSLforProperty) {\n        const childSources = this.childrenNames.map(name => this[name]._applyToShaderSource(getGLSLforProperty));\n        let childInlines = {};\n        childSources.map((source, index) => {\n            childInlines[this.childrenNames[index]] = source.inline;\n        });\n        const funcName = `buckets${this._uid}`;\n        const cmp = this.input.type === 'category' ? '==' : '<';\n        const elif = (_, index) =>\n            `${index > 0 ? 'else' : ''} if (x${cmp}(${childInlines[`arg${index}`]})){\n                return ${index}.;\n            }`;\n        const funcBody = this.list.elems.map(elif).join('');\n        const preface = `float ${funcName}(float x){\n            ${funcBody}\n            return ${this.numCategories - 1}.;\n        }`;\n\n        return {\n            preface: this._prefaceCode(childSources.map(s => s.preface).reduce((a, b) => a + b, '') + preface),\n            inline: `${funcName}(${childInlines.input})`\n        };\n    }\n}\n","import BaseExpression from '../base';\nimport { number } from '../../expressions';\nimport * as schema from '../../../schema';\n\nlet classifierUID = 0;\nexport default class Classifier extends BaseExpression {\n    constructor (children, buckets) {\n        const breakpoints = _genBreakpoints(children, buckets);\n\n        super(children);\n\n        this.classifierUID = classifierUID++;\n        this.numCategories = buckets;\n        this.buckets = buckets;\n        this.breakpoints = breakpoints;\n        this.type = 'category';\n    }\n\n    eval (feature) {\n        const NOT_FOUND_INDEX = -1;\n        const input = this.input.eval(feature);\n        const index = this.breakpoints.findIndex((br) => {\n            return input <= br.expr;\n        });\n\n        return index === NOT_FOUND_INDEX ? this.breakpoints.length : index;\n    }\n\n    getBreakpointList () {\n        this._genBreakpoints();\n        return this.breakpoints.map(br => br.expr);\n    }\n\n    _genBreakpoints () {}\n\n    _applyToShaderSource (getGLSLforProperty) {\n        const childSources = this.childrenNames.map(name => this[name]._applyToShaderSource(getGLSLforProperty));\n        let childInlines = {};\n        childSources.map((source, index) => {\n            childInlines[this.childrenNames[index]] = source.inline;\n        });\n        const funcName = `classifier${this.classifierUID}`;\n        const elif = (_, index) =>\n            `${index > 0 ? 'else' : ''} if (x<(${childInlines[`arg${index}`]})){\n                return ${index.toFixed(2)};\n            }`;\n        const funcBody = this.breakpoints.map(elif).join('');\n        const preface = `float ${funcName}(float x){\n            ${funcBody}\n            return ${this.breakpoints.length.toFixed(1)};\n        }`;\n        return {\n            preface: this._prefaceCode(childSources.map(s => s.preface).reduce((a, b) => a + b, '') + preface),\n            inline: `${funcName}(${childInlines.input})`\n        };\n    }\n\n    _preDraw (program, drawMetadata, gl) {\n        this._genBreakpoints();\n        // TODO\n        super._preDraw(program, drawMetadata, gl);\n    }\n\n    _getColumnName () {\n        if (this.input.aggName) {\n            // Property has aggregation\n            return schema.column.aggColumn(this.input.name, this.input.aggName);\n        }\n        return this.input.name;\n    }\n}\n\nfunction _genBreakpoints (children, buckets) {\n    const breakpoints = [];\n\n    for (let i = 0; i < buckets - 1; i++) {\n        children[`arg${i}`] = number(0);\n        breakpoints.push(children[`arg${i}`]);\n    }\n\n    return breakpoints;\n}\n","import Classifier from './Classifier';\nimport Property from '../basic/property';\nimport { checkNumber, checkInstance, checkType, checkExpression } from '../utils';\n\n/**\n * Classify `input` by using the equal intervals method with `n` buckets.\n *\n * It will classify the input based on the entire dataset without filtering by viewport or by `filter`.\n *\n * @param {Number} input - The input expression to classify\n * @param {number} n - Number of buckets\n * @return {Category}\n *\n * @example <caption>Use global equal intervals to define a color ramp.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   color: s.ramp(s.globalEqIntervals(s.prop('density'), 5), s.palettes.PRISM)\n * });\n *\n * @example <caption>Use global equal intervals to define a color ramp. (String)</caption>\n * const viz = new carto.Viz(`\n *   color: ramp(globalEqIntervals($density, 5), PRISM)\n * `);\n *\n * @memberof carto.expressions\n * @name globalEqIntervals\n * @function\n * @api\n */\nexport default class GlobalEqIntervals extends Classifier {\n    constructor (input, buckets) {\n        checkInstance('globalEqIntervals', 'input', 0, Property, input && (input.property || input));\n        checkNumber('globalEqIntervals', 'buckets', 1, buckets);\n\n        super({ input }, buckets);\n    }\n\n    _bindMetadata (metadata) {\n        super._bindMetadata(metadata);\n        checkExpression('globalEqIntervals', 'input', 0, this.input);\n        checkType('globalEqIntervals', 'input', 0, 'number', this.input);\n        const { min, max } = metadata.properties[this.input.name];\n        this.min = min;\n        this.max = max;\n        this.breakpoints.map((breakpoint, index) => {\n            const p = (index + 1) / this.buckets;\n            breakpoint.expr = min + (max - min) * p;\n        });\n    }\n}\n","import Classifier from './Classifier';\nimport Property from '../basic/property';\nimport { checkInstance, checkType, checkExpression, checkNumber } from '../utils';\n\n/**\n * Classify `input` by using the quantiles method with `n` buckets.\n *\n * It will classify the input based on the entire dataset without filtering by viewport or by `filter`.\n *\n * @param {Number} input - The input expression used in the quantiles\n * @param {number} n - Number of buckets to be returned\n * @return {Category}\n *\n * @example <caption>Use global quantiles to define a color ramp.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   color: s.ramp(s.globalQuantiles(s.prop('density'), 5), s.palettes.PRISM)\n * });\n *\n * @example <caption>Use global quantiles to define a color ramp. (String)</caption>\n * const viz = new carto.Viz(`\n *   color: ramp(globalQuantiles($density, 5), PRISM)\n * `);\n *\n * @memberof carto.expressions\n * @name globalQuantiles\n * @function\n * @api\n */\nexport default class GlobalQuantiles extends Classifier {\n    constructor (input, buckets) {\n        checkInstance('globalQuantiles', 'input', 0, Property, input && (input.property || input));\n        checkNumber('globalQuantiles', 'buckets', 1, buckets);\n        super({ input }, buckets);\n    }\n\n    _bindMetadata (metadata) {\n        super._bindMetadata(metadata);\n        checkExpression('globalQuantiles', 'input', 0, this.input);\n        checkType('globalQuantiles', 'input', 0, 'number', this.input);\n\n        const copy = metadata.sample.map(s => s[this.input.name]);\n\n        copy.sort((x, y) => x - y);\n\n        this.breakpoints.map((breakpoint, index) => {\n            const p = (index + 1) / this.buckets;\n            breakpoint.expr = copy[Math.floor(p * copy.length)];\n        });\n    }\n}\n","import Classifier from './Classifier';\nimport { viewportMax, viewportMin } from '../../expressions';\nimport { checkNumber, checkType } from '../utils';\n\n/**\n * Classify `input` by using the equal intervals method with `n` buckets.\n *\n * It will classify the input based on the filtered dataset, filtering by viewport and by `filter`.\n *\n * @param {Number} input - The input expression to classify\n * @param {number} n - Number of buckets\n * @return {Category}\n *\n * @example <caption>Use viewport equal intervals to define a color ramp.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   color: s.ramp(s.viewportEqIntervals(s.prop('density'), 5), s.palettes.PRISM)\n * });\n *\n * @example <caption>Use viewport equal intervals to define a color ramp. (String)</caption>\n * const viz = new carto.Viz(`\n *   color: ramp(viewportEqIntervals($density, 5), PRISM)\n * `);\n *\n * @memberof carto.expressions\n * @name viewportEqIntervals\n * @function\n * @api\n */\nexport default class ViewportEqIntervals extends Classifier {\n    constructor (input, buckets) {\n        checkNumber('viewportEqIntervals', 'buckets', 1, buckets);\n\n        const children = { input, _min: viewportMin(input), _max: viewportMax(input) };\n        super(children, buckets);\n    }\n\n    _bindMetadata (metadata) {\n        super._bindMetadata(metadata);\n        checkType('viewportEqIntervals', 'input', 0, ['number'], this.input);\n    }\n\n    _genBreakpoints () {\n        const min = this._min.eval();\n        const max = this._max.eval();\n\n        this.breakpoints.map((breakpoint, index) => {\n            const p = (index + 1) / this.buckets;\n            breakpoint.expr = min + (max - min) * p;\n        });\n    }\n}\n","import Classifier from './Classifier';\nimport { checkNumber, checkType } from '../utils';\nimport { viewportHistogram } from '../../expressions';\n\n/**\n * Classify `input` by using the quantiles method with `n` buckets.\n *\n * It will classify the input based on the filtered dataset, filtering by viewport and by `filter`.\n *\n * @param {Number} input - The input expression used in the quantiles\n * @param {number} n - Number of buckets to be returned\n * @return {Category}\n *\n * @example <caption>Use viewportQuantiles to define a color ramp.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   color: s.ramp(s.viewportQuantiles(s.prop('density'), 5), s.palettes.PRISM)\n * });\n *\n * @example <caption>Use viewportQuantiles to define a color ramp. (String)</caption>\n * const viz = new carto.Viz(`\n *   color: ramp(viewportQuantiles($density, 5), PRISM)\n * `);\n *\n * @memberof carto.expressions\n * @name quantiles\n * @function\n * @api\n */\nexport default class ViewportQuantiles extends Classifier {\n    constructor (input, buckets) {\n        checkNumber('viewportQuantiles', 'buckets', 1, buckets);\n\n        const children = { input, _histogram: viewportHistogram(input) };\n        super(children, buckets);\n    }\n\n    _bindMetadata (metadata) {\n        super._bindMetadata(metadata);\n        checkType('viewportQuantiles', 'input', 0, ['number'], this.input);\n    }\n\n    _genBreakpoints () {\n        const hist = this._histogram.value;\n\n        const histogramBuckets = hist.length;\n        const min = hist[0].x[0];\n        const max = hist[histogramBuckets - 1].x[1];\n\n        let prev = 0;\n        const accumHistogram = hist.map(({ y }) => {\n            prev += y;\n            return prev;\n        });\n\n        let i = 0;\n        const total = accumHistogram[histogramBuckets - 1];\n        let brs = [];\n        // TODO OPT: this could be faster with binary search\n        this.breakpoints.map((breakpoint, index) => {\n            for (i; i < histogramBuckets; i++) {\n                if (accumHistogram[i] > (index + 1) / this.buckets * total) {\n                    break;\n                }\n            }\n            const percentileValue = i / histogramBuckets * (max - min) + min;\n            brs.push(percentileValue);\n            breakpoint.expr = percentileValue;\n        });\n    }\n}\n","import BaseExpression from '../base';\nimport { implicitCast, checkLooseType, checkType, checkExpression } from '../utils';\n\n/**\n * Evaluates to a CIELab color.\n *\n * @param {Number} l - The lightness of the color\n * @param {Number} a - The greenred color component\n * @param {Number} b - The blueyellow color component\n * @return {Color}\n *\n * @example <caption>Display blue points.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   color: s.cielab(32.3, 79.2, -107.86)\n * });\n *\n * @example <caption>Display blue points. (String)</caption>\n * const viz = new carto.Viz(`\n *   color: cielab(32.3, 79.2, -107.86)\n * `);\n *\n * @memberof carto.expressions\n * @name cielab\n * @function\n * @api\n */\nexport default class CIELab extends BaseExpression {\n    constructor (l, a, b) {\n        l = implicitCast(l);\n        a = implicitCast(a);\n        b = implicitCast(b);\n\n        checkExpression('cielab', 'l', 0, l);\n        checkExpression('cielab', 'a', 1, a);\n        checkExpression('cielab', 'b', 2, b);\n        checkLooseType('cielab', 'l', 0, 'number', l);\n        checkLooseType('cielab', 'a', 1, 'number', a);\n        checkLooseType('cielab', 'b', 2, 'number', b);\n\n        super({ l, a, b });\n        this.type = 'color';\n\n        this._setGenericGLSL(inline =>\n            `vec4(xyztosrgb(cielabtoxyz(\n                vec3(\n                    clamp(${inline.l}, 0., 100.),\n                    clamp(${inline.a}, -128., 128.),\n                    clamp(${inline.b}, -128., 128.)\n                )\n            )), 1)`\n            , `\n        #ifndef cielabtoxyz_fn\n        #define cielabtoxyz_fn\n\n        const mat3 XYZ_2_RGB = (mat3(\n            3.2404542,-1.5371385,-0.4985314,\n           -0.9692660, 1.8760108, 0.0415560,\n            0.0556434,-0.2040259, 1.0572252\n       ));\n       const float SRGB_GAMMA = 1.0 / 2.2;\n\n       vec3 rgb_to_srgb_approx(vec3 rgb) {\n        return pow(rgb, vec3(SRGB_GAMMA));\n    }\n        float f1(float t){\n            const float sigma = 6./29.;\n            if (t>sigma){\n                return t*t*t;\n            }else{\n                return 3.*sigma*sigma*(t-4./29.);\n            }\n        }\n        vec3 cielabtoxyz(vec3 c) {\n            const float xn = 95.047/100.;\n            const float yn = 100./100.;\n            const float zn = 108.883/100.;\n            return vec3(xn*f1((c.x+16.)/116.  + c.y/500. ),\n                        yn*f1((c.x+16.)/116.),\n                        zn*f1((c.x+16.)/116.  - c.z/200. )\n                    );\n        }\n        vec3 xyztorgb(vec3 c){\n            return c *XYZ_2_RGB;\n        }\n\n        vec3 xyztosrgb(vec3 c) {\n            return rgb_to_srgb_approx(xyztorgb(c));\n        }\n        #endif\n        `);\n    }\n    // TODO EVAL\n\n    _bindMetadata (meta) {\n        super._bindMetadata(meta);\n        checkType('cielab', 'l', 0, 'number', this.l);\n        checkType('cielab', 'a', 1, 'number', this.a);\n        checkType('cielab', 'b', 2, 'number', this.b);\n    }\n}\n","import BaseExpression from '../base';\nimport { checkString, getStringErrorPreface } from '../utils';\nimport { CSS_COLOR_NAMES } from './cssColorNames';\n\n/**\n * Create a color from its name.\n *\n * @param {string} name - The name of the color\n * @return {Color}\n *\n * @example <caption>Display blue points.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   color: s.namedColor('blue')  // Equivalent to `color: 'blue'`\n * });\n *\n * @example <caption>Display blue points. (String)</caption>\n * const viz = new carto.Viz({\n *   color: blue  // Equivalent to namedColor('blue')\n * });\n *\n * @memberof carto.expressions\n * @name namedColor\n * @function\n * @api\n */\nexport default class NamedColor extends BaseExpression {\n    constructor (colorName) {\n        checkString('namedColor', 'colorName', 0, colorName);\n        if (!CSS_COLOR_NAMES.includes(colorName.toLowerCase())) {\n            throw new Error(getStringErrorPreface('namedColor', 'colorName', 0) + `\\nInvalid color name:  \"${colorName}\"`);\n        }\n        super({});\n        this.type = 'color';\n        this.name = colorName;\n        this.color = _nameToRGBA(this.name);\n        this.inlineMaker = () => `vec4(${(this.color.r / 255).toFixed(4)}, ${(this.color.g / 255).toFixed(4)}, ${(this.color.b / 255).toFixed(4)}, ${(1).toFixed(4)})`;\n    }\n    get value () {\n        return this.eval();\n    }\n    eval () {\n        return this.color;\n    }\n}\n\nconst nameToRGBACache = {};\n\nfunction _nameToRGBA (name) {\n    if (nameToRGBACache[name]) {\n        return nameToRGBACache[name];\n    }\n    const colorRegex = /^rgba?\\((\\d+),\\s*(\\d+),\\s*(\\d+)(?:,\\s*(\\d+(?:\\.\\d+)?))?\\)$/;\n    const fakeDiv = document.createElement('div');\n    fakeDiv.style.backgroundColor = name;\n    document.body.appendChild(fakeDiv);\n    const rgbSring = getComputedStyle(fakeDiv).backgroundColor;\n    document.body.removeChild(fakeDiv);\n\n    const match = colorRegex.exec(rgbSring);\n\n    const color = { r: Number(match[1]), g: Number(match[2]), b: Number(match[3]), a: match[4] || 1 };\n\n    nameToRGBACache[name] = color;\n    return color;\n}\n","export const CSS_COLOR_NAMES = [\n    'aliceblue',\n    'antiquewhite',\n    'aqua',\n    'aquamarine',\n    'azure',\n    'beige',\n    'bisque',\n    'black',\n    'blanchedalmond',\n    'blue',\n    'blueviolet',\n    'brown',\n    'burlywood',\n    'cadetblue',\n    'chartreuse',\n    'chocolate',\n    'coral',\n    'cornflowerblue',\n    'cornsilk',\n    'crimson',\n    'cyan',\n    'darkblue',\n    'darkcyan',\n    'darkgoldenrod',\n    'darkgray',\n    'darkgreen',\n    'darkgrey',\n    'darkkhaki',\n    'darkmagenta',\n    'darkolivegreen',\n    'darkorange',\n    'darkorchid',\n    'darkred',\n    'darksalmon',\n    'darkseagreen',\n    'darkslateblue',\n    'darkslategray',\n    'darkslategrey',\n    'darkturquoise',\n    'darkviolet',\n    'deeppink',\n    'deepskyblue',\n    'dimgray',\n    'dimgrey',\n    'dodgerblue',\n    'firebrick',\n    'floralwhite',\n    'forestgreen',\n    'fuchsia',\n    'gainsboro',\n    'ghostwhite',\n    'gold',\n    'goldenrod',\n    'gray',\n    'green',\n    'greenyellow',\n    'grey',\n    'honeydew',\n    'hotpink',\n    'indianred',\n    'indigo',\n    'ivory',\n    'khaki',\n    'lavender',\n    'lavenderblush',\n    'lawngreen',\n    'lemonchiffon',\n    'lightblue',\n    'lightcoral',\n    'lightcyan',\n    'lightgoldenrodyellow',\n    'lightgray',\n    'lightgreen',\n    'lightgrey',\n    'lightpink',\n    'lightsalmon',\n    'lightseagreen',\n    'lightskyblue',\n    'lightslategray',\n    'lightslategrey',\n    'lightsteelblue',\n    'lightyellow',\n    'lime',\n    'limegreen',\n    'linen',\n    'magenta',\n    'maroon',\n    'mediumaquamarine',\n    'mediumblue',\n    'mediumorchid',\n    'mediumpurple',\n    'mediumseagreen',\n    'mediumslateblue',\n    'mediumspringgreen',\n    'mediumturquoise',\n    'mediumvioletred',\n    'midnightblue',\n    'mintcream',\n    'mistyrose',\n    'moccasin',\n    'navajowhite',\n    'navy',\n    'oldlace',\n    'olive',\n    'olivedrab',\n    'orange',\n    'orangered',\n    'orchid',\n    'palegoldenrod',\n    'palegreen',\n    'paleturquoise',\n    'palevioletred',\n    'papayawhip',\n    'peachpuff',\n    'peru',\n    'pink',\n    'plum',\n    'powderblue',\n    'purple',\n    'red',\n    'rosybrown',\n    'royalblue',\n    'saddlebrown',\n    'salmon',\n    'sandybrown',\n    'seagreen',\n    'seashell',\n    'sienna',\n    'silver',\n    'skyblue',\n    'slateblue',\n    'slategray',\n    'slategrey',\n    'snow',\n    'springgreen',\n    'steelblue',\n    'tan',\n    'teal',\n    'thistle',\n    'tomato',\n    'transparent',\n    'turquoise',\n    'violet',\n    'wheat',\n    'white',\n    'whitesmoke',\n    'yellow',\n    'yellowgreen'\n];\n","import BaseExpression from '../base';\nimport { checkString, hexToRgb, getStringErrorPreface } from '../utils';\n\n/**\n * Create a color from its hexadecimal description.\n *\n * @param {string} hexadecimalColor - Color in the #RGB, #RGBA, #RRGGBB or #RRGGBBAA format\n * @return {Color}\n *\n * @example <caption>Display blue points.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   color: s.hex('#00F');  // Equivalent to `color: '#00F'`\n * });\n *\n * @example <caption>Display blue points. (String)</caption>\n * const viz = new carto.Viz(`\n *   color: #00F  // Equivalent to hex('#00F')\n * `);\n *\n * @memberof carto.expressions\n * @name hex\n * @function\n * @api\n */\nexport default class Hex extends BaseExpression {\n    constructor (hexadecimalColor) {\n        checkString('hex', 'hexadecimalColor', 0, hexadecimalColor);\n        super({});\n        this.type = 'color';\n        try {\n            this.color = hexToRgb(hexadecimalColor);\n        } catch (error) {\n            throw new Error(getStringErrorPreface('hex', 'hexadecimalColor', 0) + '\\nInvalid hexadecimal color string');\n        }\n        this.inlineMaker = () => `vec4(${(this.color.r / 255).toFixed(4)}, ${(this.color.g / 255).toFixed(4)}, ${(this.color.b / 255).toFixed(4)}, ${(this.color.a).toFixed(4)})`;\n    }\n    get value () {\n        return this.eval();\n    }\n    eval () {\n        return this.color;\n    }\n}\n","import BaseExpression from '../base';\nimport { implicitCast, checkExpression, checkLooseType, checkType, clamp } from '../utils';\n\n/**\n * Evaluates to a hsl color.\n *\n * @param {Number} h - hue of the color in the [0, 1] range\n * @param {Number} s - saturation of the color in the [0, 1] range\n * @param {Number} l - lightness of the color in the [0, 1] range\n * @return {Color}\n *\n * @example <caption>Display blue points.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   color: s.hsl(0.67, 1.0, 0.5)\n * });\n *\n * @example <caption>Display blue points. (String)</caption>\n * const viz = new carto.Viz(`\n *   color: hsl(0.67, 1.0, 0.5)\n * `);\n *\n * @memberof carto.expressions\n * @name hsl\n * @function\n * @api\n */\nexport const HSL = genHSL('hsl', false);\n\n/**\n * Evaluates to a hsla color.\n *\n * @param {Number} h - hue of the color in the [0, 1] range\n * @param {Number} s - saturation of the color in the [0, 1] range\n * @param {Number} l - lightness of the color in the [0, 1] range\n * @param {Number} a - alpha value of the color in the [0, 1] range\n * @return {Color}\n *\n * @example <caption>Display blue points.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   color: s.hsla(0.67, 1.0, 0.5, 1.0)\n * });\n *\n * @example <caption>Display blue points. (String)</caption>\n * const viz = new carto.Viz(`\n *   color: hsla(0.67, 1.0, 0.5, 1.0)\n * `);\n *\n * @memberof carto.expressions\n * @function\n * @name hsla\n * @api\n */\nexport const HSLA = genHSL('hsla', true);\n\nfunction genHSL (name, alpha) {\n    return class HSLA extends BaseExpression {\n        constructor (h, s, l, a) {\n            [h, s, l, a] = [h, s, l, a].map(implicitCast);\n\n            const children = { h, s, l };\n            if (alpha) {\n                checkLooseType(name, 'a', 3, 'number', a);\n                children.a = a;\n            }\n\n            hslCheckType('h', 0, h);\n            hslCheckType('s', 1, s);\n            hslCheckType('l', 2, l);\n\n            super(children);\n            this.type = 'color';\n        }\n        get value () {\n            return this.eval();\n        }\n        eval (f) {\n            const normalize = (value, hue = false) => {\n                if (value.type === 'category') {\n                    return value.eval(f) / (hue ? value.numCategories + 1 : value.numCategories);\n                }\n                return value.eval(f);\n            };\n            const h = clamp(normalize(this.h, true), 0, 1);\n            const s = clamp(normalize(this.s), 0, 1);\n            const l = clamp(normalize(this.l), 0, 1);\n\n            const hslToRgb = (h, s, l) => {\n                const c = {\n                    r: Math.abs(h * 6 - 3) - 1,\n                    g: 2 - Math.abs(h * 6 - 2),\n                    b: 2 - Math.abs(h * 6 - 4),\n                    a: alpha ? this.a.eval(f) : 1\n                };\n\n                const C = (1 - Math.abs(2 * l - 1)) * s;\n\n                c.r = clamp(c.r, 0, 1);\n                c.g = clamp(c.g, 0, 1);\n                c.b = clamp(c.b, 0, 1);\n\n                c.r = ((c.r - 0.5) * C + l) * 255;\n                c.g = ((c.g - 0.5) * C + l) * 255;\n                c.b = ((c.b - 0.5) * C + l) * 255;\n\n                return c;\n            };\n\n            return hslToRgb(h, s, l);\n        }\n\n        _bindMetadata (meta) {\n            super._bindMetadata(meta);\n            hslCheckType('h', 0, this.h);\n            hslCheckType('s', 1, this.s);\n            hslCheckType('l', 2, this.l);\n            if (alpha) {\n                checkType('hsla', 'a', 3, 'number', this.a);\n            }\n\n            const normalize = (value, hue = false) => {\n                if (value.type === 'category') {\n                    return `/${hue ? value.numCategories + 1 : value.numCategories}.`;\n                }\n                return '';\n            };\n            super._setGenericGLSL(inline =>\n                `vec4(HSLtoRGB(vec3(\n                    ${inline.h}${normalize(this.h, true)},\n                    clamp(${inline.s}${normalize(this.s)}, 0., 1.),\n                    clamp(${inline.l}${normalize(this.l)}, 0., 1.)\n                )), ${alpha ? `clamp(${inline.a}, 0., 1.)` : '1.'})`\n                , `\n    #ifndef HSL2RGB\n    #define HSL2RGB\n    vec3 HSLtoRGB(vec3 HSL) {\n      float R = abs(HSL.x * 6. - 3.) - 1.;\n      float G = 2. - abs(HSL.x * 6. - 2.);\n      float B = 2. - abs(HSL.x * 6. - 4.);\n      float C = (1. - abs(2. * HSL.z - 1.)) * HSL.y;\n      vec3 RGB = clamp(vec3(R,G,B), 0., 1.);\n      return (RGB - 0.5) * C + HSL.z;\n    }\n    #endif\n    `);\n        }\n    };\n\n    function hslCheckType (parameterName, parameterIndex, parameter) {\n        checkExpression(name, parameterName, parameterIndex, parameter);\n        if (parameter.type !== 'number' && parameter.type !== 'category' && parameter.type !== undefined) {\n            throw new Error(`${name}(): invalid parameter\\n\\t${parameterName} type was: '${parameter.type}'`);\n        }\n    }\n}\n","import BaseExpression from '../base';\nimport { implicitCast, checkExpression, checkLooseType, checkType, clamp } from '../utils';\n\n/**\n * Evaluates to a hsv color.\n *\n * @param {Number} h - hue of the color in the [0, 1] range\n * @param {Number} s - saturation of the color in the [0, 1] range\n * @param {Number} v - value (brightness) of the color in the [0, 1] range\n * @return {Color}\n *\n * @example <caption>Display blue points.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   color: s.hsv(0.67, 1.0, 1.0)\n * });\n *\n * @example <caption>Display blue points. (String)</caption>\n * const viz = new carto.Viz(`\n *   color: hsv(0.67, 1.0, 1.0)\n * `);\n *\n * @memberof carto.expressions\n * @name hsv\n * @function\n * @api\n */\nexport const HSV = genHSV('hsv', false);\n\n/**\n * Evaluates to a hsva color.\n *\n * @param {Number} h - hue of the color in the [0, 1] range\n * @param {Number} s - saturation of the color in the [0, 1] range\n * @param {Number} v - value (brightness) of the color in the [0, 1] range\n * @param {Number} a - alpha value of the color in the [0, 1] range\n * @return {Color}\n *\n * @example <caption>Display blue points.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   color: s.hsva(0.67, 1.0, 1.0, 1.0)\n * });\n *\n * @example <caption>Display blue points. (String)</caption>\n * const viz = new carto.Viz(`\n *   color: hsva(0.67, 1.0, 1.0, 1.0)\n * `);\n *\n * @memberof carto.expressions\n * @function\n * @name hsva\n * @api\n */\nexport const HSVA = genHSV('hsva', true);\n\nfunction genHSV (name, alpha) {\n    return class extends BaseExpression {\n        constructor (h, s, v, a) {\n            h = implicitCast(h);\n            s = implicitCast(s);\n            v = implicitCast(v);\n            const children = { h, s, v };\n            if (alpha) {\n                a = implicitCast(a);\n                checkLooseType(name, 'a', 3, 'number', a);\n                children.a = a;\n            }\n\n            hsvCheckType('h', 0, h);\n            hsvCheckType('s', 1, s);\n            hsvCheckType('v', 2, v);\n\n            super(children);\n            this.type = 'color';\n        }\n        get value () {\n            return this.eval();\n        }\n        eval (f) {\n            const normalize = (value, hue = false) => {\n                if (value.type === 'category') {\n                    return value.eval(f) / (hue ? value.numCategories + 1 : value.numCategories);\n                }\n                return value.eval(f);\n            };\n            const h = clamp(normalize(this.h, true), 0, 1);\n            const s = clamp(normalize(this.s), 0, 1);\n            const v = clamp(normalize(this.v), 0, 1);\n\n            const hsvToRgb = (h, s, v) => {\n                const c = {\n                    r: Math.abs(h * 6 - 3) - 1,\n                    g: 2 - Math.abs(h * 6 - 2),\n                    b: 2 - Math.abs(h * 6 - 4),\n                    a: alpha ? clamp(this.a.eval(f), 0, 1) : 1\n                };\n\n                c.r = clamp(c.r, 0, 1);\n                c.g = clamp(c.g, 0, 1);\n                c.b = clamp(c.b, 0, 1);\n\n                c.r = ((c.r - 1) * s + 1) * v * 255;\n                c.g = ((c.g - 1) * s + 1) * v * 255;\n                c.b = ((c.b - 1) * s + 1) * v * 255;\n\n                return c;\n            };\n\n            return hsvToRgb(h, s, v);\n        }\n        _bindMetadata (metadata) {\n            super._bindMetadata(metadata);\n            hsvCheckType('h', 0, this.h);\n            hsvCheckType('s', 1, this.s);\n            hsvCheckType('v', 2, this.v);\n            if (alpha) {\n                checkType('hsva', 'a', 3, 'number', this.a);\n            }\n            const normalize = (value, hue = false) => {\n                if (value.type === 'category') {\n                    return `/${hue ? value.numCategories + 1 : value.numCategories}.`;\n                }\n                return '';\n            };\n            super._setGenericGLSL(inline =>\n                `vec4(HSVtoRGB(vec3(\n                    ${inline.h}${normalize(this.h, true)},\n                    clamp(${inline.s}${normalize(this.s)}, 0.,1.),\n                    clamp(${inline.v}${normalize(this.v)}, 0.,1.)\n                )), ${alpha ? `clamp(${inline.a}, 0.,1.)` : '1.'})`\n                , `\n    #ifndef HSV2RGB\n    #define HSV2RGB\n    vec3 HSVtoRGB(vec3 HSV) {\n      float R = abs(HSV.x * 6. - 3.) - 1.;\n      float G = 2. - abs(HSV.x * 6. - 2.);\n      float B = 2. - abs(HSV.x * 6. - 4.);\n      vec3 RGB = clamp(vec3(R,G,B), 0., 1.);\n      return ((RGB - 1.) * HSV.y + 1.) * HSV.z;\n    }\n    #endif\n    `);\n        }\n    };\n\n    function hsvCheckType (parameterName, parameterIndex, parameter) {\n        checkExpression(name, parameterName, parameterIndex, parameter);\n        if (parameter.type !== 'number' && parameter.type !== 'category' && parameter.type !== undefined) {\n            throw new Error(`${name}(): invalid parameter\\n\\t${parameterName} type was: '${parameter.type}'`);\n        }\n    }\n}\n","import BaseExpression from '../base';\nimport { number } from '../../expressions';\nimport { checkLooseType, checkType } from '../utils';\n\n/**\n * Override the input color opacity.\n *\n * @param {Color} color - Color expression to apply the opacity\n * @param {Number} alpha - Number expression with the alpha (transparency) value\n * @return {Color}\n *\n * @example <caption>Display blue points with 50% opacity.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   color: s.opacity(s.rgb(0,0,255), 0.5)  // Equivalent to `s.rgba(0,0,255,0.5)`\n * });\n *\n * @example <caption>Display blue points with 50% opacity. (String)</caption>\n * const viz = new carto.Viz(`\n *   color: opacity(rgb(0,0,255), 0.5) // Equivalent to `rgba(0,0,255,0.5)`\n * `);\n *\n * @memberof carto.expressions\n * @name opacity\n * @function\n * @api\n */\nexport default class Opacity extends BaseExpression {\n    /**\n     * @description Override the input color opacity\n     * @param {*} color input color\n     * @param {*} alpha new opacity\n     */\n    constructor (color, alpha) {\n        if (Number.isFinite(alpha)) {\n            alpha = number(alpha);\n        }\n        checkLooseType('opacity', 'color', 0, 'color', color);\n        checkLooseType('opacity', 'alpha', 1, 'number', alpha);\n        super({ color, alpha });\n        this.type = 'color';\n        this.inlineMaker = inline => `vec4((${inline.color}).rgb, ${inline.alpha})`;\n    }\n    get value () {\n        return this.eval();\n    }\n    eval (f) {\n        const color = this.color.eval(f);\n        const alpha = this.alpha.eval(f);\n        color.a = alpha;\n        return color;\n    }\n    _bindMetadata (meta) {\n        super._bindMetadata(meta);\n        checkType('opacity', 'color', 0, 'color', this.color);\n        checkType('opacity', 'alpha', 1, 'number', this.alpha);\n    }\n}\n","\nimport * as cartocolor from 'cartocolor';\nimport Palette from './palettes/Palette';\n\nconst palettes = {};\n\nObject.keys(cartocolor).map(name => {\n    palettes[`${name.toUpperCase()}`] = new Palette(name, cartocolor[name]);\n});\n\nexport default palettes;\n","import BaseExpression from '../../base';\nimport { hexToRgb } from '../../utils';\n\n/**\n * Color palettes.\n *\n * Palettes are constants that allow to use {@link https://carto.com/carto-colors/|CARTOColors} and {@link https://github.com/axismaps/colorbrewer/|ColorBrewer} palettes easily.\n * Use them with a {@link carto.expressions.ramp|ramp}\n *\n * The following palettes are available in the namespace {@link carto.expressions.palettes|carto.expressions.palettes}.\n *\n *  ```\n *  BURG, BURGYL, REDOR, ORYEL, PEACH, PINKYL, MINT, BLUGRN, DARKMINT, EMRLD, AG_GRNYL, BLUYL, TEAL, TEALGRN,\n *  PURP, PURPOR, SUNSET, MAGENTA, SUNSETDARK, AG_SUNSET, BRWNYL, ARMYROSE, FALL, GEYSER, TEMPS, TEALROSE, TROPIC,\n *  EARTH, ANTIQUE, BOLD, PASTEL, PRISM, SAFE, VIVID, CB_YLGN, CB_YLGNBU, CB_GNBU, CB_BUGN, CB_PUBUGN, CB_PUBU,\n *  CB_BUPU, CB_RDPU, CB_PURD, CB_ORRD, CB_YLORRD, CB_YLORBR, CB_PURPLES, CB_BLUES, CB_GREENS, CB_ORANGES, CB_REDS,\n *  CB_GREYS, CB_PUOR, CB_BRBG, CB_PRGN, CB_PIYG, CB_RDBU, CB_RDGY, CB_RDYLBU, CB_SPECTRAL, CB_RDYLGN, CB_ACCENT,\n *  CB_DARK2, CB_PAIRED, CB_PASTEL1, CB_PASTEL2, CB_SET1, CB_SET2, CB_SET3\n *  ```\n *\n * @example <caption>Using a color scheme.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   color: s.ramp(s.prop('type'), s.palettes.PRISM);\n * });\n *\n * @example <caption>Using a color scheme. (String)</caption>\n * const viz = new carto.Viz(`\n *   color: ramp($type, PRISM)\n * `);\n *\n * @name carto.expressions.palettes\n * @memberof carto.expressions\n * @api\n */\n\nexport default class Palette extends BaseExpression {\n    constructor (name, subPalettes) {\n        super({});\n        this.type = 'palette';\n        this.name = name;\n        this.subPalettes = new Proxy(subPalettes, {\n            get: (target, name) => {\n                if (Number.isFinite(Number(name)) && Array.isArray(target[name])) {\n                    return target[name].map(hexToRgb);\n                }\n            }\n        });\n\n        this.tags = subPalettes.tags;\n    }\n\n    getLongestSubPalette () {\n        const s = this.subPalettes;\n        for (let i = 20; i >= 0; i--) {\n            if (s[i]) {\n                return s[i];\n            }\n        }\n    }\n\n    isQualitative () {\n        return this.tags.includes('qualitative');\n    }\n\n    isQuantitative () {\n        return this.tags.includes('quantitative');\n    }\n}\n","import Palette from './Palette';\n\n/**\n * Reverse the provided Palette.\n *\n * @param {Palette} palette - Numeric expression to compute the natural logarithm\n * @return {Palette}\n *\n * @example <caption>Invert a Palette.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   filter: s.ramp(s.prop('type'), s.reverse(s.palettes.PRISM));\n * });\n *\n * @example <caption>Invert a Palette. (String)</caption>\n * const viz = new carto.Viz(`\n *   color: ramp($type, reverse(PRISM))\n * `);\n *\n * @memberof carto.expressions\n * @name reverse\n * @function\n * @api\n */\n\nexport default class Reverse extends Palette {\n    constructor (palette) {\n        super(palette.name, palette.subPalettes);\n        this.type = 'palette';\n        this._originalPalette = palette;\n        this.tags = palette.tags;\n        this.subPalettes = new Proxy(palette.subPalettes, {\n            get: (target, name) => {\n                if (Number.isFinite(Number(name)) && Array.isArray(target[name])) {\n                    return this._reversePalette(target[name]);\n                }\n                return target[name];\n            }\n        });\n    }\n\n    getLongestSubPalette () {\n        return this._reversePalette(this._originalPalette.getLongestSubPalette());\n    }\n\n    _reversePalette (palette) {\n        if (this.isQualitative()) {\n            // Last color is 'others', therefore, we shouldn't change the order of that one\n            const copy = [...palette];\n            const others = copy.pop();\n            return [...copy.reverse(), others];\n        }\n        return [...palette].reverse();\n    }\n}\n","import BaseExpression from '../base';\nimport { implicitCast, checkLooseType, checkType } from '../utils';\n\n/**\n * Evaluates to a rgb color.\n *\n * @param {Number} r - The amount of red in the color in the [0, 255] range. Numeric expression.\n * @param {Number} g - The amount of green in the color in the [0, 255] range. Numeric expression.\n * @param {Number} b - The amount of blue in the color in the [0, 255] range. Numeric expression.\n * @return {Color}\n *\n * @example <caption>Display blue points.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   color: s.rgb(0, 0, 255)\n * });\n *\n * @example <caption>Display blue points. (String)</caption>\n * const viz = new carto.Viz(`\n *   color: rgb(0, 0, 255)\n * `);\n *\n * @memberof carto.expressions\n * @name rgb\n * @function\n * @api\n */\nexport const RGB = genRGB('rgb', false);\n\n/**\n * Evaluates to a rgba color.\n *\n * @param {Number} r - The amount of red in the color in the [0, 255] range. Numeric expression.\n * @param {Number} g - The amount of green in the color in the [0, 255] range. Numeric expression.\n * @param {Number} b - The amount of blue in the color in the [0, 255] range. Numeric expression.\n * @param {Number} a - The alpha value of the color in the [0, 1] range. Numeric expression.\n * @return {Color}\n *\n * @example <caption>Display blue points.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   color: s.rgba(0, 0, 255, 1)\n * });\n *\n * @example <caption>Display blue points. (String)</caption>\n * const viz = new carto.Viz(`\n *   color: rgba(0, 0, 255, 1)\n * `);\n *\n * @memberof carto.expressions\n * @name rgba\n * @function\n * @api\n */\nexport const RGBA = genRGB('rgba', true);\n\n// TODO refactor to uniformcolor, write color (plain, literal)\n\nfunction genRGB (name, alpha) {\n    return class RGBA extends BaseExpression {\n        constructor (r, g, b, a) {\n            [r, g, b, a] = [r, g, b, a].map(implicitCast);\n            checkLooseType(name, 'r', 0, 'number', r);\n            checkLooseType(name, 'g', 1, 'number', g);\n            checkLooseType(name, 'b', 2, 'number', b);\n\n            const children = { r, g, b };\n            if (alpha) {\n                checkLooseType(name, 'a', 3, 'number', a);\n                children.a = a;\n            }\n            super(children);\n            this.type = 'color';\n            this.inlineMaker = inline => `vec4(${inline.r}/255., ${inline.g}/255., ${inline.b}/255., ${alpha ? inline.a : '1.'})`;\n        }\n        get value () {\n            return this.eval();\n        }\n        eval (f) {\n            return {\n                r: this.r.eval(f),\n                g: this.g.eval(f),\n                b: this.b.eval(f),\n                a: alpha ? this.a.eval(f) : 1\n            };\n        }\n        _bindMetadata (meta) {\n            super._bindMetadata(meta);\n            checkType(name, 'r', 0, 'number', this.r);\n            checkType(name, 'g', 1, 'number', this.g);\n            checkType(name, 'b', 2, 'number', this.b);\n            if (alpha) {\n                checkType('rgba', 'a', 3, 'number', this.a);\n            }\n        }\n    };\n}\n","import { implicitCast } from './utils';\nimport BaseExpression from './base';\n\n// TODO type checking\n\nexport class ILinear extends genInterpolator(inner => inner, undefined, inner => inner) { }\n\nexport class Cubic extends genInterpolator(\n    inner => `cubicEaseInOut(${inner})`,\n    `\n    #ifndef CUBIC\n    #define CUBIC\n    float cubicEaseInOut(float p){\n        if (p < 0.5) {\n            return 4. * p * p * p;\n        }else {\n            float f = ((2. * p) - 2.);\n            return 0.5 * f * f * f + 1.;\n        }\n    }\n    #endif\n`,\n    inner => inner // TODO FIXME\n) { }\n\nexport class BounceEaseIn extends genInterpolator(\n    inner => `BounceEaseIn(${inner})`,\n    `\n    #ifndef BOUNCE_EASE_IN\n    #define BOUNCE_EASE_IN\n    float BounceEaseIn_BounceEaseOut(float p)\n    {\n        if(p < 4./11.0)\n        {\n            return (121. * p * p)/16.0;\n        }\n        else if(p < 8./11.0)\n        {\n            return (363./40.0 * p * p) - (99./10.0 * p) + 17./5.0;\n        }\n        else if(p < 9./10.0)\n        {\n            return (4356./361.0 * p * p) - (35442./1805.0 * p) + 16061./1805.0;\n        }\n        else\n        {\n            return (54./5.0 * p * p) - (513./25.0 * p) + 268./25.0;\n        }\n    }\n    float BounceEaseIn(float p)\n    {\n        return 1. - BounceEaseOut(1. - p);\n    }\n    #endif\n\n`,\n    inner => inner // TODO FIXME\n) { }\n\n// Interpolators\nfunction genInterpolator (inlineMaker, preface, jsEval) {\n    const fn = class Interpolator extends BaseExpression {\n        constructor (m) {\n            m = implicitCast(m);\n            super({ m });\n        }\n        eval (feature) {\n            return jsEval(this.m.eval(feature));\n        }\n        _bindMetadata (meta) {\n            super._bindMetadata(meta);\n            if (this.m.type !== 'number') {\n                throw new Error(`Blending cannot be performed by '${this.m.type}'`);\n            }\n            this.type = 'number';\n            this._setGenericGLSL(inline => inlineMaker(inline.m), preface);\n        }\n    };\n    fn.type = 'interpolator';\n    return fn;\n}\n","import BaseExpression from './base';\nimport { checkExpression, checkLooseType, implicitCast, checkType } from './utils';\nimport { globalMin, globalMax } from '../expressions';\n\n/**\n* Linearly interpolates the value of a given input between a minimum and a maximum. If `min` and `max` are not defined they will\n* default to `globalMin(input)` and `globalMax(input)`.\n*\n* @param {Number|Date} input - The input to be evaluated and interpolated, can be a numeric property or a date property\n* @param {Number|Date} [min=globalMin(input)] - Numeric or date expression pointing to the lower limit\n* @param {Number|Date} [max=globalMax(input)] - Numeric or date expression pointing to the higher limit\n* @return {Number|Date}\n*\n* @example <caption> Color by $speed using the CARTOColor Prism by assigning the first color in Prism to features with speeds of 10 or less, the last color in Prism to features with speeds of 100 or more and a interpolated value for the speeds in between.</caption>\n* const s = carto.expressions;\n* const viz = new carto.Viz({\n*   color: s.ramp(s.linear(s.prop('speed'), 10, 100), s.palettes.PRISM)\n* });\n*\n* @example <caption> Color by $speed using the CARTOColor Prism by assigning the first color in Prism to features with speeds of 10 or less, the last color in Prism to features with speeds of 100 or more and a interpolated value for the speeds in between. (String)</caption>\n* const viz = new carto.Viz(`\n*   color: ramp(linear($speed, 10, 100), PRISM)\n* `);\n*\n* @memberof carto.expressions\n* @name linear\n* @function\n* @api\n*/\nexport default class Linear extends BaseExpression {\n    constructor (input, min, max) {\n        input = implicitCast(input);\n\n        if (min === undefined && max === undefined) {\n            min = globalMin(input);\n            max = globalMax(input);\n        }\n\n        min = implicitCast(min);\n        max = implicitCast(max);\n\n        checkExpression('linear', 'input', 0, input);\n        checkExpression('linear', 'min', 1, min);\n        checkExpression('linear', 'max', 2, max);\n\n        super({ input, min, max });\n\n        if (this.min.type !== 'time') {\n            checkLooseType('linear', 'input', 0, 'number', this.input);\n            checkLooseType('linear', 'min', 1, 'number', this.min);\n            checkLooseType('linear', 'max', 2, 'number', this.max);\n        }\n        this.type = 'number';\n    }\n\n    eval (feature) {\n        if (this.input.type === 'date') {\n            const input = this.input.eval(feature);\n\n            const min = this.min.eval().getTime();\n            const max = this.max.eval().getTime();\n\n            const metadata = this._metadata;\n            const inputMin = metadata.properties[this.input.name].min.getTime();\n            const inputMax = metadata.properties[this.input.name].max.getTime();\n            const inputDiff = inputMax - inputMin;\n\n            const smin = (min - inputMin) / inputDiff;\n            const smax = (max - inputMin) / inputDiff;\n            return (input - smin) / (smax - smin);\n        }\n        const v = this.input.eval(feature);\n        const min = this.min.eval(feature);\n        const max = this.max.eval(feature);\n        return (v - min) / (max - min);\n    }\n\n    _bindMetadata (metadata) {\n        super._bindMetadata(metadata);\n\n        if (this.input.type === 'date') {\n            const min = this.min.eval().getTime();\n            const max = this.max.eval().getTime();\n\n            this._metadata = metadata;\n            const inputMin = metadata.properties[this.input.name].min.getTime();\n            const inputMax = metadata.properties[this.input.name].max.getTime();\n            const inputDiff = inputMax - inputMin;\n\n            const smin = (min - inputMin) / inputDiff;\n            const smax = (max - inputMin) / inputDiff;\n            this.inlineMaker = (inline) => `((${inline.input}-(${smin.toFixed(20)}))/(${(smax - smin).toFixed(20)}))`;\n        } else {\n            checkType('linear', 'input', 0, 'number', this.input);\n            checkType('linear', 'min', 1, 'number', this.min);\n            checkType('linear', 'max', 2, 'number', this.max);\n\n            this.inlineMaker = (inline) => `((${inline.input}-${inline.min})/(${inline.max}-${inline.min}))`;\n        }\n    }\n}\n","import BaseExpression from './base';\nimport { number } from '../expressions';\n\n/**\n * Get the current timestamp. This is an advanced form of animation, `animation` expression is preferred.\n *\n * @return {Number}\n *\n * @example <caption>Update width during the time.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.mod(s.now(), 10)\n * });\n *\n * @example <caption>Update width during the time. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: now() % 10\n * `);\n *\n * @memberof carto.expressions\n * @name now\n * @function\n * @api\n */\nexport default class Now extends BaseExpression {\n    constructor () {\n        super({ now: number(0) });\n        this.type = 'number';\n        super.inlineMaker = inline => inline.now;\n    }\n    eval () {\n        return this.now.expr;\n    }\n    isAnimated () {\n        return true;\n    }\n    _setTimestamp (timestamp) {\n        this.now.expr = timestamp;\n    }\n}\n","import BaseExpression from './base';\nimport { checkInstance } from './utils';\n\n/**\n * Order ascending by a provided expression. NOTE: only works with `width()`.\n *\n * @param {carto.expressions.Width} by - must be `width()`\n * @return {Order}\n *\n * @example <caption>Ascending order based on width.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   order: s.asc(s.width())\n * });\n *\n * @example <caption>Ascending order based on width. (String)</caption>\n * const viz = new carto.Viz(`\n *   order: asc(width())\n * `);\n *\n * @memberof carto.expressions\n * @name asc\n * @function\n * @IGNOREapi\n */\nexport class Asc extends BaseExpression {\n    constructor (by) {\n        super({});\n        checkInstance('asc', 'by', 0, Width, by);\n        this.type = 'orderer';\n    }\n}\n\n/**\n * Order descending by a provided expression. NOTE: only works with `width()`.\n *\n * @param {carto.expressions.Width} by - must be `width()`\n * @return {Order}\n *\n * @example <caption>Descending order based on width.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   order: s.desc(s.width())\n * });\n *\n * @example <caption>Descending order based on width. (String)</caption>\n * const viz = new carto.Viz(`\n *   order: desc(width())\n * `);\n *\n * @memberof carto.expressions\n * @name desc\n * @function\n * @IGNOREapi\n */\nexport class Desc extends BaseExpression {\n    constructor (by) {\n        super({});\n        checkInstance('desc', 'by', 0, Width, by);\n        this.type = 'orderer';\n    }\n}\n\n/**\n * No order expression.\n *\n * @return {Order}\n *\n * @example <caption>No order.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   order: s.noOrder()\n * });\n *\n * @example <caption>No order. (String)</caption>\n * const viz = new carto.Viz(`\n *   order: noOrder()\n * `);\n *\n * @memberof carto.expressions\n * @name noOrder\n * @function\n * @IGNOREapi\n */\nexport class NoOrder extends BaseExpression {\n    constructor () {\n        super({});\n        this.type = 'orderer';\n    }\n}\n\n/**\n * Return the expression assigned in the `width` property. ONLY usable in an `order:` property.\n *\n * @return {carto.expressions.Width}\n *\n * @example <caption>Ascending order based on width.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   order: s.asc(s.width())\n * });\n *\n * @example <caption>Ascending order based on width. (String)</caption>\n * const viz = new carto.Viz(`\n *   order: asc(width())\n * `);\n *\n * @memberof carto.expressions\n * @name width\n * @function\n * @IGNOREapi\n */\nexport class Width extends BaseExpression {\n    constructor () {\n        super({});\n        this.type = 'propertyReference';\n    }\n}\n","import BaseExpression from './base';\nimport { checkLooseType, checkType, implicitCast } from './utils';\n\n/**\n * Placement. Define an image offset relative to its size. Where:\n * - `symbolPlacement: placement(1,1)` means to align the bottom left corner of the image with the point center.\n * - `symbolPlacement: placement(0,0)` means to align the center of the image with the point center.\n * - `symbolPlacement: placement(-1,-1)` means to align the top right corner of the image with the point center.\n *\n *           |1\n *           |\n *           |\n * -1 -------+------- 1\n *           |\n *           |\n *         -1|\n *\n * You can also use `align_center` and `align_bottom` to set the simbol placement as follows:\n * - `symbolPlacement: align_bottom` is equivalent to `symbolPlacement: placement(0, 1)`\n * - `symbolPlacement: align_center` is equivalent to `symbolPlacement: placement(0, 0)`\n *\n * @param {number} x - first numeric expression that indicates the image offset in the X direction.\n * @param {number} y - second numeric expression that indicates the image offset in the Y direction.\n * @return {Placement} Numeric expression\n *\n * @example <caption>Setting the aligment to the top corner of the image.</caption>\n *   symbol: image('./marker.svg')\n *   symbolPlacement: placement(1, 0)\n *\n * @memberof carto.expressions\n * @name placement\n * @function\n * @api\n */\n\nexport default class Placement extends BaseExpression {\n    constructor (x, y) {\n        x = implicitCast(x);\n        y = implicitCast(y);\n        checkLooseType('placement', 'x', 0, 'number', x);\n        checkLooseType('placement', 'y', 1, 'number', y);\n        super({ x, y });\n        this.inlineMaker = inline => `vec2(${inline.x}, ${inline.y})`;\n        this.type = 'placement';\n    }\n    eval (v) {\n        return [this.x.eval(v), this.y.eval(v)];\n    }\n    _bindMetadata (meta) {\n        super._bindMetadata(meta);\n        checkType('placement', 'x', 0, 'number', this.x);\n        checkType('placement', 'y', 1, 'number', this.y);\n    }\n}\n","import BaseExpression from './base';\nimport { implicitCast, checkLooseType, checkExpression, checkType, clamp, checkInstance } from './utils';\n\nimport { interpolateRGBAinCieLAB } from '../colorspaces';\nimport NamedColor from './color/NamedColor';\nimport Buckets from './buckets';\nimport Property from './basic/property';\nimport Classifier from './classification/Classifier';\nimport ImageList from './ImageList';\nimport Linear from './linear';\nimport Top from './top';\n\nconst paletteTypes = {\n    PALETTE: 'palette',\n    COLOR_ARRAY: 'color-array',\n    NUMBER_ARRAY: 'number-array',\n    IMAGE: 'image'\n};\n\nconst rampTypes = {\n    COLOR: 'color',\n    NUMBER: 'number'\n};\n\nconst inputTypes = {\n    NUMBER: 'number',\n    CATEGORY: 'category'\n};\n\nconst COLOR_ARRAY_LENGTH = 256;\nconst MAX_BYTE_VALUE = 255;\n\n/**\n* Create a ramp: a mapping between an input (a numeric or categorical expression) and an output (a color palette or a numeric palette, to create bubble maps)\n*\n* Categories to colors\n* Categorical expressions can be used as the input for `ramp` in combination with color palettes. If the number of categories exceeds the number of available colors in the palette new colors will be generated by\n* using CieLAB interpolation.\n*\n* Categories to numeric\n* Categorical expression can be used as the input for `ramp` in combination with numeric palettes. If the number of input categories doesn't match the number of numbers in the numeric palette, linear interpolation will be used.\n*\n* Numeric expressions to colors\n* Numeric expressions can be used as the input for `ramp` in combination with color palettes. Colors will be generated by using CieLAB interpolation.\n*\n* Numeric expressions to numeric\n* Numeric expressions can be used as the input for `ramp` in combination with numeric palettes. Linear interpolation will be used to generate intermediate output values.\n*\n* @param {Number|Category} input - The input expression to give a color\n* @param {Palette|Color[]|Number[]} palette - The color palette that is going to be used\n* @return {Number|Color}\n*\n* @example <caption>Mapping categories to colors and numbers</caption>\n* const s = carto.expressions;\n* const viz = new carto.Viz({\n*   width: s.ramp(s.buckets(s.prop('dn'), [20, 50, 120]), [1, 4, 8])\n*   color: s.ramp(s.buckets(s.prop('dn'), [20, 50, 120]), s.palettes.PRISM)\n* });\n*\n* @example <caption>Mapping categories to colors and numbers (String)</caption>\n* const viz = new carto.Viz(`\n*   width: ramp(buckets($dn, [20, 50, 120]), [1, 10,4])\n*   color: ramp(buckets($dn, [20, 50, 120]), prism)\n* `);\n*\n*\n* @example <caption>Mapping numeric expressions to colors and numbers</caption>\n* const s = carto.expressions;\n* const viz = new carto.Viz({\n*   width: s.ramp(s.linear(s.prop('dn'), 40, 100), [1, 8])\n*   color: s.ramp(s.linear(s.prop('dn'), 40, 100), s.palettes.PRISM)\n* });\n*\n* @example <caption>Mapping numeric expressions to colors and numbers (String)</caption>\n* const viz = new carto.Viz(`\n*   width: ramp(linear($dn, 40, 100), [1, 10,4])\n*   color: ramp(linear($dn, 40, 100), prism)\n* `);\n*\n* @memberof carto.expressions\n* @name ramp\n* @function\n* @api\n*/\nexport default class Ramp extends BaseExpression {\n    constructor (input, palette) {\n        input = implicitCast(input);\n        palette = implicitCast(palette);\n\n        checkExpression('ramp', 'input', 0, input);\n        checkLooseType('ramp', 'input', 0, Object.values(inputTypes), input);\n        checkLooseType('ramp', 'palette', 1, Object.values(paletteTypes), palette);\n\n        if (palette.type === paletteTypes.IMAGE) {\n            checkInstance('ramp', 'palette', 1, ImageList, palette);\n            checkLooseType('ramp', 'input', 0, inputTypes.CATEGORY, input);\n        }\n\n        super({ input: input });\n        this.minKey = 0;\n        this.maxKey = 1;\n        this.palette = palette;\n        this.type = palette.type === paletteTypes.NUMBER_ARRAY ? rampTypes.NUMBER : rampTypes.COLOR;\n\n        try {\n            if (palette.type === paletteTypes.NUMBER_ARRAY) {\n                this.palette.floats = this.palette.eval();\n            } else if (palette.type === paletteTypes.COLOR_ARRAY) {\n                this.palette.colors = this.palette.eval();\n            }\n        } catch (error) {\n            throw new Error('Palettes must be formed by constant expressions, they cannot depend on feature properties');\n        }\n\n        this.defaultOthersColor = new NamedColor('gray');\n    }\n\n    loadImages () {\n        return Promise.all([this.input.loadImages(), this.palette.loadImages()]);\n    }\n\n    _setUID (idGenerator) {\n        super._setUID(idGenerator);\n        this.palette._setUID(idGenerator);\n    }\n\n    eval (feature) {\n        const texturePixels = this._computeTextureIfNeeded();\n        const input = this.input.eval(feature);\n\n        const numValues = texturePixels.length - 1;\n        const m = (input - this.minKey) / (this.maxKey - this.minKey);\n\n        const color = this.type === rampTypes.NUMBER\n            ? this._getValue(texturePixels, numValues, m)\n            : this._getColorValue(texturePixels, m);\n\n        return color;\n    }\n\n    _getValue (texturePixels, numValues, m) {\n        const lowIndex = clamp(Math.floor(numValues * m), 0, numValues);\n        const highIndex = clamp(Math.ceil(numValues * m), 0, numValues);\n        const fract = numValues * m - Math.floor(numValues * m);\n        const low = texturePixels[lowIndex];\n        const high = texturePixels[highIndex];\n\n        return Math.round(fract * high + (1 - fract) * low);\n    }\n\n    _getColorValue (texturePixels, m) {\n        const index = Math.round(m * MAX_BYTE_VALUE);\n\n        return {\n            r: Math.round(texturePixels[index * 4 + 0]),\n            g: Math.round(texturePixels[index * 4 + 1]),\n            b: Math.round(texturePixels[index * 4 + 2]),\n            a: Math.round(texturePixels[index * 4 + 3]) / MAX_BYTE_VALUE\n        };\n    }\n\n    _bindMetadata (metadata) {\n        super._bindMetadata(metadata);\n\n        if (this.input.isA(Property) && this.input.type === inputTypes.NUMBER) {\n            this.input = new Linear(this.input);\n            this.input._bindMetadata(metadata);\n        }\n\n        checkType('ramp', 'input', 0, Object.values(inputTypes), this.input);\n\n        if (this.palette.type === paletteTypes.IMAGE) {\n            checkType('ramp', 'input', 0, inputTypes.CATEGORY, this.input);\n            checkInstance('ramp', 'palette', 1, ImageList, this.palette);\n        }\n\n        this._texCategories = null;\n        this._GLtexCategories = null;\n    }\n\n    _free (gl) {\n        if (this.texture) {\n            gl.deleteTexture(this.texture);\n        }\n    }\n\n    _applyToShaderSource (getGLSLforProperty) {\n        const input = this.input._applyToShaderSource(getGLSLforProperty);\n\n        if (this.palette.type === paletteTypes.IMAGE) {\n            const images = this.palette._applyToShaderSource(getGLSLforProperty);\n\n            return {\n                preface: input.preface + images.preface,\n                inline: `${images.inline}(imageUV, ${input.inline})`\n            };\n        }\n\n        return {\n            preface: this._prefaceCode(input.preface + `\n                uniform sampler2D texRamp${this._uid};\n                uniform float keyMin${this._uid};\n                uniform float keyWidth${this._uid};`\n            ),\n\n            inline: this.palette.type === paletteTypes.NUMBER_ARRAY\n                ? `(texture2D(texRamp${this._uid}, vec2((${input.inline}-keyMin${this._uid})/keyWidth${this._uid}, 0.5)).a)`\n                : `texture2D(texRamp${this._uid}, vec2((${input.inline}-keyMin${this._uid})/keyWidth${this._uid}, 0.5)).rgba`\n        };\n    }\n\n    _getColorsFromPalette (input, palette) {\n        if (palette.type === paletteTypes.IMAGE) {\n            return palette.colors;\n        }\n\n        return palette.type === paletteTypes.PALETTE\n            ? _getColorsFromPaletteType(input, palette, this.maxKey, this.defaultOthersColor.eval())\n            : _getColorsFromColorArrayType(input, palette, this.maxKey, this.defaultOthersColor.eval());\n    }\n\n    _postShaderCompile (program, gl) {\n        if (this.palette.type === paletteTypes.IMAGE) {\n            this.palette._postShaderCompile(program, gl);\n            super._postShaderCompile(program, gl);\n            return;\n        }\n\n        this.input._postShaderCompile(program, gl);\n        this._getBinding(program).texLoc = gl.getUniformLocation(program, `texRamp${this._uid}`);\n        this._getBinding(program).keyMinLoc = gl.getUniformLocation(program, `keyMin${this._uid}`);\n        this._getBinding(program).keyWidthLoc = gl.getUniformLocation(program, `keyWidth${this._uid}`);\n    }\n\n    _computeTextureIfNeeded () {\n        if (this._cachedTexturePixels) {\n            return this._cachedTexturePixels;\n        }\n        this._texCategories = this.input.numCategories;\n\n        if (this.input.type === inputTypes.CATEGORY) {\n            this.maxKey = this.input.numCategories - 1;\n        }\n\n        this._cachedTexturePixels = this.type === rampTypes.COLOR\n            ? this._computeColorRampTexture()\n            : this._computeNumericRampTexture();\n\n        return this._cachedTexturePixels;\n    }\n\n    _computeColorRampTexture () {\n        const texturePixels = new Uint8Array(4 * COLOR_ARRAY_LENGTH);\n        const colors = this._getColorsFromPalette(this.input, this.palette);\n\n        for (let i = 0; i < COLOR_ARRAY_LENGTH; i++) {\n            const vColorARaw = colors[Math.floor(i / (COLOR_ARRAY_LENGTH - 1) * (colors.length - 1))];\n            const vColorBRaw = colors[Math.ceil(i / (COLOR_ARRAY_LENGTH - 1) * (colors.length - 1))];\n            const vColorA = [vColorARaw.r / (COLOR_ARRAY_LENGTH - 1), vColorARaw.g / (COLOR_ARRAY_LENGTH - 1), vColorARaw.b / (COLOR_ARRAY_LENGTH - 1), vColorARaw.a];\n            const vColorB = [vColorBRaw.r / (COLOR_ARRAY_LENGTH - 1), vColorBRaw.g / (COLOR_ARRAY_LENGTH - 1), vColorBRaw.b / (COLOR_ARRAY_LENGTH - 1), vColorBRaw.a];\n            const m = i / (COLOR_ARRAY_LENGTH - 1) * (colors.length - 1) - Math.floor(i / (COLOR_ARRAY_LENGTH - 1) * (colors.length - 1));\n            const v = interpolateRGBAinCieLAB({ r: vColorA[0], g: vColorA[1], b: vColorA[2], a: vColorA[3] }, { r: vColorB[0], g: vColorB[1], b: vColorB[2], a: vColorB[3] }, m);\n\n            texturePixels[4 * i + 0] = Math.round(v.r * MAX_BYTE_VALUE);\n            texturePixels[4 * i + 1] = Math.round(v.g * MAX_BYTE_VALUE);\n            texturePixels[4 * i + 2] = Math.round(v.b * MAX_BYTE_VALUE);\n            texturePixels[4 * i + 3] = Math.round(v.a * MAX_BYTE_VALUE);\n        }\n\n        return texturePixels;\n    }\n\n    _computeNumericRampTexture () {\n        const texturePixels = new Float32Array(COLOR_ARRAY_LENGTH);\n        const floats = this.palette.floats;\n\n        for (let i = 0; i < COLOR_ARRAY_LENGTH; i++) {\n            const vColorARaw = floats[Math.floor(i / (COLOR_ARRAY_LENGTH - 1) * (floats.length - 1))];\n            const vColorBRaw = floats[Math.ceil(i / (COLOR_ARRAY_LENGTH - 1) * (floats.length - 1))];\n            const m = i / (COLOR_ARRAY_LENGTH - 1) * (floats.length - 1) - Math.floor(i / (COLOR_ARRAY_LENGTH - 1) * (floats.length - 1));\n            texturePixels[i] = ((1.0 - m) * vColorARaw + m * vColorBRaw);\n        }\n\n        return texturePixels;\n    }\n\n    _computeGLTextureIfNeeded (gl) {\n        const texturePixels = this._computeTextureIfNeeded();\n\n        if (this._GLtexCategories !== this.input.numCategories) {\n            this._GLtexCategories = this.input.numCategories;\n\n            this.texture = gl.createTexture();\n            gl.bindTexture(gl.TEXTURE_2D, this.texture);\n\n            if (this.type === rampTypes.COLOR) {\n                gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, COLOR_ARRAY_LENGTH, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, texturePixels);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n            } else {\n                gl.texImage2D(gl.TEXTURE_2D, 0, gl.ALPHA, COLOR_ARRAY_LENGTH, 1, 0, gl.ALPHA, gl.FLOAT, texturePixels);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n            }\n\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        }\n    }\n\n    _preDraw (program, drawMetadata, gl) {\n        this.input._preDraw(program, drawMetadata, gl);\n\n        if (this.palette.type === paletteTypes.IMAGE) {\n            this.palette._preDraw(program, drawMetadata, gl);\n            return;\n        }\n\n        gl.activeTexture(gl.TEXTURE0 + drawMetadata.freeTexUnit);\n        this._computeGLTextureIfNeeded(gl);\n        gl.bindTexture(gl.TEXTURE_2D, this.texture);\n        gl.uniform1i(this._getBinding(program).texLoc, drawMetadata.freeTexUnit);\n        gl.uniform1f(this._getBinding(program).keyMinLoc, (this.minKey));\n        gl.uniform1f(this._getBinding(program).keyWidthLoc, (this.maxKey) - (this.minKey));\n        drawMetadata.freeTexUnit++;\n    }\n}\n\nfunction _getColorsFromPaletteType (input, palette, numCategories, defaultOthersColor) {\n    switch (true) {\n        case input.isA(Buckets):\n            return _getColorsFromPaletteTypeBuckets(palette, numCategories, defaultOthersColor);\n        case input.isA(Top):\n            return _getColorsFromPaletteTypeTop(palette, numCategories, defaultOthersColor);\n        default:\n            return _getColorsFromPaletteTypeDefault(input, palette, defaultOthersColor);\n    }\n}\n\nfunction _getColorsFromPaletteTypeBuckets (palette, numCategories, defaultOthersColor) {\n    let colors = _getSubPalettes(palette, numCategories);\n\n    if (palette.isQuantitative()) {\n        colors.push(defaultOthersColor);\n    }\n\n    if (palette.isQualitative()) {\n        defaultOthersColor = colors[numCategories];\n    }\n\n    return _avoidShowingInterpolation(numCategories, colors, defaultOthersColor);\n}\n\nfunction _getColorsFromPaletteTypeTop (palette, numCategories, defaultOthersColor) {\n    let colors = _getSubPalettes(palette, numCategories);\n\n    if (palette.isQualitative()) {\n        defaultOthersColor = colors[colors.length - 1];\n    }\n\n    return _avoidShowingInterpolation(numCategories, colors, defaultOthersColor);\n}\n\nfunction _getColorsFromPaletteTypeDefault (input, palette, defaultOthersColor) {\n    let colors = _getSubPalettes(palette, input.numCategories);\n\n    if (palette.isQualitative()) {\n        colors.pop();\n        defaultOthersColor = colors[input.numCategories];\n    }\n\n    if (input.numCategories === undefined) {\n        return colors;\n    }\n\n    return _avoidShowingInterpolation(input.numCategories, colors, defaultOthersColor);\n}\n\nfunction _getSubPalettes (palette, numCategories) {\n    return palette.subPalettes[numCategories]\n        ? palette.subPalettes[numCategories]\n        : palette.getLongestSubPalette();\n}\n\nfunction _getColorsFromColorArrayType (input, palette, numCategories, defaultOthersColor) {\n    return input.type === inputTypes.CATEGORY\n        ? _getColorsFromColorArrayTypeCategorical(input, numCategories, palette.colors, defaultOthersColor)\n        : _getColorsFromColorArrayTypeNumeric(input.numCategories, palette.colors);\n}\n\nfunction _getColorsFromColorArrayTypeCategorical (input, numCategories, colors, defaultOthersColor) {\n    switch (true) {\n        case input.isA(Classifier) && numCategories < colors.length:\n            return colors;\n        case input.isA(Property):\n            return colors;\n        case numCategories < colors.length:\n            return _avoidShowingInterpolation(numCategories, colors, colors[numCategories]);\n        case numCategories > colors.length:\n            return _addothersColorToColors(colors, defaultOthersColor);\n        default:\n            colors = _addothersColorToColors(colors, defaultOthersColor);\n            return _avoidShowingInterpolation(numCategories, colors, defaultOthersColor);\n    }\n}\n\nfunction _getColorsFromColorArrayTypeNumeric (numCategories, colors) {\n    let othersColor;\n\n    if (numCategories < colors.length) {\n        othersColor = colors[numCategories];\n        return _avoidShowingInterpolation(numCategories, colors, othersColor);\n    }\n\n    if (numCategories === colors.length) {\n        othersColor = colors[colors.length - 1];\n        return _avoidShowingInterpolation(numCategories, colors, othersColor);\n    }\n\n    return colors;\n}\n\nfunction _addothersColorToColors (colors, othersColor) {\n    return [...colors, othersColor];\n}\n\nfunction _avoidShowingInterpolation (numCategories, colors, defaultOthersColor) {\n    const colorArray = [];\n\n    for (let i = 0; i < colors.length; i++) {\n        if (i < numCategories) {\n            colorArray.push(colors[i]);\n        } else if (i === numCategories) {\n            colorArray.push(defaultOthersColor);\n        }\n    }\n\n    return colorArray;\n}\n","import BaseExpression from './base';\nimport * as util from '../../../utils/util';\n\n/**\n * Time contant expression\n *\n * @param {Date|string} date - The date from a JavaScript Date() object or encoded as a string\n * @return {Date}\n *\n * @example <caption>Filter by a date between dates.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   filter: s.between(s.prop('date'), s.time('2022-03-09T00:00:00Z'), s.time('2033-08-12T00:00:00Z')\n * });\n *\n * @example <caption>Filter by a date between dates. (String)</caption>\n * const viz = new carto.Viz(`\n *   filter: time('2022-03-09T00:00:00Z') < $date < time('2033-08-12T00:00:00Z')\n * `);\n *\n * @memberof carto.expressions\n * @name time\n * @function\n * @api\n */\nexport default class Time extends BaseExpression {\n    constructor (date) {\n        super({});\n        // TODO improve type check\n        this.type = 'time';\n        this.date = util.castDate(date);\n        this.inlineMaker = () => undefined;\n    }\n    get value () {\n        return this.eval();\n    }\n    eval () {\n        return this.date;\n    }\n    isAnimated () {\n        return false;\n    }\n}\n","import BaseExpression from './base';\nimport { checkType, checkLooseType, implicitCast, checkFeatureIndependent, checkInstance } from './utils';\nimport Property from './basic/property';\nimport { number } from '../expressions';\n\n// Careful! This constant must match with the shader code of the Top expression\nconst MAX_TOP_BUCKETS = 16;\n\n/**\n * Get the top `n` properties, aggregating the rest into an \"others\" bucket category.\n *\n * @param {Category} property - Column of the table\n * @param {number} n - Number of top properties to be returned, the maximum value is 16, values higher than that will result in an error\n * @return {Category}\n *\n * @example <caption>Use top 3 categories to define a color ramp.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   color: s.ramp(s.top(s.prop('category'), 3), s.palettes.VIVID)\n * });\n *\n * @example <caption>Use top 3 categories to define a color ramp. (String)</caption>\n * const viz = new carto.Viz(`\n *   color: ramp(top($category, 3), VIVID)\n * `);\n *\n * @memberof carto.expressions\n * @name top\n * @function\n * @api\n */\nexport default class Top extends BaseExpression {\n    constructor (property, buckets) {\n        buckets = implicitCast(buckets);\n        checkInstance('top', 'property', 0, Property, property);\n        checkLooseType('top', 'buckets', 1, 'number', buckets);\n        checkFeatureIndependent('top', 'buckets', 1, buckets);\n        const children = { property, buckets };\n        for (let i = 0; i < MAX_TOP_BUCKETS; i++) {\n            children[`_top${i}`] = number(0);\n        }\n        super(children);\n        this.type = 'category';\n    }\n    eval (feature) {\n        const catID = this._meta.categoryToID.get(this.property.eval(feature));\n        const buckets = this.numBuckets;\n        const metaColumn = this._meta.properties[this.property.name];\n        const orderedCategoryNames = [...metaColumn.categories].sort((a, b) =>\n            b.frequency - a.frequency\n        );\n\n        let ret;\n        orderedCategoryNames.map((name, i) => {\n            if (i === catID) {\n                ret = i < buckets ? this._meta.IDToCategory.get(i) : 'CARTOVL_TOP_OTHERS_BUCKET';\n            }\n        });\n        return ret;\n    }\n    _bindMetadata (metadata) {\n        checkFeatureIndependent('top', 'buckets', 1, this.buckets);\n        super._bindMetadata(metadata);\n        checkType('top', 'property', 0, 'category', this.property);\n        checkType('top', 'buckets', 1, 'number', this.buckets);\n        this._meta = metadata;\n        this._textureBuckets = null;\n    }\n    get numCategories () {\n        return this.numBuckets + 1;\n    }\n    get numBuckets () {\n        let buckets = Math.round(this.buckets.eval());\n        if (buckets > this.property.numCategories) {\n            buckets = this.property.numCategories;\n        }\n        if (buckets > MAX_TOP_BUCKETS) {\n            // setTimeout is used here because throwing within the renderer stack leaves the state in an invalid state,\n            // making this error an unrecoverable error, within the setTimeout the error is recoverable\n            const prev = this.buckets.eval();\n            setTimeout(() => {\n                throw new Error(`top() function has a limit of ${MAX_TOP_BUCKETS} buckets but '${prev}' buckets were specified`);\n            });\n            buckets = 0;\n        }\n        return buckets;\n    }\n    _applyToShaderSource (getGLSLforProperty) {\n        const childSources = {};\n        this.childrenNames.forEach(name => { childSources[name] = this[name]._applyToShaderSource(getGLSLforProperty); });\n        return {\n            preface: this._prefaceCode(Object.values(childSources).map(s => s.preface).join('') + `\n            float top${this._uid}(float id){\n                float r = 0.;\n                if (${childSources._top0.inline} == id){\n                    r = 1.;\n                } else if (${childSources._top1.inline} == id){\n                    r = 2.;\n                } else if (${childSources._top2.inline} == id){\n                    r = 3.;\n                } else if (${childSources._top3.inline} == id){\n                    r = 4.;\n                } else if (${childSources._top4.inline} == id){\n                    r = 5.;\n                } else if (${childSources._top5.inline} == id){\n                    r = 6.;\n                } else if (${childSources._top6.inline} == id){\n                    r = 7.;\n                } else if (${childSources._top7.inline} == id){\n                    r = 8.;\n                } else if (${childSources._top8.inline} == id){\n                    r = 9.;\n                } else if (${childSources._top9.inline} == id){\n                    r = 10.;\n                } else if (${childSources._top10.inline} == id){\n                    r = 11.;\n                } else if (${childSources._top11.inline} == id){\n                    r = 12.;\n                } else if (${childSources._top12.inline} == id){\n                    r = 13.;\n                } else if (${childSources._top13.inline} == id){\n                    r = 14.;\n                } else if (${childSources._top14.inline} == id){\n                    r = 15.;\n                } else if (${childSources._top15.inline} == id){\n                    r = 16.;\n                }\n                return r;\n            }`),\n            inline: `top${this._uid}(${childSources.property.inline})`\n        };\n    }\n    _preDraw (program, drawMetadata, gl) {\n        super._preDraw(program, drawMetadata, gl);\n        const buckets = this.numBuckets;\n        const metaColumn = this._meta.properties[this.property.name];\n\n        const orderedCategoryNames = [...metaColumn.categories].sort((a, b) =>\n            b.frequency - a.frequency\n        );\n\n        for (let i = 0; i < MAX_TOP_BUCKETS; i++) {\n            this[`_top${i}`].expr = Number.POSITIVE_INFINITY;\n        }\n\n        orderedCategoryNames.map((cat, i) => {\n            if (i < buckets) {\n                this[`_top${i}`].expr = (i + 1);\n            }\n        });\n    }\n    // TODO _free\n}\n","import BaseExpression from './base';\nimport { checkNumber, getStringErrorPreface } from './utils';\n\n/**\n * Transition returns a number from zero to one based on the elapsed number of milliseconds since the viz was instantiated.\n * The animation is not cyclic. It will stick to one once the elapsed number of milliseconds reach the animation's duration.\n *\n * @param {number} duration - Animation duration in milliseconds\n * @return {Number}\n *\n * @memberof carto.expressions\n * @name transition\n * @function\n * @api\n */\n// TODO refactor to use uniformfloat class\nexport default class Transition extends BaseExpression {\n    constructor (duration) {\n        checkNumber('transition', 'duration', 0, duration);\n        if (duration < 0) {\n            throw new Error(getStringErrorPreface('transition', 'duration', 0) + 'duration must be greater than or equal to 0');\n        }\n        super({});\n        this.aTime = Date.now();\n        this.bTime = this.aTime + Number(duration);\n        this.type = 'number';\n    }\n    eval () {\n        const time = Date.now();\n        this.mix = (time - this.aTime) / (this.bTime - this.aTime);\n        return Math.min(this.mix, 1.0);\n    }\n    isAnimated () {\n        return !this.mix || this.mix <= 1.0;\n    }\n    _applyToShaderSource () {\n        return {\n            preface: this._prefaceCode(`uniform float anim${this._uid};\\n`),\n            inline: `anim${this._uid}`\n        };\n    }\n    _postShaderCompile (program, gl) {\n        this._getBinding(program).uniformLocation = gl.getUniformLocation(program, `anim${this._uid}`);\n    }\n    _preDraw (program, drawMetadata, gl) {\n        const time = Date.now();\n        this.mix = (time - this.aTime) / (this.bTime - this.aTime);\n        if (this.mix > 1.0) {\n            gl.uniform1f(this._getBinding(program).uniformLocation, 1);\n        } else {\n            gl.uniform1f(this._getBinding(program).uniformLocation, this.mix);\n        }\n    }\n}\n","import { implicitCast, checkLooseType, checkType } from './utils';\nimport BaseExpression from './base';\n\n/**\n * Compute the natural logarithm (base e) of a number x.\n *\n * @param {Number} x - Numeric expression to compute the natural logarithm\n * @return {Number}\n *\n * @example <caption>Natural Logarithm.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.log(10)  // 2.302585092994046\n * });\n *\n * @example <caption>Natural Logarithm. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: log(10)\n * `);\n *\n * @memberof carto.expressions\n * @name log\n * @function\n * @api\n */\nexport const Log = genUnaryOp('log', x => Math.log(x), x => `log(${x})`);\n\n/**\n * Compute the square root of a number x.\n *\n * @param {Number} x - Numeric expression to compute the square root\n * @return {Number}\n *\n * @example <caption>Square root.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.sqrt(4)  // 2\n * });\n *\n * @example <caption>Square root. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: sqrt(4)\n * `);\n *\n * @memberof carto.expressions\n * @name sqrt\n * @function\n * @api\n */\nexport const Sqrt = genUnaryOp('sqrt', x => Math.sqrt(x), x => `sqrt(${x})`);\n\n/**\n * Compute the sine of a number x.\n *\n * @param {Number} x - Numeric expression to compute the sine in radians\n * @return {Number}\n *\n * @example <caption>Sin.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.sin(Math.PI/2)  // 1\n * });\n *\n * @example <caption>Sin. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: sin(PI/2)\n * `);\n *\n * @memberof carto.expressions\n * @name sin\n * @function\n * @api\n */\nexport const Sin = genUnaryOp('sin', x => Math.sin(x), x => `sin(${x})`);\n\n/**\n * Compute the cosine of a number x.\n *\n * @param {Number} x - Numeric expression to compute the cosine in radians\n * @return {Number}\n *\n * @example <caption>Cos.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.cos(0)  // 1\n * });\n *\n * @example <caption>Cos. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: cos(0)\n * `);\n *\n * @memberof carto.expressions\n * @name cos\n * @function\n * @api\n */\nexport const Cos = genUnaryOp('cos', x => Math.cos(x), x => `cos(${x})`);\n\n/**\n * Compute the tangent of a number x.\n *\n * @param {Number} x - Numeric expression to compute the tangent in radians\n * @return {Number}\n *\n * @example <caption>Tan</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.tan(0)  // 0\n * });\n *\n * @example <caption>Tan. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: tan(0)\n * `);\n *\n * @memberof carto.expressions\n * @name tan\n * @function\n * @api\n */\nexport const Tan = genUnaryOp('tan', x => Math.tan(x), x => `tan(${x})`);\n\n/**\n * Compute the sign of a number x, indicating whether the number is positive, negative or zero\n * This means this function will return 1 if the number is positive, -1 if the number is negative\n * 0 if the number is 0 and -0 if the number is -0.\n *\n * @param {Number} x - Numeric expression to compute the sign\n * @return {Number}\n *\n * @example <caption>Sign.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.sign(100)  // 1\n * });\n *\n * @example <caption>Sign. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: sign(100)\n * `);\n *\n * @memberof carto.expressions\n * @name sign\n * @function\n * @api\n */\nexport const Sign = genUnaryOp('sign', x => Math.sign(x), x => `sign(${x})`);\n\n/**\n * Compute the absolute value of a number x.\n *\n * @param {Number} x - Numeric expression to compute the absolute value\n * @return {Number}\n *\n * @example <caption>Abs.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.abs(-100)  // 100\n * });\n *\n * @example <caption>Abs. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: abs(-100) // 100\n * `);\n *\n * @memberof carto.expressions\n * @name abs\n * @function\n * @api\n */\nexport const Abs = genUnaryOp('abs', x => Math.abs(x), x => `abs(${x})`);\n\n/**\n * Check if a numeric expression is NaN.\n *\n * This returns a numeric expression where 0 means `false` and 1 means `true`.\n *\n * @param {Number} x - Numeric expression to check\n * @return {Number}\n *\n * @memberof carto.expressions\n * @name isNaN\n * @function\n * @api\n */\nexport const IsNaN = genUnaryOp('isNaN', x => Number.isNaN(x) ? 1 : 0, x => `((${x} <= 0.0 || 0.0 <= ${x}) ? 0. : 1.)`);\n\n/**\n * Compute the logical negation of the given expression.\n * This is internally computed as 1 - x preserving boolean behavior and allowing fuzzy logic.\n *\n *  - When x is equal to 1 not(x) will be evaluated to 0\n *  - When x is equal to 0 not(x) will be evaluated to 1\n *\n * @param {Number} x - Number to compute the not value\n * @return {Number}\n *\n * @example <caption>Not.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.not(0)  // 1\n * });\n *\n * @example <caption>Not. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: not(0)\n * `);\n *\n * @memberof carto.expressions\n * @name not\n * @function\n * @api\n */\nexport const Not = genUnaryOp('not', x => 1 - x, x => `(1.0 - ${x})`);\n\n/**\n * Compute the floor of the given expression.\n * Find the nearest integer less than or equal to the expression value.\n *\n *  - When x is equal to 0.8 floor(x) will be evaluated to 0\n *  - When x is equal to 1.3 floor(x) will be evaluated to 1\n *\n * @param {Number} x - Number to compute the floor value\n * @return {Number}\n *\n * @example <caption>Floor.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.floor(5.9)  // 5\n * });\n *\n * @example <caption>Floor. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: floor(5.9)\n * `);\n *\n * @memberof carto.expressions\n * @name floor\n * @function\n * @api\n */\nexport const Floor = genUnaryOp('floor', x => Math.floor(x), x => `floor(${x})`);\n\n/**\n * Compute the ceil of the given expression.\n * Find the nearest integer that is greater than or equal to the expression value.\n *\n *  - When x is equal to 0.8 ceil(x) will be evaluated to 1\n *  - When x is equal to 1.3 ceil(x) will be evaluated to 2\n *\n * @param {Number} x - Number to compute the ceil value\n * @return {Number}\n *\n * @example <caption>Ceil.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.ceil(5.1);  // 6\n * });\n *\n * @example <caption>Ceil. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: ceil(5.1)\n * `);\n *\n * @memberof carto.expressions\n * @name ceil\n * @function\n * @api\n */\nexport const Ceil = genUnaryOp('ceil', x => Math.ceil(x), x => `ceil(${x})`);\n\nfunction genUnaryOp (name, jsFn, glsl) {\n    return class UnaryOperation extends BaseExpression {\n        constructor (a) {\n            a = implicitCast(a);\n            checkLooseType(name, 'x', 0, 'number', a);\n            super({ a });\n            this.type = 'number';\n            this.inlineMaker = inlines => glsl(inlines.a);\n        }\n        get value () {\n            return this.eval();\n        }\n        eval (feature) {\n            return jsFn(this.a.eval(feature));\n        }\n        _bindMetadata (meta) {\n            super._bindMetadata(meta);\n            checkType(name, 'x', 0, 'number', this.a);\n            if (this.a.type !== 'number') {\n                throw new Error(`Unary operation cannot be performed to '${this.a.type}'`);\n            }\n        }\n    };\n}\n","import { number, category, array } from '../expressions';\nimport BaseExpression from './base';\n\nexport const DEFAULT = undefined;\n\n// To support literals (string and numeric) out of the box we need to cast them implicitly on constructors\nexport function implicitCast (value) {\n    if (_isNumber(value)) {\n        return number(value);\n    }\n    if (typeof value === 'string') {\n        return category(value);\n    }\n    if (Array.isArray(value)) {\n        return array(value);\n    }\n    return value;\n}\n\nexport function hexToRgb (hex) {\n    // Evaluate #ABC\n    let result = /^#?([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})$/i.exec(hex);\n    if (result) {\n        return {\n            r: parseInt(result[1] + result[1], 16),\n            g: parseInt(result[2] + result[2], 16),\n            b: parseInt(result[3] + result[3], 16),\n            a: 1\n        };\n    }\n\n    // Evaluate #ABCD\n    result = /^#?([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})([a-f\\d]{1})$/i.exec(hex);\n    if (result) {\n        return {\n            r: parseInt(result[1] + result[1], 16),\n            g: parseInt(result[2] + result[2], 16),\n            b: parseInt(result[3] + result[3], 16),\n            a: parseInt(result[4] + result[4], 16) / 255\n        };\n    }\n\n    // Evaluate #ABCDEF\n    result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    if (result) {\n        return {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16),\n            a: 1\n        };\n    }\n\n    // Evaluate #ABCDEFAF\n    result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    if (result) {\n        return {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16),\n            a: parseInt(result[4], 16) / 255\n        };\n    }\n\n    throw new Error('Invalid hexadecimal color');\n}\n\nexport function getOrdinalFromIndex (index) {\n    const indexToOrdinal = {\n        1: 'first',\n        2: 'second',\n        3: 'third',\n        4: 'fourth'\n    };\n    return indexToOrdinal[index] || String(index);\n}\n\nexport function getStringErrorPreface (expressionName, parameterName, parameterIndex) {\n    return `${expressionName}(): invalid ${getOrdinalFromIndex(parameterIndex + 1)} parameter '${parameterName}'`;\n}\nexport function throwInvalidType (expressionName, parameterName, parameterIndex, expectedType, actualType) {\n    throw new Error(`${getStringErrorPreface(expressionName, parameterName, parameterIndex)}\nexpected type was '${expectedType}', actual type was '${actualType}'`);\n}\n\nexport function throwInvalidInstance (expressionName, parameterName, parameterIndex, expectedClass, actualInstance) {\n    throw new Error(`${getStringErrorPreface(expressionName, parameterName, parameterIndex)}\n    '${actualInstance}' is not an instance of '${expectedClass.name}'`);\n}\n\nexport function throwInvalidNumber (expressionName, parameterName, parameterIndex, number) {\n    throw new Error(`${getStringErrorPreface(expressionName, parameterName, parameterIndex)}\n    type of '${number}' is ${typeof number}, 'number' was expected`);\n}\n\nexport function throwInvalidArray (expressionName, parameterName, parameterIndex, array) {\n    throw new Error(`${getStringErrorPreface(expressionName, parameterName, parameterIndex)}\n    '${array}' is not an array`);\n}\n\nexport function throwInvalidString (expressionName, parameterName, parameterIndex, str) {\n    throw new Error(`${getStringErrorPreface(expressionName, parameterName, parameterIndex)}\n    '${str}' is not a string`);\n}\n\n// Try to check the type, but accept undefined types without throwing, unless the expected type had to be known at constructor time\n// This condition happens with types like color or fade, see isArgConstructorTimeTyped for details\n//\n// This is useful to make constructor-time checks, at constructor-time some types can be already known and errors can be throw.\n// Constructor-time is the best time to throw, but metadata is not provided yet, therefore, the checks cannot be complete,\n// they must be loose, the unknown of variables aliases types makes, also, a point to reduce the strictness of the check\nexport function checkLooseType (expressionName, parameterName, parameterIndex, expectedType, parameter) {\n    checkExpression(expressionName, parameterName, parameterIndex, parameter);\n    const constructorTimeTyped = Array.isArray(expectedType) ? expectedType.every(isArgConstructorTimeTyped) : isArgConstructorTimeTyped(expectedType);\n    if (parameter.type !== undefined || constructorTimeTyped) {\n        checkType(expressionName, parameterName, parameterIndex, expectedType, parameter);\n    }\n}\n\n// Returns true if the argument is of a type that cannot be strictly checked at constructor time\nexport function isArgConstructorTimeTyped (arg) {\n    switch (arg) {\n        case 'number':\n        case 'number-array':\n        case 'number-property':\n        case 'category':\n        case 'category-array':\n        case 'category-property':\n            return false;\n        default:\n            return true;\n    }\n}\n\nexport function checkExpression (expressionName, parameterName, parameterIndex, parameter) {\n    if (!(parameter instanceof BaseExpression)) {\n        throw new Error(`${getStringErrorPreface(expressionName, parameterName, parameterIndex)}\n        '${parameter}' is not of type carto.expressions.Base`);\n    }\n}\n\nexport function checkType (expressionName, parameterName, parameterIndex, expectedType, parameter) {\n    checkExpression(expressionName, parameterName, parameterIndex, parameter);\n    if (Array.isArray(expectedType)) {\n        const ok = expectedType.some(type =>\n            parameter.type === type\n        );\n        if (!ok) {\n            throw new Error(`${getStringErrorPreface(expressionName, parameterName, parameterIndex)}\n            expected type was one of ${expectedType.join()}, actual type was '${parameter.type}'`);\n        }\n    } else if (parameter.type !== expectedType) {\n        throwInvalidType(expressionName, parameterName, parameterIndex, expectedType, parameter.type);\n    }\n}\n\nexport function checkInstance (expressionName, parameterName, parameterIndex, expectedClass, parameter) {\n    checkExpression(expressionName, parameterName, parameterIndex, parameter);\n    if (!(parameter.isA(expectedClass))) {\n        throwInvalidInstance(expressionName, parameterName, parameterIndex, expectedClass, parameter.type);\n    }\n}\n\nexport function checkNumber (expressionName, parameterName, parameterIndex, number) {\n    if (!_isNumber(number)) {\n        throwInvalidNumber(expressionName, parameterName, parameterIndex, number);\n    }\n}\n\nexport function checkString (expressionName, parameterName, parameterIndex, str) {\n    if (typeof str !== 'string') {\n        throwInvalidString(expressionName, parameterName, parameterIndex, str);\n    }\n}\n\nexport function checkArray (expressionName, parameterName, parameterIndex, array) {\n    if (!Array.isArray(array)) {\n        throwInvalidArray(expressionName, parameterName, parameterIndex, array);\n    }\n}\n\nexport function checkFeatureIndependent (expressionName, parameterName, parameterIndex, parameter) {\n    if (parameter.isFeatureDependent()) {\n        throw new Error(`${getStringErrorPreface(expressionName, parameterName, parameterIndex)}\n        parameter cannot be feature dependent`);\n    }\n}\n\nexport function clamp (x, min, max) {\n    return Math.min(Math.max(x, min), max);\n}\n\nexport function mix (x, y, a) {\n    return x * (1 - a) + y * a;\n}\n\nfunction _isNumber (value) {\n    return Number.isFinite(value) || value === Infinity || value === -Infinity || Number.isNaN(value);\n}\n","import BaseExpression from './base';\nimport Property from './basic/property';\nimport { implicitCast } from './utils';\n\n/**\n * Generates a list of features in the viewport\n *\n * For each feature, the properties specified as arguments to this expression will be available.\n * Filtered features will not be present in the list.\n * This expression cannot be used for rendering, it can only be used in JavaScript code as in the example below.\n *\n * @param {...Property} properties - properties that will appear in the feature list\n * @return {ViewportFeatures} ViewportFeatures\n *\n * @example <caption>Define and use a list of features. (String)</caption>\n * const source = carto.source.Dataset('data');\n * const viz = new carto.Viz(`\n *          \\@list: viewportFeatures($value, $category)\n * `);\n * const layer = carto.Layer('layer', source, viz);\n * ...\n *\n * layer.on('updated', () => {\n *     viz.variables.list.value.forEach(feature => {\n *         console.log('value:', feature.value, 'category:', feature.category);\n *     });\n * });\n *\n * @memberof carto.expressions\n * @name viewportFeatures\n * @function\n * @api\n */\nexport default class ViewportFeatures extends BaseExpression {\n    constructor (...properties) {\n        properties = properties.map(p => implicitCast(p));\n\n        // We need to set all the properties as children of the expression\n        // in order for variables to be resolved.\n        // And as an additional bonus we don't need to define _getMinimumNeededSchema\n        super(_childrenFromProperties(properties));\n\n        this.expr = [];\n        this.type = 'featureList';\n        this._isViewport = true;\n        this._requiredProperties = properties;\n        this._FeatureProxy = null;\n    }\n\n    _applyToShaderSource () {\n        throw new Error('viewportFeatures cannot be used in visualizations');\n    }\n\n    isFeatureDependent () {\n        return false;\n    }\n\n    get value () {\n        return this.expr;\n    }\n\n    eval () {\n        return this.expr;\n    }\n\n    _resetViewportAgg () {\n        if (!this._FeatureProxy) {\n            if (!this._requiredProperties.every(p => (p.isA(Property)))) {\n                throw new Error('viewportFeatures arguments can only be properties');\n            }\n            const columns = this._getMinimumNeededSchema().columns;\n            this._FeatureProxy = this.genViewportFeatureClass(columns);\n        }\n        this.expr = [];\n    }\n\n    accumViewportAgg (feature) {\n        this.expr.push(new this._FeatureProxy(feature));\n    }\n\n    genViewportFeatureClass (properties) {\n        const cls = class ViewportFeature {\n            constructor (feature) {\n                this._feature = feature;\n            }\n        };\n        properties.forEach(prop => {\n            Object.defineProperty(cls.prototype, prop, {\n                get: function () {\n                    return this._feature[prop];\n                }\n            });\n        });\n        return cls;\n    }\n}\n\nfunction _childrenFromProperties (properties) {\n    let i = 0;\n    const childContainer = {};\n    properties.forEach(property => {\n        childContainer['p' + ++i] = property;\n    });\n    return childContainer;\n}\n","import BaseExpression from './base';\nimport { implicitCast } from './utils';\n\n// TODO should this expression be removed?\nexport default class XYZ extends BaseExpression {\n    constructor (x, y, z) {\n        x = implicitCast(x);\n        y = implicitCast(y);\n        z = implicitCast(z);\n        super({ x: x, y: y, z: z });\n        // TODO improve type check\n    }\n    _bindMetadata (meta) {\n        super._bindMetadata(meta);\n        if (this.x.type !== 'number' || this.y.type !== 'number' || this.z.type !== 'number') {\n            throw new Error('XYZ() invalid parameters');\n        }\n        this.type = 'color';\n        this._setGenericGLSL(inline =>\n            `vec4(xyztosrgb((\n                vec3(\n                    clamp(${inline.x}, -100000., 10000.),\n                    clamp(${inline.y}, -12800., 12800.),\n                    clamp(${inline.z}, -12800., 12800.)\n                )\n            )), 1)`\n            , `\n        #ifndef cielabtoxyz_fn\n        #define cielabtoxyz_fn\n\n        const mat3 XYZ_2_RGB = (mat3(\n            3.2404542,-1.5371385,-0.4985314,\n           -0.9692660, 1.8760108, 0.0415560,\n            0.0556434,-0.2040259, 1.0572252\n       ));\n       const mat3 XYZ_2_RGB_T = (mat3(\n        3.2404542,-0.9692660,0.0556434,\n        -1.5371385, 1.8760108, -0.2040259,\n        -0.4985314,0.0415560, 1.0572252\n   ));\n       const float SRGB_GAMMA = 1.0 / 2.2;\n\n       vec3 rgb_to_srgb_approx(vec3 rgb) {\n        return pow(rgb, vec3(SRGB_GAMMA));\n    }\n        float f1(float t){\n            const float sigma = 6./29.;\n            if (t>sigma){\n                return t*t*t;\n            }else{\n                return 3.*sigma*sigma*(t-4./29.);\n            }\n        }\n        vec3 cielabtoxyz(vec3 c) {\n            const float xn = 95.047;\n            const float yn = 100.;\n            const float zn = 108.883;\n            return vec3(xn*f1((c.x+16.)/116.  + c.y/500. ),\n                        yn*f1((c.x+16.)/116.),\n                        zn*f1((c.x+16.)/116.  - c.z/200. )\n                    );\n        }\n        vec3 xyztorgb(vec3 c){\n            return c * XYZ_2_RGB;\n        }\n\n        vec3 xyztosrgb(vec3 c) {\n            return rgb_to_srgb_approx(xyztorgb(c));\n        }\n        #endif\n        `);\n    }\n}\n","import BaseExpression from './base';\nimport { number } from '../expressions';\n\n/**\n * Get the current zoom level. Multiplying by zoom() makes features constant in real-world space respect their size at zoom level 0.\n *\n * @return {Number}\n *\n * @example <caption>Show constant width in zoom.</caption>\n * const s = carto.expressions;\n * const viz = new carto.Viz({\n *   width: s.div(s.zoom(), 1000)\n * });\n *\n * @example <caption>Show constant width in zoom. (String)</caption>\n * const viz = new carto.Viz(`\n *   width: zoom() / 1000\n * `);\n *\n * @memberof carto.expressions\n * @name zoom\n * @function\n * @api\n */\nexport default class Zoom extends BaseExpression {\n    constructor () {\n        super({ zoom: number(0) });\n        this.type = 'number';\n        super.inlineMaker = inline => inline.zoom;\n    }\n    eval () {\n        return this.zoom.expr;\n    }\n    _preDraw (program, drawMetadata, gl) {\n        this.zoom.expr = drawMetadata.zoom;\n        this.zoom._preDraw(program, drawMetadata, gl);\n    }\n}\n","\nimport jsep from 'jsep';\nimport * as functions from './expressions';\nimport { implicitCast } from './expressions/utils';\nimport { CSS_COLOR_NAMES } from './expressions/color/cssColorNames';\nimport NamedColor from './expressions/color/NamedColor';\nimport Hex from './expressions/color/hex';\n\n// TODO use Schema classes\n\nconst aggFns = [];\n\nconst lowerCaseFunctions = {};\nObject.keys(functions)\n    .filter(name => name[0] === name[0].toLowerCase()) // Only get functions starting with lowercase\n    .map(name => { lowerCaseFunctions[name.toLocaleLowerCase()] = functions[name]; });\nlowerCaseFunctions.true = functions.TRUE;\nlowerCaseFunctions.false = functions.FALSE;\nlowerCaseFunctions.align_center = functions.ALIGN_CENTER;\nlowerCaseFunctions.align_bottom = functions.ALIGN_BOTTOM;\n\nlowerCaseFunctions.pi = functions.PI;\nlowerCaseFunctions.e = functions.E;\nlowerCaseFunctions.hold = functions.HOLD;\n\nlowerCaseFunctions.bicycle = functions.BICYCLE;\nlowerCaseFunctions.building = functions.BUILDING;\nlowerCaseFunctions.bus = functions.BUS;\nlowerCaseFunctions.car = functions.CAR;\nlowerCaseFunctions.circle = functions.CIRCLE;\nlowerCaseFunctions.circleoutline = functions.CIRCLE_OUTLINE;\nlowerCaseFunctions.cross = functions.CROSS;\nlowerCaseFunctions.flag = functions.FLAG;\nlowerCaseFunctions.house = functions.HOUSE;\nlowerCaseFunctions.marker = functions.MARKER;\nlowerCaseFunctions.markeroutline = functions.MARKER_OUTLINE;\nlowerCaseFunctions.plus = functions.PLUS;\nlowerCaseFunctions.square = functions.SQUARE;\nlowerCaseFunctions.squareoutline = functions.SQUARE_OUTLINE;\nlowerCaseFunctions.star = functions.STAR;\nlowerCaseFunctions.staroutline = functions.STAR_OUTLINE;\nlowerCaseFunctions.triangle = functions.TRIANGLE;\nlowerCaseFunctions.triangleoutline = functions.TRIANGLE_OUTLINE;\n\nexport function parseVizExpression (str) {\n    prepareJsep();\n    const r = implicitCast(parseNode(jsep(str)));\n    cleanJsep();\n    return r;\n}\n\nexport function parseVizDefinition (str) {\n    prepareJsep();\n    const ast = jsep(cleanComments(str));\n    let vizSpec = { variables: {} };\n    if (ast.type === 'Compound') {\n        ast.body.map(node => parseVizNamedExpr(vizSpec, node));\n    } else {\n        parseVizNamedExpr(vizSpec, ast);\n    }\n    cleanJsep();\n    return vizSpec;\n}\n\nfunction parseVizNamedExpr (vizSpec, node) {\n    if (node.operator !== ':') {\n        throw new Error('Invalid syntax');\n    }\n    if (node.left.name.length && node.left.name[0] === '@') {\n        node.left.name = '__cartovl_variable_' + node.left.name.substr(1);\n    }\n    const name = node.left.name;\n    if (!name) {\n        throw new Error('Invalid syntax');\n    }\n    if (name.startsWith('__cartovl_variable_')) {\n        vizSpec.variables[node.left.name.substr('__cartovl_variable_'.length)] = implicitCast(parseNode(node.right));\n    } else if (name === 'resolution') {\n        const value = parseNode(node.right);\n        vizSpec[name] = value;\n    } else {\n        const value = parseNode(node.right);\n        vizSpec[name] = implicitCast(value);\n    }\n}\n\nfunction parseFunctionCall (node) {\n    const name = node.callee.name.toLowerCase();\n    if (aggFns.includes(name)) {\n        // node.arguments[0].name += '_' + name;\n        const args = node.arguments.map(arg => parseNode(arg));\n        return args[0];\n    }\n    const args = node.arguments.map(arg => parseNode(arg));\n    if (lowerCaseFunctions[name]) {\n        return lowerCaseFunctions[name](...args);\n    }\n    throw new Error(`Invalid function name '${node.callee.name}'`);\n}\n\nfunction parseBinaryOperation (node) {\n    const left = parseNode(node.left);\n    const right = parseNode(node.right);\n    switch (node.operator) {\n        case '*':\n            return functions.mul(left, right);\n        case '/':\n            return functions.div(left, right);\n        case '+':\n            return functions.add(left, right);\n        case '-':\n            return functions.sub(left, right);\n        case '%':\n            return functions.mod(left, right);\n        case '^':\n            return functions.pow(left, right);\n        case '>':\n            return functions.greaterThan(left, right);\n        case '>=':\n            return functions.greaterThanOrEqualTo(left, right);\n        case '<':\n            return functions.lessThan(left, right);\n        case '<=':\n            return functions.lessThanOrEqualTo(left, right);\n        case '==':\n            return functions.equals(left, right);\n        case '!=':\n            return functions.notEquals(left, right);\n        case 'and':\n            return functions.and(left, right);\n        case 'or':\n            return functions.or(left, right);\n        default:\n            throw new Error(`Invalid binary operator '${node.operator}'`);\n    }\n}\n\nfunction parseUnaryOperation (node) {\n    switch (node.operator) {\n        case '-':\n            return functions.mul(-1, parseNode(node.argument));\n        case '+':\n            return parseNode(node.argument);\n        default:\n            throw new Error(`Invalid unary operator '${node.operator}'`);\n    }\n}\n\nfunction parseIdentifier (node) {\n    if (node.name.length && node.name[0] === '@') {\n        node.name = '__cartovl_variable_' + node.name.substr(1);\n    }\n    if (node.name.startsWith('__cartovl_variable_')) {\n        return functions.variable(node.name.substr('__cartovl_variable_'.length));\n    } else if (node.name[0] === '#') {\n        return new Hex(node.name);\n    } else if (node.name[0] === '$') {\n        return functions.property(node.name.substring(1));\n    } else if (functions.palettes[node.name.toUpperCase()]) {\n        return functions.palettes[node.name.toUpperCase()];\n    } else if (lowerCaseFunctions[node.name.toLowerCase()]) {\n        return lowerCaseFunctions[node.name.toLowerCase()];\n    } else if (CSS_COLOR_NAMES.includes(node.name.toLowerCase())) {\n        return new NamedColor(node.name.toLowerCase());\n    } else {\n        throw new Error(`Invalid expression '${JSON.stringify(node)}'`);\n    }\n}\n\nfunction parseNode (node) {\n    if (node.type === 'CallExpression') {\n        return parseFunctionCall(node);\n    } else if (node.type === 'Literal') {\n        return node.value;\n    } else if (node.type === 'ArrayExpression') {\n        return node.elements.map(e => parseNode(e));\n    } else if (node.type === 'BinaryExpression') {\n        return parseBinaryOperation(node);\n    } else if (node.type === 'UnaryExpression') {\n        return parseUnaryOperation(node);\n    } else if (node.type === 'Identifier') {\n        return parseIdentifier(node);\n    }\n    throw new Error(`Invalid expression '${JSON.stringify(node)}'`);\n}\n\nfunction prepareJsep () {\n    // jsep addBinaryOp pollutes its module scope, we need to remove the custom operators afterwards\n    jsep.addBinaryOp(':', 0);\n    jsep.addBinaryOp('^', 11);\n    jsep.addBinaryOp('or', 1);\n    jsep.addBinaryOp('and', 2);\n    jsep.addIdentifierChar('@');\n    jsep.addIdentifierChar('#');\n    jsep.removeLiteral('true');\n    jsep.removeLiteral('false');\n}\n\nfunction cleanJsep () {\n    jsep.removeBinaryOp('and');\n    jsep.removeBinaryOp('or');\n    jsep.removeBinaryOp('^');\n    jsep.removeBinaryOp(':');\n    jsep.removeIdentifierChar('@');\n    jsep.removeIdentifierChar('#');\n    jsep.addLiteral('true');\n    jsep.addLiteral('false');\n}\n\n/**\n * Remove comments from string\n * - // line comments\n * - /* block comments\n * - Keep comments inside single and double quotes tracking escape chars\n * Based on: https://j11y.io/javascript/removing-comments-in-javascript/\n */\nexport function cleanComments (str) {\n    const mode = {\n        singleQuote: false,\n        doubleQuote: false,\n        blockComment: false,\n        lineComment: false,\n        escape: 0\n    };\n\n    // Adding chars to avoid index checking\n    str = ('_' + str + '_').split('');\n\n    for (let i = 0, l = str.length; i < l; i++) {\n        if (mode.singleQuote) {\n            if (str[i] === '\\\\') {\n                mode.escape++;\n            } else if (str[i] === '\\'' && mode.escape % 2 === 0) {\n                mode.singleQuote = false;\n                mode.escape = 0;\n            }\n            continue;\n        }\n\n        if (mode.doubleQuote) {\n            if (str[i] === '\\\\') {\n                mode.escape++;\n            } else if (str[i] === '\"' && mode.escape % 2 === 0) {\n                mode.doubleQuote = false;\n                mode.escape = 0;\n            }\n            continue;\n        }\n\n        if (mode.blockComment) {\n            if (str[i] === '*' && str[i + 1] === '/') {\n                str[i + 1] = '';\n                mode.blockComment = false;\n            }\n            str[i] = '';\n            continue;\n        }\n\n        if (mode.lineComment) {\n            if (str[i + 1] === '\\n' || str[i + 1] === '\\r') {\n                mode.lineComment = false;\n            }\n            if (i + 1 < l) {\n                str[i] = '';\n            }\n            continue;\n        }\n\n        mode.doubleQuote = str[i] === '\"';\n        mode.singleQuote = str[i] === '\\'';\n\n        if (str[i] === '/') {\n            if (str[i + 1] === '*') {\n                str[i] = '';\n                mode.blockComment = true;\n                continue;\n            }\n            if (str[i + 1] === '/') {\n                str[i] = '';\n                mode.lineComment = true;\n                continue;\n            }\n        }\n    }\n\n    // Remove chars added before\n    return str.join('').slice(1, -1);\n}\n","module.exports = \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 15 15\\\"><path d=\\\"M7.5 2c-.676-.01-.676 1.01 0 1H9v1.266L6.197 6.6 5.223 4H5.5c.676.01.676-1.01 0-1h-2c-.676-.01-.676 1.01 0 1h.652l.891 2.375A3.45 3.45 0 0 0 3.5 6C1.573 6 0 7.573 0 9.5S1.573 13 3.5 13 7 11.427 7 9.5c0-.67-.2-1.291-.53-1.824l2.821-2.35.463 1.16C8.71 7.094 8 8.211 8 9.5c0 1.927 1.573 3.5 3.5 3.5S15 11.427 15 9.5 13.427 6 11.5 6c-.283 0-.554.043-.818.107L10 4.402V2.5a.5.5 0 0 0-.5-.5h-2zm-4 5a2.48 2.48 0 0 1 1.555.553L3.18 9.115c-.511.427.128 1.195.64.77l1.875-1.563c.188.352.305.75.305 1.178C6 10.887 4.887 12 3.5 12S1 10.887 1 9.5 2.113 7 3.5 7zm8 0C12.887 7 14 8.113 14 9.5S12.887 12 11.5 12 9 10.887 9 9.5c0-.877.447-1.642 1.125-2.088l.91 2.274c.246.623 1.18.25.93-.372l-.908-2.27C11.2 7.02 11.348 7 11.5 7z\\\"></path></svg>\"","module.exports = \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 15 15\\\"><path d=\\\"M3 2v11h5v-3h3v3h1V2H3zm4 10H4v-2h3v2zm0-3H4V7h3v2zm0-3H4V4h3v2zm4 3H8V7h3v2zm0-3H8V4h3v2z\\\"></path></svg>\"","module.exports = \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 15 15\\\"><path d=\\\"M4 0C2.636 0 1 .743 1 2.746V12s0 1 1 1v1s0 1 1 1 1-1 1-1v-1h7v1s0 1 1 1 1-1 1-1v-1s1 0 1-1V2.746C14 .701 12.764 0 11.4 0H4zm.25 1.5h6.5a.25.25 0 1 1 0 .5h-6.5a.25.25 0 1 1 0-.5zM3 3h9c1 0 1 .967 1 .967V7s0 1-1 1H3C2 8 2 7 2 7V4s0-1 1-1zm0 7a1 1 0 1 1 0 2 1 1 0 0 1 0-2zm9 0a1 1 0 1 1 0 2 1 1 0 0 1 0-2z\\\"></path></svg>\"","module.exports = \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 15 15\\\"><path d=\\\"M14 7a1.5 1.5 0 0 0-1.15-1.45l-1.39-3.24A.5.5 0 0 0 11 2H4a.5.5 0 0 0-.44.28L2.15 5.54A1.5 1.5 0 0 0 1 7v3.5h1v1a1 1 0 1 0 2 0v-1h7v1a1 1 0 1 0 2 0v-1h1V7zM4.3 3h6.4l1.05 2.5h-8.5L4.3 3zM3 9a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm9 0a1 1 0 1 1 0-2 1 1 0 0 1 0 2z\\\"></path></svg>\"","module.exports = \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 15 15\\\"><path d=\\\"M14 7.5a6.5 6.5 0 1 1-13 0 6.5 6.5 0 0 1 13 0z\\\"></path></svg>\"","module.exports = \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 15 15\\\"><path d=\\\"M7.5 0a7.5 7.5 0 1 1 0 15 7.5 7.5 0 0 1 0-15zm0 1.667a5.833 5.833 0 1 0 0 11.666 5.833 5.833 0 0 0 0-11.666z\\\"></path></svg>\"","module.exports = \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 15 15\\\"><path d=\\\"M2.64 1.27L7.5 6.13l4.84-4.84A.92.92 0 0 1 13 1a1 1 0 0 1 1 1 .9.9 0 0 1-.27.66L8.84 7.5l4.89 4.89A.9.9 0 0 1 14 13a1 1 0 0 1-1 1 .92.92 0 0 1-.69-.27L7.5 8.87l-4.85 4.85A.92.92 0 0 1 2 14a1 1 0 0 1-1-1 .9.9 0 0 1 .27-.66L6.16 7.5 1.27 2.61A.9.9 0 0 1 1 2a1 1 0 0 1 1-1c.24.003.47.1.64.27z\\\"></path></svg>\"","module.exports = \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 15 15\\\"><path d=\\\"M6.65 2C5.43 2 4.48 3.38 4.11 3.82a.49.49 0 0 0-.11.32v4.4a.44.44 0 0 0 .72.36 3 3 0 0 1 1.93-1.17C8.06 7.73 8.6 9 10.07 9a5.28 5.28 0 0 0 2.73-1.09.49.49 0 0 0 .2-.4V2.45a.44.44 0 0 0-.62-.45 5.75 5.75 0 0 1-2.31 1.06C8.6 3.08 8.12 2 6.65 2zM2.5 3a1 1 0 1 1 0-2 1 1 0 0 1 0 2zM3 4v9.48a.5.5 0 0 1-1 0V4a.5.5 0 0 1 1 0z\\\"></path></svg>\"","module.exports = \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 15 15\\\"><path d=\\\"M2 13.748c0 .138.112.25.25.25h3.749v-3h3v3h3.749a.25.25 0 0 0 .25-.25v-5.75H2v5.75zm11.93-7.17l-.932-.82V2a1 1 0 1 0-2 0v2L7.681 1.09a.25.25 0 0 0-.353-.011l-.011.011-6.25 5.463a.25.25 0 0 0 .18.42L3 7h10.747a.25.25 0 0 0 .183-.421z\\\"></path></svg>\"","module.exports = \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 15 15\\\"><path d=\\\"M7.5 0C5.068 0 2.23 1.486 2.23 5.27c0 2.568 4.054 8.244 5.27 9.73 1.081-1.486 5.27-7.027 5.27-9.73C12.77 1.487 9.932 0 7.5 0z\\\"></path></svg>\"","module.exports = \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 15 15\\\"><path data-name=\\\"Layer 7\\\" d=\\\"M7.5 14.941l-.4-.495c-.973-1.189-4.9-6.556-4.9-9.16A5.066 5.066 0 0 1 7.036 0q.222-.01.445 0a5.066 5.066 0 0 1 5.286 4.836q.01.225 0 .45c0 2.213-2.669 6.111-4.678 8.851zM7.481.986a4.077 4.077 0 0 0-4.3 4.3c0 1.832 2.759 6.038 4.286 8.034 1.25-1.71 4.315-5.989 4.315-8.034a4.077 4.077 0 0 0-4.3-4.3z\\\"></path></svg>\"","module.exports = \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 15 15\\\"><path d=\\\"M7 1c-.6 0-1 .4-1 1v4H2c-.6 0-1 .4-1 1v1c0 .6.4 1 1 1h4v4c0 .6.4 1 1 1h1c.6 0 1-.4 1-1V9h4c.6 0 1-.4 1-1V7c0-.6-.4-1-1-1H9V2c0-.6-.4-1-1-1H7z\\\" fill=\\\"#010101\\\"></path></svg>\"","module.exports = \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 15 15\\\"><path d=\\\"M13 14H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h11a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1z\\\"></path></svg>\"","module.exports = \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 15 15\\\"><path d=\\\"M12.7 2.3v10.4H2.3V2.3h10.4M13 1H2a1 1 0 0 0-1 1v11a1 1 0 0 0 1 1h11a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1z\\\"></path></svg>\"","module.exports = \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 15 15\\\"><path d=\\\"M7.5 0l-2 5h-5l4 3.5-2 6 5-3.5 5 3.5-2-6 4-3.5h-5l-2-5z\\\"></path></svg>\"","module.exports = \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 15 15\\\"><path d=\\\"M7.5 3.19l1.07 2.68.25.63h3l-2 1.75-.5.44.23.63 1 3.13-2.48-1.77-.57-.4-.57.4-2.52 1.77 1-3.13.21-.63-.5-.44-2-1.75h3l.25-.63L7.5 3.19M7.5.5l-2 5h-5l4 3.5-2 6 5-3.5 5 3.5-2-6 4-3.5h-5l-2-5z\\\" fill=\\\"#010101\\\"></path></svg>\"","module.exports = \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 15 15\\\"><path d=\\\"M7.538 2c-.294 0-.488.177-.615.385l-5.846 9.538C1 12 1 12.153 1 12.308c0 .538.385.692.692.692h11.616c.384 0 .692-.154.692-.692 0-.154 0-.231-.077-.385l-5.77-9.538C8.029 2.177 7.789 2 7.539 2z\\\"></path></svg>\"","module.exports = \"<svg version=\\\"1.1\\\" xmlns=\\\"http://www.w3.org/2000/svg\\\" viewBox=\\\"0 0 15 15\\\"><path d=\\\"M7.524 1.5a.77.77 0 0 0-.69.395l-5.5 9.87C1.022 12.307 1.395 13 2 13h11c.605 0 .978-.692.666-1.236l-5.5-9.869a.773.773 0 0 0-.642-.395zM7.5 3.9l4.127 7.47H3.373L7.5 3.9z\\\"></path></svg>\"","import * as util from '../utils/util';\nimport CartoValidationError from '../errors/carto-validation-error';\n\nlet defaultAuth;\n\n/**\n * Set default authentication parameters: user and apiKey.\n *\n * @param {object} auth\n * @param {string} auth.user - Name of the user\n * @param {string} auth.apiKey - API key used to authenticate against CARTO\n *\n * @memberof carto\n * @api\n */\nfunction setDefaultAuth (auth) {\n    checkAuth(auth);\n    defaultAuth = auth;\n}\n\n/**\n * Get default authentication\n * @return {object}\n */\nfunction getDefaultAuth () {\n    return defaultAuth;\n}\n\n/**\n * Reset the default auth object\n */\nfunction cleanDefaultAuth () {\n    defaultAuth = undefined;\n}\n\n/**\n * Check a valid auth parameter.\n *\n * @param  {object} auth\n */\nfunction checkAuth (auth) {\n    if (util.isUndefined(auth)) {\n        throw new CartoValidationError('setup', 'authRequired');\n    }\n    if (!util.isObject(auth)) {\n        throw new CartoValidationError('setup', 'authObjectRequired');\n    }\n    auth.username = auth.user; // API adapter\n    checkApiKey(auth.apiKey);\n    checkUsername(auth.username);\n}\n\nfunction checkApiKey (apiKey) {\n    if (util.isUndefined(apiKey)) {\n        throw new CartoValidationError('setup', 'apiKeyRequired');\n    }\n    if (!util.isString(apiKey)) {\n        throw new CartoValidationError('setup', 'apiKeyStringRequired');\n    }\n    if (apiKey === '') {\n        throw new CartoValidationError('setup', 'nonValidApiKey');\n    }\n}\n\nfunction checkUsername (username) {\n    if (util.isUndefined(username)) {\n        throw new CartoValidationError('setup', 'usernameRequired');\n    }\n    if (!util.isString(username)) {\n        throw new CartoValidationError('setup', 'usernameStringRequired');\n    }\n    if (username === '') {\n        throw new CartoValidationError('setup', 'nonValidUsername');\n    }\n}\n\nexport { setDefaultAuth, getDefaultAuth, checkAuth, cleanDefaultAuth };\n","import * as util from '../utils/util';\nimport CartoValidationError from '../errors/carto-validation-error';\n\nlet defaultConfig;\n\n/**\n * Set default configuration parameters\n *\n * @param {object} config\n * @param {string} config.serverURL='https://{user}.carto.com' - Template URL of the CARTO Maps API server\n *\n * @memberof carto\n * @api\n */\nfunction setDefaultConfig (config) {\n    checkConfig(config);\n    defaultConfig = config;\n}\n\n/**\n * Get default config\n * @return {object}\n */\nfunction getDefaultConfig () {\n    return defaultConfig;\n}\n\n/**\n * Clean default config object\n */\nfunction cleanDefaultConfig () {\n    defaultConfig = undefined;\n}\n\n/**\n * Check a valid config parameter.\n *\n * @param  {object} config\n */\nfunction checkConfig (config) {\n    if (config) {\n        if (!util.isObject(config)) {\n            throw new CartoValidationError('setup', 'configObjectRequired');\n        }\n        _checkServerURL(config.serverURL);\n    }\n}\n\nfunction _checkServerURL (serverURL) {\n    if (!util.isString(serverURL)) {\n        throw new CartoValidationError('setup', 'serverURLStringRequired');\n    }\n}\n\nexport { setDefaultConfig, getDefaultConfig, checkConfig, cleanDefaultConfig };\n","export default class Base {\n    /**\n     * Base data source object.\n     *\n     * The methods listed in the {@link carto.source.Base} object are available in all source objects.\n     *\n     * Use a source to reference the data used in a {@link carto.layer.Base|layer}.\n     *\n     * {@link carto.source.Base} should not be used directly use {@link carto.source.Dataset}, {@link carto.source.SQL} of {@link carto.source.GeoJSON} instead.\n     *\n     *\n     * @memberof carto.source\n     * @constructor Base\n     * @abstract\n     * @api\n     */\n}\n","import Base from './Base';\nimport Windshaft from '../client/windshaft';\nimport { getDefaultAuth, checkAuth } from '../setup/auth-service';\nimport { getDefaultConfig, checkConfig } from '../setup/config-service';\n\nconst DEFAULT_SERVER_URL_TEMPLATE = 'https://{user}.carto.com';\n\nexport default class BaseWindshaft extends Base {\n    constructor () {\n        super();\n        this._client = new Windshaft(this);\n    }\n\n    initialize (auth, config) {\n        this._auth = auth || getDefaultAuth();\n        this._config = config || getDefaultConfig();\n        checkAuth(this._auth);\n        checkConfig(this._config);\n        this._apiKey = this._auth.apiKey;\n        this._username = this._auth.username;\n        this._serverURL = this._generateURL(this._auth, this._config);\n    }\n\n    bindLayer (...args) {\n        this._client.bindLayer(...args);\n    }\n\n    requiresNewMetadata (viz) {\n        return this._client.requiresNewMetadata(viz);\n    }\n\n    requestMetadata (viz) {\n        return this._client.getMetadata(viz);\n    }\n\n    requestData (zoom, viewport) {\n        return this._client.getData(zoom, viewport);\n    }\n\n    free () {\n        this._client.free();\n    }\n\n    _generateURL (auth, config) {\n        let url = (config && config.serverURL) || DEFAULT_SERVER_URL_TEMPLATE;\n        url = url.replace(/{user}/, auth.username);\n        return url;\n    }\n}\n","import * as LRU from 'lru-cache';\n\nexport default class DataframeCache {\n    constructor () {\n        const lruOptions = {\n            max: 256,\n            // TODO improve cache length heuristic\n            length: () => 1,\n            maxAge: 1000 * 60 * 60,\n            dispose: (uid, dataframePromise) => {\n                dataframePromise.then(dataframe => {\n                    if (!dataframe.empty) {\n                        dataframe.free();\n                    }\n                });\n            }\n        };\n        this._cache = LRU(lruOptions);\n    }\n\n    // Get the promise of the dataframe with the provided unique ID, by querying the local cache, and using the fetch function as a fallback.\n    // The `fetch` function will be called with the provided `uid` and it is expected that it will return a promise to a Dataframe\n    get (uid, fetch) {\n        const cachedDataframe = this._cache.get(uid);\n        if (cachedDataframe) {\n            return cachedDataframe;\n        }\n\n        const dataframePromise = fetch(uid);\n        this._cache.set(uid, dataframePromise);\n        return dataframePromise;\n    }\n\n    free () {\n        this._cache.reset();\n    }\n}\n","import CartoValidationError from '../errors/carto-validation-error';\nimport util from '../utils/util';\nimport BaseWindshaft from './BaseWindshaft';\n\nexport default class Dataset extends BaseWindshaft {\n    /**\n     * A dataset defines the data that will be displayed in a layer and is equivalent\n     * to a table in the server.\n     *\n     * If you have a table named `european_cities` in your CARTO account you could load all the\n     * data in a layer using a `carto.source.Dataset`.\n     *\n     * If you want to load data applying a SQL query see {@link carto.source.SQL|carto.source.SQL}.\n     *\n     * Since tables in the server are protected you must provide valid credentials in order to get access to the data.\n     * This can be done {@link carto.setDefaultAuth|setting the default auth} in the carto object or providing an `auth`\n     * object with your username and apiKey.\n     *\n     * If your server is not hosted by CARTO you must add a third parameter that includes the serverURL. This can be done {@link carto.setDefaultConfig|setting the default config} in the carto object or providing a `config`\n     * object with your serverURL.\n     *\n     * @param {string} tableName - The name of an existing table\n     * @param {object} auth\n     * @param {string} auth.apiKey - API key used to authenticate against CARTO\n     * @param {string} auth.user - Name of the user\n     * @param {object} config\n     * @param {string} [config.serverURL='https://{user}.carto.com'] - URL of the CARTO Maps API server\n     *\n     * @example\n     * const source = new carto.source.Dataset('european_cities', {\n     *   apiKey: 'YOUR_API_KEY_HERE',\n     *   user: 'YOUR_USERNAME_HERE'\n     * });\n     *\n     * @fires CartoError\n     *\n     * @constructor Dataset\n     * @extends carto.source.Base\n     * @memberof carto.source\n     * @api\n     */\n    constructor (tableName, auth, config) {\n        super();\n        this._checkTableName(tableName);\n        this._tableName = tableName;\n        this.initialize(auth, config);\n    }\n\n    _clone () {\n        return new Dataset(this._tableName, this._auth, this._config);\n    }\n\n    _checkTableName (tableName) {\n        if (util.isUndefined(tableName)) {\n            throw new CartoValidationError('source', 'tableNameRequired');\n        }\n        if (!util.isString(tableName)) {\n            throw new CartoValidationError('source', 'tableNameStringRequired');\n        }\n        if (tableName === '') {\n            throw new CartoValidationError('source', 'nonValidTableName');\n        }\n    }\n}\n","import * as rsys from '../client/rsys';\nimport Dataframe from '../renderer/Dataframe';\nimport Metadata from '../renderer/Metadata';\nimport CartoValidationError from '../errors/carto-validation-error';\nimport util from '../utils/util';\nimport Base from './Base';\n\nconst SAMPLE_TARGET_SIZE = 1000;\n\nexport default class GeoJSON extends Base {\n    /**\n     * Create a carto.source.GeoJSON source from a GeoJSON object.\n     *\n     * @param {object} data - A GeoJSON data object\n     * @param {object} options - Options\n     * @param {array<string>} options.dateColumns - List of columns that contain dates.\n     *\n     * @example\n     * const source = new carto.source.GeoJSON({\n     *   \"type\": \"Feature\",\n     *   \"geometry\": {\n     *     \"type\": \"Point\",\n     *     \"coordinates\": [ 0, 0 ]\n     *   },\n     *   \"properties\": {\n     *     \"index\": 1\n     *   }\n     * });\n     *\n     * @fires CartoError\n     *\n     * @constructor GeoJSON\n     * @extends carto.source.Base\n     * @memberof carto.source\n     * @api\n     */\n    constructor (data, options = {}) {\n        super();\n        this._checkData(data);\n\n        this._type = ''; // Point, LineString, MultiLineString, Polygon, MultiPolygon\n        this._categoryStringToIDMap = {};\n        this._numCategories = 0;\n        this._numFields = new Set();\n        this._catFields = new Set();\n        this._dateFields = new Set();\n        this._providedDateColumns = new Set(options.dateColumns);\n        this._properties = {};\n        this._boundColumns = new Set();\n\n        this._data = data;\n        if (data.type === 'FeatureCollection') {\n            this._features = data.features;\n        } else if (data.type === 'Feature') {\n            this._features = [data];\n        } else {\n            throw new CartoValidationError('source', 'nonValidGeoJSONData');\n        }\n\n        this._features = this._initializeFeatureProperties(this._features);\n\n        this._setCoordinatesCenter();\n    }\n\n    bindLayer (addDataframe, dataLoadedCallback) {\n        this._addDataframe = addDataframe;\n        this._dataLoadedCallback = dataLoadedCallback;\n    }\n\n    requestMetadata (viz) {\n        return Promise.resolve(this._computeMetadata(viz));\n    }\n\n    requestData () {\n        if (this._dataframe) {\n            const newProperties = this._decodeUnboundProperties();\n            this._dataframe.addProperties(newProperties);\n            Object.keys(newProperties).forEach(propertyName => {\n                this._boundColumns.add(propertyName);\n            });\n            return;\n        }\n        const dataframe = new Dataframe({\n            active: true,\n            center: this._dataframeCenter,\n            geom: this._decodeGeometry(),\n            properties: this._decodeUnboundProperties(),\n            scale: 1,\n            size: this._features.length,\n            type: this._getDataframeType(this._type),\n            metadata: this._metadata\n        });\n        this._boundColumns = new Set(Object.keys(dataframe.properties));\n        this._dataframe = dataframe;\n        this._addDataframe(dataframe);\n        this._dataLoadedCallback();\n    }\n\n    requiresNewMetadata () {\n        return false;\n    }\n\n    _clone () {\n        return new GeoJSON(this._data, { dateColumns: Array.from(this._providedDateColumns) });\n    }\n\n    _checkData (data) {\n        if (util.isUndefined(data)) {\n            throw new CartoValidationError('source', 'dataRequired');\n        }\n        if (!util.isObject(data)) {\n            throw new CartoValidationError('source', 'dataObjectRequired');\n        }\n    }\n\n    _initializeFeatureProperties (features) {\n        for (let i = 0; i < features.length; i++) {\n            features[i].properties = features[i].properties || {};\n        }\n        return features;\n    }\n\n    _computeMetadata (viz) {\n        const sample = [];\n        this._addNumericColumnField('cartodb_id');\n\n        const featureCount = this._features.length;\n        const requiredColumns = new Set(viz.getMinimumNeededSchema().columns);\n        for (let i = 0; i < this._features.length; i++) {\n            const properties = this._features[i].properties;\n            const keys = Object.keys(properties);\n            for (let j = 0, len = keys.length; j < len; j++) {\n                const name = keys[j];\n                if (!requiredColumns.has(name) || this._boundColumns.has(name)) {\n                    continue;\n                }\n                const value = properties[name];\n                this._addPropertyToMetadata(name, value);\n            }\n            this._sampleFeatureOnMetadata(properties, sample, this._features.length);\n        }\n\n        this._numFields.forEach(name => {\n            const property = this._properties[name];\n            property.avg = property.sum / property.count;\n        });\n\n        let geomType = '';\n        if (featureCount > 0) {\n            // Set the geomType of the first feature to the metadata\n            geomType = this._getDataframeType(this._features[0].geometry.type);\n        }\n        const idProperty = 'cartodb_id';\n\n        this._metadata = new Metadata({ properties: this._properties, featureCount, sample, geomType, idProperty });\n\n        return this._metadata;\n    }\n\n    _sampleFeatureOnMetadata (properties, sample, featureCount) {\n        if (featureCount > SAMPLE_TARGET_SIZE) {\n            const sampling = SAMPLE_TARGET_SIZE / featureCount;\n            if (Math.random() > sampling) {\n                return;\n            }\n        }\n        sample.push(properties);\n    }\n\n    _addNumericPropertyToMetadata (propertyName, value) {\n        if (this._catFields.has(propertyName) || this._dateFields.has(propertyName)) {\n            throw new Error(`Unsupported GeoJSON: the property '${propertyName}' has different types in different features.`);\n        }\n        this._addNumericColumnField(propertyName);\n        const property = this._properties[propertyName];\n        property.min = Math.min(property.min, value);\n        property.max = Math.max(property.max, value);\n        property.sum += value;\n    }\n\n    _addNumericColumnField (propertyName) {\n        if (!this._numFields.has(propertyName)) {\n            this._numFields.add(propertyName);\n            this._properties[propertyName] = {\n                type: 'number',\n                min: Number.POSITIVE_INFINITY,\n                max: Number.NEGATIVE_INFINITY,\n                avg: Number.NaN,\n                sum: 0,\n                count: 0\n            };\n        }\n    }\n\n    _addDatePropertyToMetadata (propertyName, value) {\n        if (this._catFields.has(propertyName) || this._numFields.has(propertyName)) {\n            throw new Error(`Unsupported GeoJSON: the property '${propertyName}' has different types in different features.`);\n        }\n        this._addDateColumnField(propertyName);\n        const column = this._properties[propertyName];\n        const dateValue = util.castDate(value);\n        column.min = column.min ? util.castDate(Math.min(column.min, dateValue)) : dateValue;\n        column.max = column.max ? util.castDate(Math.max(column.max, dateValue)) : dateValue;\n        column.sum += value;\n        column.count++;\n    }\n\n    _addDateColumnField (propertyName) {\n        if (!this._dateFields.has(propertyName)) {\n            this._dateFields.add(propertyName);\n            this._properties[propertyName] = {\n                type: 'date',\n                min: null,\n                max: null,\n                avg: null,\n                sum: 0,\n                count: 0\n            };\n        }\n    }\n\n    _addPropertyToMetadata (propertyName, value) {\n        if (this._providedDateColumns.has(propertyName)) {\n            return this._addDatePropertyToMetadata(propertyName, value);\n        }\n        if (Number.isFinite(value)) {\n            return this._addNumericPropertyToMetadata(propertyName, value);\n        }\n        this._addCategoryPropertyToMetadata(propertyName, value);\n    }\n\n    _addCategoryPropertyToMetadata (propertyName, value) {\n        if (this._numFields.has(propertyName) || this._dateFields.has(propertyName)) {\n            throw new Error(`Unsupported GeoJSON: the property '${propertyName}' has different types in different features.`);\n        }\n        if (!this._catFields.has(propertyName)) {\n            this._catFields.add(propertyName);\n            this._properties[propertyName] = {\n                type: 'category',\n                categories: []\n            };\n        }\n        const property = this._properties[propertyName];\n        const cat = property.categories.find(cat => cat.name === value);\n        if (cat) {\n            cat.frequency++;\n        } else {\n            property.categories.push({ name: value, frequency: 1 });\n        }\n    }\n\n    _decodeUnboundProperties () {\n        const properties = {};\n        [...this._numFields].concat([...this._catFields]).concat([...this._dateFields]).map(name => {\n            if (this._boundColumns.has(name)) {\n                return;\n            }\n            // The dataframe expects to have a padding of 1024, adding 1024 empty values assures this condition is met\n            properties[name] = new Float32Array(this._features.length + 1024);\n        });\n\n        const catFields = [...this._catFields].filter(name => !this._boundColumns.has(name));\n        const numFields = [...this._numFields].filter(name => !this._boundColumns.has(name));\n        const dateFields = [...this._dateFields].filter(name => !this._boundColumns.has(name));\n\n        for (let i = 0; i < this._features.length; i++) {\n            const f = this._features[i];\n\n            catFields.forEach(name => {\n                properties[name][i] = this._getCategoryIDFromString(f.properties[name]);\n            });\n            numFields.forEach(name => {\n                if (name === 'cartodb_id' && !Number.isFinite(f.properties.cartodb_id)) {\n                    // Using negative ids for GeoJSON features\n                    f.properties.cartodb_id = -i;\n                }\n                properties[name][i] = Number(f.properties[name]);\n            });\n            dateFields.forEach(name => {\n                const property = this._properties[name];\n                // dates in Dataframes are mapped to [0,1] to maximize precision\n                const d = util.castDate(f.properties[name]).getTime();\n                const min = property.min;\n                const max = property.max;\n                const n = (d - min.getTime()) / (max.getTime() - min.getTime());\n                properties[name][i] = n;\n            });\n        }\n        return properties;\n    }\n\n    _getCategoryIDFromString (category) {\n        if (this._categoryStringToIDMap[category] !== undefined) {\n            return this._categoryStringToIDMap[category];\n        }\n        this._categoryStringToIDMap[category] = this._numCategories;\n        this._numCategories++;\n        return this._categoryStringToIDMap[category];\n    }\n\n    _getDataframeType (type) {\n        switch (type) {\n            case 'Point':\n                return 'point';\n            case 'LineString':\n            case 'MultiLineString':\n                return 'line';\n            case 'Polygon':\n            case 'MultiPolygon':\n                return 'polygon';\n            default:\n                return '';\n        }\n    }\n\n    _fetchFeatureGeometry (options = {}, callback) {\n        let geometry = null;\n        const numFeatures = this._features.length;\n        const incr = options.sample ? Math.max(1, Math.floor(numFeatures / options.sample)) : 1;\n\n        for (let i = 0; i < numFeatures; i += incr) {\n            const feature = this._features[i];\n            if (feature.type === 'Feature') {\n                callback(i, feature.geometry);\n            }\n        }\n        return geometry;\n    }\n\n    _allocGeometry () {\n        if (this._type === 'Point') {\n            return new Float32Array(this._features.length * 2);\n        }\n        return [];\n    }\n\n    _decodeGeometry () {\n        let geometries = this._allocGeometry();\n\n        this._fetchFeatureGeometry({}, (i, geometry) => {\n            const type = geometry.type;\n            const coordinates = geometry.coordinates;\n            if (this._type !== type) {\n                throw new CartoValidationError('source', `multipleFeatureTypes[${this._type}, ${type}]`);\n            }\n            if (type === 'Point') {\n                const point = this._computePointGeometry(coordinates);\n                geometries[2 * i + 0] = point.x;\n                geometries[2 * i + 1] = point.y;\n            } else if (type === 'LineString') {\n                const line = this._computeLineStringGeometry(coordinates);\n                geometries.push([line]);\n            } else if (type === 'MultiLineString') {\n                const multiline = this._computeMultiLineStringGeometry(coordinates);\n                geometries.push(multiline);\n            } else if (type === 'Polygon') {\n                const polygon = this._computePolygonGeometry(coordinates);\n                geometries.push([polygon]);\n            } else if (type === 'MultiPolygon') {\n                const multipolygon = this._computeMultiPolygonGeometry(coordinates);\n                geometries.push(multipolygon);\n            }\n        });\n\n        return geometries;\n    }\n\n    _computePointGeometry (data) {\n        const lat = data[1];\n        const lng = data[0];\n        const wm = util.projectToWebMercator({ lat, lng });\n        return rsys.wToR(wm.x, wm.y, { scale: util.WM_R, center: this._center });\n    }\n\n    _computeLineStringGeometry (data, reverse) {\n        let line = [];\n        for (let i = 0; i < data.length; i++) {\n            const point = this._computePointGeometry(\n                data[reverse ? (data.length - i - 1) : i]\n            );\n            line.push(point.x, point.y);\n        }\n        return line;\n    }\n\n    _computeMultiLineStringGeometry (data) {\n        let multiline = [];\n        for (let i = 0; i < data.length; i++) {\n            let line = this._computeLineStringGeometry(data[i]);\n            if (line.length > 0) {\n                multiline.push(line);\n            }\n        }\n        return multiline;\n    }\n\n    _computePolygonGeometry (data) {\n        let polygon = {\n            flat: [],\n            holes: [],\n            clipped: []\n        };\n        let holeIndex = 0;\n        let firstReverse = false;\n\n        if (data.length) {\n            firstReverse = this._isReversed(data[0]);\n            const flat = this._computeLineStringGeometry(data[0], firstReverse);\n            polygon.flat = polygon.flat.concat(flat);\n        }\n        for (let i = 1; i < data.length; i++) {\n            if (firstReverse !== this._isReversed(data[i])) {\n                holeIndex += data[i - 1].length;\n                polygon.holes.push(holeIndex);\n            }\n            const flat = this._computeLineStringGeometry(data[i], firstReverse);\n            polygon.flat = polygon.flat.concat(flat);\n        }\n        return polygon;\n    }\n\n    _computeMultiPolygonGeometry (data) {\n        let multipolygon = [];\n        for (let i = 0; i < data.length; i++) {\n            let polygon = this._computePolygonGeometry(data[i]);\n            if (polygon.flat.length > 0) {\n                multipolygon.push(polygon);\n            }\n        }\n        return multipolygon;\n    }\n\n    _isReversed (vertices) {\n        let total = 0;\n        let pt1 = vertices[0];\n        let pt2;\n        for (let i = 0; i < vertices.length - 1; i++) {\n            pt2 = vertices[i + 1];\n            total += (pt2[1] - pt1[1]) * (pt2[0] + pt1[0]);\n            pt1 = pt2;\n        }\n        // When total is positive it means that vertices are oriented clock wise\n        // and, since positive orientation is counter-clock wise, it is reversed.\n        return total >= 0;\n    }\n\n    _samplePoint (geometry) {\n        const type = geometry.type;\n\n        const coordinates = geometry.coordinates;\n        if (type === 'Point') {\n            return coordinates;\n        } else if (type === 'LineString') {\n            return coordinates[0];\n        } else if (type === 'MultiLineString' || type === 'Polygon') {\n            return coordinates[0][0];\n        } else if (type === 'MultiPolygon') {\n            return coordinates[0][0][0];\n        }\n    }\n\n    // sets this._type, this._center, this._dataframeCenter\n    _setCoordinatesCenter () {\n        let x = 0;\n        let y = 0;\n        let nPoints = 0;\n        this._fetchFeatureGeometry({ sample: 10 }, (_, geometry) => {\n            if (!this._type) {\n                this._type = geometry.type;\n            }\n            const samplePoint = this._samplePoint(geometry);\n            const sampleXY = util.projectToWebMercator({ lng: samplePoint[0], lat: samplePoint[1] });\n            x += sampleXY.x;\n            y += sampleXY.y;\n            nPoints += 1;\n        });\n        if (nPoints > 1) {\n            x /= nPoints;\n            y /= nPoints;\n        }\n\n        this._center = { x, y };\n        this._dataframeCenter = rsys.wToR(this._center.x, this._center.y, { scale: util.WM_R, center: { x: 0, y: 0 } });\n    }\n\n    free () {\n    }\n}\n","import { VectorTile } from '@mapbox/vector-tile';\nimport * as Protobuf from 'pbf';\nimport { decodeLines, decodePolygons } from '../client/mvt/feature-decoder';\nimport * as rsys from '../client/rsys';\nimport Dataframe from '../renderer/Dataframe';\nimport Metadata from '../renderer/Metadata';\nimport { RTT_WIDTH } from '../renderer/Renderer';\nimport Base from './Base';\nimport TileClient from './TileClient';\n\n// Constants for '@mapbox/vector-tile' geometry types, from https://github.com/mapbox/vector-tile-js/blob/v1.3.0/lib/vectortilefeature.js#L39\nconst mvtDecoderGeomTypes = { point: 1, line: 2, polygon: 3 };\n\nconst geometryTypes = {\n    UNKNOWN: 'unknown',\n    POINT: 'point',\n    LINE: 'line',\n    POLYGON: 'polygon'\n};\n\nconst MVT_TO_CARTO_TYPES = {\n    1: geometryTypes.POINT,\n    2: geometryTypes.LINE,\n    3: geometryTypes.POLYGON\n};\n\n/**\n * A MVTOptions object declares a MVT configuration\n * @typedef {object} MVTOptions\n * @property {string} layerID - layerID on the MVT tiles to decode, the parameter is optional if the MVT tiles only contain one layer\n * @property {function} [viewportZoomToSourceZoom=Math.ceil] - function to transform the viewport zoom into a zoom value to replace `{z}` in the MVT URL template, undefined defaults to `Math.ceil`\n * @property {number} maxZoom - limit MVT tile requests to this zoom level, undefined defaults to no limit\n *\n * @example <caption>Use layer `myAwesomeLayer` and request tiles up to zoom level 12.</caption>\n * const options = {\n *     layerID: 'myAwesomeLayer',\n *     maxZoom: 12\n * };\n *\n * @example <caption>Use layer `myAwesomeLayer` and request tiles only at zoom levels 4, 5 and 6.</caption>\n * const options = {\n *     layerID: 'myAwesomeLayer',\n *     viewportZoomToSourceZoom: zoom => Math.min(Math.max(Math.ceil(zoom), 4), 6)\n * };\n *\n * @example <caption>Use layer `myAwesomeLayer` and request tiles only at zoom levels 0,3,6,9...</caption>\n * const options = {\n *     layerID: 'myAwesomeLayer',\n *     viewportZoomToSourceZoom: zoom => Math.round(zoom / 3) * 3\n * };\n *\n * @api\n */\n\nexport default class MVT extends Base {\n    /**\n     * Create a carto.source.MVT.\n     *\n     * @param {object} data - A MVT data object\n     * @param {object} [metadata] - A carto.source.mvt.Metadata object\n     * @param {MVTOptions} [options] - MVT source configuration, the default value will be valid for regular URL templates if the tiles are composed of only one layer\n     *\n     * @example\n     * const metadata = new carto.source.mvt.Metadata([{ type: 'number', name: 'total_pop'}])\n     * new carto.source.MVT(\"https://{server}/{z}/{x}/{y}.mvt\", metadata);\n     *\n     * @fires CartoError\n     *\n     * @constructor MVT\n     * @extends carto.source.Base\n     * @memberof carto.source\n     * @api\n     */\n    constructor (templateURL, metadata = new Metadata(), options = { layerId: undefined, viewportZoomToSourceZoom: Math.ceil, maxZoom: undefined }) {\n        super();\n        this._templateURL = templateURL;\n        if (!(metadata instanceof Metadata)) {\n            metadata = new Metadata(metadata);\n        }\n        this._metadata = metadata;\n        this._tileClient = new TileClient(templateURL);\n        this._options = options;\n        this._options.viewportZoomToSourceZoom = this._options.viewportZoomToSourceZoom || Math.ceil;\n    }\n\n    _clone () {\n        return new MVT(this._templateURL, JSON.parse(JSON.stringify(this._metadata)), this._options);\n    }\n\n    bindLayer (addDataframe, dataLoadedCallback) {\n        this._tileClient.bindLayer(addDataframe, dataLoadedCallback);\n    }\n\n    async requestMetadata () {\n        return this._metadata;\n    }\n\n    requestData (zoom, viewport) {\n        return this._tileClient.requestData(zoom, viewport, this.responseToDataframeTransformer.bind(this),\n            zoom => this._options.maxZoom === undefined\n                ? this._options.viewportZoomToSourceZoom(zoom)\n                : Math.min(this._options.viewportZoomToSourceZoom(zoom), this._options.maxZoom)\n        );\n    }\n\n    async responseToDataframeTransformer (response, x, y, z) {\n        const MVT_EXTENT = 4096;\n        const arrayBuffer = await response.arrayBuffer();\n        if (arrayBuffer.byteLength === 0 || response === 'null') {\n            return { empty: true };\n        }\n        const tile = new VectorTile(new Protobuf(arrayBuffer));\n\n        if (Object.keys(tile.layers).length > 1 && !this._options.layerID) {\n            throw new Error(`LayerID parameter wasn't specified and the MVT tile contains multiple layers: ${JSON.stringify(Object.keys(tile.layers))}`);\n        }\n\n        const mvtLayer = tile.layers[this._options.layerID || Object.keys(tile.layers)[0]];\n\n        if (!mvtLayer) {\n            throw new Error(`LayerID '${this._options.layerID}' doesn't exist on the MVT tile`);\n        }\n\n        const { geometries, properties, numFeatures } = this._decodeMVTLayer(mvtLayer, this._metadata, MVT_EXTENT);\n        const rs = rsys.getRsysFromTile(x, y, z);\n        const dataframe = this._generateDataFrame(rs, geometries, properties, numFeatures, this._metadata.geomType);\n\n        return dataframe;\n    }\n\n    _decodeMVTLayer (mvtLayer, metadata, mvtExtent) {\n        if (!mvtLayer.length) {\n            return { properties: [], geometries: {}, numFeatures: 0 };\n        }\n        if (!metadata.geomType) {\n            metadata.geomType = this._autoDiscoverType(mvtLayer);\n        }\n        switch (metadata.geomType) {\n            case geometryTypes.POINT:\n                return this._decode(mvtLayer, metadata, mvtExtent, new Float32Array(mvtLayer.length * 2));\n            case geometryTypes.LINE:\n                return this._decode(mvtLayer, metadata, mvtExtent, [], decodeLines);\n            case geometryTypes.POLYGON:\n                return this._decode(mvtLayer, metadata, mvtExtent, [], decodePolygons);\n            default:\n                throw new Error('MVT: invalid geometry type');\n        }\n    }\n\n    _autoDiscoverType (mvtLayer) {\n        const type = mvtLayer.feature(0).type;\n        switch (type) {\n            case mvtDecoderGeomTypes.point:\n                return geometryTypes.POINT;\n            case mvtDecoderGeomTypes.line:\n                return geometryTypes.LINE;\n            case mvtDecoderGeomTypes.polygon:\n                return geometryTypes.POLYGON;\n            default:\n                throw new Error('MVT: invalid geometry type');\n        }\n    }\n\n    _decode (mvtLayer, metadata, mvtExtent, geometries, decodeFn) {\n        let numFeatures = 0;\n        const { properties, propertyNames } = this._initializePropertyArrays(metadata, mvtLayer.length);\n        for (let i = 0; i < mvtLayer.length; i++) {\n            const f = mvtLayer.feature(i);\n            this._checkType(f, metadata.geomType);\n            const geom = f.loadGeometry();\n            if (decodeFn) {\n                const decodedPolygons = decodeFn(geom, mvtExtent);\n                geometries.push(decodedPolygons);\n            } else {\n                const x = 2 * (geom[0][0].x) / mvtExtent - 1.0;\n                const y = 2 * (1.0 - (geom[0][0].y) / mvtExtent) - 1.0;\n                // Tiles may contain points in the border;\n                // we'll avoid here duplicatend points between tiles by excluding the 1-edge\n                if (x < -1 || x >= 1 || y < -1 || y >= 1) {\n                    continue;\n                }\n                geometries[2 * numFeatures + 0] = x;\n                geometries[2 * numFeatures + 1] = y;\n            }\n            if (f.properties[this._metadata.idProperty] === undefined) {\n                throw new Error(`MVT feature with undefined idProperty '${this._metadata.idProperty}'`);\n            }\n            this._decodeProperties(propertyNames, properties, f, numFeatures);\n            numFeatures++;\n        }\n\n        return { properties, geometries, numFeatures };\n    }\n\n    // Currently only mvtLayers with the same type in every feature are supported\n    _checkType (feature, expected) {\n        const type = feature.type;\n        const actual = MVT_TO_CARTO_TYPES[type];\n        if (actual !== expected) {\n            throw new Error(`MVT: mixed geometry types in the same layer. Layer has type: ${expected} but feature was ${actual}`);\n        }\n    }\n\n    _initializePropertyArrays (metadata, length) {\n        const properties = {};\n        const propertyNames = [];\n        for (let i = 0; i < metadata.propertyKeys.length; i++) {\n            const propertyName = metadata.propertyKeys[i];\n            if (metadata.properties[propertyName].type === 'geometry') {\n                continue;\n            }\n            propertyNames.push(...metadata.propertyNames(propertyName));\n        }\n\n        const size = Math.ceil(length / RTT_WIDTH) * RTT_WIDTH;\n\n        const arrayBuffer = new ArrayBuffer(4 * size * propertyNames.length);\n        for (let i = 0; i < propertyNames.length; i++) {\n            const propertyName = propertyNames[i];\n            properties[propertyName] = new Float32Array(arrayBuffer, i * 4 * size, size);\n        }\n\n        return { properties, propertyNames };\n    }\n\n    _decodeProperties (propertyNames, properties, feature, i) {\n        const length = propertyNames.length;\n        for (let j = 0; j < length; j++) {\n            const propertyName = propertyNames[j];\n            const propertyValue = feature.properties[propertyName];\n            properties[propertyName][i] = this.decodeProperty(propertyName, propertyValue);\n        }\n    }\n\n    decodeProperty (propertyName, propertyValue) {\n        if (typeof propertyValue === 'string') {\n            if (this._metadata.properties[propertyName].type !== 'category') {\n                throw new Error(`MVT decoding error. Metadata property '${propertyName}' is of type '${this._metadata.properties[propertyName].type}' but the MVT tile contained a feature property of type string: '${propertyValue}'`);\n            }\n            return this._metadata.categorizeString(propertyValue);\n        } else if (typeof propertyValue === 'number') {\n            if (this._metadata.properties[propertyName].type !== 'number') {\n                throw new Error(`MVT decoding error. Metadata property '${propertyName}' is of type '${this._metadata.properties[propertyName].type}' but the MVT tile contained a feature property of type number: '${propertyValue}'`);\n            }\n            return propertyValue;\n        } else if (propertyValue === null || propertyValue === undefined) {\n            return Number.NaN;\n        } else {\n            throw new Error(`MVT decoding error. Feature property value of type '${typeof propertyValue}' cannot be decoded.`);\n        }\n    }\n\n    _generateDataFrame (rs, geometry, properties, size, type) {\n        return new Dataframe({\n            active: false,\n            center: rs.center,\n            geom: geometry,\n            properties: properties,\n            scale: rs.scale,\n            size: size,\n            type: type,\n            metadata: this._metadata\n        });\n    }\n\n    free () {\n        this._tileClient.free();\n    }\n}\n","import CartoValidationError from '../errors/carto-validation-error';\nimport util from '../utils/util';\nimport BaseWindshaft from './BaseWindshaft';\n\nexport default class SQL extends BaseWindshaft {\n    /**\n     * A SQL defines the data that will be displayed in a layer.\n     *\n     * Imagine you have a table named `european_cities` and you only want to download data from european cities with population > 100000\n     *\n     * ```javascript\n     * const source = new carto.source.SQL(`SELECT * FROM european_cities WHERE country like 'europe' AND population > 10000`, {\n     *   apiKey: 'YOUR_API_KEY_HERE',\n     *   user: 'YOUR_USERNAME_HERE'\n     * });\n     * ````\n     *\n     * This only downloads the data you need from the server reducing data usage.\n     *\n     * If you need all the data see {@link carto.source.Dataset|carto.source.Dataset}.\n     *\n     * Since tables in the server are protected you must provide valid credentials in order to get access to the data.\n     * This can be done {@link carto.setDefaultAuth|setting the default auth} in the carto object or providing an `auth`\n     * object with your username and apiKey.\n     *\n     * If your server is not hosted by CARTO you must add a third parameter that includes the serverURL. This can be done {@link carto.setDefaultConfig|setting the default config} in the carto object or providing a `config`\n     * object with your serverURL.\n     *\n     * @param {string} query - A SQL query containing a SELECT statement\n     * @param {object} auth\n     * @param {string} auth.apiKey - API key used to authenticate against CARTO\n     * @param {string} auth.user - Name of the user\n     * @param {object} config\n     * @param {string} [config.serverURL='https://{user}.carto.com'] - URL of the CARTO Maps API server\n     *\n     * @example\n     * const source = new carto.source.SQL('SELECT * FROM european_cities', {\n     *   apiKey: 'YOUR_API_KEY_HERE',\n     *   user: 'YOUR_USERNAME_HERE'\n     * });\n     *\n     * @fires CartoError\n     *\n     * @constructor SQL\n     * @extends carto.source.Base\n     * @memberof carto.source\n     * @api\n     */\n    constructor (query, auth, config) {\n        super();\n        this._checkQuery(query);\n        this._query = query;\n        this.initialize(auth, config);\n    }\n\n    _clone () {\n        return new SQL(this._query, this._auth, this._config);\n    }\n\n    _checkQuery (query) {\n        if (util.isUndefined(query)) {\n            throw new CartoValidationError('source', 'queryRequired');\n        }\n        if (!util.isString(query)) {\n            throw new CartoValidationError('source', 'queryStringRequired');\n        }\n        if (query === '') {\n            throw new CartoValidationError('source', 'nonValidQuery');\n        }\n        let sqlRegex = /\\bSELECT\\b/i;\n        if (!query.match(sqlRegex)) {\n            throw new CartoValidationError('source', 'nonValidSQLQuery');\n        }\n    }\n}\n","import DataframeCache from './DataframeCache';\nimport { rTiles } from '../client/rsys';\n\nexport default class TileClient {\n    constructor (templateURLs) {\n        if (!Array.isArray(templateURLs)) {\n            templateURLs = [templateURLs];\n        }\n        this._templateURLs = templateURLs;\n        this._requestGroupID = 0;\n        this._oldDataframes = [];\n        this._cache = new DataframeCache();\n    }\n\n    bindLayer (addDataframe, dataLoadedCallback) {\n        this._addDataframe = addDataframe;\n        this._dataLoadedCallback = dataLoadedCallback;\n    }\n\n    requestData (zoom, viewport, responseToDataframeTransformer, viewportZoomToSourceZoom = Math.ceil) {\n        const tiles = rTiles(zoom, viewport, viewportZoomToSourceZoom);\n        this._getTiles(tiles, responseToDataframeTransformer);\n    }\n\n    free () {\n        this._cache.free();\n        this._cache = new DataframeCache();\n        this._oldDataframes = [];\n    }\n\n    _getTiles (tiles, responseToDataframeTransformer) {\n        this._requestGroupID++;\n        let completedTiles = [];\n        let needToComplete = tiles.length;\n        const requestGroupID = this._requestGroupID;\n        tiles.forEach(({ x, y, z }) => {\n            this._cache.get(`${x},${y},${z}`, () => this._requestDataframe(x, y, z, responseToDataframeTransformer)).then(\n                dataframe => {\n                    dataframe.orderID = x + y / 1000;\n                    if (dataframe.empty) {\n                        needToComplete--;\n                    } else {\n                        completedTiles.push(dataframe);\n                    }\n                    if (completedTiles.length === needToComplete && requestGroupID === this._requestGroupID) {\n                        this._oldDataframes.forEach(d => {\n                            d.active = false;\n                        });\n                        completedTiles.map(d => {\n                            d.active = true;\n                        });\n                        this._oldDataframes = completedTiles;\n                        this._dataLoadedCallback();\n                    }\n                });\n        });\n    }\n\n    _getTileUrl (x, y, z) {\n        const subdomainIndex = this._getSubdomainIndex(x, y);\n        return this._templateURLs[subdomainIndex].replace('{x}', x).replace('{y}', y).replace('{z}', z);\n    }\n\n    _getSubdomainIndex (x, y) {\n        // Reference https://github.com/Leaflet/Leaflet/blob/v1.3.1/src/layer/tile/TileLayer.js#L214-L217\n        return Math.abs(x + y) % this._templateURLs.length;\n    }\n\n    async _requestDataframe (x, y, z, responseToDataframeTransformer) {\n        const response = await fetch(this._getTileUrl(x, y, z));\n        const dataframe = await responseToDataframeTransformer(response, x, y, z);\n        if (!dataframe.empty) {\n            this._addDataframe(dataframe);\n        }\n        return dataframe;\n    }\n}\n","import { halfPlaneSign } from './geometry';\n\nconst SEPARATING_LINE_FOUND = 'separatingLineFound';\nconst SEPARATING_LINE_NOT_FOUND = 'separatingLineNotFound';\n\nexport function triangleCollides (triangle, viewportAABB) {\n    const viewport = [\n        { x: viewportAABB.minx, y: viewportAABB.miny },\n        { x: viewportAABB.minx, y: viewportAABB.maxy },\n        { x: viewportAABB.maxx, y: viewportAABB.miny },\n        { x: viewportAABB.maxx, y: viewportAABB.maxy }\n    ];\n\n    /*\n     * TODO\n     *\n     * Optimize triangle collision:\n     *\n     * if (_isAnyTriangleVertexInViewport(triangle, viewportAABB)) {\n     *   return true;\n     * }\n     *\n     * if (_isAnyViewportVertexInTriangle(triangle, viewport)) {\n     *   return true;\n     * }\n     */\n\n    if (_viewportLineSeparatesTriangle(viewportAABB, triangle) === SEPARATING_LINE_FOUND) {\n        return false;\n    }\n\n    if (_triangleLineSeparatesViewport(triangle, viewport) === SEPARATING_LINE_FOUND) {\n        return false;\n    }\n\n    return true;\n}\n\n/*\n * TODO\n *\n * Optimize triangle collision:\n *\n * function _isAnyViewportVertexInTriangle (triangle, viewport) {\n *     for (let i = 0; i < viewport.length; i++) {\n *         if (pointInTriangle(viewport[i], triangle[0], triangle[1], triangle[2])) {\n *             return true;\n *         }\n *     }\n *\n *     return false;\n * }\n * function _isAnyTriangleVertexInViewport (triangle, viewportAABB) {\n *  for (let i = 0; i < 3; i++) {\n *       if (pointInRectangle(triangle[i], viewportAABB)) {\n *           return true;\n *       }\n *   }\n *   return false;\n * }\n */\n\nfunction _viewportLineSeparatesTriangle (viewportAABB, triangle) {\n    if (triangle[0].x < viewportAABB.minx &&\n        triangle[1].x < viewportAABB.minx &&\n        triangle[2].x < viewportAABB.minx) {\n        return SEPARATING_LINE_FOUND;\n    }\n\n    if (triangle[0].y < viewportAABB.miny &&\n        triangle[1].y < viewportAABB.miny &&\n        triangle[2].y < viewportAABB.miny) {\n        return SEPARATING_LINE_FOUND;\n    }\n\n    if (triangle[0].x > viewportAABB.maxx &&\n        triangle[1].x > viewportAABB.maxx &&\n        triangle[2].x > viewportAABB.maxx) {\n        return SEPARATING_LINE_FOUND;\n    }\n\n    if (triangle[0].y > viewportAABB.maxy &&\n        triangle[1].y > viewportAABB.maxy &&\n        triangle[2].y > viewportAABB.maxy) {\n        return SEPARATING_LINE_FOUND;\n    }\n\n    return SEPARATING_LINE_NOT_FOUND;\n}\n\nfunction _triangleLineSeparatesViewport (triangle, viewport) {\n    const TRIANGLE_VERTICES = 3;\n\n    for (let i = 0; i < TRIANGLE_VERTICES; i++) {\n        for (let j = 0; j < viewport.length; j++) {\n            const position = halfPlaneSign(viewport[j], triangle[i], triangle[(i + 1) % TRIANGLE_VERTICES]);\n\n            if (position > 0) {\n                break;\n            }\n\n            if (j === TRIANGLE_VERTICES) {\n                return SEPARATING_LINE_FOUND;\n            }\n        }\n    }\n\n    return SEPARATING_LINE_NOT_FOUND;\n}\n","// If AB intersects CD => return intersection point\n// Intersection method from Real Time Rendering, Third Edition, page 780\nexport function intersect (a, b, c, d) {\n    const o1 = a;\n    const o2 = c;\n    const d1 = sub(b, a);\n    const d2 = sub(d, c);\n    const d1t = perpendicular(d1);\n    const d2t = perpendicular(d2);\n\n    const s = dot(sub(o2, o1), d2t) / dot(d1, d2t);\n    const t = dot(sub(o1, o2), d1t) / dot(d2, d1t);\n\n    if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n        return [o1[0] + s * d1[0], o1[1] + s * d1[1]];\n    }\n}\n\nexport function sub ([ax, ay], [bx, by]) {\n    return ([ax - bx, ay - by]);\n}\n\nexport function dot ([ax, ay], [bx, by]) {\n    return (ax * bx + ay * by);\n}\n\nexport function perpendicular ([x, y]) {\n    return [-y, x];\n}\n\n/**\n * Compute the normal of a line AB.\n * By definition it is the unitary vector from B to A, rotated +90 degrees counter-clockwise\n */\nexport function getLineNormal (a, b) {\n    const u = normalize(vector(b, a));\n    return [-u[1], u[0]];\n}\n\n/**\n * Compute the normal of the join from the lines' normals.\n * By definition this is the sum of the unitary vectors `u` (from B to A) and `v` (from B to C)\n * multiplied by a factor of `1/sin(theta)` to reach the intersection of the wide lines.\n * Theta is the angle between the vectors `v` and `u`. But instead of computing the angle,\n * the `sin(theta)` (with sign) is obtained directly from the vectorial product of `v` and `u`\n */\nexport function getJoinNormal (prevNormal, nextNormal) {\n    const u = [prevNormal[1], -prevNormal[0]];\n    const v = [-nextNormal[1], nextNormal[0]];\n    const sin = v[0] * u[1] - v[1] * u[0];\n    const cos = v[0] * u[0] + v[1] * u[1];\n    const factor = Math.abs(sin);\n    const miterJoin = !(factor < 0.866 && cos > 0.5); // 60 deg\n    return {\n        turnLeft: sin > 0,\n        joinNormal: miterJoin && neg([\n            (u[0] + v[0]) / factor,\n            (u[1] + v[1]) / factor\n        ])\n    };\n}\n\n/**\n * Return the negative of the provided vector\n */\nexport function neg (v) {\n    return [-v[0], -v[1]];\n}\n\n/**\n * Create a vector which goes from p1 to p2\n */\nfunction vector (p1, p2) {\n    return [p2[0] - p1[0], p2[1] - p1[1]];\n}\n\n/**\n * Return the vector scaled to length 1\n */\nfunction normalize (v) {\n    const s = Math.hypot(v[0], v[1]);\n    return [v[0] / s, v[1] / s];\n}\n\n// Returns true if p is inside the triangle or on a triangle's edge, false otherwise\n// Parameters in {x: 0, y:0} form\nexport function pointInTriangle (p, v1, v2, v3) {\n    // https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle\n    // contains an explanation of both this algorithm and one based on barycentric coordinates,\n    // which could be faster, but, nevertheless, it is quite similar in terms of required arithmetic operations\n\n    if (equalPoints(v1, v2) || equalPoints(v2, v3) || equalPoints(v3, v1)) {\n        // Avoid zero area triangle\n        return false;\n    }\n\n    // A point is inside a triangle or in one of the triangles edges\n    // if the point is in the three half-plane defined by the 3 edges\n    const b1 = halfPlaneSign(p, v1, v2) < 0;\n    const b2 = halfPlaneSign(p, v2, v3) < 0;\n    const b3 = halfPlaneSign(p, v3, v1) < 0;\n\n    return (b1 === b2) && (b2 === b3);\n}\n\n// Tests if a point `p` is in the half plane defined by the line with points `a` and `b`\n// Returns a negative number if the result is INSIDE, returns 0 if the result is ON_LINE,\n// returns >0 if the point is OUTSIDE\n// Parameters in {x: 0, y:0} form\nexport function halfPlaneSign (p, a, b) {\n    // We use the cross product of `PB x AB` to get `sin(angle(PB, AB))`\n    // The result's sign is the half plane test result\n    return (p.x - b.x) * (a.y - b.y) - (a.x - b.x) * (p.y - b.y);\n}\n\nexport function equalPoints (a, b) {\n    return (a.x === b.x) && (a.y === b.y);\n}\n\nexport function pointInCircle (p, center, scale) {\n    const diff = {\n        x: p.x - center.x,\n        y: p.y - center.y\n    };\n    const lengthSquared = diff.x * diff.x + diff.y * diff.y;\n    return lengthSquared <= scale * scale;\n}\n\nexport function pointInRectangle (point, bbox) {\n    const p = {\n        x: point.x.toFixed(2),\n        y: point.y.toFixed(2)\n    };\n\n    return ((bbox.minx <= p.x) && (p.x <= bbox.maxx) && (bbox.miny <= p.y) && (p.y <= bbox.maxy));\n}\n\nexport default {\n    intersect,\n    sub,\n    dot,\n    perpendicular,\n    normalize,\n    getLineNormal,\n    getJoinNormal,\n    neg,\n    halfPlaneSign,\n    pointInTriangle,\n    equalPoints,\n    pointInCircle,\n    pointInRectangle\n};\n","/**\n * Export util functions\n */\n\nconst DEG2RAD = Math.PI / 180;\nconst EARTH_RADIUS = 6378137;\nexport const WM_R = EARTH_RADIUS * Math.PI; // Webmercator *radius*: half length Earth's circumference\nexport const WM_2R = WM_R * 2; // Webmercator coordinate range (Earth's circumference)\n\nexport function projectToWebMercator (latLng) {\n    let lat = latLng.lat * DEG2RAD;\n    let lng = latLng.lng * DEG2RAD;\n    let x = lng * EARTH_RADIUS;\n    let y = Math.log(Math.tan(lat / 2 + Math.PI / 4)) * EARTH_RADIUS;\n    return { x, y };\n}\n\nexport function isUndefined (value) {\n    return value === undefined;\n}\n\nexport function isString (value) {\n    return typeof value === 'string';\n}\n\nexport function isNumber (value) {\n    return typeof value === 'number';\n}\n\nexport function isObject (value) {\n    const type = typeof value;\n    return value !== null && (type === 'object' || type === 'function');\n}\n\nexport function getFloat32ArrayFromArray (array) {\n    const length = array.length;\n    const float32Array = new Float32Array(length);\n    for (let i = 0; i < length; i++) {\n        float32Array[i] = array[i];\n    }\n    return float32Array;\n}\n\n/**\n * Transform the given parameter into a Date object.\n * When a number is given as a parameter is asummed to be a milliseconds epoch.\n * @param {Date|number|string} date\n */\nexport function castDate (date) {\n    if (date instanceof Date) {\n        return date;\n    }\n    if (typeof (date) === 'number') {\n        const msEpoch = date;\n        date = new Date(0);\n        date.setUTCMilliseconds(msEpoch);\n        return date;\n    }\n    return new Date(date);\n}\n\nexport function isSetsEqual (a, b) {\n    return a.size === b.size && [...a].every(value => b.has(value));\n}\n\nexport default {\n    WM_R,\n    WM_2R,\n    projectToWebMercator,\n    isUndefined,\n    isString,\n    isNumber,\n    isObject,\n    castDate,\n    isSetsEqual\n};\n"],"sourceRoot":""}